
STM32F4xx-Nucleo-DataLogExtended.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000d340  080001a0  080001a0  000101a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000023c  0800d4e0  0800d4e0  0001d4e0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  0800d71c  0800d71c  0001d71c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  0800d724  0800d724  0001d724  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  0800d728  0800d728  0001d728  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000580  20000000  0800d72c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00000850  20000580  0800dcac  00020580  2**2
                  ALLOC
  8 ._user_heap_stack 00000600  20000dd0  0800dcac  00020dd0  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00020580  2**0
                  CONTENTS, READONLY
 10 .debug_info   00069bc5  00000000  00000000  000205b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00007260  00000000  00000000  0008a175  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00048bf2  00000000  00000000  000913d5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00002d90  00000000  00000000  000d9fc8  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 0000bde0  00000000  00000000  000dcd58  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_macro  00020a12  00000000  00000000  000e8b38  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   000217b7  00000000  00000000  0010954a  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    000ada73  00000000  00000000  0012ad01  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .comment      0000007c  00000000  00000000  001d8774  2**0
                  CONTENTS, READONLY
 19 .debug_frame  0000ae08  00000000  00000000  001d87f0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001a0 <__do_global_dtors_aux>:
 80001a0:	b510      	push	{r4, lr}
 80001a2:	4c05      	ldr	r4, [pc, #20]	; (80001b8 <__do_global_dtors_aux+0x18>)
 80001a4:	7823      	ldrb	r3, [r4, #0]
 80001a6:	b933      	cbnz	r3, 80001b6 <__do_global_dtors_aux+0x16>
 80001a8:	4b04      	ldr	r3, [pc, #16]	; (80001bc <__do_global_dtors_aux+0x1c>)
 80001aa:	b113      	cbz	r3, 80001b2 <__do_global_dtors_aux+0x12>
 80001ac:	4804      	ldr	r0, [pc, #16]	; (80001c0 <__do_global_dtors_aux+0x20>)
 80001ae:	f3af 8000 	nop.w
 80001b2:	2301      	movs	r3, #1
 80001b4:	7023      	strb	r3, [r4, #0]
 80001b6:	bd10      	pop	{r4, pc}
 80001b8:	20000580 	.word	0x20000580
 80001bc:	00000000 	.word	0x00000000
 80001c0:	0800d4c8 	.word	0x0800d4c8

080001c4 <frame_dummy>:
 80001c4:	b508      	push	{r3, lr}
 80001c6:	4b03      	ldr	r3, [pc, #12]	; (80001d4 <frame_dummy+0x10>)
 80001c8:	b11b      	cbz	r3, 80001d2 <frame_dummy+0xe>
 80001ca:	4903      	ldr	r1, [pc, #12]	; (80001d8 <frame_dummy+0x14>)
 80001cc:	4803      	ldr	r0, [pc, #12]	; (80001dc <frame_dummy+0x18>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	bd08      	pop	{r3, pc}
 80001d4:	00000000 	.word	0x00000000
 80001d8:	20000584 	.word	0x20000584
 80001dc:	0800d4c8 	.word	0x0800d4c8

080001e0 <strlen>:
 80001e0:	4603      	mov	r3, r0
 80001e2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001e6:	2a00      	cmp	r2, #0
 80001e8:	d1fb      	bne.n	80001e2 <strlen+0x2>
 80001ea:	1a18      	subs	r0, r3, r0
 80001ec:	3801      	subs	r0, #1
 80001ee:	4770      	bx	lr

080001f0 <memchr>:
 80001f0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80001f4:	2a10      	cmp	r2, #16
 80001f6:	db2b      	blt.n	8000250 <memchr+0x60>
 80001f8:	f010 0f07 	tst.w	r0, #7
 80001fc:	d008      	beq.n	8000210 <memchr+0x20>
 80001fe:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000202:	3a01      	subs	r2, #1
 8000204:	428b      	cmp	r3, r1
 8000206:	d02d      	beq.n	8000264 <memchr+0x74>
 8000208:	f010 0f07 	tst.w	r0, #7
 800020c:	b342      	cbz	r2, 8000260 <memchr+0x70>
 800020e:	d1f6      	bne.n	80001fe <memchr+0xe>
 8000210:	b4f0      	push	{r4, r5, r6, r7}
 8000212:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000216:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800021a:	f022 0407 	bic.w	r4, r2, #7
 800021e:	f07f 0700 	mvns.w	r7, #0
 8000222:	2300      	movs	r3, #0
 8000224:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000228:	3c08      	subs	r4, #8
 800022a:	ea85 0501 	eor.w	r5, r5, r1
 800022e:	ea86 0601 	eor.w	r6, r6, r1
 8000232:	fa85 f547 	uadd8	r5, r5, r7
 8000236:	faa3 f587 	sel	r5, r3, r7
 800023a:	fa86 f647 	uadd8	r6, r6, r7
 800023e:	faa5 f687 	sel	r6, r5, r7
 8000242:	b98e      	cbnz	r6, 8000268 <memchr+0x78>
 8000244:	d1ee      	bne.n	8000224 <memchr+0x34>
 8000246:	bcf0      	pop	{r4, r5, r6, r7}
 8000248:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800024c:	f002 0207 	and.w	r2, r2, #7
 8000250:	b132      	cbz	r2, 8000260 <memchr+0x70>
 8000252:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000256:	3a01      	subs	r2, #1
 8000258:	ea83 0301 	eor.w	r3, r3, r1
 800025c:	b113      	cbz	r3, 8000264 <memchr+0x74>
 800025e:	d1f8      	bne.n	8000252 <memchr+0x62>
 8000260:	2000      	movs	r0, #0
 8000262:	4770      	bx	lr
 8000264:	3801      	subs	r0, #1
 8000266:	4770      	bx	lr
 8000268:	2d00      	cmp	r5, #0
 800026a:	bf06      	itte	eq
 800026c:	4635      	moveq	r5, r6
 800026e:	3803      	subeq	r0, #3
 8000270:	3807      	subne	r0, #7
 8000272:	f015 0f01 	tst.w	r5, #1
 8000276:	d107      	bne.n	8000288 <memchr+0x98>
 8000278:	3001      	adds	r0, #1
 800027a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800027e:	bf02      	ittt	eq
 8000280:	3001      	addeq	r0, #1
 8000282:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000286:	3001      	addeq	r0, #1
 8000288:	bcf0      	pop	{r4, r5, r6, r7}
 800028a:	3801      	subs	r0, #1
 800028c:	4770      	bx	lr
 800028e:	bf00      	nop

08000290 <__aeabi_drsub>:
 8000290:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000294:	e002      	b.n	800029c <__adddf3>
 8000296:	bf00      	nop

08000298 <__aeabi_dsub>:
 8000298:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800029c <__adddf3>:
 800029c:	b530      	push	{r4, r5, lr}
 800029e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002a2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002a6:	ea94 0f05 	teq	r4, r5
 80002aa:	bf08      	it	eq
 80002ac:	ea90 0f02 	teqeq	r0, r2
 80002b0:	bf1f      	itttt	ne
 80002b2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002b6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002ba:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002be:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002c2:	f000 80e2 	beq.w	800048a <__adddf3+0x1ee>
 80002c6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002ca:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002ce:	bfb8      	it	lt
 80002d0:	426d      	neglt	r5, r5
 80002d2:	dd0c      	ble.n	80002ee <__adddf3+0x52>
 80002d4:	442c      	add	r4, r5
 80002d6:	ea80 0202 	eor.w	r2, r0, r2
 80002da:	ea81 0303 	eor.w	r3, r1, r3
 80002de:	ea82 0000 	eor.w	r0, r2, r0
 80002e2:	ea83 0101 	eor.w	r1, r3, r1
 80002e6:	ea80 0202 	eor.w	r2, r0, r2
 80002ea:	ea81 0303 	eor.w	r3, r1, r3
 80002ee:	2d36      	cmp	r5, #54	; 0x36
 80002f0:	bf88      	it	hi
 80002f2:	bd30      	pophi	{r4, r5, pc}
 80002f4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80002f8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80002fc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000300:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000304:	d002      	beq.n	800030c <__adddf3+0x70>
 8000306:	4240      	negs	r0, r0
 8000308:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800030c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000310:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000314:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000318:	d002      	beq.n	8000320 <__adddf3+0x84>
 800031a:	4252      	negs	r2, r2
 800031c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000320:	ea94 0f05 	teq	r4, r5
 8000324:	f000 80a7 	beq.w	8000476 <__adddf3+0x1da>
 8000328:	f1a4 0401 	sub.w	r4, r4, #1
 800032c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000330:	db0d      	blt.n	800034e <__adddf3+0xb2>
 8000332:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000336:	fa22 f205 	lsr.w	r2, r2, r5
 800033a:	1880      	adds	r0, r0, r2
 800033c:	f141 0100 	adc.w	r1, r1, #0
 8000340:	fa03 f20e 	lsl.w	r2, r3, lr
 8000344:	1880      	adds	r0, r0, r2
 8000346:	fa43 f305 	asr.w	r3, r3, r5
 800034a:	4159      	adcs	r1, r3
 800034c:	e00e      	b.n	800036c <__adddf3+0xd0>
 800034e:	f1a5 0520 	sub.w	r5, r5, #32
 8000352:	f10e 0e20 	add.w	lr, lr, #32
 8000356:	2a01      	cmp	r2, #1
 8000358:	fa03 fc0e 	lsl.w	ip, r3, lr
 800035c:	bf28      	it	cs
 800035e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000362:	fa43 f305 	asr.w	r3, r3, r5
 8000366:	18c0      	adds	r0, r0, r3
 8000368:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800036c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000370:	d507      	bpl.n	8000382 <__adddf3+0xe6>
 8000372:	f04f 0e00 	mov.w	lr, #0
 8000376:	f1dc 0c00 	rsbs	ip, ip, #0
 800037a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800037e:	eb6e 0101 	sbc.w	r1, lr, r1
 8000382:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8000386:	d31b      	bcc.n	80003c0 <__adddf3+0x124>
 8000388:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800038c:	d30c      	bcc.n	80003a8 <__adddf3+0x10c>
 800038e:	0849      	lsrs	r1, r1, #1
 8000390:	ea5f 0030 	movs.w	r0, r0, rrx
 8000394:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000398:	f104 0401 	add.w	r4, r4, #1
 800039c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003a0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003a4:	f080 809a 	bcs.w	80004dc <__adddf3+0x240>
 80003a8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80003ac:	bf08      	it	eq
 80003ae:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003b2:	f150 0000 	adcs.w	r0, r0, #0
 80003b6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003ba:	ea41 0105 	orr.w	r1, r1, r5
 80003be:	bd30      	pop	{r4, r5, pc}
 80003c0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003c4:	4140      	adcs	r0, r0
 80003c6:	eb41 0101 	adc.w	r1, r1, r1
 80003ca:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80003ce:	f1a4 0401 	sub.w	r4, r4, #1
 80003d2:	d1e9      	bne.n	80003a8 <__adddf3+0x10c>
 80003d4:	f091 0f00 	teq	r1, #0
 80003d8:	bf04      	itt	eq
 80003da:	4601      	moveq	r1, r0
 80003dc:	2000      	moveq	r0, #0
 80003de:	fab1 f381 	clz	r3, r1
 80003e2:	bf08      	it	eq
 80003e4:	3320      	addeq	r3, #32
 80003e6:	f1a3 030b 	sub.w	r3, r3, #11
 80003ea:	f1b3 0220 	subs.w	r2, r3, #32
 80003ee:	da0c      	bge.n	800040a <__adddf3+0x16e>
 80003f0:	320c      	adds	r2, #12
 80003f2:	dd08      	ble.n	8000406 <__adddf3+0x16a>
 80003f4:	f102 0c14 	add.w	ip, r2, #20
 80003f8:	f1c2 020c 	rsb	r2, r2, #12
 80003fc:	fa01 f00c 	lsl.w	r0, r1, ip
 8000400:	fa21 f102 	lsr.w	r1, r1, r2
 8000404:	e00c      	b.n	8000420 <__adddf3+0x184>
 8000406:	f102 0214 	add.w	r2, r2, #20
 800040a:	bfd8      	it	le
 800040c:	f1c2 0c20 	rsble	ip, r2, #32
 8000410:	fa01 f102 	lsl.w	r1, r1, r2
 8000414:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000418:	bfdc      	itt	le
 800041a:	ea41 010c 	orrle.w	r1, r1, ip
 800041e:	4090      	lslle	r0, r2
 8000420:	1ae4      	subs	r4, r4, r3
 8000422:	bfa2      	ittt	ge
 8000424:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000428:	4329      	orrge	r1, r5
 800042a:	bd30      	popge	{r4, r5, pc}
 800042c:	ea6f 0404 	mvn.w	r4, r4
 8000430:	3c1f      	subs	r4, #31
 8000432:	da1c      	bge.n	800046e <__adddf3+0x1d2>
 8000434:	340c      	adds	r4, #12
 8000436:	dc0e      	bgt.n	8000456 <__adddf3+0x1ba>
 8000438:	f104 0414 	add.w	r4, r4, #20
 800043c:	f1c4 0220 	rsb	r2, r4, #32
 8000440:	fa20 f004 	lsr.w	r0, r0, r4
 8000444:	fa01 f302 	lsl.w	r3, r1, r2
 8000448:	ea40 0003 	orr.w	r0, r0, r3
 800044c:	fa21 f304 	lsr.w	r3, r1, r4
 8000450:	ea45 0103 	orr.w	r1, r5, r3
 8000454:	bd30      	pop	{r4, r5, pc}
 8000456:	f1c4 040c 	rsb	r4, r4, #12
 800045a:	f1c4 0220 	rsb	r2, r4, #32
 800045e:	fa20 f002 	lsr.w	r0, r0, r2
 8000462:	fa01 f304 	lsl.w	r3, r1, r4
 8000466:	ea40 0003 	orr.w	r0, r0, r3
 800046a:	4629      	mov	r1, r5
 800046c:	bd30      	pop	{r4, r5, pc}
 800046e:	fa21 f004 	lsr.w	r0, r1, r4
 8000472:	4629      	mov	r1, r5
 8000474:	bd30      	pop	{r4, r5, pc}
 8000476:	f094 0f00 	teq	r4, #0
 800047a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800047e:	bf06      	itte	eq
 8000480:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8000484:	3401      	addeq	r4, #1
 8000486:	3d01      	subne	r5, #1
 8000488:	e74e      	b.n	8000328 <__adddf3+0x8c>
 800048a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800048e:	bf18      	it	ne
 8000490:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000494:	d029      	beq.n	80004ea <__adddf3+0x24e>
 8000496:	ea94 0f05 	teq	r4, r5
 800049a:	bf08      	it	eq
 800049c:	ea90 0f02 	teqeq	r0, r2
 80004a0:	d005      	beq.n	80004ae <__adddf3+0x212>
 80004a2:	ea54 0c00 	orrs.w	ip, r4, r0
 80004a6:	bf04      	itt	eq
 80004a8:	4619      	moveq	r1, r3
 80004aa:	4610      	moveq	r0, r2
 80004ac:	bd30      	pop	{r4, r5, pc}
 80004ae:	ea91 0f03 	teq	r1, r3
 80004b2:	bf1e      	ittt	ne
 80004b4:	2100      	movne	r1, #0
 80004b6:	2000      	movne	r0, #0
 80004b8:	bd30      	popne	{r4, r5, pc}
 80004ba:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004be:	d105      	bne.n	80004cc <__adddf3+0x230>
 80004c0:	0040      	lsls	r0, r0, #1
 80004c2:	4149      	adcs	r1, r1
 80004c4:	bf28      	it	cs
 80004c6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80004ca:	bd30      	pop	{r4, r5, pc}
 80004cc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80004d0:	bf3c      	itt	cc
 80004d2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80004d6:	bd30      	popcc	{r4, r5, pc}
 80004d8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004dc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80004e0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80004e4:	f04f 0000 	mov.w	r0, #0
 80004e8:	bd30      	pop	{r4, r5, pc}
 80004ea:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004ee:	bf1a      	itte	ne
 80004f0:	4619      	movne	r1, r3
 80004f2:	4610      	movne	r0, r2
 80004f4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80004f8:	bf1c      	itt	ne
 80004fa:	460b      	movne	r3, r1
 80004fc:	4602      	movne	r2, r0
 80004fe:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000502:	bf06      	itte	eq
 8000504:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000508:	ea91 0f03 	teqeq	r1, r3
 800050c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000510:	bd30      	pop	{r4, r5, pc}
 8000512:	bf00      	nop

08000514 <__aeabi_ui2d>:
 8000514:	f090 0f00 	teq	r0, #0
 8000518:	bf04      	itt	eq
 800051a:	2100      	moveq	r1, #0
 800051c:	4770      	bxeq	lr
 800051e:	b530      	push	{r4, r5, lr}
 8000520:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000524:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000528:	f04f 0500 	mov.w	r5, #0
 800052c:	f04f 0100 	mov.w	r1, #0
 8000530:	e750      	b.n	80003d4 <__adddf3+0x138>
 8000532:	bf00      	nop

08000534 <__aeabi_i2d>:
 8000534:	f090 0f00 	teq	r0, #0
 8000538:	bf04      	itt	eq
 800053a:	2100      	moveq	r1, #0
 800053c:	4770      	bxeq	lr
 800053e:	b530      	push	{r4, r5, lr}
 8000540:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000544:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000548:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800054c:	bf48      	it	mi
 800054e:	4240      	negmi	r0, r0
 8000550:	f04f 0100 	mov.w	r1, #0
 8000554:	e73e      	b.n	80003d4 <__adddf3+0x138>
 8000556:	bf00      	nop

08000558 <__aeabi_f2d>:
 8000558:	0042      	lsls	r2, r0, #1
 800055a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800055e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000562:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000566:	bf1f      	itttt	ne
 8000568:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800056c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000570:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000574:	4770      	bxne	lr
 8000576:	f092 0f00 	teq	r2, #0
 800057a:	bf14      	ite	ne
 800057c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000580:	4770      	bxeq	lr
 8000582:	b530      	push	{r4, r5, lr}
 8000584:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000588:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800058c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000590:	e720      	b.n	80003d4 <__adddf3+0x138>
 8000592:	bf00      	nop

08000594 <__aeabi_ul2d>:
 8000594:	ea50 0201 	orrs.w	r2, r0, r1
 8000598:	bf08      	it	eq
 800059a:	4770      	bxeq	lr
 800059c:	b530      	push	{r4, r5, lr}
 800059e:	f04f 0500 	mov.w	r5, #0
 80005a2:	e00a      	b.n	80005ba <__aeabi_l2d+0x16>

080005a4 <__aeabi_l2d>:
 80005a4:	ea50 0201 	orrs.w	r2, r0, r1
 80005a8:	bf08      	it	eq
 80005aa:	4770      	bxeq	lr
 80005ac:	b530      	push	{r4, r5, lr}
 80005ae:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80005b2:	d502      	bpl.n	80005ba <__aeabi_l2d+0x16>
 80005b4:	4240      	negs	r0, r0
 80005b6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005ba:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005be:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005c2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005c6:	f43f aedc 	beq.w	8000382 <__adddf3+0xe6>
 80005ca:	f04f 0203 	mov.w	r2, #3
 80005ce:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005d2:	bf18      	it	ne
 80005d4:	3203      	addne	r2, #3
 80005d6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005da:	bf18      	it	ne
 80005dc:	3203      	addne	r2, #3
 80005de:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80005e2:	f1c2 0320 	rsb	r3, r2, #32
 80005e6:	fa00 fc03 	lsl.w	ip, r0, r3
 80005ea:	fa20 f002 	lsr.w	r0, r0, r2
 80005ee:	fa01 fe03 	lsl.w	lr, r1, r3
 80005f2:	ea40 000e 	orr.w	r0, r0, lr
 80005f6:	fa21 f102 	lsr.w	r1, r1, r2
 80005fa:	4414      	add	r4, r2
 80005fc:	e6c1      	b.n	8000382 <__adddf3+0xe6>
 80005fe:	bf00      	nop

08000600 <__aeabi_dmul>:
 8000600:	b570      	push	{r4, r5, r6, lr}
 8000602:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000606:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800060a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800060e:	bf1d      	ittte	ne
 8000610:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000614:	ea94 0f0c 	teqne	r4, ip
 8000618:	ea95 0f0c 	teqne	r5, ip
 800061c:	f000 f8de 	bleq	80007dc <__aeabi_dmul+0x1dc>
 8000620:	442c      	add	r4, r5
 8000622:	ea81 0603 	eor.w	r6, r1, r3
 8000626:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800062a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800062e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000632:	bf18      	it	ne
 8000634:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000638:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800063c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000640:	d038      	beq.n	80006b4 <__aeabi_dmul+0xb4>
 8000642:	fba0 ce02 	umull	ip, lr, r0, r2
 8000646:	f04f 0500 	mov.w	r5, #0
 800064a:	fbe1 e502 	umlal	lr, r5, r1, r2
 800064e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8000652:	fbe0 e503 	umlal	lr, r5, r0, r3
 8000656:	f04f 0600 	mov.w	r6, #0
 800065a:	fbe1 5603 	umlal	r5, r6, r1, r3
 800065e:	f09c 0f00 	teq	ip, #0
 8000662:	bf18      	it	ne
 8000664:	f04e 0e01 	orrne.w	lr, lr, #1
 8000668:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800066c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000670:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000674:	d204      	bcs.n	8000680 <__aeabi_dmul+0x80>
 8000676:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800067a:	416d      	adcs	r5, r5
 800067c:	eb46 0606 	adc.w	r6, r6, r6
 8000680:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000684:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000688:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800068c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000690:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000694:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000698:	bf88      	it	hi
 800069a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800069e:	d81e      	bhi.n	80006de <__aeabi_dmul+0xde>
 80006a0:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80006a4:	bf08      	it	eq
 80006a6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80006aa:	f150 0000 	adcs.w	r0, r0, #0
 80006ae:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80006b2:	bd70      	pop	{r4, r5, r6, pc}
 80006b4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80006b8:	ea46 0101 	orr.w	r1, r6, r1
 80006bc:	ea40 0002 	orr.w	r0, r0, r2
 80006c0:	ea81 0103 	eor.w	r1, r1, r3
 80006c4:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80006c8:	bfc2      	ittt	gt
 80006ca:	ebd4 050c 	rsbsgt	r5, r4, ip
 80006ce:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80006d2:	bd70      	popgt	{r4, r5, r6, pc}
 80006d4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80006d8:	f04f 0e00 	mov.w	lr, #0
 80006dc:	3c01      	subs	r4, #1
 80006de:	f300 80ab 	bgt.w	8000838 <__aeabi_dmul+0x238>
 80006e2:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80006e6:	bfde      	ittt	le
 80006e8:	2000      	movle	r0, #0
 80006ea:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80006ee:	bd70      	pople	{r4, r5, r6, pc}
 80006f0:	f1c4 0400 	rsb	r4, r4, #0
 80006f4:	3c20      	subs	r4, #32
 80006f6:	da35      	bge.n	8000764 <__aeabi_dmul+0x164>
 80006f8:	340c      	adds	r4, #12
 80006fa:	dc1b      	bgt.n	8000734 <__aeabi_dmul+0x134>
 80006fc:	f104 0414 	add.w	r4, r4, #20
 8000700:	f1c4 0520 	rsb	r5, r4, #32
 8000704:	fa00 f305 	lsl.w	r3, r0, r5
 8000708:	fa20 f004 	lsr.w	r0, r0, r4
 800070c:	fa01 f205 	lsl.w	r2, r1, r5
 8000710:	ea40 0002 	orr.w	r0, r0, r2
 8000714:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000718:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800071c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000720:	fa21 f604 	lsr.w	r6, r1, r4
 8000724:	eb42 0106 	adc.w	r1, r2, r6
 8000728:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800072c:	bf08      	it	eq
 800072e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000732:	bd70      	pop	{r4, r5, r6, pc}
 8000734:	f1c4 040c 	rsb	r4, r4, #12
 8000738:	f1c4 0520 	rsb	r5, r4, #32
 800073c:	fa00 f304 	lsl.w	r3, r0, r4
 8000740:	fa20 f005 	lsr.w	r0, r0, r5
 8000744:	fa01 f204 	lsl.w	r2, r1, r4
 8000748:	ea40 0002 	orr.w	r0, r0, r2
 800074c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000750:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000754:	f141 0100 	adc.w	r1, r1, #0
 8000758:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800075c:	bf08      	it	eq
 800075e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000762:	bd70      	pop	{r4, r5, r6, pc}
 8000764:	f1c4 0520 	rsb	r5, r4, #32
 8000768:	fa00 f205 	lsl.w	r2, r0, r5
 800076c:	ea4e 0e02 	orr.w	lr, lr, r2
 8000770:	fa20 f304 	lsr.w	r3, r0, r4
 8000774:	fa01 f205 	lsl.w	r2, r1, r5
 8000778:	ea43 0302 	orr.w	r3, r3, r2
 800077c:	fa21 f004 	lsr.w	r0, r1, r4
 8000780:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000784:	fa21 f204 	lsr.w	r2, r1, r4
 8000788:	ea20 0002 	bic.w	r0, r0, r2
 800078c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000790:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000794:	bf08      	it	eq
 8000796:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800079a:	bd70      	pop	{r4, r5, r6, pc}
 800079c:	f094 0f00 	teq	r4, #0
 80007a0:	d10f      	bne.n	80007c2 <__aeabi_dmul+0x1c2>
 80007a2:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80007a6:	0040      	lsls	r0, r0, #1
 80007a8:	eb41 0101 	adc.w	r1, r1, r1
 80007ac:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80007b0:	bf08      	it	eq
 80007b2:	3c01      	subeq	r4, #1
 80007b4:	d0f7      	beq.n	80007a6 <__aeabi_dmul+0x1a6>
 80007b6:	ea41 0106 	orr.w	r1, r1, r6
 80007ba:	f095 0f00 	teq	r5, #0
 80007be:	bf18      	it	ne
 80007c0:	4770      	bxne	lr
 80007c2:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80007c6:	0052      	lsls	r2, r2, #1
 80007c8:	eb43 0303 	adc.w	r3, r3, r3
 80007cc:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80007d0:	bf08      	it	eq
 80007d2:	3d01      	subeq	r5, #1
 80007d4:	d0f7      	beq.n	80007c6 <__aeabi_dmul+0x1c6>
 80007d6:	ea43 0306 	orr.w	r3, r3, r6
 80007da:	4770      	bx	lr
 80007dc:	ea94 0f0c 	teq	r4, ip
 80007e0:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80007e4:	bf18      	it	ne
 80007e6:	ea95 0f0c 	teqne	r5, ip
 80007ea:	d00c      	beq.n	8000806 <__aeabi_dmul+0x206>
 80007ec:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80007f0:	bf18      	it	ne
 80007f2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80007f6:	d1d1      	bne.n	800079c <__aeabi_dmul+0x19c>
 80007f8:	ea81 0103 	eor.w	r1, r1, r3
 80007fc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000800:	f04f 0000 	mov.w	r0, #0
 8000804:	bd70      	pop	{r4, r5, r6, pc}
 8000806:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800080a:	bf06      	itte	eq
 800080c:	4610      	moveq	r0, r2
 800080e:	4619      	moveq	r1, r3
 8000810:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000814:	d019      	beq.n	800084a <__aeabi_dmul+0x24a>
 8000816:	ea94 0f0c 	teq	r4, ip
 800081a:	d102      	bne.n	8000822 <__aeabi_dmul+0x222>
 800081c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000820:	d113      	bne.n	800084a <__aeabi_dmul+0x24a>
 8000822:	ea95 0f0c 	teq	r5, ip
 8000826:	d105      	bne.n	8000834 <__aeabi_dmul+0x234>
 8000828:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800082c:	bf1c      	itt	ne
 800082e:	4610      	movne	r0, r2
 8000830:	4619      	movne	r1, r3
 8000832:	d10a      	bne.n	800084a <__aeabi_dmul+0x24a>
 8000834:	ea81 0103 	eor.w	r1, r1, r3
 8000838:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800083c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000840:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000844:	f04f 0000 	mov.w	r0, #0
 8000848:	bd70      	pop	{r4, r5, r6, pc}
 800084a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800084e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8000852:	bd70      	pop	{r4, r5, r6, pc}

08000854 <__aeabi_ddiv>:
 8000854:	b570      	push	{r4, r5, r6, lr}
 8000856:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800085a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800085e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000862:	bf1d      	ittte	ne
 8000864:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000868:	ea94 0f0c 	teqne	r4, ip
 800086c:	ea95 0f0c 	teqne	r5, ip
 8000870:	f000 f8a7 	bleq	80009c2 <__aeabi_ddiv+0x16e>
 8000874:	eba4 0405 	sub.w	r4, r4, r5
 8000878:	ea81 0e03 	eor.w	lr, r1, r3
 800087c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000880:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000884:	f000 8088 	beq.w	8000998 <__aeabi_ddiv+0x144>
 8000888:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800088c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8000890:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8000894:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000898:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800089c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80008a0:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80008a4:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80008a8:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80008ac:	429d      	cmp	r5, r3
 80008ae:	bf08      	it	eq
 80008b0:	4296      	cmpeq	r6, r2
 80008b2:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80008b6:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80008ba:	d202      	bcs.n	80008c2 <__aeabi_ddiv+0x6e>
 80008bc:	085b      	lsrs	r3, r3, #1
 80008be:	ea4f 0232 	mov.w	r2, r2, rrx
 80008c2:	1ab6      	subs	r6, r6, r2
 80008c4:	eb65 0503 	sbc.w	r5, r5, r3
 80008c8:	085b      	lsrs	r3, r3, #1
 80008ca:	ea4f 0232 	mov.w	r2, r2, rrx
 80008ce:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80008d2:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80008d6:	ebb6 0e02 	subs.w	lr, r6, r2
 80008da:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008de:	bf22      	ittt	cs
 80008e0:	1ab6      	subcs	r6, r6, r2
 80008e2:	4675      	movcs	r5, lr
 80008e4:	ea40 000c 	orrcs.w	r0, r0, ip
 80008e8:	085b      	lsrs	r3, r3, #1
 80008ea:	ea4f 0232 	mov.w	r2, r2, rrx
 80008ee:	ebb6 0e02 	subs.w	lr, r6, r2
 80008f2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008f6:	bf22      	ittt	cs
 80008f8:	1ab6      	subcs	r6, r6, r2
 80008fa:	4675      	movcs	r5, lr
 80008fc:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000900:	085b      	lsrs	r3, r3, #1
 8000902:	ea4f 0232 	mov.w	r2, r2, rrx
 8000906:	ebb6 0e02 	subs.w	lr, r6, r2
 800090a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800090e:	bf22      	ittt	cs
 8000910:	1ab6      	subcs	r6, r6, r2
 8000912:	4675      	movcs	r5, lr
 8000914:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000918:	085b      	lsrs	r3, r3, #1
 800091a:	ea4f 0232 	mov.w	r2, r2, rrx
 800091e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000922:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000926:	bf22      	ittt	cs
 8000928:	1ab6      	subcs	r6, r6, r2
 800092a:	4675      	movcs	r5, lr
 800092c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000930:	ea55 0e06 	orrs.w	lr, r5, r6
 8000934:	d018      	beq.n	8000968 <__aeabi_ddiv+0x114>
 8000936:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800093a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800093e:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000942:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000946:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800094a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800094e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000952:	d1c0      	bne.n	80008d6 <__aeabi_ddiv+0x82>
 8000954:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000958:	d10b      	bne.n	8000972 <__aeabi_ddiv+0x11e>
 800095a:	ea41 0100 	orr.w	r1, r1, r0
 800095e:	f04f 0000 	mov.w	r0, #0
 8000962:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8000966:	e7b6      	b.n	80008d6 <__aeabi_ddiv+0x82>
 8000968:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800096c:	bf04      	itt	eq
 800096e:	4301      	orreq	r1, r0
 8000970:	2000      	moveq	r0, #0
 8000972:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000976:	bf88      	it	hi
 8000978:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800097c:	f63f aeaf 	bhi.w	80006de <__aeabi_dmul+0xde>
 8000980:	ebb5 0c03 	subs.w	ip, r5, r3
 8000984:	bf04      	itt	eq
 8000986:	ebb6 0c02 	subseq.w	ip, r6, r2
 800098a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800098e:	f150 0000 	adcs.w	r0, r0, #0
 8000992:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000996:	bd70      	pop	{r4, r5, r6, pc}
 8000998:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800099c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80009a0:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80009a4:	bfc2      	ittt	gt
 80009a6:	ebd4 050c 	rsbsgt	r5, r4, ip
 80009aa:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80009ae:	bd70      	popgt	{r4, r5, r6, pc}
 80009b0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80009b4:	f04f 0e00 	mov.w	lr, #0
 80009b8:	3c01      	subs	r4, #1
 80009ba:	e690      	b.n	80006de <__aeabi_dmul+0xde>
 80009bc:	ea45 0e06 	orr.w	lr, r5, r6
 80009c0:	e68d      	b.n	80006de <__aeabi_dmul+0xde>
 80009c2:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009c6:	ea94 0f0c 	teq	r4, ip
 80009ca:	bf08      	it	eq
 80009cc:	ea95 0f0c 	teqeq	r5, ip
 80009d0:	f43f af3b 	beq.w	800084a <__aeabi_dmul+0x24a>
 80009d4:	ea94 0f0c 	teq	r4, ip
 80009d8:	d10a      	bne.n	80009f0 <__aeabi_ddiv+0x19c>
 80009da:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80009de:	f47f af34 	bne.w	800084a <__aeabi_dmul+0x24a>
 80009e2:	ea95 0f0c 	teq	r5, ip
 80009e6:	f47f af25 	bne.w	8000834 <__aeabi_dmul+0x234>
 80009ea:	4610      	mov	r0, r2
 80009ec:	4619      	mov	r1, r3
 80009ee:	e72c      	b.n	800084a <__aeabi_dmul+0x24a>
 80009f0:	ea95 0f0c 	teq	r5, ip
 80009f4:	d106      	bne.n	8000a04 <__aeabi_ddiv+0x1b0>
 80009f6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80009fa:	f43f aefd 	beq.w	80007f8 <__aeabi_dmul+0x1f8>
 80009fe:	4610      	mov	r0, r2
 8000a00:	4619      	mov	r1, r3
 8000a02:	e722      	b.n	800084a <__aeabi_dmul+0x24a>
 8000a04:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a08:	bf18      	it	ne
 8000a0a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a0e:	f47f aec5 	bne.w	800079c <__aeabi_dmul+0x19c>
 8000a12:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a16:	f47f af0d 	bne.w	8000834 <__aeabi_dmul+0x234>
 8000a1a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a1e:	f47f aeeb 	bne.w	80007f8 <__aeabi_dmul+0x1f8>
 8000a22:	e712      	b.n	800084a <__aeabi_dmul+0x24a>

08000a24 <__aeabi_d2iz>:
 8000a24:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a28:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000a2c:	d215      	bcs.n	8000a5a <__aeabi_d2iz+0x36>
 8000a2e:	d511      	bpl.n	8000a54 <__aeabi_d2iz+0x30>
 8000a30:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000a34:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000a38:	d912      	bls.n	8000a60 <__aeabi_d2iz+0x3c>
 8000a3a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000a3e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000a42:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000a46:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000a4a:	fa23 f002 	lsr.w	r0, r3, r2
 8000a4e:	bf18      	it	ne
 8000a50:	4240      	negne	r0, r0
 8000a52:	4770      	bx	lr
 8000a54:	f04f 0000 	mov.w	r0, #0
 8000a58:	4770      	bx	lr
 8000a5a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000a5e:	d105      	bne.n	8000a6c <__aeabi_d2iz+0x48>
 8000a60:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000a64:	bf08      	it	eq
 8000a66:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000a6a:	4770      	bx	lr
 8000a6c:	f04f 0000 	mov.w	r0, #0
 8000a70:	4770      	bx	lr
 8000a72:	bf00      	nop

08000a74 <__aeabi_ldivmod>:
 8000a74:	b97b      	cbnz	r3, 8000a96 <__aeabi_ldivmod+0x22>
 8000a76:	b972      	cbnz	r2, 8000a96 <__aeabi_ldivmod+0x22>
 8000a78:	2900      	cmp	r1, #0
 8000a7a:	bfbe      	ittt	lt
 8000a7c:	2000      	movlt	r0, #0
 8000a7e:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
 8000a82:	e006      	blt.n	8000a92 <__aeabi_ldivmod+0x1e>
 8000a84:	bf08      	it	eq
 8000a86:	2800      	cmpeq	r0, #0
 8000a88:	bf1c      	itt	ne
 8000a8a:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
 8000a8e:	f04f 30ff 	movne.w	r0, #4294967295
 8000a92:	f000 b9c5 	b.w	8000e20 <__aeabi_idiv0>
 8000a96:	f1ad 0c08 	sub.w	ip, sp, #8
 8000a9a:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000a9e:	2900      	cmp	r1, #0
 8000aa0:	db09      	blt.n	8000ab6 <__aeabi_ldivmod+0x42>
 8000aa2:	2b00      	cmp	r3, #0
 8000aa4:	db1a      	blt.n	8000adc <__aeabi_ldivmod+0x68>
 8000aa6:	f000 f84d 	bl	8000b44 <__udivmoddi4>
 8000aaa:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000aae:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000ab2:	b004      	add	sp, #16
 8000ab4:	4770      	bx	lr
 8000ab6:	4240      	negs	r0, r0
 8000ab8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000abc:	2b00      	cmp	r3, #0
 8000abe:	db1b      	blt.n	8000af8 <__aeabi_ldivmod+0x84>
 8000ac0:	f000 f840 	bl	8000b44 <__udivmoddi4>
 8000ac4:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000ac8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000acc:	b004      	add	sp, #16
 8000ace:	4240      	negs	r0, r0
 8000ad0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000ad4:	4252      	negs	r2, r2
 8000ad6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000ada:	4770      	bx	lr
 8000adc:	4252      	negs	r2, r2
 8000ade:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000ae2:	f000 f82f 	bl	8000b44 <__udivmoddi4>
 8000ae6:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000aea:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000aee:	b004      	add	sp, #16
 8000af0:	4240      	negs	r0, r0
 8000af2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000af6:	4770      	bx	lr
 8000af8:	4252      	negs	r2, r2
 8000afa:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000afe:	f000 f821 	bl	8000b44 <__udivmoddi4>
 8000b02:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000b06:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000b0a:	b004      	add	sp, #16
 8000b0c:	4252      	negs	r2, r2
 8000b0e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000b12:	4770      	bx	lr

08000b14 <__aeabi_uldivmod>:
 8000b14:	b953      	cbnz	r3, 8000b2c <__aeabi_uldivmod+0x18>
 8000b16:	b94a      	cbnz	r2, 8000b2c <__aeabi_uldivmod+0x18>
 8000b18:	2900      	cmp	r1, #0
 8000b1a:	bf08      	it	eq
 8000b1c:	2800      	cmpeq	r0, #0
 8000b1e:	bf1c      	itt	ne
 8000b20:	f04f 31ff 	movne.w	r1, #4294967295
 8000b24:	f04f 30ff 	movne.w	r0, #4294967295
 8000b28:	f000 b97a 	b.w	8000e20 <__aeabi_idiv0>
 8000b2c:	f1ad 0c08 	sub.w	ip, sp, #8
 8000b30:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000b34:	f000 f806 	bl	8000b44 <__udivmoddi4>
 8000b38:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000b3c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000b40:	b004      	add	sp, #16
 8000b42:	4770      	bx	lr

08000b44 <__udivmoddi4>:
 8000b44:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000b48:	468c      	mov	ip, r1
 8000b4a:	460d      	mov	r5, r1
 8000b4c:	4604      	mov	r4, r0
 8000b4e:	9e08      	ldr	r6, [sp, #32]
 8000b50:	2b00      	cmp	r3, #0
 8000b52:	d151      	bne.n	8000bf8 <__udivmoddi4+0xb4>
 8000b54:	428a      	cmp	r2, r1
 8000b56:	4617      	mov	r7, r2
 8000b58:	d96d      	bls.n	8000c36 <__udivmoddi4+0xf2>
 8000b5a:	fab2 fe82 	clz	lr, r2
 8000b5e:	f1be 0f00 	cmp.w	lr, #0
 8000b62:	d00b      	beq.n	8000b7c <__udivmoddi4+0x38>
 8000b64:	f1ce 0c20 	rsb	ip, lr, #32
 8000b68:	fa01 f50e 	lsl.w	r5, r1, lr
 8000b6c:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000b70:	fa02 f70e 	lsl.w	r7, r2, lr
 8000b74:	ea4c 0c05 	orr.w	ip, ip, r5
 8000b78:	fa00 f40e 	lsl.w	r4, r0, lr
 8000b7c:	ea4f 4a17 	mov.w	sl, r7, lsr #16
 8000b80:	0c25      	lsrs	r5, r4, #16
 8000b82:	fbbc f8fa 	udiv	r8, ip, sl
 8000b86:	fa1f f987 	uxth.w	r9, r7
 8000b8a:	fb0a cc18 	mls	ip, sl, r8, ip
 8000b8e:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 8000b92:	fb08 f309 	mul.w	r3, r8, r9
 8000b96:	42ab      	cmp	r3, r5
 8000b98:	d90a      	bls.n	8000bb0 <__udivmoddi4+0x6c>
 8000b9a:	19ed      	adds	r5, r5, r7
 8000b9c:	f108 32ff 	add.w	r2, r8, #4294967295
 8000ba0:	f080 8123 	bcs.w	8000dea <__udivmoddi4+0x2a6>
 8000ba4:	42ab      	cmp	r3, r5
 8000ba6:	f240 8120 	bls.w	8000dea <__udivmoddi4+0x2a6>
 8000baa:	f1a8 0802 	sub.w	r8, r8, #2
 8000bae:	443d      	add	r5, r7
 8000bb0:	1aed      	subs	r5, r5, r3
 8000bb2:	b2a4      	uxth	r4, r4
 8000bb4:	fbb5 f0fa 	udiv	r0, r5, sl
 8000bb8:	fb0a 5510 	mls	r5, sl, r0, r5
 8000bbc:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8000bc0:	fb00 f909 	mul.w	r9, r0, r9
 8000bc4:	45a1      	cmp	r9, r4
 8000bc6:	d909      	bls.n	8000bdc <__udivmoddi4+0x98>
 8000bc8:	19e4      	adds	r4, r4, r7
 8000bca:	f100 33ff 	add.w	r3, r0, #4294967295
 8000bce:	f080 810a 	bcs.w	8000de6 <__udivmoddi4+0x2a2>
 8000bd2:	45a1      	cmp	r9, r4
 8000bd4:	f240 8107 	bls.w	8000de6 <__udivmoddi4+0x2a2>
 8000bd8:	3802      	subs	r0, #2
 8000bda:	443c      	add	r4, r7
 8000bdc:	eba4 0409 	sub.w	r4, r4, r9
 8000be0:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000be4:	2100      	movs	r1, #0
 8000be6:	2e00      	cmp	r6, #0
 8000be8:	d061      	beq.n	8000cae <__udivmoddi4+0x16a>
 8000bea:	fa24 f40e 	lsr.w	r4, r4, lr
 8000bee:	2300      	movs	r3, #0
 8000bf0:	6034      	str	r4, [r6, #0]
 8000bf2:	6073      	str	r3, [r6, #4]
 8000bf4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000bf8:	428b      	cmp	r3, r1
 8000bfa:	d907      	bls.n	8000c0c <__udivmoddi4+0xc8>
 8000bfc:	2e00      	cmp	r6, #0
 8000bfe:	d054      	beq.n	8000caa <__udivmoddi4+0x166>
 8000c00:	2100      	movs	r1, #0
 8000c02:	e886 0021 	stmia.w	r6, {r0, r5}
 8000c06:	4608      	mov	r0, r1
 8000c08:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000c0c:	fab3 f183 	clz	r1, r3
 8000c10:	2900      	cmp	r1, #0
 8000c12:	f040 808e 	bne.w	8000d32 <__udivmoddi4+0x1ee>
 8000c16:	42ab      	cmp	r3, r5
 8000c18:	d302      	bcc.n	8000c20 <__udivmoddi4+0xdc>
 8000c1a:	4282      	cmp	r2, r0
 8000c1c:	f200 80fa 	bhi.w	8000e14 <__udivmoddi4+0x2d0>
 8000c20:	1a84      	subs	r4, r0, r2
 8000c22:	eb65 0503 	sbc.w	r5, r5, r3
 8000c26:	2001      	movs	r0, #1
 8000c28:	46ac      	mov	ip, r5
 8000c2a:	2e00      	cmp	r6, #0
 8000c2c:	d03f      	beq.n	8000cae <__udivmoddi4+0x16a>
 8000c2e:	e886 1010 	stmia.w	r6, {r4, ip}
 8000c32:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000c36:	b912      	cbnz	r2, 8000c3e <__udivmoddi4+0xfa>
 8000c38:	2701      	movs	r7, #1
 8000c3a:	fbb7 f7f2 	udiv	r7, r7, r2
 8000c3e:	fab7 fe87 	clz	lr, r7
 8000c42:	f1be 0f00 	cmp.w	lr, #0
 8000c46:	d134      	bne.n	8000cb2 <__udivmoddi4+0x16e>
 8000c48:	1beb      	subs	r3, r5, r7
 8000c4a:	0c3a      	lsrs	r2, r7, #16
 8000c4c:	fa1f fc87 	uxth.w	ip, r7
 8000c50:	2101      	movs	r1, #1
 8000c52:	fbb3 f8f2 	udiv	r8, r3, r2
 8000c56:	0c25      	lsrs	r5, r4, #16
 8000c58:	fb02 3318 	mls	r3, r2, r8, r3
 8000c5c:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 8000c60:	fb0c f308 	mul.w	r3, ip, r8
 8000c64:	42ab      	cmp	r3, r5
 8000c66:	d907      	bls.n	8000c78 <__udivmoddi4+0x134>
 8000c68:	19ed      	adds	r5, r5, r7
 8000c6a:	f108 30ff 	add.w	r0, r8, #4294967295
 8000c6e:	d202      	bcs.n	8000c76 <__udivmoddi4+0x132>
 8000c70:	42ab      	cmp	r3, r5
 8000c72:	f200 80d1 	bhi.w	8000e18 <__udivmoddi4+0x2d4>
 8000c76:	4680      	mov	r8, r0
 8000c78:	1aed      	subs	r5, r5, r3
 8000c7a:	b2a3      	uxth	r3, r4
 8000c7c:	fbb5 f0f2 	udiv	r0, r5, r2
 8000c80:	fb02 5510 	mls	r5, r2, r0, r5
 8000c84:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 8000c88:	fb0c fc00 	mul.w	ip, ip, r0
 8000c8c:	45a4      	cmp	ip, r4
 8000c8e:	d907      	bls.n	8000ca0 <__udivmoddi4+0x15c>
 8000c90:	19e4      	adds	r4, r4, r7
 8000c92:	f100 33ff 	add.w	r3, r0, #4294967295
 8000c96:	d202      	bcs.n	8000c9e <__udivmoddi4+0x15a>
 8000c98:	45a4      	cmp	ip, r4
 8000c9a:	f200 80b8 	bhi.w	8000e0e <__udivmoddi4+0x2ca>
 8000c9e:	4618      	mov	r0, r3
 8000ca0:	eba4 040c 	sub.w	r4, r4, ip
 8000ca4:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000ca8:	e79d      	b.n	8000be6 <__udivmoddi4+0xa2>
 8000caa:	4631      	mov	r1, r6
 8000cac:	4630      	mov	r0, r6
 8000cae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000cb2:	f1ce 0420 	rsb	r4, lr, #32
 8000cb6:	fa05 f30e 	lsl.w	r3, r5, lr
 8000cba:	fa07 f70e 	lsl.w	r7, r7, lr
 8000cbe:	fa20 f804 	lsr.w	r8, r0, r4
 8000cc2:	0c3a      	lsrs	r2, r7, #16
 8000cc4:	fa25 f404 	lsr.w	r4, r5, r4
 8000cc8:	ea48 0803 	orr.w	r8, r8, r3
 8000ccc:	fbb4 f1f2 	udiv	r1, r4, r2
 8000cd0:	ea4f 4518 	mov.w	r5, r8, lsr #16
 8000cd4:	fb02 4411 	mls	r4, r2, r1, r4
 8000cd8:	fa1f fc87 	uxth.w	ip, r7
 8000cdc:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
 8000ce0:	fb01 f30c 	mul.w	r3, r1, ip
 8000ce4:	42ab      	cmp	r3, r5
 8000ce6:	fa00 f40e 	lsl.w	r4, r0, lr
 8000cea:	d909      	bls.n	8000d00 <__udivmoddi4+0x1bc>
 8000cec:	19ed      	adds	r5, r5, r7
 8000cee:	f101 30ff 	add.w	r0, r1, #4294967295
 8000cf2:	f080 808a 	bcs.w	8000e0a <__udivmoddi4+0x2c6>
 8000cf6:	42ab      	cmp	r3, r5
 8000cf8:	f240 8087 	bls.w	8000e0a <__udivmoddi4+0x2c6>
 8000cfc:	3902      	subs	r1, #2
 8000cfe:	443d      	add	r5, r7
 8000d00:	1aeb      	subs	r3, r5, r3
 8000d02:	fa1f f588 	uxth.w	r5, r8
 8000d06:	fbb3 f0f2 	udiv	r0, r3, r2
 8000d0a:	fb02 3310 	mls	r3, r2, r0, r3
 8000d0e:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 8000d12:	fb00 f30c 	mul.w	r3, r0, ip
 8000d16:	42ab      	cmp	r3, r5
 8000d18:	d907      	bls.n	8000d2a <__udivmoddi4+0x1e6>
 8000d1a:	19ed      	adds	r5, r5, r7
 8000d1c:	f100 38ff 	add.w	r8, r0, #4294967295
 8000d20:	d26f      	bcs.n	8000e02 <__udivmoddi4+0x2be>
 8000d22:	42ab      	cmp	r3, r5
 8000d24:	d96d      	bls.n	8000e02 <__udivmoddi4+0x2be>
 8000d26:	3802      	subs	r0, #2
 8000d28:	443d      	add	r5, r7
 8000d2a:	1aeb      	subs	r3, r5, r3
 8000d2c:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 8000d30:	e78f      	b.n	8000c52 <__udivmoddi4+0x10e>
 8000d32:	f1c1 0720 	rsb	r7, r1, #32
 8000d36:	fa22 f807 	lsr.w	r8, r2, r7
 8000d3a:	408b      	lsls	r3, r1
 8000d3c:	fa05 f401 	lsl.w	r4, r5, r1
 8000d40:	ea48 0303 	orr.w	r3, r8, r3
 8000d44:	fa20 fe07 	lsr.w	lr, r0, r7
 8000d48:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 8000d4c:	40fd      	lsrs	r5, r7
 8000d4e:	ea4e 0e04 	orr.w	lr, lr, r4
 8000d52:	fbb5 f9fc 	udiv	r9, r5, ip
 8000d56:	ea4f 441e 	mov.w	r4, lr, lsr #16
 8000d5a:	fb0c 5519 	mls	r5, ip, r9, r5
 8000d5e:	fa1f f883 	uxth.w	r8, r3
 8000d62:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 8000d66:	fb09 f408 	mul.w	r4, r9, r8
 8000d6a:	42ac      	cmp	r4, r5
 8000d6c:	fa02 f201 	lsl.w	r2, r2, r1
 8000d70:	fa00 fa01 	lsl.w	sl, r0, r1
 8000d74:	d908      	bls.n	8000d88 <__udivmoddi4+0x244>
 8000d76:	18ed      	adds	r5, r5, r3
 8000d78:	f109 30ff 	add.w	r0, r9, #4294967295
 8000d7c:	d243      	bcs.n	8000e06 <__udivmoddi4+0x2c2>
 8000d7e:	42ac      	cmp	r4, r5
 8000d80:	d941      	bls.n	8000e06 <__udivmoddi4+0x2c2>
 8000d82:	f1a9 0902 	sub.w	r9, r9, #2
 8000d86:	441d      	add	r5, r3
 8000d88:	1b2d      	subs	r5, r5, r4
 8000d8a:	fa1f fe8e 	uxth.w	lr, lr
 8000d8e:	fbb5 f0fc 	udiv	r0, r5, ip
 8000d92:	fb0c 5510 	mls	r5, ip, r0, r5
 8000d96:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
 8000d9a:	fb00 f808 	mul.w	r8, r0, r8
 8000d9e:	45a0      	cmp	r8, r4
 8000da0:	d907      	bls.n	8000db2 <__udivmoddi4+0x26e>
 8000da2:	18e4      	adds	r4, r4, r3
 8000da4:	f100 35ff 	add.w	r5, r0, #4294967295
 8000da8:	d229      	bcs.n	8000dfe <__udivmoddi4+0x2ba>
 8000daa:	45a0      	cmp	r8, r4
 8000dac:	d927      	bls.n	8000dfe <__udivmoddi4+0x2ba>
 8000dae:	3802      	subs	r0, #2
 8000db0:	441c      	add	r4, r3
 8000db2:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000db6:	eba4 0408 	sub.w	r4, r4, r8
 8000dba:	fba0 8902 	umull	r8, r9, r0, r2
 8000dbe:	454c      	cmp	r4, r9
 8000dc0:	46c6      	mov	lr, r8
 8000dc2:	464d      	mov	r5, r9
 8000dc4:	d315      	bcc.n	8000df2 <__udivmoddi4+0x2ae>
 8000dc6:	d012      	beq.n	8000dee <__udivmoddi4+0x2aa>
 8000dc8:	b156      	cbz	r6, 8000de0 <__udivmoddi4+0x29c>
 8000dca:	ebba 030e 	subs.w	r3, sl, lr
 8000dce:	eb64 0405 	sbc.w	r4, r4, r5
 8000dd2:	fa04 f707 	lsl.w	r7, r4, r7
 8000dd6:	40cb      	lsrs	r3, r1
 8000dd8:	431f      	orrs	r7, r3
 8000dda:	40cc      	lsrs	r4, r1
 8000ddc:	6037      	str	r7, [r6, #0]
 8000dde:	6074      	str	r4, [r6, #4]
 8000de0:	2100      	movs	r1, #0
 8000de2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000de6:	4618      	mov	r0, r3
 8000de8:	e6f8      	b.n	8000bdc <__udivmoddi4+0x98>
 8000dea:	4690      	mov	r8, r2
 8000dec:	e6e0      	b.n	8000bb0 <__udivmoddi4+0x6c>
 8000dee:	45c2      	cmp	sl, r8
 8000df0:	d2ea      	bcs.n	8000dc8 <__udivmoddi4+0x284>
 8000df2:	ebb8 0e02 	subs.w	lr, r8, r2
 8000df6:	eb69 0503 	sbc.w	r5, r9, r3
 8000dfa:	3801      	subs	r0, #1
 8000dfc:	e7e4      	b.n	8000dc8 <__udivmoddi4+0x284>
 8000dfe:	4628      	mov	r0, r5
 8000e00:	e7d7      	b.n	8000db2 <__udivmoddi4+0x26e>
 8000e02:	4640      	mov	r0, r8
 8000e04:	e791      	b.n	8000d2a <__udivmoddi4+0x1e6>
 8000e06:	4681      	mov	r9, r0
 8000e08:	e7be      	b.n	8000d88 <__udivmoddi4+0x244>
 8000e0a:	4601      	mov	r1, r0
 8000e0c:	e778      	b.n	8000d00 <__udivmoddi4+0x1bc>
 8000e0e:	3802      	subs	r0, #2
 8000e10:	443c      	add	r4, r7
 8000e12:	e745      	b.n	8000ca0 <__udivmoddi4+0x15c>
 8000e14:	4608      	mov	r0, r1
 8000e16:	e708      	b.n	8000c2a <__udivmoddi4+0xe6>
 8000e18:	f1a8 0802 	sub.w	r8, r8, #2
 8000e1c:	443d      	add	r5, r7
 8000e1e:	e72b      	b.n	8000c78 <__udivmoddi4+0x134>

08000e20 <__aeabi_idiv0>:
 8000e20:	4770      	bx	lr
 8000e22:	bf00      	nop

08000e24 <HTS221_ReadReg>:
* Input       : Register Address
* Output      : Data Read
* Return      : None
*******************************************************************************/
HTS221_Error_et HTS221_ReadReg( void *handle, uint8_t RegAddr, uint16_t NumByteToRead, uint8_t *Data )
{
 8000e24:	b510      	push	{r4, lr}
 8000e26:	461c      	mov	r4, r3

  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8000e28:	4613      	mov	r3, r2
 8000e2a:	4622      	mov	r2, r4
 8000e2c:	f006 fb9e 	bl	800756c <Sensor_IO_Read>
    return HTS221_ERROR;
  else
    return HTS221_OK;
}
 8000e30:	3000      	adds	r0, #0
 8000e32:	bf18      	it	ne
 8000e34:	2001      	movne	r0, #1
 8000e36:	bd10      	pop	{r4, pc}

08000e38 <HTS221_WriteReg>:
* Input       : Register Address, Data to be written
* Output      : None
* Return      : None
*******************************************************************************/
HTS221_Error_et HTS221_WriteReg( void *handle, uint8_t RegAddr, uint16_t NumByteToWrite, uint8_t *Data )
{
 8000e38:	b510      	push	{r4, lr}
 8000e3a:	461c      	mov	r4, r3

  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8000e3c:	4613      	mov	r3, r2
 8000e3e:	4622      	mov	r2, r4
 8000e40:	f006 fb46 	bl	80074d0 <Sensor_IO_Write>
    return HTS221_ERROR;
  else
    return HTS221_OK;
}
 8000e44:	3000      	adds	r0, #0
 8000e46:	bf18      	it	ne
 8000e48:	2001      	movne	r0, #1
 8000e4a:	bd10      	pop	{r4, pc}

08000e4c <HTS221_Get_DeviceID>:
* @param  *handle Device handle.
* @param  deviceid pointer to the returned device type ID.
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Get_DeviceID(void *handle, uint8_t* deviceid)
{
 8000e4c:	b508      	push	{r3, lr}
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8000e4e:	460a      	mov	r2, r1
 8000e50:	2301      	movs	r3, #1
 8000e52:	210f      	movs	r1, #15
 8000e54:	f006 fb8a 	bl	800756c <Sensor_IO_Read>
  if(HTS221_ReadReg(handle, HTS221_WHO_AM_I_REG, 1, deviceid))
    return HTS221_ERROR;

  return HTS221_OK;
}
 8000e58:	3000      	adds	r0, #0
 8000e5a:	bf18      	it	ne
 8000e5c:	2001      	movne	r0, #1
 8000e5e:	bd08      	pop	{r3, pc}

08000e60 <HTS221_Get_Humidity>:
* @param  *handle Device handle.
* @param  Pointer to the returned humidity value that must be divided by 10 to get the value in [%].
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Get_Humidity(void *handle, uint16_t* value)
{
 8000e60:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000e64:	b084      	sub	sp, #16
 8000e66:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8000e68:	aa03      	add	r2, sp, #12
 8000e6a:	2302      	movs	r3, #2
 8000e6c:	2130      	movs	r1, #48	; 0x30
{
 8000e6e:	4604      	mov	r4, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8000e70:	f006 fb7c 	bl	800756c <Sensor_IO_Read>
 8000e74:	b950      	cbnz	r0, 8000e8c <HTS221_Get_Humidity+0x2c>
 8000e76:	2302      	movs	r3, #2
 8000e78:	aa03      	add	r2, sp, #12
 8000e7a:	2136      	movs	r1, #54	; 0x36
 8000e7c:	4620      	mov	r0, r4
  uint8_t buffer[2];
  float   tmp_f;

  if(HTS221_ReadReg(handle, HTS221_H0_RH_X2, 2, buffer))
    return HTS221_ERROR;
  H0_rh = buffer[0] >> 1;
 8000e7e:	f89d 600c 	ldrb.w	r6, [sp, #12]
  H1_rh = buffer[1] >> 1;
 8000e82:	f89d 700d 	ldrb.w	r7, [sp, #13]
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8000e86:	f006 fb71 	bl	800756c <Sensor_IO_Read>
 8000e8a:	b118      	cbz	r0, 8000e94 <HTS221_Get_Humidity+0x34>
    return HTS221_ERROR;
 8000e8c:	2001      	movs	r0, #1
  *value = ( tmp_f > 1000.0f ) ? 1000
           : ( tmp_f <    0.0f ) ?    0
           : ( uint16_t )tmp_f;

  return HTS221_OK;
}
 8000e8e:	b004      	add	sp, #16
 8000e90:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8000e94:	2302      	movs	r3, #2
 8000e96:	aa03      	add	r2, sp, #12
 8000e98:	213a      	movs	r1, #58	; 0x3a
 8000e9a:	4620      	mov	r0, r4
  H0_T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8000e9c:	f89d a00d 	ldrb.w	sl, [sp, #13]
 8000ea0:	f89d 900c 	ldrb.w	r9, [sp, #12]
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8000ea4:	f006 fb62 	bl	800756c <Sensor_IO_Read>
 8000ea8:	2800      	cmp	r0, #0
 8000eaa:	d1ef      	bne.n	8000e8c <HTS221_Get_Humidity+0x2c>
 8000eac:	4620      	mov	r0, r4
 8000eae:	aa03      	add	r2, sp, #12
 8000eb0:	2302      	movs	r3, #2
 8000eb2:	2128      	movs	r1, #40	; 0x28
  H1_T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8000eb4:	f89d 800d 	ldrb.w	r8, [sp, #13]
 8000eb8:	f89d 400c 	ldrb.w	r4, [sp, #12]
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8000ebc:	f006 fb56 	bl	800756c <Sensor_IO_Read>
 8000ec0:	2800      	cmp	r0, #0
 8000ec2:	d1e3      	bne.n	8000e8c <HTS221_Get_Humidity+0x2c>
  H_T_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8000ec4:	f89d 200d 	ldrb.w	r2, [sp, #13]
 8000ec8:	f89d 300c 	ldrb.w	r3, [sp, #12]
  *value = ( tmp_f > 1000.0f ) ? 1000
 8000ecc:	eddf 5a21 	vldr	s11, [pc, #132]	; 8000f54 <HTS221_Get_Humidity+0xf4>
  H0_T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8000ed0:	ea49 290a 	orr.w	r9, r9, sl, lsl #8
  H_T_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8000ed4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  tmp_f = (float)(H_T_out - H0_T0_out) * (float)(H1_rh - H0_rh) / (float)(H1_T0_out - H0_T0_out)  +  H0_rh;
 8000ed8:	fa0f f989 	sxth.w	r9, r9
  H0_rh = buffer[0] >> 1;
 8000edc:	0876      	lsrs	r6, r6, #1
  tmp_f = (float)(H_T_out - H0_T0_out) * (float)(H1_rh - H0_rh) / (float)(H1_T0_out - H0_T0_out)  +  H0_rh;
 8000ede:	b21b      	sxth	r3, r3
 8000ee0:	eba3 0309 	sub.w	r3, r3, r9
 8000ee4:	ebc6 0757 	rsb	r7, r6, r7, lsr #1
 8000ee8:	ee07 3a10 	vmov	s14, r3
 8000eec:	ee07 7a90 	vmov	s15, r7
  H1_T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8000ef0:	ea44 2408 	orr.w	r4, r4, r8, lsl #8
  tmp_f = (float)(H_T_out - H0_T0_out) * (float)(H1_rh - H0_rh) / (float)(H1_T0_out - H0_T0_out)  +  H0_rh;
 8000ef4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8000ef8:	b224      	sxth	r4, r4
 8000efa:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8000efe:	eba4 0909 	sub.w	r9, r4, r9
 8000f02:	ee27 7a27 	vmul.f32	s14, s14, s15
 8000f06:	ee07 9a90 	vmov	s15, r9
 8000f0a:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 8000f0e:	ee07 6a90 	vmov	s15, r6
 8000f12:	ee87 6a26 	vdiv.f32	s12, s14, s13
 8000f16:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  tmp_f *= 10.0f;
 8000f1a:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
  tmp_f = (float)(H_T_out - H0_T0_out) * (float)(H1_rh - H0_rh) / (float)(H1_T0_out - H0_T0_out)  +  H0_rh;
 8000f1e:	ee76 7a27 	vadd.f32	s15, s12, s15
  tmp_f *= 10.0f;
 8000f22:	ee67 7a87 	vmul.f32	s15, s15, s14
  *value = ( tmp_f > 1000.0f ) ? 1000
 8000f26:	eef4 7ae5 	vcmpe.f32	s15, s11
 8000f2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000f2e:	dd04      	ble.n	8000f3a <HTS221_Get_Humidity+0xda>
 8000f30:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000f34:	8028      	strh	r0, [r5, #0]
  return HTS221_OK;
 8000f36:	2000      	movs	r0, #0
 8000f38:	e7a9      	b.n	8000e8e <HTS221_Get_Humidity+0x2e>
  *value = ( tmp_f > 1000.0f ) ? 1000
 8000f3a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8000f3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000f42:	d4f7      	bmi.n	8000f34 <HTS221_Get_Humidity+0xd4>
 8000f44:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8000f48:	edcd 7a01 	vstr	s15, [sp, #4]
 8000f4c:	f8bd 0004 	ldrh.w	r0, [sp, #4]
 8000f50:	e7f0      	b.n	8000f34 <HTS221_Get_Humidity+0xd4>
 8000f52:	bf00      	nop
 8000f54:	447a0000 	.word	0x447a0000

08000f58 <HTS221_Get_Temperature>:
* @param  *handle Device handle.
* @param  Pointer to the returned temperature value that must be divided by 10 to get the value in ['C].
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Get_Temperature(void *handle, int16_t *value)
{
 8000f58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000f5c:	b083      	sub	sp, #12
 8000f5e:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8000f60:	aa01      	add	r2, sp, #4
 8000f62:	2302      	movs	r3, #2
 8000f64:	2132      	movs	r1, #50	; 0x32
{
 8000f66:	4606      	mov	r6, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8000f68:	f006 fb00 	bl	800756c <Sensor_IO_Read>
 8000f6c:	b938      	cbnz	r0, 8000f7e <HTS221_Get_Temperature+0x26>
 8000f6e:	2301      	movs	r3, #1
 8000f70:	f10d 0203 	add.w	r2, sp, #3
 8000f74:	2135      	movs	r1, #53	; 0x35
 8000f76:	4630      	mov	r0, r6
 8000f78:	f006 faf8 	bl	800756c <Sensor_IO_Read>
 8000f7c:	b118      	cbz	r0, 8000f86 <HTS221_Get_Temperature+0x2e>
  int16_t T0_degC, T1_degC;
  uint8_t buffer[4], tmp;
  float   tmp_f;

  if(HTS221_ReadReg(handle, HTS221_T0_DEGC_X8, 2, buffer))
    return HTS221_ERROR;
 8000f7e:	2001      	movs	r0, #1
  tmp_f *= 10.0f;

  *value = ( int16_t )tmp_f;

  return HTS221_OK;
}
 8000f80:	b003      	add	sp, #12
 8000f82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8000f86:	2304      	movs	r3, #4
 8000f88:	eb0d 0203 	add.w	r2, sp, r3
 8000f8c:	213c      	movs	r1, #60	; 0x3c
 8000f8e:	4630      	mov	r0, r6
  T0_degC_x8_u16 = (((uint16_t)(tmp & 0x03)) << 8) | ((uint16_t)buffer[0]);
 8000f90:	f89d 5003 	ldrb.w	r5, [sp, #3]
 8000f94:	f89d 9004 	ldrb.w	r9, [sp, #4]
  T1_degC_x8_u16 = (((uint16_t)(tmp & 0x0C)) << 6) | ((uint16_t)buffer[1]);
 8000f98:	f89d 8005 	ldrb.w	r8, [sp, #5]
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8000f9c:	f006 fae6 	bl	800756c <Sensor_IO_Read>
 8000fa0:	2800      	cmp	r0, #0
 8000fa2:	d1ec      	bne.n	8000f7e <HTS221_Get_Temperature+0x26>
 8000fa4:	4630      	mov	r0, r6
 8000fa6:	aa01      	add	r2, sp, #4
 8000fa8:	2302      	movs	r3, #2
 8000faa:	212a      	movs	r1, #42	; 0x2a
  T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8000fac:	f89d b005 	ldrb.w	fp, [sp, #5]
 8000fb0:	f89d 7004 	ldrb.w	r7, [sp, #4]
  T1_out = (((uint16_t)buffer[3]) << 8) | (uint16_t)buffer[2];
 8000fb4:	f89d a007 	ldrb.w	sl, [sp, #7]
 8000fb8:	f89d 6006 	ldrb.w	r6, [sp, #6]
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8000fbc:	f006 fad6 	bl	800756c <Sensor_IO_Read>
 8000fc0:	2800      	cmp	r0, #0
 8000fc2:	d1dc      	bne.n	8000f7e <HTS221_Get_Temperature+0x26>
  T_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8000fc4:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8000fc8:	f89d 2005 	ldrb.w	r2, [sp, #5]
 8000fcc:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
  T0_degC_x8_u16 = (((uint16_t)(tmp & 0x03)) << 8) | ((uint16_t)buffer[0]);
 8000fd0:	022b      	lsls	r3, r5, #8
 8000fd2:	f403 7340 	and.w	r3, r3, #768	; 0x300
  T1_degC_x8_u16 = (((uint16_t)(tmp & 0x0C)) << 6) | ((uint16_t)buffer[1]);
 8000fd6:	01ad      	lsls	r5, r5, #6
  T0_degC = T0_degC_x8_u16 >> 3;
 8000fd8:	ea43 0909 	orr.w	r9, r3, r9
  T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8000fdc:	ea47 270b 	orr.w	r7, r7, fp, lsl #8
  T1_degC_x8_u16 = (((uint16_t)(tmp & 0x0C)) << 6) | ((uint16_t)buffer[1]);
 8000fe0:	f405 7540 	and.w	r5, r5, #768	; 0x300
  tmp_f = (float)(T_out - T0_out) * (float)(T1_degC - T0_degC) / (float)(T1_out - T0_out)  +  T0_degC;
 8000fe4:	b23f      	sxth	r7, r7
  T0_degC = T0_degC_x8_u16 >> 3;
 8000fe6:	ea4f 09d9 	mov.w	r9, r9, lsr #3
  tmp_f = (float)(T_out - T0_out) * (float)(T1_degC - T0_degC) / (float)(T1_out - T0_out)  +  T0_degC;
 8000fea:	b213      	sxth	r3, r2
  T1_degC = T1_degC_x8_u16 >> 3;
 8000fec:	ea45 0808 	orr.w	r8, r5, r8
  tmp_f = (float)(T_out - T0_out) * (float)(T1_degC - T0_degC) / (float)(T1_out - T0_out)  +  T0_degC;
 8000ff0:	1bdb      	subs	r3, r3, r7
 8000ff2:	ebc9 08d8 	rsb	r8, r9, r8, lsr #3
 8000ff6:	ee07 3a10 	vmov	s14, r3
 8000ffa:	ee07 8a90 	vmov	s15, r8
  T1_out = (((uint16_t)buffer[3]) << 8) | (uint16_t)buffer[2];
 8000ffe:	ea46 260a 	orr.w	r6, r6, sl, lsl #8
  tmp_f = (float)(T_out - T0_out) * (float)(T1_degC - T0_degC) / (float)(T1_out - T0_out)  +  T0_degC;
 8001002:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8001006:	b236      	sxth	r6, r6
 8001008:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800100c:	1bf6      	subs	r6, r6, r7
 800100e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8001012:	ee07 6a10 	vmov	s14, r6
 8001016:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800101a:	ee06 9a90 	vmov	s13, r9
 800101e:	ee87 6a87 	vdiv.f32	s12, s15, s14
 8001022:	eef8 6ae6 	vcvt.f32.s32	s13, s13
  tmp_f *= 10.0f;
 8001026:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
  tmp_f = (float)(T_out - T0_out) * (float)(T1_degC - T0_degC) / (float)(T1_out - T0_out)  +  T0_degC;
 800102a:	ee76 6a26 	vadd.f32	s13, s12, s13
  tmp_f *= 10.0f;
 800102e:	ee66 6aa7 	vmul.f32	s13, s13, s15
  *value = ( int16_t )tmp_f;
 8001032:	eefd 7ae6 	vcvt.s32.f32	s15, s13
 8001036:	ee17 3a90 	vmov	r3, s15
 800103a:	8023      	strh	r3, [r4, #0]
  return HTS221_OK;
 800103c:	e7a0      	b.n	8000f80 <HTS221_Get_Temperature+0x28>
 800103e:	bf00      	nop

08001040 <HTS221_Get_DataStatus>:
* @param  temperature pointer to the returned temperature data status [HTS221_SET/HTS221_RESET].
*         This parameter is a pointer to @ref HTS221_BitStatus_et.
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Get_DataStatus(void *handle, HTS221_BitStatus_et* humidity, HTS221_BitStatus_et* temperature)
{
 8001040:	b530      	push	{r4, r5, lr}
 8001042:	b083      	sub	sp, #12
 8001044:	460d      	mov	r5, r1
 8001046:	4614      	mov	r4, r2
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001048:	2301      	movs	r3, #1
 800104a:	f10d 0207 	add.w	r2, sp, #7
 800104e:	2127      	movs	r1, #39	; 0x27
 8001050:	f006 fa8c 	bl	800756c <Sensor_IO_Read>
 8001054:	b110      	cbz	r0, 800105c <HTS221_Get_DataStatus+0x1c>
  uint8_t tmp;

  if(HTS221_ReadReg(handle, HTS221_STATUS_REG, 1, &tmp))
    return HTS221_ERROR;
 8001056:	2001      	movs	r0, #1

  *humidity = (HTS221_BitStatus_et)((tmp & HTS221_HDA_MASK) >> HTS221_H_DA_BIT);
  *temperature = (HTS221_BitStatus_et)(tmp & HTS221_TDA_MASK);

  return HTS221_OK;
}
 8001058:	b003      	add	sp, #12
 800105a:	bd30      	pop	{r4, r5, pc}
  *humidity = (HTS221_BitStatus_et)((tmp & HTS221_HDA_MASK) >> HTS221_H_DA_BIT);
 800105c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001060:	f3c3 0240 	ubfx	r2, r3, #1, #1
  *temperature = (HTS221_BitStatus_et)(tmp & HTS221_TDA_MASK);
 8001064:	f003 0301 	and.w	r3, r3, #1
  *humidity = (HTS221_BitStatus_et)((tmp & HTS221_HDA_MASK) >> HTS221_H_DA_BIT);
 8001068:	702a      	strb	r2, [r5, #0]
  *temperature = (HTS221_BitStatus_et)(tmp & HTS221_TDA_MASK);
 800106a:	7023      	strb	r3, [r4, #0]
}
 800106c:	b003      	add	sp, #12
 800106e:	bd30      	pop	{r4, r5, pc}

08001070 <HTS221_Activate>:
* @param  *handle Device handle.
* @param  void.
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Activate(void *handle)
{
 8001070:	b530      	push	{r4, r5, lr}
 8001072:	b083      	sub	sp, #12
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001074:	f10d 0207 	add.w	r2, sp, #7
 8001078:	2301      	movs	r3, #1
 800107a:	2120      	movs	r1, #32
{
 800107c:	4605      	mov	r5, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 800107e:	f006 fa75 	bl	800756c <Sensor_IO_Read>
 8001082:	b110      	cbz	r0, 800108a <HTS221_Activate+0x1a>
  uint8_t tmp;

  if(HTS221_ReadReg(handle, HTS221_CTRL_REG1, 1, &tmp))
    return HTS221_ERROR;
 8001084:	2001      	movs	r0, #1

  if(HTS221_WriteReg(handle, HTS221_CTRL_REG1, 1, &tmp))
    return HTS221_ERROR;

  return HTS221_OK;
}
 8001086:	b003      	add	sp, #12
 8001088:	bd30      	pop	{r4, r5, pc}
  tmp |= HTS221_PD_MASK;
 800108a:	f89d 4007 	ldrb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 800108e:	f10d 0207 	add.w	r2, sp, #7
 8001092:	4628      	mov	r0, r5
  tmp |= HTS221_PD_MASK;
 8001094:	f064 047f 	orn	r4, r4, #127	; 0x7f
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001098:	2301      	movs	r3, #1
 800109a:	2120      	movs	r1, #32
  tmp |= HTS221_PD_MASK;
 800109c:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80010a0:	f006 fa16 	bl	80074d0 <Sensor_IO_Write>
    return HTS221_ERROR;
 80010a4:	3000      	adds	r0, #0
 80010a6:	bf18      	it	ne
 80010a8:	2001      	movne	r0, #1
}
 80010aa:	b003      	add	sp, #12
 80010ac:	bd30      	pop	{r4, r5, pc}
 80010ae:	bf00      	nop

080010b0 <HTS221_DeActivate>:
* @brief  Put the sensor in power down mode.
* @param  *handle Device handle.
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_DeActivate(void *handle)
{
 80010b0:	b530      	push	{r4, r5, lr}
 80010b2:	b083      	sub	sp, #12
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80010b4:	f10d 0207 	add.w	r2, sp, #7
 80010b8:	2301      	movs	r3, #1
 80010ba:	2120      	movs	r1, #32
{
 80010bc:	4605      	mov	r5, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80010be:	f006 fa55 	bl	800756c <Sensor_IO_Read>
 80010c2:	b110      	cbz	r0, 80010ca <HTS221_DeActivate+0x1a>
  uint8_t tmp;

  if(HTS221_ReadReg(handle, HTS221_CTRL_REG1, 1, &tmp))
    return HTS221_ERROR;
 80010c4:	2001      	movs	r0, #1

  if(HTS221_WriteReg(handle, HTS221_CTRL_REG1, 1, &tmp))
    return HTS221_ERROR;

  return HTS221_OK;
}
 80010c6:	b003      	add	sp, #12
 80010c8:	bd30      	pop	{r4, r5, pc}
  tmp &= ~HTS221_PD_MASK;
 80010ca:	f89d 4007 	ldrb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80010ce:	f10d 0207 	add.w	r2, sp, #7
 80010d2:	4628      	mov	r0, r5
  tmp &= ~HTS221_PD_MASK;
 80010d4:	f004 047f 	and.w	r4, r4, #127	; 0x7f
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80010d8:	2301      	movs	r3, #1
 80010da:	2120      	movs	r1, #32
  tmp &= ~HTS221_PD_MASK;
 80010dc:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80010e0:	f006 f9f6 	bl	80074d0 <Sensor_IO_Write>
    return HTS221_ERROR;
 80010e4:	3000      	adds	r0, #0
 80010e6:	bf18      	it	ne
 80010e8:	2001      	movne	r0, #1
}
 80010ea:	b003      	add	sp, #12
 80010ec:	bd30      	pop	{r4, r5, pc}
 80010ee:	bf00      	nop

080010f0 <HTS221_Get_Odr>:
* @param  *handle Device handle.
* @param  Pointer to the returned value with output data rate mode.
* @retval Error code [HTS221_OK, HTS221_ERROR].
*/
HTS221_Error_et HTS221_Get_Odr(void *handle, HTS221_Odr_et* odr)
{
 80010f0:	b510      	push	{r4, lr}
 80010f2:	b082      	sub	sp, #8
 80010f4:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80010f6:	2301      	movs	r3, #1
 80010f8:	f10d 0207 	add.w	r2, sp, #7
 80010fc:	2120      	movs	r1, #32
 80010fe:	f006 fa35 	bl	800756c <Sensor_IO_Read>
 8001102:	b110      	cbz	r0, 800110a <HTS221_Get_Odr+0x1a>
  uint8_t tmp;

  if(HTS221_ReadReg(handle, HTS221_CTRL_REG1, 1, &tmp))
    return HTS221_ERROR;
 8001104:	2001      	movs	r0, #1

  tmp &= HTS221_ODR_MASK;
  *odr = (HTS221_Odr_et)tmp;

  return HTS221_OK;
}
 8001106:	b002      	add	sp, #8
 8001108:	bd10      	pop	{r4, pc}
  tmp &= HTS221_ODR_MASK;
 800110a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800110e:	f003 0303 	and.w	r3, r3, #3
  *odr = (HTS221_Odr_et)tmp;
 8001112:	7023      	strb	r3, [r4, #0]
}
 8001114:	b002      	add	sp, #8
 8001116:	bd10      	pop	{r4, pc}

08001118 <HTS221_assert_failed>:
* @retval : None
*/
void HTS221_assert_failed(uint8_t* file, uint32_t line)
{
  /* User can add his own implementation to report the file name and line number */
  printf("Wrong parameters value: file %s on line %d\r\n", file, (int)line);
 8001118:	460a      	mov	r2, r1
{
 800111a:	b508      	push	{r3, lr}
  printf("Wrong parameters value: file %s on line %d\r\n", file, (int)line);
 800111c:	4601      	mov	r1, r0
 800111e:	4802      	ldr	r0, [pc, #8]	; (8001128 <HTS221_assert_failed+0x10>)
 8001120:	f00b f900 	bl	800c324 <iprintf>
 8001124:	e7fe      	b.n	8001124 <HTS221_assert_failed+0xc>
 8001126:	bf00      	nop
 8001128:	0800d560 	.word	0x0800d560

0800112c <HTS221_Set_BduMode>:
{
 800112c:	b570      	push	{r4, r5, r6, lr}
  HTS221_assert_param(IS_HTS221_State(status));
 800112e:	2901      	cmp	r1, #1
{
 8001130:	b082      	sub	sp, #8
  HTS221_assert_param(IS_HTS221_State(status));
 8001132:	d81f      	bhi.n	8001174 <HTS221_Set_BduMode+0x48>
 8001134:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001136:	f10d 0207 	add.w	r2, sp, #7
 800113a:	2301      	movs	r3, #1
 800113c:	2120      	movs	r1, #32
 800113e:	4606      	mov	r6, r0
 8001140:	f006 fa14 	bl	800756c <Sensor_IO_Read>
 8001144:	b998      	cbnz	r0, 800116e <HTS221_Set_BduMode+0x42>
  tmp &= ~HTS221_BDU_MASK;
 8001146:	f89d 4007 	ldrb.w	r4, [sp, #7]
 800114a:	f024 0404 	bic.w	r4, r4, #4
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 800114e:	f10d 0207 	add.w	r2, sp, #7
 8001152:	4630      	mov	r0, r6
  tmp |= ((uint8_t)status) << HTS221_BDU_BIT;
 8001154:	ea44 0485 	orr.w	r4, r4, r5, lsl #2
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001158:	2301      	movs	r3, #1
 800115a:	2120      	movs	r1, #32
  tmp |= ((uint8_t)status) << HTS221_BDU_BIT;
 800115c:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001160:	f006 f9b6 	bl	80074d0 <Sensor_IO_Write>
    return HTS221_ERROR;
 8001164:	3000      	adds	r0, #0
 8001166:	bf18      	it	ne
 8001168:	2001      	movne	r0, #1
}
 800116a:	b002      	add	sp, #8
 800116c:	bd70      	pop	{r4, r5, r6, pc}
    return HTS221_ERROR;
 800116e:	2001      	movs	r0, #1
}
 8001170:	b002      	add	sp, #8
 8001172:	bd70      	pop	{r4, r5, r6, pc}
  HTS221_assert_param(IS_HTS221_State(status));
 8001174:	f240 216b 	movw	r1, #619	; 0x26b
 8001178:	4801      	ldr	r0, [pc, #4]	; (8001180 <HTS221_Set_BduMode+0x54>)
 800117a:	f7ff ffcd 	bl	8001118 <HTS221_assert_failed>
 800117e:	bf00      	nop
 8001180:	0800d590 	.word	0x0800d590

08001184 <HTS221_Set_Odr>:
{
 8001184:	b530      	push	{r4, r5, lr}
  HTS221_assert_param(IS_HTS221_ODR(odr));
 8001186:	2903      	cmp	r1, #3
{
 8001188:	b083      	sub	sp, #12
  HTS221_assert_param(IS_HTS221_ODR(odr));
 800118a:	d81e      	bhi.n	80011ca <HTS221_Set_Odr+0x46>
 800118c:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 800118e:	f10d 0207 	add.w	r2, sp, #7
 8001192:	2301      	movs	r3, #1
 8001194:	2120      	movs	r1, #32
 8001196:	4605      	mov	r5, r0
 8001198:	f006 f9e8 	bl	800756c <Sensor_IO_Read>
 800119c:	b990      	cbnz	r0, 80011c4 <HTS221_Set_Odr+0x40>
  tmp &= ~HTS221_ODR_MASK;
 800119e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80011a2:	f023 0303 	bic.w	r3, r3, #3
  tmp |= (uint8_t)odr;
 80011a6:	431c      	orrs	r4, r3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80011a8:	f10d 0207 	add.w	r2, sp, #7
 80011ac:	4628      	mov	r0, r5
 80011ae:	2301      	movs	r3, #1
 80011b0:	2120      	movs	r1, #32
  tmp |= (uint8_t)odr;
 80011b2:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80011b6:	f006 f98b 	bl	80074d0 <Sensor_IO_Write>
    return HTS221_ERROR;
 80011ba:	3000      	adds	r0, #0
 80011bc:	bf18      	it	ne
 80011be:	2001      	movne	r0, #1
}
 80011c0:	b003      	add	sp, #12
 80011c2:	bd30      	pop	{r4, r5, pc}
    return HTS221_ERROR;
 80011c4:	2001      	movs	r0, #1
}
 80011c6:	b003      	add	sp, #12
 80011c8:	bd30      	pop	{r4, r5, pc}
  HTS221_assert_param(IS_HTS221_ODR(odr));
 80011ca:	f240 21c2 	movw	r1, #706	; 0x2c2
 80011ce:	4801      	ldr	r0, [pc, #4]	; (80011d4 <HTS221_Set_Odr+0x50>)
 80011d0:	f7ff ffa2 	bl	8001118 <HTS221_assert_failed>
 80011d4:	0800d590 	.word	0x0800d590

080011d8 <HTS221_H_Get_DRDY_Status>:
 * @param status the data ready status
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_H_Get_DRDY_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 80011d8:	b510      	push	{r4, lr}
 80011da:	b082      	sub	sp, #8
 80011dc:	460c      	mov	r4, r1

  HTS221_BitStatus_et hum_status_raw;
  HTS221_BitStatus_et temp_status_raw;

  if ( HTS221_Get_DataStatus( (void *)handle, &hum_status_raw, &temp_status_raw ) == HTS221_ERROR )
 80011de:	f10d 0207 	add.w	r2, sp, #7
 80011e2:	f10d 0106 	add.w	r1, sp, #6
 80011e6:	f7ff ff2b 	bl	8001040 <HTS221_Get_DataStatus>
 80011ea:	2801      	cmp	r0, #1
 80011ec:	d006      	beq.n	80011fc <HTS221_H_Get_DRDY_Status+0x24>
  {
    return COMPONENT_ERROR;
  }

  switch( hum_status_raw )
 80011ee:	f89d 0006 	ldrb.w	r0, [sp, #6]
 80011f2:	b140      	cbz	r0, 8001206 <HTS221_H_Get_DRDY_Status+0x2e>
 80011f4:	2801      	cmp	r0, #1
 80011f6:	d103      	bne.n	8001200 <HTS221_H_Get_DRDY_Status+0x28>
  {
    case HTS221_SET:
      *status = 1;
 80011f8:	7020      	strb	r0, [r4, #0]
      break;
    default:
      return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
 80011fa:	2000      	movs	r0, #0
}
 80011fc:	b002      	add	sp, #8
 80011fe:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 8001200:	2001      	movs	r0, #1
}
 8001202:	b002      	add	sp, #8
 8001204:	bd10      	pop	{r4, pc}
      *status = 0;
 8001206:	7020      	strb	r0, [r4, #0]
}
 8001208:	b002      	add	sp, #8
 800120a:	bd10      	pop	{r4, pc}

0800120c <HTS221_T_Get_DRDY_Status>:
 * @param status the data ready status
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_T_Get_DRDY_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 800120c:	b510      	push	{r4, lr}
 800120e:	b082      	sub	sp, #8
 8001210:	460c      	mov	r4, r1

  HTS221_BitStatus_et hum_status_raw;
  HTS221_BitStatus_et temp_status_raw;

  if ( HTS221_Get_DataStatus( (void *)handle, &hum_status_raw, &temp_status_raw ) == HTS221_ERROR )
 8001212:	f10d 0207 	add.w	r2, sp, #7
 8001216:	f10d 0106 	add.w	r1, sp, #6
 800121a:	f7ff ff11 	bl	8001040 <HTS221_Get_DataStatus>
 800121e:	2801      	cmp	r0, #1
 8001220:	d006      	beq.n	8001230 <HTS221_T_Get_DRDY_Status+0x24>
  {
    return COMPONENT_ERROR;
  }

  switch( temp_status_raw )
 8001222:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8001226:	b140      	cbz	r0, 800123a <HTS221_T_Get_DRDY_Status+0x2e>
 8001228:	2801      	cmp	r0, #1
 800122a:	d103      	bne.n	8001234 <HTS221_T_Get_DRDY_Status+0x28>
  {
    case HTS221_SET:
      *status = 1;
 800122c:	7020      	strb	r0, [r4, #0]
      break;
    default:
      return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
 800122e:	2000      	movs	r0, #0
}
 8001230:	b002      	add	sp, #8
 8001232:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 8001234:	2001      	movs	r0, #1
}
 8001236:	b002      	add	sp, #8
 8001238:	bd10      	pop	{r4, pc}
      *status = 0;
 800123a:	7020      	strb	r0, [r4, #0]
}
 800123c:	b002      	add	sp, #8
 800123e:	bd10      	pop	{r4, pc}

08001240 <HTS221_T_Write_Reg>:
{
 8001240:	b500      	push	{lr}
 8001242:	b083      	sub	sp, #12
 8001244:	ab02      	add	r3, sp, #8
 8001246:	f803 2d01 	strb.w	r2, [r3, #-1]!
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef HTS221_Write_Reg( DrvContextTypeDef *handle, uint8_t reg, uint8_t data )
{

  if ( HTS221_WriteReg( (void *)handle, reg, 1, &data ) == HTS221_ERROR )
 800124a:	2201      	movs	r2, #1
 800124c:	f7ff fdf4 	bl	8000e38 <HTS221_WriteReg>
}
 8001250:	f1a0 0001 	sub.w	r0, r0, #1
 8001254:	fab0 f080 	clz	r0, r0
 8001258:	0940      	lsrs	r0, r0, #5
 800125a:	b003      	add	sp, #12
 800125c:	f85d fb04 	ldr.w	pc, [sp], #4

08001260 <HTS221_T_Read_Reg>:
{
 8001260:	b508      	push	{r3, lr}
  if ( HTS221_ReadReg( (void *)handle, reg, 1, data ) == HTS221_ERROR )
 8001262:	4613      	mov	r3, r2
 8001264:	2201      	movs	r2, #1
 8001266:	f7ff fddd 	bl	8000e24 <HTS221_ReadReg>
}
 800126a:	f1a0 0001 	sub.w	r0, r0, #1
 800126e:	fab0 f080 	clz	r0, r0
 8001272:	0940      	lsrs	r0, r0, #5
 8001274:	bd08      	pop	{r3, pc}
 8001276:	bf00      	nop

08001278 <HTS221_T_Set_ODR_Value>:
            : ( odr <= 7.0f ) ? HTS221_ODR_7HZ
 8001278:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800127c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8001280:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 8001284:	b508      	push	{r3, lr}
            : ( odr <= 7.0f ) ? HTS221_ODR_7HZ
 8001286:	d910      	bls.n	80012aa <HTS221_T_Set_ODR_Value+0x32>
 8001288:	eef1 7a0c 	vmov.f32	s15, #28	; 0x40e00000  7.0
 800128c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8001290:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001294:	bf94      	ite	ls
 8001296:	2102      	movls	r1, #2
 8001298:	2103      	movhi	r1, #3
  if ( HTS221_Set_Odr( (void *)handle, new_odr ) == HTS221_ERROR )
 800129a:	f7ff ff73 	bl	8001184 <HTS221_Set_Odr>
}
 800129e:	f1a0 0001 	sub.w	r0, r0, #1
 80012a2:	fab0 f080 	clz	r0, r0
 80012a6:	0940      	lsrs	r0, r0, #5
 80012a8:	bd08      	pop	{r3, pc}
            : ( odr <= 7.0f ) ? HTS221_ODR_7HZ
 80012aa:	2101      	movs	r1, #1
 80012ac:	e7f5      	b.n	800129a <HTS221_T_Set_ODR_Value+0x22>
 80012ae:	bf00      	nop

080012b0 <HTS221_T_Set_ODR>:
  switch( odr )
 80012b0:	b159      	cbz	r1, 80012ca <HTS221_T_Set_ODR+0x1a>
 80012b2:	2904      	cmp	r1, #4
 80012b4:	d80b      	bhi.n	80012ce <HTS221_T_Set_ODR+0x1e>
      new_odr = HTS221_ODR_12_5HZ;
 80012b6:	2103      	movs	r1, #3
{
 80012b8:	b508      	push	{r3, lr}
  if ( HTS221_Set_Odr( (void *)handle, new_odr ) == HTS221_ERROR )
 80012ba:	f7ff ff63 	bl	8001184 <HTS221_Set_Odr>
      return COMPONENT_ERROR;
 80012be:	f1a0 0001 	sub.w	r0, r0, #1
 80012c2:	fab0 f080 	clz	r0, r0
 80012c6:	0940      	lsrs	r0, r0, #5
 80012c8:	bd08      	pop	{r3, pc}
      new_odr = HTS221_ODR_1HZ;
 80012ca:	2101      	movs	r1, #1
 80012cc:	e7f4      	b.n	80012b8 <HTS221_T_Set_ODR+0x8>
      return COMPONENT_ERROR;
 80012ce:	2001      	movs	r0, #1
 80012d0:	4770      	bx	lr
 80012d2:	bf00      	nop

080012d4 <HTS221_H_Get_Hum>:
{
 80012d4:	b530      	push	{r4, r5, lr}
 80012d6:	b083      	sub	sp, #12
  uint16_t uint16data = 0;
 80012d8:	ab02      	add	r3, sp, #8
 80012da:	2400      	movs	r4, #0
 80012dc:	f823 4d02 	strh.w	r4, [r3, #-2]!
{
 80012e0:	460d      	mov	r5, r1
  if ( HTS221_Get_Humidity( (void *)handle, &uint16data ) == HTS221_ERROR )
 80012e2:	4619      	mov	r1, r3
 80012e4:	f7ff fdbc 	bl	8000e60 <HTS221_Get_Humidity>
 80012e8:	2801      	cmp	r0, #1
 80012ea:	d00c      	beq.n	8001306 <HTS221_H_Get_Hum+0x32>
  *humidity = ( float )uint16data / 10.0f;
 80012ec:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80012f0:	ee07 3a90 	vmov	s15, r3
 80012f4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80012f8:	eef2 6a04 	vmov.f32	s13, #36	; 0x41200000  10.0
 80012fc:	ee87 7aa6 	vdiv.f32	s14, s15, s13
  return COMPONENT_OK;
 8001300:	4620      	mov	r0, r4
  *humidity = ( float )uint16data / 10.0f;
 8001302:	ed85 7a00 	vstr	s14, [r5]
}
 8001306:	b003      	add	sp, #12
 8001308:	bd30      	pop	{r4, r5, pc}
 800130a:	bf00      	nop

0800130c <HTS221_T_Get_WhoAmI>:
{
 800130c:	b508      	push	{r3, lr}
  if ( HTS221_Get_DeviceID( (void *)handle, who_am_i ) == HTS221_ERROR )
 800130e:	f7ff fd9d 	bl	8000e4c <HTS221_Get_DeviceID>
}
 8001312:	f1a0 0001 	sub.w	r0, r0, #1
 8001316:	fab0 f080 	clz	r0, r0
 800131a:	0940      	lsrs	r0, r0, #5
 800131c:	bd08      	pop	{r3, pc}
 800131e:	bf00      	nop

08001320 <HTS221_H_Sensor_Enable>:
  if ( handle->isEnabled == 1 )
 8001320:	7982      	ldrb	r2, [r0, #6]
 8001322:	2a01      	cmp	r2, #1
 8001324:	d018      	beq.n	8001358 <HTS221_H_Sensor_Enable+0x38>
  if((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled == 0))
 8001326:	6883      	ldr	r3, [r0, #8]
{
 8001328:	b510      	push	{r4, lr}
  if((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled == 0))
 800132a:	681b      	ldr	r3, [r3, #0]
 800132c:	681b      	ldr	r3, [r3, #0]
 800132e:	78da      	ldrb	r2, [r3, #3]
 8001330:	4604      	mov	r4, r0
 8001332:	b122      	cbz	r2, 800133e <HTS221_H_Sensor_Enable+0x1e>
  ((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled = 1;
 8001334:	2201      	movs	r2, #1
 8001336:	709a      	strb	r2, [r3, #2]
  handle->isEnabled = 1;
 8001338:	71a2      	strb	r2, [r4, #6]
  return COMPONENT_OK;
 800133a:	2000      	movs	r0, #0
 800133c:	bd10      	pop	{r4, pc}
  if ( HTS221_Activate( (void *)handle ) == HTS221_ERROR )
 800133e:	f7ff fe97 	bl	8001070 <HTS221_Activate>
 8001342:	2801      	cmp	r0, #1
 8001344:	d007      	beq.n	8001356 <HTS221_H_Sensor_Enable+0x36>
 8001346:	68a3      	ldr	r3, [r4, #8]
 8001348:	681b      	ldr	r3, [r3, #0]
 800134a:	681b      	ldr	r3, [r3, #0]
  ((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled = 1;
 800134c:	2201      	movs	r2, #1
 800134e:	709a      	strb	r2, [r3, #2]
  handle->isEnabled = 1;
 8001350:	71a2      	strb	r2, [r4, #6]
  return COMPONENT_OK;
 8001352:	2000      	movs	r0, #0
 8001354:	bd10      	pop	{r4, pc}
}
 8001356:	bd10      	pop	{r4, pc}
    return COMPONENT_OK;
 8001358:	2000      	movs	r0, #0
 800135a:	4770      	bx	lr

0800135c <HTS221_T_Sensor_Enable>:
  if ( handle->isEnabled == 1 )
 800135c:	7982      	ldrb	r2, [r0, #6]
 800135e:	2a01      	cmp	r2, #1
 8001360:	d018      	beq.n	8001394 <HTS221_T_Sensor_Enable+0x38>
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled == 0))
 8001362:	6883      	ldr	r3, [r0, #8]
{
 8001364:	b510      	push	{r4, lr}
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled == 0))
 8001366:	681b      	ldr	r3, [r3, #0]
 8001368:	681b      	ldr	r3, [r3, #0]
 800136a:	789a      	ldrb	r2, [r3, #2]
 800136c:	4604      	mov	r4, r0
 800136e:	b122      	cbz	r2, 800137a <HTS221_T_Sensor_Enable+0x1e>
  ((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled = 1;
 8001370:	2201      	movs	r2, #1
 8001372:	70da      	strb	r2, [r3, #3]
  handle->isEnabled = 1;
 8001374:	71a2      	strb	r2, [r4, #6]
  return COMPONENT_OK;
 8001376:	2000      	movs	r0, #0
 8001378:	bd10      	pop	{r4, pc}
  if ( HTS221_Activate( (void *)handle ) == HTS221_ERROR )
 800137a:	f7ff fe79 	bl	8001070 <HTS221_Activate>
 800137e:	2801      	cmp	r0, #1
 8001380:	d007      	beq.n	8001392 <HTS221_T_Sensor_Enable+0x36>
 8001382:	68a3      	ldr	r3, [r4, #8]
 8001384:	681b      	ldr	r3, [r3, #0]
 8001386:	681b      	ldr	r3, [r3, #0]
  ((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled = 1;
 8001388:	2201      	movs	r2, #1
 800138a:	70da      	strb	r2, [r3, #3]
  handle->isEnabled = 1;
 800138c:	71a2      	strb	r2, [r4, #6]
  return COMPONENT_OK;
 800138e:	2000      	movs	r0, #0
 8001390:	bd10      	pop	{r4, pc}
}
 8001392:	bd10      	pop	{r4, pc}
    return COMPONENT_OK;
 8001394:	2000      	movs	r0, #0
 8001396:	4770      	bx	lr

08001398 <HTS221_T_Get_Temp>:
{
 8001398:	b530      	push	{r4, r5, lr}
 800139a:	b083      	sub	sp, #12
  int16_t int16data = 0;
 800139c:	ab02      	add	r3, sp, #8
 800139e:	2400      	movs	r4, #0
 80013a0:	f823 4d02 	strh.w	r4, [r3, #-2]!
{
 80013a4:	460d      	mov	r5, r1
  if ( HTS221_Get_Temperature( (void *)handle, &int16data ) == HTS221_ERROR )
 80013a6:	4619      	mov	r1, r3
 80013a8:	f7ff fdd6 	bl	8000f58 <HTS221_Get_Temperature>
 80013ac:	2801      	cmp	r0, #1
 80013ae:	d00c      	beq.n	80013ca <HTS221_T_Get_Temp+0x32>
  *temperature = ( float )int16data / 10.0f;
 80013b0:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 80013b4:	ee07 3a90 	vmov	s15, r3
 80013b8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80013bc:	eef2 6a04 	vmov.f32	s13, #36	; 0x41200000  10.0
 80013c0:	ee87 7aa6 	vdiv.f32	s14, s15, s13
  return COMPONENT_OK;
 80013c4:	4620      	mov	r0, r4
  *temperature = ( float )int16data / 10.0f;
 80013c6:	ed85 7a00 	vstr	s14, [r5]
}
 80013ca:	b003      	add	sp, #12
 80013cc:	bd30      	pop	{r4, r5, pc}
 80013ce:	bf00      	nop

080013d0 <HTS221_H_Sensor_Disable>:
  if ( handle->isEnabled == 0 )
 80013d0:	7983      	ldrb	r3, [r0, #6]
 80013d2:	b15b      	cbz	r3, 80013ec <HTS221_H_Sensor_Disable+0x1c>
  if((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled == 0))
 80013d4:	6883      	ldr	r3, [r0, #8]
{
 80013d6:	b510      	push	{r4, lr}
  if((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled == 0))
 80013d8:	681b      	ldr	r3, [r3, #0]
 80013da:	681a      	ldr	r2, [r3, #0]
 80013dc:	78d3      	ldrb	r3, [r2, #3]
 80013de:	4604      	mov	r4, r0
 80013e0:	b133      	cbz	r3, 80013f0 <HTS221_H_Sensor_Disable+0x20>
  ((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled = 0;
 80013e2:	2300      	movs	r3, #0
 80013e4:	7093      	strb	r3, [r2, #2]
  handle->isEnabled = 0;
 80013e6:	71a3      	strb	r3, [r4, #6]
 80013e8:	4618      	mov	r0, r3
 80013ea:	bd10      	pop	{r4, pc}
    return COMPONENT_OK;
 80013ec:	4618      	mov	r0, r3
 80013ee:	4770      	bx	lr
  if ( HTS221_DeActivate( (void *)handle ) == HTS221_ERROR )
 80013f0:	f7ff fe5e 	bl	80010b0 <HTS221_DeActivate>
 80013f4:	2801      	cmp	r0, #1
 80013f6:	d007      	beq.n	8001408 <HTS221_H_Sensor_Disable+0x38>
 80013f8:	68a3      	ldr	r3, [r4, #8]
 80013fa:	681b      	ldr	r3, [r3, #0]
 80013fc:	681a      	ldr	r2, [r3, #0]
  ((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled = 0;
 80013fe:	2300      	movs	r3, #0
 8001400:	7093      	strb	r3, [r2, #2]
  handle->isEnabled = 0;
 8001402:	71a3      	strb	r3, [r4, #6]
 8001404:	4618      	mov	r0, r3
 8001406:	bd10      	pop	{r4, pc}
}
 8001408:	bd10      	pop	{r4, pc}
 800140a:	bf00      	nop

0800140c <HTS221_T_Sensor_Disable>:
  if ( handle->isEnabled == 0 )
 800140c:	7983      	ldrb	r3, [r0, #6]
 800140e:	b15b      	cbz	r3, 8001428 <HTS221_T_Sensor_Disable+0x1c>
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled == 0))
 8001410:	6883      	ldr	r3, [r0, #8]
{
 8001412:	b510      	push	{r4, lr}
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled == 0))
 8001414:	681b      	ldr	r3, [r3, #0]
 8001416:	681a      	ldr	r2, [r3, #0]
 8001418:	7893      	ldrb	r3, [r2, #2]
 800141a:	4604      	mov	r4, r0
 800141c:	b133      	cbz	r3, 800142c <HTS221_T_Sensor_Disable+0x20>
  ((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled = 0;
 800141e:	2300      	movs	r3, #0
 8001420:	70d3      	strb	r3, [r2, #3]
  handle->isEnabled = 0;
 8001422:	71a3      	strb	r3, [r4, #6]
 8001424:	4618      	mov	r0, r3
 8001426:	bd10      	pop	{r4, pc}
    return COMPONENT_OK;
 8001428:	4618      	mov	r0, r3
 800142a:	4770      	bx	lr
  if ( HTS221_DeActivate( (void *)handle ) == HTS221_ERROR )
 800142c:	f7ff fe40 	bl	80010b0 <HTS221_DeActivate>
 8001430:	2801      	cmp	r0, #1
 8001432:	d007      	beq.n	8001444 <HTS221_T_Sensor_Disable+0x38>
 8001434:	68a3      	ldr	r3, [r4, #8]
 8001436:	681b      	ldr	r3, [r3, #0]
 8001438:	681a      	ldr	r2, [r3, #0]
  ((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled = 0;
 800143a:	2300      	movs	r3, #0
 800143c:	70d3      	strb	r3, [r2, #3]
  handle->isEnabled = 0;
 800143e:	71a3      	strb	r3, [r4, #6]
 8001440:	4618      	mov	r0, r3
 8001442:	bd10      	pop	{r4, pc}
}
 8001444:	bd10      	pop	{r4, pc}
 8001446:	bf00      	nop

08001448 <HTS221_T_Init>:
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized == 0))
 8001448:	6883      	ldr	r3, [r0, #8]
{
 800144a:	b510      	push	{r4, lr}
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized == 0))
 800144c:	681b      	ldr	r3, [r3, #0]
 800144e:	681b      	ldr	r3, [r3, #0]
 8001450:	781a      	ldrb	r2, [r3, #0]
{
 8001452:	b082      	sub	sp, #8
 8001454:	4604      	mov	r4, r0
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized == 0))
 8001456:	b12a      	cbz	r2, 8001464 <HTS221_T_Init+0x1c>
  ((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized = 1;
 8001458:	2201      	movs	r2, #1
  return COMPONENT_OK;
 800145a:	2000      	movs	r0, #0
  ((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized = 1;
 800145c:	705a      	strb	r2, [r3, #1]
  handle->isInitialized = 1;
 800145e:	7162      	strb	r2, [r4, #5]
}
 8001460:	b002      	add	sp, #8
 8001462:	bd10      	pop	{r4, pc}
  uint8_t who_am_i = 0x00;
 8001464:	a902      	add	r1, sp, #8
 8001466:	f801 2d01 	strb.w	r2, [r1, #-1]!
  if ( HTS221_Get_DeviceID( (void *)handle, who_am_i ) == HTS221_ERROR )
 800146a:	f7ff fcef 	bl	8000e4c <HTS221_Get_DeviceID>
 800146e:	2801      	cmp	r0, #1
 8001470:	d004      	beq.n	800147c <HTS221_T_Init+0x34>
  if ( who_am_i != handle->who_am_i )
 8001472:	7822      	ldrb	r2, [r4, #0]
 8001474:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001478:	429a      	cmp	r2, r3
 800147a:	d002      	beq.n	8001482 <HTS221_T_Init+0x3a>
      return COMPONENT_ERROR;
 800147c:	2001      	movs	r0, #1
}
 800147e:	b002      	add	sp, #8
 8001480:	bd10      	pop	{r4, pc}
  if ( HTS221_DeActivate( (void *)handle ) == HTS221_ERROR )
 8001482:	4620      	mov	r0, r4
 8001484:	f7ff fe14 	bl	80010b0 <HTS221_DeActivate>
 8001488:	2801      	cmp	r0, #1
 800148a:	d0f7      	beq.n	800147c <HTS221_T_Init+0x34>
  if ( HTS221_Set_BduMode( (void *)handle, HTS221_ENABLE ) == HTS221_ERROR )
 800148c:	2101      	movs	r1, #1
 800148e:	4620      	mov	r0, r4
 8001490:	f7ff fe4c 	bl	800112c <HTS221_Set_BduMode>
 8001494:	2801      	cmp	r0, #1
 8001496:	d0f1      	beq.n	800147c <HTS221_T_Init+0x34>
  if ( HTS221_Set_Odr( (void *)handle, new_odr ) == HTS221_ERROR )
 8001498:	2101      	movs	r1, #1
 800149a:	4620      	mov	r0, r4
 800149c:	f7ff fe72 	bl	8001184 <HTS221_Set_Odr>
    if(HTS221_Init(handle) == COMPONENT_ERROR)
 80014a0:	2801      	cmp	r0, #1
 80014a2:	d0eb      	beq.n	800147c <HTS221_T_Init+0x34>
 80014a4:	68a3      	ldr	r3, [r4, #8]
 80014a6:	681b      	ldr	r3, [r3, #0]
 80014a8:	681b      	ldr	r3, [r3, #0]
 80014aa:	e7d5      	b.n	8001458 <HTS221_T_Init+0x10>

080014ac <HTS221_H_Get_ODR>:
 80014ac:	b510      	push	{r4, lr}
 80014ae:	b082      	sub	sp, #8
 80014b0:	460c      	mov	r4, r1
 80014b2:	f10d 0107 	add.w	r1, sp, #7
 80014b6:	f7ff fe1b 	bl	80010f0 <HTS221_Get_Odr>
 80014ba:	2801      	cmp	r0, #1
 80014bc:	d00a      	beq.n	80014d4 <HTS221_H_Get_ODR+0x28>
 80014be:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80014c2:	2b03      	cmp	r3, #3
 80014c4:	d818      	bhi.n	80014f8 <HTS221_H_Get_ODR+0x4c>
 80014c6:	e8df f003 	tbb	[pc, r3]
 80014ca:	110c      	.short	0x110c
 80014cc:	0702      	.short	0x0702
 80014ce:	4b0d      	ldr	r3, [pc, #52]	; (8001504 <HTS221_H_Get_ODR+0x58>)
 80014d0:	6023      	str	r3, [r4, #0]
 80014d2:	2000      	movs	r0, #0
 80014d4:	b002      	add	sp, #8
 80014d6:	bd10      	pop	{r4, pc}
 80014d8:	4b0b      	ldr	r3, [pc, #44]	; (8001508 <HTS221_H_Get_ODR+0x5c>)
 80014da:	6023      	str	r3, [r4, #0]
 80014dc:	2000      	movs	r0, #0
 80014de:	b002      	add	sp, #8
 80014e0:	bd10      	pop	{r4, pc}
 80014e2:	2300      	movs	r3, #0
 80014e4:	2000      	movs	r0, #0
 80014e6:	6023      	str	r3, [r4, #0]
 80014e8:	b002      	add	sp, #8
 80014ea:	bd10      	pop	{r4, pc}
 80014ec:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 80014f0:	2000      	movs	r0, #0
 80014f2:	6023      	str	r3, [r4, #0]
 80014f4:	b002      	add	sp, #8
 80014f6:	bd10      	pop	{r4, pc}
 80014f8:	4b04      	ldr	r3, [pc, #16]	; (800150c <HTS221_H_Get_ODR+0x60>)
 80014fa:	6023      	str	r3, [r4, #0]
 80014fc:	2001      	movs	r0, #1
 80014fe:	b002      	add	sp, #8
 8001500:	bd10      	pop	{r4, pc}
 8001502:	bf00      	nop
 8001504:	40e00000 	.word	0x40e00000
 8001508:	41480000 	.word	0x41480000
 800150c:	bf800000 	.word	0xbf800000

08001510 <HTS221_H_Get_WhoAmI>:
 8001510:	b508      	push	{r3, lr}
 8001512:	f7ff fc9b 	bl	8000e4c <HTS221_Get_DeviceID>
 8001516:	f1a0 0001 	sub.w	r0, r0, #1
 800151a:	fab0 f080 	clz	r0, r0
 800151e:	0940      	lsrs	r0, r0, #5
 8001520:	bd08      	pop	{r3, pc}
 8001522:	bf00      	nop

08001524 <HTS221_H_Set_ODR>:
 8001524:	b159      	cbz	r1, 800153e <HTS221_H_Set_ODR+0x1a>
 8001526:	2904      	cmp	r1, #4
 8001528:	d80b      	bhi.n	8001542 <HTS221_H_Set_ODR+0x1e>
 800152a:	2103      	movs	r1, #3
 800152c:	b508      	push	{r3, lr}
 800152e:	f7ff fe29 	bl	8001184 <HTS221_Set_Odr>
 8001532:	f1a0 0001 	sub.w	r0, r0, #1
 8001536:	fab0 f080 	clz	r0, r0
 800153a:	0940      	lsrs	r0, r0, #5
 800153c:	bd08      	pop	{r3, pc}
 800153e:	2101      	movs	r1, #1
 8001540:	e7f4      	b.n	800152c <HTS221_H_Set_ODR+0x8>
 8001542:	2001      	movs	r0, #1
 8001544:	4770      	bx	lr
 8001546:	bf00      	nop

08001548 <HTS221_T_Get_ODR>:
{
 8001548:	b510      	push	{r4, lr}
 800154a:	b082      	sub	sp, #8
 800154c:	460c      	mov	r4, r1
  if ( HTS221_Get_Odr( (void *)handle, &odr_low_level ) == HTS221_ERROR )
 800154e:	f10d 0107 	add.w	r1, sp, #7
 8001552:	f7ff fdcd 	bl	80010f0 <HTS221_Get_Odr>
 8001556:	2801      	cmp	r0, #1
 8001558:	d00a      	beq.n	8001570 <HTS221_T_Get_ODR+0x28>
  switch( odr_low_level )
 800155a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800155e:	2b03      	cmp	r3, #3
 8001560:	d818      	bhi.n	8001594 <HTS221_T_Get_ODR+0x4c>
 8001562:	e8df f003 	tbb	[pc, r3]
 8001566:	110c      	.short	0x110c
 8001568:	0702      	.short	0x0702
      *odr =  7.0f;
 800156a:	4b0d      	ldr	r3, [pc, #52]	; (80015a0 <HTS221_T_Get_ODR+0x58>)
 800156c:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800156e:	2000      	movs	r0, #0
}
 8001570:	b002      	add	sp, #8
 8001572:	bd10      	pop	{r4, pc}
      *odr = 12.5f;
 8001574:	4b0b      	ldr	r3, [pc, #44]	; (80015a4 <HTS221_T_Get_ODR+0x5c>)
 8001576:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8001578:	2000      	movs	r0, #0
}
 800157a:	b002      	add	sp, #8
 800157c:	bd10      	pop	{r4, pc}
      *odr =  0.0f;
 800157e:	2300      	movs	r3, #0
  return COMPONENT_OK;
 8001580:	2000      	movs	r0, #0
      *odr =  0.0f;
 8001582:	6023      	str	r3, [r4, #0]
}
 8001584:	b002      	add	sp, #8
 8001586:	bd10      	pop	{r4, pc}
      *odr =  1.0f;
 8001588:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
  return COMPONENT_OK;
 800158c:	2000      	movs	r0, #0
      *odr =  1.0f;
 800158e:	6023      	str	r3, [r4, #0]
}
 8001590:	b002      	add	sp, #8
 8001592:	bd10      	pop	{r4, pc}
      *odr = -1.0f;
 8001594:	4b04      	ldr	r3, [pc, #16]	; (80015a8 <HTS221_T_Get_ODR+0x60>)
 8001596:	6023      	str	r3, [r4, #0]
      return COMPONENT_ERROR;
 8001598:	2001      	movs	r0, #1
}
 800159a:	b002      	add	sp, #8
 800159c:	bd10      	pop	{r4, pc}
 800159e:	bf00      	nop
 80015a0:	40e00000 	.word	0x40e00000
 80015a4:	41480000 	.word	0x41480000
 80015a8:	bf800000 	.word	0xbf800000

080015ac <HTS221_H_Read_Reg>:
 80015ac:	b508      	push	{r3, lr}
 80015ae:	4613      	mov	r3, r2
 80015b0:	2201      	movs	r2, #1
 80015b2:	f7ff fc37 	bl	8000e24 <HTS221_ReadReg>
 80015b6:	f1a0 0001 	sub.w	r0, r0, #1
 80015ba:	fab0 f080 	clz	r0, r0
 80015be:	0940      	lsrs	r0, r0, #5
 80015c0:	bd08      	pop	{r3, pc}
 80015c2:	bf00      	nop

080015c4 <HTS221_H_Check_WhoAmI>:
 80015c4:	b510      	push	{r4, lr}
 80015c6:	b082      	sub	sp, #8
 80015c8:	a902      	add	r1, sp, #8
 80015ca:	2300      	movs	r3, #0
 80015cc:	f801 3d01 	strb.w	r3, [r1, #-1]!
 80015d0:	4604      	mov	r4, r0
 80015d2:	f7ff fc3b 	bl	8000e4c <HTS221_Get_DeviceID>
 80015d6:	2801      	cmp	r0, #1
 80015d8:	d005      	beq.n	80015e6 <HTS221_H_Check_WhoAmI+0x22>
 80015da:	7820      	ldrb	r0, [r4, #0]
 80015dc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80015e0:	1ac0      	subs	r0, r0, r3
 80015e2:	bf18      	it	ne
 80015e4:	2001      	movne	r0, #1
 80015e6:	b002      	add	sp, #8
 80015e8:	bd10      	pop	{r4, pc}
 80015ea:	bf00      	nop

080015ec <HTS221_T_Check_WhoAmI>:
{
 80015ec:	b510      	push	{r4, lr}
 80015ee:	b082      	sub	sp, #8
  uint8_t who_am_i = 0x00;
 80015f0:	a902      	add	r1, sp, #8
 80015f2:	2300      	movs	r3, #0
 80015f4:	f801 3d01 	strb.w	r3, [r1, #-1]!
{
 80015f8:	4604      	mov	r4, r0
  if ( HTS221_Get_DeviceID( (void *)handle, who_am_i ) == HTS221_ERROR )
 80015fa:	f7ff fc27 	bl	8000e4c <HTS221_Get_DeviceID>
 80015fe:	2801      	cmp	r0, #1
 8001600:	d005      	beq.n	800160e <HTS221_T_Check_WhoAmI+0x22>
  if ( who_am_i != handle->who_am_i )
 8001602:	7820      	ldrb	r0, [r4, #0]
 8001604:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001608:	1ac0      	subs	r0, r0, r3
 800160a:	bf18      	it	ne
 800160c:	2001      	movne	r0, #1
}
 800160e:	b002      	add	sp, #8
 8001610:	bd10      	pop	{r4, pc}
 8001612:	bf00      	nop

08001614 <HTS221_H_Set_ODR_Value>:
 8001614:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8001618:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800161c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001620:	b508      	push	{r3, lr}
 8001622:	d910      	bls.n	8001646 <HTS221_H_Set_ODR_Value+0x32>
 8001624:	eef1 7a0c 	vmov.f32	s15, #28	; 0x40e00000  7.0
 8001628:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800162c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001630:	bf94      	ite	ls
 8001632:	2102      	movls	r1, #2
 8001634:	2103      	movhi	r1, #3
 8001636:	f7ff fda5 	bl	8001184 <HTS221_Set_Odr>
 800163a:	f1a0 0001 	sub.w	r0, r0, #1
 800163e:	fab0 f080 	clz	r0, r0
 8001642:	0940      	lsrs	r0, r0, #5
 8001644:	bd08      	pop	{r3, pc}
 8001646:	2101      	movs	r1, #1
 8001648:	e7f5      	b.n	8001636 <HTS221_H_Set_ODR_Value+0x22>
 800164a:	bf00      	nop

0800164c <HTS221_H_Write_Reg>:
 800164c:	b500      	push	{lr}
 800164e:	b083      	sub	sp, #12
 8001650:	ab02      	add	r3, sp, #8
 8001652:	f803 2d01 	strb.w	r2, [r3, #-1]!
 8001656:	2201      	movs	r2, #1
 8001658:	f7ff fbee 	bl	8000e38 <HTS221_WriteReg>
 800165c:	f1a0 0001 	sub.w	r0, r0, #1
 8001660:	fab0 f080 	clz	r0, r0
 8001664:	0940      	lsrs	r0, r0, #5
 8001666:	b003      	add	sp, #12
 8001668:	f85d fb04 	ldr.w	pc, [sp], #4

0800166c <HTS221_H_DeInit>:
  if ((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized == 0))
 800166c:	6883      	ldr	r3, [r0, #8]
{
 800166e:	b510      	push	{r4, lr}
  if ((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized == 0))
 8001670:	681b      	ldr	r3, [r3, #0]
 8001672:	681a      	ldr	r2, [r3, #0]
 8001674:	7853      	ldrb	r3, [r2, #1]
{
 8001676:	4604      	mov	r4, r0
  if ((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized == 0))
 8001678:	b123      	cbz	r3, 8001684 <HTS221_H_DeInit+0x18>
  ((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized = 0;
 800167a:	2300      	movs	r3, #0
 800167c:	7013      	strb	r3, [r2, #0]
  return COMPONENT_OK;
 800167e:	4618      	mov	r0, r3
  handle->isInitialized = 0;
 8001680:	7163      	strb	r3, [r4, #5]
}
 8001682:	bd10      	pop	{r4, pc}
  if ( handle->isEnabled == 0 )
 8001684:	7983      	ldrb	r3, [r0, #6]
 8001686:	2b00      	cmp	r3, #0
 8001688:	d0f7      	beq.n	800167a <HTS221_H_DeInit+0xe>
  if((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled == 0))
 800168a:	78d3      	ldrb	r3, [r2, #3]
 800168c:	b11b      	cbz	r3, 8001696 <HTS221_H_DeInit+0x2a>
  ((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled = 0;
 800168e:	2300      	movs	r3, #0
 8001690:	7093      	strb	r3, [r2, #2]
  handle->isEnabled = 0;
 8001692:	71a3      	strb	r3, [r4, #6]
 8001694:	e7f1      	b.n	800167a <HTS221_H_DeInit+0xe>
  if ( HTS221_DeActivate( (void *)handle ) == HTS221_ERROR )
 8001696:	f7ff fd0b 	bl	80010b0 <HTS221_DeActivate>
 800169a:	2801      	cmp	r0, #1
 800169c:	d0f1      	beq.n	8001682 <HTS221_H_DeInit+0x16>
 800169e:	68a3      	ldr	r3, [r4, #8]
 80016a0:	681b      	ldr	r3, [r3, #0]
 80016a2:	681a      	ldr	r2, [r3, #0]
 80016a4:	e7f3      	b.n	800168e <HTS221_H_DeInit+0x22>
 80016a6:	bf00      	nop

080016a8 <HTS221_T_DeInit>:
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized == 0))
 80016a8:	6883      	ldr	r3, [r0, #8]
{
 80016aa:	b510      	push	{r4, lr}
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized == 0))
 80016ac:	681b      	ldr	r3, [r3, #0]
 80016ae:	681a      	ldr	r2, [r3, #0]
 80016b0:	7813      	ldrb	r3, [r2, #0]
{
 80016b2:	4604      	mov	r4, r0
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized == 0))
 80016b4:	b123      	cbz	r3, 80016c0 <HTS221_T_DeInit+0x18>
  ((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized = 0;
 80016b6:	2300      	movs	r3, #0
 80016b8:	7053      	strb	r3, [r2, #1]
  return COMPONENT_OK;
 80016ba:	4618      	mov	r0, r3
  handle->isInitialized = 0;
 80016bc:	7163      	strb	r3, [r4, #5]
}
 80016be:	bd10      	pop	{r4, pc}
  if ( handle->isEnabled == 0 )
 80016c0:	7983      	ldrb	r3, [r0, #6]
 80016c2:	2b00      	cmp	r3, #0
 80016c4:	d0f7      	beq.n	80016b6 <HTS221_T_DeInit+0xe>
  if((((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isHumEnabled == 0))
 80016c6:	7893      	ldrb	r3, [r2, #2]
 80016c8:	b11b      	cbz	r3, 80016d2 <HTS221_T_DeInit+0x2a>
  ((HTS221_T_Data_t *)(((TEMPERATURE_Data_t *)(handle->pData))->pComponentData))->comboData->isTempEnabled = 0;
 80016ca:	2300      	movs	r3, #0
 80016cc:	70d3      	strb	r3, [r2, #3]
  handle->isEnabled = 0;
 80016ce:	71a3      	strb	r3, [r4, #6]
 80016d0:	e7f1      	b.n	80016b6 <HTS221_T_DeInit+0xe>
  if ( HTS221_DeActivate( (void *)handle ) == HTS221_ERROR )
 80016d2:	f7ff fced 	bl	80010b0 <HTS221_DeActivate>
 80016d6:	2801      	cmp	r0, #1
 80016d8:	d0f1      	beq.n	80016be <HTS221_T_DeInit+0x16>
 80016da:	68a3      	ldr	r3, [r4, #8]
 80016dc:	681b      	ldr	r3, [r3, #0]
 80016de:	681a      	ldr	r2, [r3, #0]
 80016e0:	e7f3      	b.n	80016ca <HTS221_T_DeInit+0x22>
 80016e2:	bf00      	nop

080016e4 <HTS221_H_Init>:
  if ((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized == 0))
 80016e4:	6883      	ldr	r3, [r0, #8]
{
 80016e6:	b510      	push	{r4, lr}
  if ((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized == 0))
 80016e8:	681b      	ldr	r3, [r3, #0]
 80016ea:	681b      	ldr	r3, [r3, #0]
 80016ec:	785a      	ldrb	r2, [r3, #1]
{
 80016ee:	b082      	sub	sp, #8
 80016f0:	4604      	mov	r4, r0
  if ((((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isTempInitialized == 0))
 80016f2:	b12a      	cbz	r2, 8001700 <HTS221_H_Init+0x1c>
  ((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized = 1;
 80016f4:	2201      	movs	r2, #1
  return COMPONENT_OK;
 80016f6:	2000      	movs	r0, #0
  ((HTS221_H_Data_t *)(((HUMIDITY_Data_t *)(handle->pData))->pComponentData))->comboData->isHumInitialized = 1;
 80016f8:	701a      	strb	r2, [r3, #0]
  handle->isInitialized = 1;
 80016fa:	7162      	strb	r2, [r4, #5]
}
 80016fc:	b002      	add	sp, #8
 80016fe:	bd10      	pop	{r4, pc}
  uint8_t who_am_i = 0x00;
 8001700:	a902      	add	r1, sp, #8
 8001702:	f801 2d01 	strb.w	r2, [r1, #-1]!
  if ( HTS221_Get_DeviceID( (void *)handle, who_am_i ) == HTS221_ERROR )
 8001706:	f7ff fba1 	bl	8000e4c <HTS221_Get_DeviceID>
 800170a:	2801      	cmp	r0, #1
 800170c:	d004      	beq.n	8001718 <HTS221_H_Init+0x34>
  if ( who_am_i != handle->who_am_i )
 800170e:	7822      	ldrb	r2, [r4, #0]
 8001710:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001714:	429a      	cmp	r2, r3
 8001716:	d002      	beq.n	800171e <HTS221_H_Init+0x3a>
      return COMPONENT_ERROR;
 8001718:	2001      	movs	r0, #1
}
 800171a:	b002      	add	sp, #8
 800171c:	bd10      	pop	{r4, pc}
  if ( HTS221_DeActivate( (void *)handle ) == HTS221_ERROR )
 800171e:	4620      	mov	r0, r4
 8001720:	f7ff fcc6 	bl	80010b0 <HTS221_DeActivate>
 8001724:	2801      	cmp	r0, #1
 8001726:	d0f7      	beq.n	8001718 <HTS221_H_Init+0x34>
  if ( HTS221_Set_BduMode( (void *)handle, HTS221_ENABLE ) == HTS221_ERROR )
 8001728:	2101      	movs	r1, #1
 800172a:	4620      	mov	r0, r4
 800172c:	f7ff fcfe 	bl	800112c <HTS221_Set_BduMode>
 8001730:	2801      	cmp	r0, #1
 8001732:	d0f1      	beq.n	8001718 <HTS221_H_Init+0x34>
  if ( HTS221_Set_Odr( (void *)handle, new_odr ) == HTS221_ERROR )
 8001734:	2101      	movs	r1, #1
 8001736:	4620      	mov	r0, r4
 8001738:	f7ff fd24 	bl	8001184 <HTS221_Set_Odr>
    if(HTS221_Init(handle) == COMPONENT_ERROR)
 800173c:	2801      	cmp	r0, #1
 800173e:	d0eb      	beq.n	8001718 <HTS221_H_Init+0x34>
 8001740:	68a3      	ldr	r3, [r4, #8]
 8001742:	681b      	ldr	r3, [r3, #0]
 8001744:	681b      	ldr	r3, [r3, #0]
 8001746:	e7d5      	b.n	80016f4 <HTS221_H_Init+0x10>

08001748 <LPS22HB_ReadReg>:
* Input       : Register Address
* Output      : Data Read
* Return      : None
*******************************************************************************/
LPS22HB_Error_et LPS22HB_ReadReg( void *handle, uint8_t RegAddr, uint16_t NumByteToRead, uint8_t *Data )
{
 8001748:	b510      	push	{r4, lr}
 800174a:	461c      	mov	r4, r3
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 800174c:	4613      	mov	r3, r2
 800174e:	4622      	mov	r2, r4
 8001750:	f005 ff0c 	bl	800756c <Sensor_IO_Read>
    return LPS22HB_ERROR;
  else
    return LPS22HB_OK;
}
 8001754:	3000      	adds	r0, #0
 8001756:	bf18      	it	ne
 8001758:	2001      	movne	r0, #1
 800175a:	bd10      	pop	{r4, pc}

0800175c <LPS22HB_WriteReg>:
* Input       : Register Address, Data to be written
* Output      : None
* Return      : None
*******************************************************************************/
LPS22HB_Error_et LPS22HB_WriteReg( void *handle, uint8_t RegAddr, uint16_t NumByteToWrite, uint8_t *Data )
{
 800175c:	b510      	push	{r4, lr}
 800175e:	461c      	mov	r4, r3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001760:	4613      	mov	r3, r2
 8001762:	4622      	mov	r2, r4
 8001764:	f005 feb4 	bl	80074d0 <Sensor_IO_Write>
    return LPS22HB_ERROR;
  else
    return LPS22HB_OK;
}
 8001768:	3000      	adds	r0, #0
 800176a:	bf18      	it	ne
 800176c:	2001      	movne	r0, #1
 800176e:	bd10      	pop	{r4, pc}

08001770 <LPS22HB_Get_DeviceID>:
* @param  *handle Device handle.
* @param  Buffer to empty by Device identification Value.
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_DeviceID(void *handle, uint8_t* deviceid)
{
 8001770:	b508      	push	{r3, lr}
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001772:	460a      	mov	r2, r1
 8001774:	2301      	movs	r3, #1
 8001776:	210f      	movs	r1, #15
 8001778:	f005 fef8 	bl	800756c <Sensor_IO_Read>
  if(LPS22HB_ReadReg(handle, LPS22HB_WHO_AM_I_REG, 1, deviceid))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 800177c:	3000      	adds	r0, #0
 800177e:	bf18      	it	ne
 8001780:	2001      	movne	r0, #1
 8001782:	bd08      	pop	{r3, pc}

08001784 <LPS22HB_Set_PowerMode>:
* @param  *handle Device handle.
* @param  LPS22HB_LowNoise or LPS22HB_LowPower mode
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_PowerMode(void *handle, LPS22HB_PowerMode_et mode)
{
 8001784:	b530      	push	{r4, r5, lr}
 8001786:	b083      	sub	sp, #12
 8001788:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 800178a:	f10d 0207 	add.w	r2, sp, #7
 800178e:	2301      	movs	r3, #1
 8001790:	211a      	movs	r1, #26
{
 8001792:	4605      	mov	r5, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001794:	f005 feea 	bl	800756c <Sensor_IO_Read>
 8001798:	b110      	cbz	r0, 80017a0 <LPS22HB_Set_PowerMode+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_PowerMode(mode));

  if(LPS22HB_ReadReg(handle, LPS22HB_RES_CONF_REG, 1, &tmp))
    return LPS22HB_ERROR;
 800179a:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_RES_CONF_REG, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 800179c:	b003      	add	sp, #12
 800179e:	bd30      	pop	{r4, r5, pc}
  tmp &= ~LPS22HB_LCEN_MASK;
 80017a0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80017a4:	f023 0301 	bic.w	r3, r3, #1
  tmp |= (uint8_t)mode;
 80017a8:	431c      	orrs	r4, r3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80017aa:	f10d 0207 	add.w	r2, sp, #7
 80017ae:	4628      	mov	r0, r5
 80017b0:	2301      	movs	r3, #1
 80017b2:	211a      	movs	r1, #26
  tmp |= (uint8_t)mode;
 80017b4:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80017b8:	f005 fe8a 	bl	80074d0 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 80017bc:	3000      	adds	r0, #0
 80017be:	bf18      	it	ne
 80017c0:	2001      	movne	r0, #1
}
 80017c2:	b003      	add	sp, #12
 80017c4:	bd30      	pop	{r4, r5, pc}
 80017c6:	bf00      	nop

080017c8 <LPS22HB_Set_Odr>:
* @param  *handle Device handle.
* @param  Output Data Rate
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_Odr(void *handle, LPS22HB_Odr_et odr)
{
 80017c8:	b530      	push	{r4, r5, lr}
 80017ca:	b083      	sub	sp, #12
 80017cc:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80017ce:	f10d 0207 	add.w	r2, sp, #7
 80017d2:	2301      	movs	r3, #1
 80017d4:	2110      	movs	r1, #16
{
 80017d6:	4605      	mov	r5, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80017d8:	f005 fec8 	bl	800756c <Sensor_IO_Read>
 80017dc:	b110      	cbz	r0, 80017e4 <LPS22HB_Set_Odr+0x1c>


  LPS22HB_assert_param(IS_LPS22HB_ODR(odr));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
    return LPS22HB_ERROR;
 80017de:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 80017e0:	b003      	add	sp, #12
 80017e2:	bd30      	pop	{r4, r5, pc}
  tmp &= ~LPS22HB_ODR_MASK;
 80017e4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80017e8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmp |= (uint8_t)odr;
 80017ec:	431c      	orrs	r4, r3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80017ee:	f10d 0207 	add.w	r2, sp, #7
 80017f2:	4628      	mov	r0, r5
 80017f4:	2301      	movs	r3, #1
 80017f6:	2110      	movs	r1, #16
  tmp |= (uint8_t)odr;
 80017f8:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80017fc:	f005 fe68 	bl	80074d0 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 8001800:	3000      	adds	r0, #0
 8001802:	bf18      	it	ne
 8001804:	2001      	movne	r0, #1
}
 8001806:	b003      	add	sp, #12
 8001808:	bd30      	pop	{r4, r5, pc}
 800180a:	bf00      	nop

0800180c <LPS22HB_Get_Odr>:
* @param  *handle Device handle.
* @param  Buffer to empty with Output Data Rate
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_Odr(void *handle, LPS22HB_Odr_et* odr)
{
 800180c:	b510      	push	{r4, lr}
 800180e:	b082      	sub	sp, #8
 8001810:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001812:	2301      	movs	r3, #1
 8001814:	f10d 0207 	add.w	r2, sp, #7
 8001818:	2110      	movs	r1, #16
 800181a:	f005 fea7 	bl	800756c <Sensor_IO_Read>
 800181e:	b110      	cbz	r0, 8001826 <LPS22HB_Get_Odr+0x1a>
  uint8_t tmp;

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
    return LPS22HB_ERROR;
 8001820:	2001      	movs	r0, #1

  *odr = (LPS22HB_Odr_et)(tmp & LPS22HB_ODR_MASK);

  return LPS22HB_OK;
}
 8001822:	b002      	add	sp, #8
 8001824:	bd10      	pop	{r4, pc}
  *odr = (LPS22HB_Odr_et)(tmp & LPS22HB_ODR_MASK);
 8001826:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800182a:	f003 0370 	and.w	r3, r3, #112	; 0x70
 800182e:	7023      	strb	r3, [r4, #0]
}
 8001830:	b002      	add	sp, #8
 8001832:	bd10      	pop	{r4, pc}

08001834 <LPS22HB_Set_LowPassFilter>:
* @param  *handle Device handle.
* @param  state: enable or disable
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_LowPassFilter(void *handle, LPS22HB_State_et state)
{
 8001834:	b570      	push	{r4, r5, r6, lr}
 8001836:	b082      	sub	sp, #8
 8001838:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 800183a:	f10d 0207 	add.w	r2, sp, #7
 800183e:	2301      	movs	r3, #1
 8001840:	2110      	movs	r1, #16
{
 8001842:	4606      	mov	r6, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001844:	f005 fe92 	bl	800756c <Sensor_IO_Read>
 8001848:	b110      	cbz	r0, 8001850 <LPS22HB_Set_LowPassFilter+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(state));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
    return LPS22HB_ERROR;
 800184a:	2001      	movs	r0, #1
  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
    return LPS22HB_ERROR;


  return LPS22HB_OK;
}
 800184c:	b002      	add	sp, #8
 800184e:	bd70      	pop	{r4, r5, r6, pc}
  tmp &= ~LPS22HB_LPFP_MASK;
 8001850:	f89d 4007 	ldrb.w	r4, [sp, #7]
 8001854:	f024 0408 	bic.w	r4, r4, #8
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001858:	f10d 0207 	add.w	r2, sp, #7
 800185c:	4630      	mov	r0, r6
  tmp |= ((uint8_t)state) << LPS22HB_LPFP_BIT;
 800185e:	ea44 04c5 	orr.w	r4, r4, r5, lsl #3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001862:	2301      	movs	r3, #1
 8001864:	2110      	movs	r1, #16
  tmp |= ((uint8_t)state) << LPS22HB_LPFP_BIT;
 8001866:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 800186a:	f005 fe31 	bl	80074d0 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 800186e:	3000      	adds	r0, #0
 8001870:	bf18      	it	ne
 8001872:	2001      	movne	r0, #1
}
 8001874:	b002      	add	sp, #8
 8001876:	bd70      	pop	{r4, r5, r6, pc}

08001878 <LPS22HB_Set_LowPassFilterCutoff>:
* @param  *handle Device handle.
* @param  Filter Cutoff ODR/9 or ODR/20
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_LowPassFilterCutoff(void *handle, LPS22HB_LPF_Cutoff_et cutoff)
{
 8001878:	b530      	push	{r4, r5, lr}
 800187a:	b083      	sub	sp, #12
 800187c:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 800187e:	f10d 0207 	add.w	r2, sp, #7
 8001882:	2301      	movs	r3, #1
 8001884:	2110      	movs	r1, #16
{
 8001886:	4605      	mov	r5, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001888:	f005 fe70 	bl	800756c <Sensor_IO_Read>
 800188c:	b110      	cbz	r0, 8001894 <LPS22HB_Set_LowPassFilterCutoff+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_LPF_Cutoff(cutoff));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
    return LPS22HB_ERROR;
 800188e:	2001      	movs	r0, #1
    return LPS22HB_ERROR;


  return LPS22HB_OK;

}
 8001890:	b003      	add	sp, #12
 8001892:	bd30      	pop	{r4, r5, pc}
  tmp &= ~LPS22HB_LPFP_CUTOFF_MASK;
 8001894:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001898:	f023 0304 	bic.w	r3, r3, #4
  tmp |= (uint8_t)cutoff;
 800189c:	431c      	orrs	r4, r3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 800189e:	f10d 0207 	add.w	r2, sp, #7
 80018a2:	4628      	mov	r0, r5
 80018a4:	2301      	movs	r3, #1
 80018a6:	2110      	movs	r1, #16
  tmp |= (uint8_t)cutoff;
 80018a8:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80018ac:	f005 fe10 	bl	80074d0 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 80018b0:	3000      	adds	r0, #0
 80018b2:	bf18      	it	ne
 80018b4:	2001      	movne	r0, #1
}
 80018b6:	b003      	add	sp, #12
 80018b8:	bd30      	pop	{r4, r5, pc}
 80018ba:	bf00      	nop

080018bc <LPS22HB_Set_Bdu>:
* @param  LPS22HB_BDU_CONTINUOUS_UPDATE, LPS22HB_BDU_NO_UPDATE
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/

LPS22HB_Error_et LPS22HB_Set_Bdu(void *handle, LPS22HB_Bdu_et bdu)
{
 80018bc:	b570      	push	{r4, r5, r6, lr}
 80018be:	b082      	sub	sp, #8
 80018c0:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80018c2:	f10d 0207 	add.w	r2, sp, #7
 80018c6:	2301      	movs	r3, #1
 80018c8:	2110      	movs	r1, #16
{
 80018ca:	4606      	mov	r6, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80018cc:	f005 fe4e 	bl	800756c <Sensor_IO_Read>
 80018d0:	b110      	cbz	r0, 80018d8 <LPS22HB_Set_Bdu+0x1c>


  LPS22HB_assert_param(IS_LPS22HB_BDUMode(bdu));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
    return LPS22HB_ERROR;
 80018d2:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG1, 1, &tmp))
    return LPS22HB_OK;

  return LPS22HB_OK;
}
 80018d4:	b002      	add	sp, #8
 80018d6:	bd70      	pop	{r4, r5, r6, pc}
  tmp &= ~LPS22HB_BDU_MASK;
 80018d8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80018dc:	f023 0302 	bic.w	r3, r3, #2
 80018e0:	4604      	mov	r4, r0
  tmp |= ((uint8_t)bdu);
 80018e2:	431d      	orrs	r5, r3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80018e4:	f10d 0207 	add.w	r2, sp, #7
 80018e8:	4630      	mov	r0, r6
 80018ea:	2301      	movs	r3, #1
 80018ec:	2110      	movs	r1, #16
  tmp |= ((uint8_t)bdu);
 80018ee:	f88d 5007 	strb.w	r5, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80018f2:	f005 fded 	bl	80074d0 <Sensor_IO_Write>
    return LPS22HB_OK;
 80018f6:	4620      	mov	r0, r4
}
 80018f8:	b002      	add	sp, #8
 80018fa:	bd70      	pop	{r4, r5, r6, pc}

080018fc <LPS22HB_Set_FifoModeUse>:
* @param  *handle Device handle.
* @param LPS22HB_ENABLE/LPS22HB_DISABLE
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FifoModeUse(void *handle, LPS22HB_State_et status)
{
 80018fc:	b570      	push	{r4, r5, r6, lr}
 80018fe:	b082      	sub	sp, #8
 8001900:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001902:	f10d 0207 	add.w	r2, sp, #7
 8001906:	2301      	movs	r3, #1
 8001908:	2111      	movs	r1, #17
{
 800190a:	4606      	mov	r6, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 800190c:	f005 fe2e 	bl	800756c <Sensor_IO_Read>
 8001910:	b110      	cbz	r0, 8001918 <LPS22HB_Set_FifoModeUse+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(status));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
    return LPS22HB_ERROR;
 8001912:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 8001914:	b002      	add	sp, #8
 8001916:	bd70      	pop	{r4, r5, r6, pc}
  tmp &= ~LPS22HB_FIFO_EN_MASK;
 8001918:	f89d 4007 	ldrb.w	r4, [sp, #7]
 800191c:	f024 0440 	bic.w	r4, r4, #64	; 0x40
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001920:	f10d 0207 	add.w	r2, sp, #7
 8001924:	4630      	mov	r0, r6
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_EN_BIT;
 8001926:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 800192a:	2301      	movs	r3, #1
 800192c:	2111      	movs	r1, #17
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_EN_BIT;
 800192e:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001932:	f005 fdcd 	bl	80074d0 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 8001936:	3000      	adds	r0, #0
 8001938:	bf18      	it	ne
 800193a:	2001      	movne	r0, #1
}
 800193c:	b002      	add	sp, #8
 800193e:	bd70      	pop	{r4, r5, r6, pc}

08001940 <LPS22HB_Set_FifoWatermarkLevelUse>:
* @param  *handle Device handle.
* @param   LPS22HB_ENABLE/LPS22HB_DISABLE
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FifoWatermarkLevelUse(void *handle, LPS22HB_State_et status)
{
 8001940:	b570      	push	{r4, r5, r6, lr}
 8001942:	b082      	sub	sp, #8
 8001944:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001946:	f10d 0207 	add.w	r2, sp, #7
 800194a:	2301      	movs	r3, #1
 800194c:	2111      	movs	r1, #17
{
 800194e:	4606      	mov	r6, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001950:	f005 fe0c 	bl	800756c <Sensor_IO_Read>
 8001954:	b110      	cbz	r0, 800195c <LPS22HB_Set_FifoWatermarkLevelUse+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(status));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
    return LPS22HB_ERROR;
 8001956:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 8001958:	b002      	add	sp, #8
 800195a:	bd70      	pop	{r4, r5, r6, pc}
  tmp &= ~LPS22HB_WTM_EN_MASK;
 800195c:	f89d 4007 	ldrb.w	r4, [sp, #7]
 8001960:	f024 0420 	bic.w	r4, r4, #32
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001964:	f10d 0207 	add.w	r2, sp, #7
 8001968:	4630      	mov	r0, r6
  tmp |= ((uint8_t)status) << LPS22HB_WTM_EN_BIT;
 800196a:	ea44 1445 	orr.w	r4, r4, r5, lsl #5
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 800196e:	2301      	movs	r3, #1
 8001970:	2111      	movs	r1, #17
  tmp |= ((uint8_t)status) << LPS22HB_WTM_EN_BIT;
 8001972:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001976:	f005 fdab 	bl	80074d0 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 800197a:	3000      	adds	r0, #0
 800197c:	bf18      	it	ne
 800197e:	2001      	movne	r0, #1
}
 8001980:	b002      	add	sp, #8
 8001982:	bd70      	pop	{r4, r5, r6, pc}

08001984 <LPS22HB_Set_AutomaticIncrementRegAddress>:
* @param  *handle Device handle.
* @param  LPS22HB_ENABLE/LPS22HB_DISABLE. Default is LPS22HB_ENABLE
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_AutomaticIncrementRegAddress(void *handle, LPS22HB_State_et status)
{
 8001984:	b570      	push	{r4, r5, r6, lr}
 8001986:	b082      	sub	sp, #8
 8001988:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 800198a:	f10d 0207 	add.w	r2, sp, #7
 800198e:	2301      	movs	r3, #1
 8001990:	2111      	movs	r1, #17
{
 8001992:	4606      	mov	r6, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001994:	f005 fdea 	bl	800756c <Sensor_IO_Read>
 8001998:	b110      	cbz	r0, 80019a0 <LPS22HB_Set_AutomaticIncrementRegAddress+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(status));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
    return LPS22HB_ERROR;
 800199a:	2001      	movs	r0, #1
  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG2, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;

}
 800199c:	b002      	add	sp, #8
 800199e:	bd70      	pop	{r4, r5, r6, pc}
  tmp &= ~LPS22HB_ADD_INC_MASK;
 80019a0:	f89d 4007 	ldrb.w	r4, [sp, #7]
 80019a4:	f024 0410 	bic.w	r4, r4, #16
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80019a8:	f10d 0207 	add.w	r2, sp, #7
 80019ac:	4630      	mov	r0, r6
  tmp |= (((uint8_t)status) << LPS22HB_ADD_INC_BIT);
 80019ae:	ea44 1405 	orr.w	r4, r4, r5, lsl #4
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80019b2:	2301      	movs	r3, #1
 80019b4:	2111      	movs	r1, #17
  tmp |= (((uint8_t)status) << LPS22HB_ADD_INC_BIT);
 80019b6:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80019ba:	f005 fd89 	bl	80074d0 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 80019be:	3000      	adds	r0, #0
 80019c0:	bf18      	it	ne
 80019c2:	2001      	movne	r0, #1
}
 80019c4:	b002      	add	sp, #8
 80019c6:	bd70      	pop	{r4, r5, r6, pc}

080019c8 <LPS22HB_Set_FIFO_OVR_Interrupt>:
* @param  *handle Device handle.
* @param  LPS22HB_ENABLE/LPS22HB_DISABLE
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FIFO_OVR_Interrupt(void *handle, LPS22HB_State_et status)
{
 80019c8:	b570      	push	{r4, r5, r6, lr}
 80019ca:	b082      	sub	sp, #8
 80019cc:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80019ce:	f10d 0207 	add.w	r2, sp, #7
 80019d2:	2301      	movs	r3, #1
 80019d4:	2112      	movs	r1, #18
{
 80019d6:	4606      	mov	r6, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 80019d8:	f005 fdc8 	bl	800756c <Sensor_IO_Read>
 80019dc:	b110      	cbz	r0, 80019e4 <LPS22HB_Set_FIFO_OVR_Interrupt+0x1c>


  LPS22HB_assert_param(IS_LPS22HB_State(status));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG3, 1, &tmp))
    return LPS22HB_ERROR;
 80019de:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG3, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 80019e0:	b002      	add	sp, #8
 80019e2:	bd70      	pop	{r4, r5, r6, pc}
  tmp &= ~LPS22HB_FIFO_OVR_MASK;
 80019e4:	f89d 4007 	ldrb.w	r4, [sp, #7]
 80019e8:	f024 0408 	bic.w	r4, r4, #8
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80019ec:	f10d 0207 	add.w	r2, sp, #7
 80019f0:	4630      	mov	r0, r6
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_OVR_BIT;
 80019f2:	ea44 04c5 	orr.w	r4, r4, r5, lsl #3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80019f6:	2301      	movs	r3, #1
 80019f8:	2112      	movs	r1, #18
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_OVR_BIT;
 80019fa:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 80019fe:	f005 fd67 	bl	80074d0 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 8001a02:	3000      	adds	r0, #0
 8001a04:	bf18      	it	ne
 8001a06:	2001      	movne	r0, #1
}
 8001a08:	b002      	add	sp, #8
 8001a0a:	bd70      	pop	{r4, r5, r6, pc}

08001a0c <LPS22HB_Set_FIFO_FTH_Interrupt>:
* @param  *handle Device handle.
* @param  LPS22HB_ENABLE/LPS22HB_DISABLE
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FIFO_FTH_Interrupt(void *handle, LPS22HB_State_et status)
{
 8001a0c:	b570      	push	{r4, r5, r6, lr}
 8001a0e:	b082      	sub	sp, #8
 8001a10:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001a12:	f10d 0207 	add.w	r2, sp, #7
 8001a16:	2301      	movs	r3, #1
 8001a18:	2112      	movs	r1, #18
{
 8001a1a:	4606      	mov	r6, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001a1c:	f005 fda6 	bl	800756c <Sensor_IO_Read>
 8001a20:	b110      	cbz	r0, 8001a28 <LPS22HB_Set_FIFO_FTH_Interrupt+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(status));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG3, 1, &tmp))
    return LPS22HB_ERROR;
 8001a22:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG3, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 8001a24:	b002      	add	sp, #8
 8001a26:	bd70      	pop	{r4, r5, r6, pc}
  tmp &= ~LPS22HB_FIFO_FTH_MASK;
 8001a28:	f89d 4007 	ldrb.w	r4, [sp, #7]
 8001a2c:	f024 0410 	bic.w	r4, r4, #16
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001a30:	f10d 0207 	add.w	r2, sp, #7
 8001a34:	4630      	mov	r0, r6
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_FTH_BIT;
 8001a36:	ea44 1405 	orr.w	r4, r4, r5, lsl #4
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001a3a:	2301      	movs	r3, #1
 8001a3c:	2112      	movs	r1, #18
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_FTH_BIT;
 8001a3e:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001a42:	f005 fd45 	bl	80074d0 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 8001a46:	3000      	adds	r0, #0
 8001a48:	bf18      	it	ne
 8001a4a:	2001      	movne	r0, #1
}
 8001a4c:	b002      	add	sp, #8
 8001a4e:	bd70      	pop	{r4, r5, r6, pc}

08001a50 <LPS22HB_Set_FIFO_FULL_Interrupt>:
* @param  *handle Device handle.
* @param  LPS22HB_ENABLE/LPS22HB_DISABLE
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FIFO_FULL_Interrupt(void *handle, LPS22HB_State_et status)
{
 8001a50:	b570      	push	{r4, r5, r6, lr}
 8001a52:	b082      	sub	sp, #8
 8001a54:	460d      	mov	r5, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001a56:	f10d 0207 	add.w	r2, sp, #7
 8001a5a:	2301      	movs	r3, #1
 8001a5c:	2112      	movs	r1, #18
{
 8001a5e:	4606      	mov	r6, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001a60:	f005 fd84 	bl	800756c <Sensor_IO_Read>
 8001a64:	b110      	cbz	r0, 8001a6c <LPS22HB_Set_FIFO_FULL_Interrupt+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_State(status));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_REG3, 1, &tmp))
    return LPS22HB_ERROR;
 8001a66:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_REG3, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 8001a68:	b002      	add	sp, #8
 8001a6a:	bd70      	pop	{r4, r5, r6, pc}
  tmp &= ~LPS22HB_FIFO_FULL_MASK;
 8001a6c:	f89d 4007 	ldrb.w	r4, [sp, #7]
 8001a70:	f024 0420 	bic.w	r4, r4, #32
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001a74:	f10d 0207 	add.w	r2, sp, #7
 8001a78:	4630      	mov	r0, r6
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_FULL_BIT;
 8001a7a:	ea44 1445 	orr.w	r4, r4, r5, lsl #5
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001a7e:	2301      	movs	r3, #1
 8001a80:	2112      	movs	r1, #18
  tmp |= ((uint8_t)status) << LPS22HB_FIFO_FULL_BIT;
 8001a82:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001a86:	f005 fd23 	bl	80074d0 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 8001a8a:	3000      	adds	r0, #0
 8001a8c:	bf18      	it	ne
 8001a8e:	2001      	movne	r0, #1
}
 8001a90:	b002      	add	sp, #8
 8001a92:	bd70      	pop	{r4, r5, r6, pc}

08001a94 <LPS22HB_Get_DataStatus>:
* @param  *handle Device handle.
* @param  Data Status Flag:  TempDataAvailable, TempDataOverrun, PressDataAvailable, PressDataOverrun
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_DataStatus(void *handle, LPS22HB_DataStatus_st* datastatus)
{
 8001a94:	b510      	push	{r4, lr}
 8001a96:	b082      	sub	sp, #8
 8001a98:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001a9a:	2301      	movs	r3, #1
 8001a9c:	f10d 0207 	add.w	r2, sp, #7
 8001aa0:	2127      	movs	r1, #39	; 0x27
 8001aa2:	f005 fd63 	bl	800756c <Sensor_IO_Read>
 8001aa6:	b110      	cbz	r0, 8001aae <LPS22HB_Get_DataStatus+0x1a>
  uint8_t tmp;

  if(LPS22HB_ReadReg(handle, LPS22HB_STATUS_REG, 1, &tmp))
    return LPS22HB_ERROR;
 8001aa8:	2001      	movs	r0, #1
  datastatus->TempDataAvailable = (uint8_t)((tmp & LPS22HB_TDA_MASK) >> LPS22HB_PDA_BIT);
  datastatus->TempDataOverrun = (uint8_t)((tmp & LPS22HB_TOR_MASK) >> LPS22HB_TOR_BIT);
  datastatus->PressDataOverrun = (uint8_t)((tmp & LPS22HB_POR_MASK) >> LPS22HB_POR_BIT);

  return LPS22HB_OK;
}
 8001aaa:	b002      	add	sp, #8
 8001aac:	bd10      	pop	{r4, pc}
  datastatus->PressDataAvailable = (uint8_t)(tmp & LPS22HB_PDA_MASK);
 8001aae:	f89d 3007 	ldrb.w	r3, [sp, #7]
  datastatus->TempDataAvailable = (uint8_t)((tmp & LPS22HB_TDA_MASK) >> LPS22HB_PDA_BIT);
 8001ab2:	f003 0102 	and.w	r1, r3, #2
 8001ab6:	4602      	mov	r2, r0
 8001ab8:	f361 0207 	bfi	r2, r1, #0, #8
  datastatus->PressDataAvailable = (uint8_t)(tmp & LPS22HB_PDA_MASK);
 8001abc:	f003 0101 	and.w	r1, r3, #1
  datastatus->TempDataAvailable = (uint8_t)((tmp & LPS22HB_TDA_MASK) >> LPS22HB_PDA_BIT);
 8001ac0:	f361 220f 	bfi	r2, r1, #8, #8
  datastatus->TempDataOverrun = (uint8_t)((tmp & LPS22HB_TOR_MASK) >> LPS22HB_TOR_BIT);
 8001ac4:	f3c3 1140 	ubfx	r1, r3, #5, #1
  datastatus->TempDataAvailable = (uint8_t)((tmp & LPS22HB_TDA_MASK) >> LPS22HB_PDA_BIT);
 8001ac8:	f361 4217 	bfi	r2, r1, #16, #8
  datastatus->PressDataOverrun = (uint8_t)((tmp & LPS22HB_POR_MASK) >> LPS22HB_POR_BIT);
 8001acc:	f3c3 1300 	ubfx	r3, r3, #4, #1
  datastatus->TempDataAvailable = (uint8_t)((tmp & LPS22HB_TDA_MASK) >> LPS22HB_PDA_BIT);
 8001ad0:	f363 621f 	bfi	r2, r3, #24, #8
 8001ad4:	6022      	str	r2, [r4, #0]
}
 8001ad6:	b002      	add	sp, #8
 8001ad8:	bd10      	pop	{r4, pc}
 8001ada:	bf00      	nop

08001adc <LPS22HB_Get_Pressure>:
* @param  *handle Device handle.
* @param      The buffer to empty with the pressure value that must be divided by 100 to get the value in hPA
* @retval   Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_Pressure(void *handle, int32_t* Pout)
{
 8001adc:	b510      	push	{r4, lr}
 8001ade:	b082      	sub	sp, #8
 8001ae0:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001ae2:	2303      	movs	r3, #3
 8001ae4:	aa01      	add	r2, sp, #4
 8001ae6:	2128      	movs	r1, #40	; 0x28
 8001ae8:	f005 fd40 	bl	800756c <Sensor_IO_Read>
 8001aec:	b110      	cbz	r0, 8001af4 <LPS22HB_Get_Pressure+0x18>
  int32_t raw_press;

  if(LPS22HB_Get_RawPressure(handle, &raw_press))
    return LPS22HB_ERROR;
 8001aee:	2001      	movs	r0, #1

  *Pout = (raw_press * 100) / 4096;

  return LPS22HB_OK;
}
 8001af0:	b002      	add	sp, #8
 8001af2:	bd10      	pop	{r4, pc}
    tmp |= (((uint32_t)buffer[i]) << (8 * i));
 8001af4:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8001af8:	f89d 1005 	ldrb.w	r1, [sp, #5]
 8001afc:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8001b00:	041b      	lsls	r3, r3, #16
 8001b02:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8001b06:	4313      	orrs	r3, r2
  if(tmp & 0x00800000)
 8001b08:	021a      	lsls	r2, r3, #8
 8001b0a:	d501      	bpl.n	8001b10 <LPS22HB_Get_Pressure+0x34>
    tmp |= 0xFF000000;
 8001b0c:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
  *Pout = (raw_press * 100) / 4096;
 8001b10:	2264      	movs	r2, #100	; 0x64
 8001b12:	fb02 f303 	mul.w	r3, r2, r3
 8001b16:	2b00      	cmp	r3, #0
 8001b18:	bfb8      	it	lt
 8001b1a:	f603 73ff 	addwlt	r3, r3, #4095	; 0xfff
 8001b1e:	131b      	asrs	r3, r3, #12
  return LPS22HB_OK;
 8001b20:	2000      	movs	r0, #0
  *Pout = (raw_press * 100) / 4096;
 8001b22:	6023      	str	r3, [r4, #0]
}
 8001b24:	b002      	add	sp, #8
 8001b26:	bd10      	pop	{r4, pc}

08001b28 <LPS22HB_Get_Temperature>:
* @param  *handle Device handle.
* @param Buffer to empty with the temperature value that must be divided by 10 to get the value in C
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_Temperature(void *handle, int16_t* Tout)
{
 8001b28:	b510      	push	{r4, lr}
 8001b2a:	b082      	sub	sp, #8
 8001b2c:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001b2e:	2302      	movs	r3, #2
 8001b30:	aa01      	add	r2, sp, #4
 8001b32:	212b      	movs	r1, #43	; 0x2b
 8001b34:	f005 fd1a 	bl	800756c <Sensor_IO_Read>
 8001b38:	b110      	cbz	r0, 8001b40 <LPS22HB_Get_Temperature+0x18>
  int16_t raw_data;

  if(LPS22HB_Get_RawTemperature(handle, &raw_data))
    return LPS22HB_ERROR;
 8001b3a:	2001      	movs	r0, #1

  *Tout = (raw_data * 10) / 100;

  return LPS22HB_OK;
}
 8001b3c:	b002      	add	sp, #8
 8001b3e:	bd10      	pop	{r4, pc}
  tmp = (((uint16_t)buffer[1]) << 8) + (uint16_t)buffer[0];
 8001b40:	f89d 1005 	ldrb.w	r1, [sp, #5]
 8001b44:	f89d 3004 	ldrb.w	r3, [sp, #4]
  *Tout = (raw_data * 10) / 100;
 8001b48:	4a05      	ldr	r2, [pc, #20]	; (8001b60 <LPS22HB_Get_Temperature+0x38>)
  tmp = (((uint16_t)buffer[1]) << 8) + (uint16_t)buffer[0];
 8001b4a:	eb03 2301 	add.w	r3, r3, r1, lsl #8
  *raw_data = ((int16_t)tmp);
 8001b4e:	b21b      	sxth	r3, r3
  *Tout = (raw_data * 10) / 100;
 8001b50:	fb82 1203 	smull	r1, r2, r2, r3
 8001b54:	17db      	asrs	r3, r3, #31
 8001b56:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 8001b5a:	8023      	strh	r3, [r4, #0]
}
 8001b5c:	b002      	add	sp, #8
 8001b5e:	bd10      	pop	{r4, pc}
 8001b60:	66666667 	.word	0x66666667

08001b64 <LPS22HB_Set_FifoMode>:
* @param  *handle Device handle.
* @param  Fifo Mode struct
* @retval Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FifoMode(void *handle, LPS22HB_FifoMode_et fifomode)
{
 8001b64:	b530      	push	{r4, r5, lr}
 8001b66:	b083      	sub	sp, #12
 8001b68:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001b6a:	f10d 0207 	add.w	r2, sp, #7
 8001b6e:	2301      	movs	r3, #1
 8001b70:	2114      	movs	r1, #20
{
 8001b72:	4605      	mov	r5, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001b74:	f005 fcfa 	bl	800756c <Sensor_IO_Read>
 8001b78:	b110      	cbz	r0, 8001b80 <LPS22HB_Set_FifoMode+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_FifoMode(fifomode));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_FIFO_REG, 1, &tmp))
    return LPS22HB_ERROR;
 8001b7a:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_FIFO_REG, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 8001b7c:	b003      	add	sp, #12
 8001b7e:	bd30      	pop	{r4, r5, pc}
  tmp &= ~LPS22HB_FIFO_MODE_MASK;
 8001b80:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001b84:	f003 031f 	and.w	r3, r3, #31
  tmp |= (uint8_t)fifomode;
 8001b88:	431c      	orrs	r4, r3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001b8a:	f10d 0207 	add.w	r2, sp, #7
 8001b8e:	4628      	mov	r0, r5
 8001b90:	2301      	movs	r3, #1
 8001b92:	2114      	movs	r1, #20
  tmp |= (uint8_t)fifomode;
 8001b94:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001b98:	f005 fc9a 	bl	80074d0 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 8001b9c:	3000      	adds	r0, #0
 8001b9e:	bf18      	it	ne
 8001ba0:	2001      	movne	r0, #1
}
 8001ba2:	b003      	add	sp, #12
 8001ba4:	bd30      	pop	{r4, r5, pc}
 8001ba6:	bf00      	nop

08001ba8 <LPS22HB_Get_FifoMode>:
* @param  *handle Device handle.
* @param   buffer to empty with fifo mode tmp
* @retval   Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_FifoMode(void *handle, LPS22HB_FifoMode_et* fifomode)
{
 8001ba8:	b510      	push	{r4, lr}
 8001baa:	b082      	sub	sp, #8
 8001bac:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001bae:	2301      	movs	r3, #1
 8001bb0:	f10d 0207 	add.w	r2, sp, #7
 8001bb4:	2114      	movs	r1, #20
 8001bb6:	f005 fcd9 	bl	800756c <Sensor_IO_Read>
 8001bba:	b110      	cbz	r0, 8001bc2 <LPS22HB_Get_FifoMode+0x1a>
  uint8_t tmp;

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_FIFO_REG, 1, &tmp))
    return LPS22HB_ERROR;
 8001bbc:	2001      	movs	r0, #1

  tmp &= LPS22HB_FIFO_MODE_MASK;
  *fifomode = (LPS22HB_FifoMode_et)tmp;

  return LPS22HB_OK;
}
 8001bbe:	b002      	add	sp, #8
 8001bc0:	bd10      	pop	{r4, pc}
  tmp &= LPS22HB_FIFO_MODE_MASK;
 8001bc2:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001bc6:	f023 031f 	bic.w	r3, r3, #31
  *fifomode = (LPS22HB_FifoMode_et)tmp;
 8001bca:	7023      	strb	r3, [r4, #0]
}
 8001bcc:	b002      	add	sp, #8
 8001bce:	bd10      	pop	{r4, pc}

08001bd0 <LPS22HB_Set_FifoWatermarkLevel>:
* @param  *handle Device handle.
* @param    Watermark level value [0 31]
* @retval   Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Set_FifoWatermarkLevel(void *handle, uint8_t wtmlevel)
{
 8001bd0:	b530      	push	{r4, r5, lr}
 8001bd2:	b083      	sub	sp, #12
 8001bd4:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001bd6:	f10d 0207 	add.w	r2, sp, #7
 8001bda:	2301      	movs	r3, #1
 8001bdc:	2114      	movs	r1, #20
{
 8001bde:	4605      	mov	r5, r0
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001be0:	f005 fcc4 	bl	800756c <Sensor_IO_Read>
 8001be4:	b110      	cbz	r0, 8001bec <LPS22HB_Set_FifoWatermarkLevel+0x1c>
  uint8_t tmp;

  LPS22HB_assert_param(IS_LPS22HB_WtmLevel(wtmlevel));

  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_FIFO_REG, 1, &tmp))
    return LPS22HB_ERROR;
 8001be6:	2001      	movs	r0, #1

  if(LPS22HB_WriteReg(handle, LPS22HB_CTRL_FIFO_REG, 1, &tmp))
    return LPS22HB_ERROR;

  return LPS22HB_OK;
}
 8001be8:	b003      	add	sp, #12
 8001bea:	bd30      	pop	{r4, r5, pc}
  tmp &= ~LPS22HB_WTM_POINT_MASK;
 8001bec:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001bf0:	f023 031f 	bic.w	r3, r3, #31
  tmp |= wtmlevel;
 8001bf4:	431c      	orrs	r4, r3
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001bf6:	f10d 0207 	add.w	r2, sp, #7
 8001bfa:	4628      	mov	r0, r5
 8001bfc:	2301      	movs	r3, #1
 8001bfe:	2114      	movs	r1, #20
  tmp |= wtmlevel;
 8001c00:	f88d 4007 	strb.w	r4, [sp, #7]
  if ( Sensor_IO_Write( handle, RegAddr, Data, NumByteToWrite ) )
 8001c04:	f005 fc64 	bl	80074d0 <Sensor_IO_Write>
    return LPS22HB_ERROR;
 8001c08:	3000      	adds	r0, #0
 8001c0a:	bf18      	it	ne
 8001c0c:	2001      	movne	r0, #1
}
 8001c0e:	b003      	add	sp, #12
 8001c10:	bd30      	pop	{r4, r5, pc}
 8001c12:	bf00      	nop

08001c14 <LPS22HB_Get_FifoWatermarkLevel>:
* @param  *handle Device handle.
* @param   buffer to empty with watermak level[0,31] value read from sensor
* @retval  Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_FifoWatermarkLevel(void *handle, uint8_t *wtmlevel)
{
 8001c14:	b510      	push	{r4, lr}
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001c16:	460a      	mov	r2, r1
{
 8001c18:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001c1a:	2301      	movs	r3, #1
 8001c1c:	2114      	movs	r1, #20
 8001c1e:	f005 fca5 	bl	800756c <Sensor_IO_Read>
 8001c22:	b108      	cbz	r0, 8001c28 <LPS22HB_Get_FifoWatermarkLevel+0x14>
  if(LPS22HB_ReadReg(handle, LPS22HB_CTRL_FIFO_REG, 1, wtmlevel))
    return LPS22HB_ERROR;
 8001c24:	2001      	movs	r0, #1
 8001c26:	bd10      	pop	{r4, pc}

  *wtmlevel &= LPS22HB_WTM_POINT_MASK;
 8001c28:	7823      	ldrb	r3, [r4, #0]
 8001c2a:	f003 031f 	and.w	r3, r3, #31
 8001c2e:	7023      	strb	r3, [r4, #0]

  return LPS22HB_OK;
}
 8001c30:	bd10      	pop	{r4, pc}
 8001c32:	bf00      	nop

08001c34 <LPS22HB_Get_FifoStatus>:
* @param  *handle Device handle.
* @param    Status Flag: FIFO_FTH,FIFO_EMPTY,FIFO_FULL,FIFO_OVR and level of the FIFO->FIFO_LEVEL
* @retval   Error Code [LPS22HB_ERROR, LPS22HB_OK]
*/
LPS22HB_Error_et LPS22HB_Get_FifoStatus(void *handle, LPS22HB_FifoStatus_st* status)
{
 8001c34:	b510      	push	{r4, lr}
 8001c36:	b082      	sub	sp, #8
 8001c38:	460c      	mov	r4, r1
  if ( Sensor_IO_Read( handle, RegAddr, Data, NumByteToRead ) )
 8001c3a:	2301      	movs	r3, #1
 8001c3c:	f10d 0207 	add.w	r2, sp, #7
 8001c40:	2126      	movs	r1, #38	; 0x26
 8001c42:	f005 fc93 	bl	800756c <Sensor_IO_Read>
 8001c46:	b110      	cbz	r0, 8001c4e <LPS22HB_Get_FifoStatus+0x1a>
  uint8_t tmp;

  if(LPS22HB_ReadReg(handle, LPS22HB_STATUS_FIFO_REG, 1, &tmp))
    return LPS22HB_ERROR;
 8001c48:	2001      	movs	r0, #1
  else
    status->FIFO_FULL = 0x00;


  return LPS22HB_OK;
}
 8001c4a:	b002      	add	sp, #8
 8001c4c:	bd10      	pop	{r4, pc}
  status->FIFO_FTH = (uint8_t)((tmp & LPS22HB_FTH_FIFO_MASK) >> LPS22HB_FTH_FIFO_BIT);
 8001c4e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001c52:	09d9      	lsrs	r1, r3, #7
  status->FIFO_OVR = (uint8_t)((tmp & LPS22HB_OVR_FIFO_MASK) >> LPS22HB_OVR_FIFO_BIT);
 8001c54:	f3c3 1280 	ubfx	r2, r3, #6, #1
  status->FIFO_LEVEL = (uint8_t)(tmp & LPS22HB_LEVEL_FIFO_MASK);
 8001c58:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  status->FIFO_FTH = (uint8_t)((tmp & LPS22HB_FTH_FIFO_MASK) >> LPS22HB_FTH_FIFO_BIT);
 8001c5c:	7121      	strb	r1, [r4, #4]
  status->FIFO_OVR = (uint8_t)((tmp & LPS22HB_OVR_FIFO_MASK) >> LPS22HB_OVR_FIFO_BIT);
 8001c5e:	70e2      	strb	r2, [r4, #3]
  status->FIFO_LEVEL = (uint8_t)(tmp & LPS22HB_LEVEL_FIFO_MASK);
 8001c60:	7023      	strb	r3, [r4, #0]
  if(status->FIFO_LEVEL == LPS22HB_FIFO_EMPTY)
 8001c62:	b92b      	cbnz	r3, 8001c70 <LPS22HB_Get_FifoStatus+0x3c>
    status->FIFO_EMPTY = 0x01;
 8001c64:	2301      	movs	r3, #1
 8001c66:	7063      	strb	r3, [r4, #1]
    status->FIFO_FULL = 0x00;
 8001c68:	2000      	movs	r0, #0
 8001c6a:	70a0      	strb	r0, [r4, #2]
}
 8001c6c:	b002      	add	sp, #8
 8001c6e:	bd10      	pop	{r4, pc}
  if (status->FIFO_LEVEL == LPS22HB_FIFO_FULL)
 8001c70:	2b20      	cmp	r3, #32
    status->FIFO_EMPTY = 0x00;
 8001c72:	7060      	strb	r0, [r4, #1]
  if (status->FIFO_LEVEL == LPS22HB_FIFO_FULL)
 8001c74:	d1f8      	bne.n	8001c68 <LPS22HB_Get_FifoStatus+0x34>
    status->FIFO_FULL = 0x01;
 8001c76:	2301      	movs	r3, #1
 8001c78:	70a3      	strb	r3, [r4, #2]
}
 8001c7a:	b002      	add	sp, #8
 8001c7c:	bd10      	pop	{r4, pc}
 8001c7e:	bf00      	nop

08001c80 <LPS22HB_P_Get_DRDY_Status>:
 * @param status the data ready status
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_P_Get_DRDY_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 8001c80:	b510      	push	{r4, lr}
 8001c82:	b082      	sub	sp, #8
 8001c84:	460c      	mov	r4, r1

  LPS22HB_DataStatus_st status_raw;

  if ( LPS22HB_Get_DataStatus( (void *)handle, &status_raw ) == LPS22HB_ERROR )
 8001c86:	a901      	add	r1, sp, #4
 8001c88:	f7ff ff04 	bl	8001a94 <LPS22HB_Get_DataStatus>
 8001c8c:	2801      	cmp	r0, #1
 8001c8e:	d003      	beq.n	8001c98 <LPS22HB_P_Get_DRDY_Status+0x18>
  {
    return COMPONENT_ERROR;
  }

  *status = status_raw.PressDataAvailable;
 8001c90:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8001c94:	7023      	strb	r3, [r4, #0]

  return COMPONENT_OK;
 8001c96:	2000      	movs	r0, #0
}
 8001c98:	b002      	add	sp, #8
 8001c9a:	bd10      	pop	{r4, pc}

08001c9c <LPS22HB_T_Get_DRDY_Status>:
 * @param status the data ready status
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_T_Get_DRDY_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 8001c9c:	b510      	push	{r4, lr}
 8001c9e:	b082      	sub	sp, #8
 8001ca0:	460c      	mov	r4, r1

  LPS22HB_DataStatus_st status_raw;

  if ( LPS22HB_Get_DataStatus( (void *)handle, &status_raw ) == LPS22HB_ERROR )
 8001ca2:	a901      	add	r1, sp, #4
 8001ca4:	f7ff fef6 	bl	8001a94 <LPS22HB_Get_DataStatus>
 8001ca8:	2801      	cmp	r0, #1
 8001caa:	d003      	beq.n	8001cb4 <LPS22HB_T_Get_DRDY_Status+0x18>
  {
    return COMPONENT_ERROR;
  }

  *status = status_raw.TempDataAvailable;
 8001cac:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8001cb0:	7023      	strb	r3, [r4, #0]

  return COMPONENT_OK;
 8001cb2:	2000      	movs	r0, #0
}
 8001cb4:	b002      	add	sp, #8
 8001cb6:	bd10      	pop	{r4, pc}

08001cb8 <LPS22HB_T_Write_Reg>:
{
 8001cb8:	b500      	push	{lr}
 8001cba:	b083      	sub	sp, #12
 8001cbc:	ab02      	add	r3, sp, #8
 8001cbe:	f803 2d01 	strb.w	r2, [r3, #-1]!
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LPS22HB_Write_Reg( DrvContextTypeDef *handle, uint8_t reg, uint8_t data )
{

  if ( LPS22HB_WriteReg( (void *)handle, reg, 1, &data ) == LPS22HB_ERROR )
 8001cc2:	2201      	movs	r2, #1
 8001cc4:	f7ff fd4a 	bl	800175c <LPS22HB_WriteReg>
}
 8001cc8:	f1a0 0001 	sub.w	r0, r0, #1
 8001ccc:	fab0 f080 	clz	r0, r0
 8001cd0:	0940      	lsrs	r0, r0, #5
 8001cd2:	b003      	add	sp, #12
 8001cd4:	f85d fb04 	ldr.w	pc, [sp], #4

08001cd8 <LPS22HB_T_Read_Reg>:
{
 8001cd8:	b508      	push	{r3, lr}
  if ( LPS22HB_ReadReg( (void *)handle, reg, 1, data ) == LPS22HB_ERROR )
 8001cda:	4613      	mov	r3, r2
 8001cdc:	2201      	movs	r2, #1
 8001cde:	f7ff fd33 	bl	8001748 <LPS22HB_ReadReg>
}
 8001ce2:	f1a0 0001 	sub.w	r0, r0, #1
 8001ce6:	fab0 f080 	clz	r0, r0
 8001cea:	0940      	lsrs	r0, r0, #5
 8001cec:	bd08      	pop	{r3, pc}
 8001cee:	bf00      	nop

08001cf0 <LPS22HB_P_Sensor_Disable>:
{
 8001cf0:	b538      	push	{r3, r4, r5, lr}
  if ( handle->isEnabled == 0 )
 8001cf2:	7983      	ldrb	r3, [r0, #6]
 8001cf4:	b153      	cbz	r3, 8001d0c <LPS22HB_P_Sensor_Disable+0x1c>
                                       handle->pData))->pComponentData))->comboData;
 8001cf6:	6883      	ldr	r3, [r0, #8]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 8001cf8:	681b      	ldr	r3, [r3, #0]
 8001cfa:	681d      	ldr	r5, [r3, #0]
  if(comboData->isTempEnabled == 0)
 8001cfc:	78e9      	ldrb	r1, [r5, #3]
 8001cfe:	4604      	mov	r4, r0
 8001d00:	b131      	cbz	r1, 8001d10 <LPS22HB_P_Sensor_Disable+0x20>
  comboData->isPressEnabled = 0;
 8001d02:	2300      	movs	r3, #0
 8001d04:	70ab      	strb	r3, [r5, #2]
  handle->isEnabled = 0;
 8001d06:	71a3      	strb	r3, [r4, #6]
  return COMPONENT_OK;
 8001d08:	4618      	mov	r0, r3
 8001d0a:	bd38      	pop	{r3, r4, r5, pc}
    return COMPONENT_OK;
 8001d0c:	4618      	mov	r0, r3
}
 8001d0e:	bd38      	pop	{r3, r4, r5, pc}
    if ( LPS22HB_Set_Odr( (void *)handle, LPS22HB_ODR_ONE_SHOT ) == LPS22HB_ERROR )
 8001d10:	f7ff fd5a 	bl	80017c8 <LPS22HB_Set_Odr>
 8001d14:	2801      	cmp	r0, #1
 8001d16:	d1f4      	bne.n	8001d02 <LPS22HB_P_Sensor_Disable+0x12>
 8001d18:	bd38      	pop	{r3, r4, r5, pc}
 8001d1a:	bf00      	nop

08001d1c <LPS22HB_T_Sensor_Disable>:
{
 8001d1c:	b538      	push	{r3, r4, r5, lr}
  if ( handle->isEnabled == 0 )
 8001d1e:	7983      	ldrb	r3, [r0, #6]
 8001d20:	b153      	cbz	r3, 8001d38 <LPS22HB_T_Sensor_Disable+0x1c>
                                       handle->pData))->pComponentData))->comboData;
 8001d22:	6883      	ldr	r3, [r0, #8]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 8001d24:	681b      	ldr	r3, [r3, #0]
 8001d26:	681d      	ldr	r5, [r3, #0]
  if(comboData->isPressEnabled == 0)
 8001d28:	78a9      	ldrb	r1, [r5, #2]
 8001d2a:	4604      	mov	r4, r0
 8001d2c:	b131      	cbz	r1, 8001d3c <LPS22HB_T_Sensor_Disable+0x20>
  comboData->isTempEnabled = 0;
 8001d2e:	2300      	movs	r3, #0
 8001d30:	70eb      	strb	r3, [r5, #3]
  handle->isEnabled = 0;
 8001d32:	71a3      	strb	r3, [r4, #6]
  return COMPONENT_OK;
 8001d34:	4618      	mov	r0, r3
 8001d36:	bd38      	pop	{r3, r4, r5, pc}
    return COMPONENT_OK;
 8001d38:	4618      	mov	r0, r3
}
 8001d3a:	bd38      	pop	{r3, r4, r5, pc}
    if ( LPS22HB_Set_Odr( (void *)handle, LPS22HB_ODR_ONE_SHOT ) == LPS22HB_ERROR )
 8001d3c:	f7ff fd44 	bl	80017c8 <LPS22HB_Set_Odr>
 8001d40:	2801      	cmp	r0, #1
 8001d42:	d1f4      	bne.n	8001d2e <LPS22HB_T_Sensor_Disable+0x12>
 8001d44:	bd38      	pop	{r3, r4, r5, pc}
 8001d46:	bf00      	nop

08001d48 <LPS22HB_P_Get_Press>:
{
 8001d48:	b530      	push	{r4, r5, lr}
 8001d4a:	b083      	sub	sp, #12
  int32_t int32data = 0;
 8001d4c:	ab02      	add	r3, sp, #8
 8001d4e:	2400      	movs	r4, #0
 8001d50:	f843 4d04 	str.w	r4, [r3, #-4]!
{
 8001d54:	460d      	mov	r5, r1
  if ( LPS22HB_Get_Pressure( (void *)handle, &int32data ) == LPS22HB_ERROR )
 8001d56:	4619      	mov	r1, r3
 8001d58:	f7ff fec0 	bl	8001adc <LPS22HB_Get_Pressure>
 8001d5c:	2801      	cmp	r0, #1
 8001d5e:	d00a      	beq.n	8001d76 <LPS22HB_P_Get_Press+0x2e>
  *pressure = ( float )int32data / 100.0f;
 8001d60:	eddd 7a01 	vldr	s15, [sp, #4]
 8001d64:	eddf 6a05 	vldr	s13, [pc, #20]	; 8001d7c <LPS22HB_P_Get_Press+0x34>
 8001d68:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  return COMPONENT_OK;
 8001d6c:	4620      	mov	r0, r4
  *pressure = ( float )int32data / 100.0f;
 8001d6e:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8001d72:	ed85 7a00 	vstr	s14, [r5]
}
 8001d76:	b003      	add	sp, #12
 8001d78:	bd30      	pop	{r4, r5, pc}
 8001d7a:	bf00      	nop
 8001d7c:	42c80000 	.word	0x42c80000

08001d80 <LPS22HB_T_Get_WhoAmI>:
{
 8001d80:	b508      	push	{r3, lr}
  if ( LPS22HB_Get_DeviceID( (void *)handle, who_am_i ) == LPS22HB_ERROR )
 8001d82:	f7ff fcf5 	bl	8001770 <LPS22HB_Get_DeviceID>
}
 8001d86:	f1a0 0001 	sub.w	r0, r0, #1
 8001d8a:	fab0 f080 	clz	r0, r0
 8001d8e:	0940      	lsrs	r0, r0, #5
 8001d90:	bd08      	pop	{r3, pc}
 8001d92:	bf00      	nop

08001d94 <LPS22HB_T_Get_Temp>:
{
 8001d94:	b530      	push	{r4, r5, lr}
 8001d96:	b083      	sub	sp, #12
  int16_t int16data = 0;
 8001d98:	ab02      	add	r3, sp, #8
 8001d9a:	2400      	movs	r4, #0
 8001d9c:	f823 4d02 	strh.w	r4, [r3, #-2]!
{
 8001da0:	460d      	mov	r5, r1
  if ( LPS22HB_Get_Temperature( (void *)handle, &int16data ) == LPS22HB_ERROR )
 8001da2:	4619      	mov	r1, r3
 8001da4:	f7ff fec0 	bl	8001b28 <LPS22HB_Get_Temperature>
 8001da8:	2801      	cmp	r0, #1
 8001daa:	d00c      	beq.n	8001dc6 <LPS22HB_T_Get_Temp+0x32>
  *temperature = ( float )int16data / 10.0f;
 8001dac:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 8001db0:	ee07 3a90 	vmov	s15, r3
 8001db4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001db8:	eef2 6a04 	vmov.f32	s13, #36	; 0x41200000  10.0
 8001dbc:	ee87 7aa6 	vdiv.f32	s14, s15, s13
  return COMPONENT_OK;
 8001dc0:	4620      	mov	r0, r4
  *temperature = ( float )int16data / 10.0f;
 8001dc2:	ed85 7a00 	vstr	s14, [r5]
}
 8001dc6:	b003      	add	sp, #12
 8001dc8:	bd30      	pop	{r4, r5, pc}
 8001dca:	bf00      	nop

08001dcc <LPS22HB_FIFO_Set_Watermark_Level>:
 * @param watermark The FIFO watermark level to be set; values: from 0 to 31
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Set_Watermark_Level( DrvContextTypeDef *handle, uint8_t watermark )
{
 8001dcc:	b508      	push	{r3, lr}

  if ( LPS22HB_Set_FifoWatermarkLevel( handle, watermark ) == LPS22HB_ERROR )
 8001dce:	f7ff feff 	bl	8001bd0 <LPS22HB_Set_FifoWatermarkLevel>
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8001dd2:	f1a0 0001 	sub.w	r0, r0, #1
 8001dd6:	fab0 f080 	clz	r0, r0
 8001dda:	0940      	lsrs	r0, r0, #5
 8001ddc:	bd08      	pop	{r3, pc}
 8001dde:	bf00      	nop

08001de0 <LPS22HB_FIFO_Get_Watermark_Level>:
{
 8001de0:	b508      	push	{r3, lr}
  if ( LPS22HB_Get_FifoWatermarkLevel( handle, watermark ) == LPS22HB_ERROR )
 8001de2:	f7ff ff17 	bl	8001c14 <LPS22HB_Get_FifoWatermarkLevel>
}
 8001de6:	f1a0 0001 	sub.w	r0, r0, #1
 8001dea:	fab0 f080 	clz	r0, r0
 8001dee:	0940      	lsrs	r0, r0, #5
 8001df0:	bd08      	pop	{r3, pc}
 8001df2:	bf00      	nop

08001df4 <LPS22HB_FIFO_Get_Mode>:
{
 8001df4:	b510      	push	{r4, lr}
 8001df6:	b082      	sub	sp, #8
 8001df8:	460c      	mov	r4, r1
  if ( LPS22HB_Get_FifoMode( handle, &mode_raw ) == LPS22HB_ERROR )
 8001dfa:	f10d 0107 	add.w	r1, sp, #7
 8001dfe:	f7ff fed3 	bl	8001ba8 <LPS22HB_Get_FifoMode>
 8001e02:	2801      	cmp	r0, #1
 8001e04:	d003      	beq.n	8001e0e <LPS22HB_FIFO_Get_Mode+0x1a>
  *mode = ( uint8_t )mode_raw;
 8001e06:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001e0a:	7023      	strb	r3, [r4, #0]
  return COMPONENT_OK;
 8001e0c:	2000      	movs	r0, #0
}
 8001e0e:	b002      	add	sp, #8
 8001e10:	bd10      	pop	{r4, pc}
 8001e12:	bf00      	nop

08001e14 <LPS22HB_FIFO_Get_Num_Of_Samples>:
{
 8001e14:	b510      	push	{r4, lr}
 8001e16:	b082      	sub	sp, #8
 8001e18:	460c      	mov	r4, r1
  if ( LPS22HB_Get_FifoStatus( handle, &status_raw ) == LPS22HB_ERROR )
 8001e1a:	4669      	mov	r1, sp
 8001e1c:	f7ff ff0a 	bl	8001c34 <LPS22HB_Get_FifoStatus>
 8001e20:	2801      	cmp	r0, #1
 8001e22:	d003      	beq.n	8001e2c <LPS22HB_FIFO_Get_Num_Of_Samples+0x18>
  *nSamples = status_raw.FIFO_LEVEL;
 8001e24:	f89d 3000 	ldrb.w	r3, [sp]
 8001e28:	7023      	strb	r3, [r4, #0]
  return COMPONENT_OK;
 8001e2a:	2000      	movs	r0, #0
}
 8001e2c:	b002      	add	sp, #8
 8001e2e:	bd10      	pop	{r4, pc}

08001e30 <LPS22HB_FIFO_Get_Fth_Status>:
{
 8001e30:	b510      	push	{r4, lr}
 8001e32:	b082      	sub	sp, #8
 8001e34:	460c      	mov	r4, r1
  if ( LPS22HB_Get_FifoStatus( handle, &status_raw ) == LPS22HB_ERROR )
 8001e36:	4669      	mov	r1, sp
 8001e38:	f7ff fefc 	bl	8001c34 <LPS22HB_Get_FifoStatus>
 8001e3c:	2801      	cmp	r0, #1
 8001e3e:	d003      	beq.n	8001e48 <LPS22HB_FIFO_Get_Fth_Status+0x18>
  *status = status_raw.FIFO_FTH;
 8001e40:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8001e44:	7023      	strb	r3, [r4, #0]
  return COMPONENT_OK;
 8001e46:	2000      	movs	r0, #0
}
 8001e48:	b002      	add	sp, #8
 8001e4a:	bd10      	pop	{r4, pc}

08001e4c <LPS22HB_FIFO_Get_Ovr_Status>:
{
 8001e4c:	b510      	push	{r4, lr}
 8001e4e:	b082      	sub	sp, #8
 8001e50:	460c      	mov	r4, r1
  if ( LPS22HB_Get_FifoStatus( handle, &status_raw ) == LPS22HB_ERROR )
 8001e52:	4669      	mov	r1, sp
 8001e54:	f7ff feee 	bl	8001c34 <LPS22HB_Get_FifoStatus>
 8001e58:	2801      	cmp	r0, #1
 8001e5a:	d003      	beq.n	8001e64 <LPS22HB_FIFO_Get_Ovr_Status+0x18>
  *status = status_raw.FIFO_OVR;
 8001e5c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001e60:	7023      	strb	r3, [r4, #0]
  return COMPONENT_OK;
 8001e62:	2000      	movs	r0, #0
}
 8001e64:	b002      	add	sp, #8
 8001e66:	bd10      	pop	{r4, pc}

08001e68 <LPS22HB_FIFO_Get_Full_Status>:
{
 8001e68:	b510      	push	{r4, lr}
 8001e6a:	b082      	sub	sp, #8
 8001e6c:	460c      	mov	r4, r1
  if ( LPS22HB_Get_FifoStatus( handle, &status_raw ) == LPS22HB_ERROR )
 8001e6e:	4669      	mov	r1, sp
 8001e70:	f7ff fee0 	bl	8001c34 <LPS22HB_Get_FifoStatus>
 8001e74:	2801      	cmp	r0, #1
 8001e76:	d003      	beq.n	8001e80 <LPS22HB_FIFO_Get_Full_Status+0x18>
  *status = status_raw.FIFO_FULL;
 8001e78:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8001e7c:	7023      	strb	r3, [r4, #0]
  return COMPONENT_OK;
 8001e7e:	2000      	movs	r0, #0
}
 8001e80:	b002      	add	sp, #8
 8001e82:	bd10      	pop	{r4, pc}

08001e84 <LPS22HB_FIFO_Get_Empty_Status>:
{
 8001e84:	b510      	push	{r4, lr}
 8001e86:	b082      	sub	sp, #8
 8001e88:	460c      	mov	r4, r1
  if ( LPS22HB_Get_FifoStatus( handle, &status_raw ) == LPS22HB_ERROR )
 8001e8a:	4669      	mov	r1, sp
 8001e8c:	f7ff fed2 	bl	8001c34 <LPS22HB_Get_FifoStatus>
 8001e90:	2801      	cmp	r0, #1
 8001e92:	d003      	beq.n	8001e9c <LPS22HB_FIFO_Get_Empty_Status+0x18>
  *status = status_raw.FIFO_EMPTY;
 8001e94:	f89d 3001 	ldrb.w	r3, [sp, #1]
 8001e98:	7023      	strb	r3, [r4, #0]
  return COMPONENT_OK;
 8001e9a:	2000      	movs	r0, #0
}
 8001e9c:	b002      	add	sp, #8
 8001e9e:	bd10      	pop	{r4, pc}

08001ea0 <LPS22HB_P_Set_ODR>:
{
 8001ea0:	b530      	push	{r4, r5, lr}
                                       handle->pData))->pComponentData))->comboData;
 8001ea2:	6882      	ldr	r2, [r0, #8]
  if(handle->isEnabled == 1)
 8001ea4:	7983      	ldrb	r3, [r0, #6]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 8001ea6:	6812      	ldr	r2, [r2, #0]
  if(handle->isEnabled == 1)
 8001ea8:	2b01      	cmp	r3, #1
{
 8001eaa:	b083      	sub	sp, #12
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 8001eac:	6815      	ldr	r5, [r2, #0]
  if(handle->isEnabled == 1)
 8001eae:	d020      	beq.n	8001ef2 <LPS22HB_P_Set_ODR+0x52>
  switch( odr )
 8001eb0:	2904      	cmp	r1, #4
 8001eb2:	d83f      	bhi.n	8001f34 <LPS22HB_P_Set_ODR+0x94>
 8001eb4:	e8df f001 	tbb	[pc, r1]
 8001eb8:	18130e08 	.word	0x18130e08
 8001ebc:	03          	.byte	0x03
 8001ebd:	00          	.byte	0x00
      combo->Last_ODR = 75.0f;
 8001ebe:	4b2e      	ldr	r3, [pc, #184]	; (8001f78 <LPS22HB_P_Set_ODR+0xd8>)
 8001ec0:	606b      	str	r3, [r5, #4]
  return COMPONENT_OK;
 8001ec2:	2000      	movs	r0, #0
}
 8001ec4:	b003      	add	sp, #12
 8001ec6:	bd30      	pop	{r4, r5, pc}
      combo->Last_ODR = 1.0f;
 8001ec8:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
  return COMPONENT_OK;
 8001ecc:	2000      	movs	r0, #0
      combo->Last_ODR = 1.0f;
 8001ece:	606b      	str	r3, [r5, #4]
}
 8001ed0:	b003      	add	sp, #12
 8001ed2:	bd30      	pop	{r4, r5, pc}
      combo->Last_ODR = 10.0f;
 8001ed4:	4b29      	ldr	r3, [pc, #164]	; (8001f7c <LPS22HB_P_Set_ODR+0xdc>)
 8001ed6:	606b      	str	r3, [r5, #4]
  return COMPONENT_OK;
 8001ed8:	2000      	movs	r0, #0
}
 8001eda:	b003      	add	sp, #12
 8001edc:	bd30      	pop	{r4, r5, pc}
      combo->Last_ODR = 25.0f;
 8001ede:	4b28      	ldr	r3, [pc, #160]	; (8001f80 <LPS22HB_P_Set_ODR+0xe0>)
 8001ee0:	606b      	str	r3, [r5, #4]
  return COMPONENT_OK;
 8001ee2:	2000      	movs	r0, #0
}
 8001ee4:	b003      	add	sp, #12
 8001ee6:	bd30      	pop	{r4, r5, pc}
      combo->Last_ODR = 50.0f;
 8001ee8:	4b26      	ldr	r3, [pc, #152]	; (8001f84 <LPS22HB_P_Set_ODR+0xe4>)
 8001eea:	606b      	str	r3, [r5, #4]
  return COMPONENT_OK;
 8001eec:	2000      	movs	r0, #0
}
 8001eee:	b003      	add	sp, #12
 8001ef0:	bd30      	pop	{r4, r5, pc}
  switch( odr )
 8001ef2:	2904      	cmp	r1, #4
 8001ef4:	d81e      	bhi.n	8001f34 <LPS22HB_P_Set_ODR+0x94>
 8001ef6:	e8df f001 	tbb	[pc, r1]
 8001efa:	031f      	.short	0x031f
 8001efc:	2325      	.short	0x2325
 8001efe:	21          	.byte	0x21
 8001eff:	00          	.byte	0x00
      new_odr = LPS22HB_ODR_10HZ;
 8001f00:	2120      	movs	r1, #32
 8001f02:	4604      	mov	r4, r0
  if ( LPS22HB_Set_Odr( (void *)handle, new_odr ) == LPS22HB_ERROR )
 8001f04:	f7ff fc60 	bl	80017c8 <LPS22HB_Set_Odr>
 8001f08:	2801      	cmp	r0, #1
 8001f0a:	d0db      	beq.n	8001ec4 <LPS22HB_P_Set_ODR+0x24>
  if ( LPS22HB_Get_Odr( (void *)handle, &odr_low_level ) == LPS22HB_ERROR )
 8001f0c:	4620      	mov	r0, r4
 8001f0e:	f10d 0107 	add.w	r1, sp, #7
 8001f12:	f7ff fc7b 	bl	800180c <LPS22HB_Get_Odr>
 8001f16:	2801      	cmp	r0, #1
 8001f18:	d00c      	beq.n	8001f34 <LPS22HB_P_Set_ODR+0x94>
  switch( odr_low_level )
 8001f1a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001f1e:	2b20      	cmp	r3, #32
 8001f20:	d01a      	beq.n	8001f58 <LPS22HB_P_Set_ODR+0xb8>
 8001f22:	d911      	bls.n	8001f48 <LPS22HB_P_Set_ODR+0xa8>
 8001f24:	2b40      	cmp	r3, #64	; 0x40
 8001f26:	d020      	beq.n	8001f6a <LPS22HB_P_Set_ODR+0xca>
 8001f28:	2b50      	cmp	r3, #80	; 0x50
 8001f2a:	d01b      	beq.n	8001f64 <LPS22HB_P_Set_ODR+0xc4>
 8001f2c:	2b30      	cmp	r3, #48	; 0x30
 8001f2e:	d016      	beq.n	8001f5e <LPS22HB_P_Set_ODR+0xbe>
      *odr = -1.0f;
 8001f30:	4b15      	ldr	r3, [pc, #84]	; (8001f88 <LPS22HB_P_Set_ODR+0xe8>)
 8001f32:	606b      	str	r3, [r5, #4]
    return COMPONENT_ERROR;
 8001f34:	2001      	movs	r0, #1
 8001f36:	e7c5      	b.n	8001ec4 <LPS22HB_P_Set_ODR+0x24>
      new_odr = LPS22HB_ODR_1HZ;
 8001f38:	2110      	movs	r1, #16
 8001f3a:	e7e2      	b.n	8001f02 <LPS22HB_P_Set_ODR+0x62>
      new_odr = LPS22HB_ODR_75HZ;
 8001f3c:	2150      	movs	r1, #80	; 0x50
 8001f3e:	e7e0      	b.n	8001f02 <LPS22HB_P_Set_ODR+0x62>
      new_odr = LPS22HB_ODR_50HZ;
 8001f40:	2140      	movs	r1, #64	; 0x40
 8001f42:	e7de      	b.n	8001f02 <LPS22HB_P_Set_ODR+0x62>
      new_odr = LPS22HB_ODR_25HZ;
 8001f44:	2130      	movs	r1, #48	; 0x30
 8001f46:	e7dc      	b.n	8001f02 <LPS22HB_P_Set_ODR+0x62>
  switch( odr_low_level )
 8001f48:	b193      	cbz	r3, 8001f70 <LPS22HB_P_Set_ODR+0xd0>
 8001f4a:	2b10      	cmp	r3, #16
 8001f4c:	d1f0      	bne.n	8001f30 <LPS22HB_P_Set_ODR+0x90>
      *odr = 1.0f;
 8001f4e:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8001f52:	606b      	str	r3, [r5, #4]
  return COMPONENT_OK;
 8001f54:	2000      	movs	r0, #0
 8001f56:	e7b5      	b.n	8001ec4 <LPS22HB_P_Set_ODR+0x24>
      *odr = 10.0f;
 8001f58:	4b08      	ldr	r3, [pc, #32]	; (8001f7c <LPS22HB_P_Set_ODR+0xdc>)
 8001f5a:	606b      	str	r3, [r5, #4]
 8001f5c:	e7fa      	b.n	8001f54 <LPS22HB_P_Set_ODR+0xb4>
      *odr = 25.0f;
 8001f5e:	4b08      	ldr	r3, [pc, #32]	; (8001f80 <LPS22HB_P_Set_ODR+0xe0>)
 8001f60:	606b      	str	r3, [r5, #4]
 8001f62:	e7f7      	b.n	8001f54 <LPS22HB_P_Set_ODR+0xb4>
      *odr = 75.0f;
 8001f64:	4b04      	ldr	r3, [pc, #16]	; (8001f78 <LPS22HB_P_Set_ODR+0xd8>)
 8001f66:	606b      	str	r3, [r5, #4]
 8001f68:	e7f4      	b.n	8001f54 <LPS22HB_P_Set_ODR+0xb4>
      *odr = 50.0f;
 8001f6a:	4b06      	ldr	r3, [pc, #24]	; (8001f84 <LPS22HB_P_Set_ODR+0xe4>)
 8001f6c:	606b      	str	r3, [r5, #4]
 8001f6e:	e7f1      	b.n	8001f54 <LPS22HB_P_Set_ODR+0xb4>
      *odr = 0.0f;
 8001f70:	2300      	movs	r3, #0
 8001f72:	606b      	str	r3, [r5, #4]
 8001f74:	e7ee      	b.n	8001f54 <LPS22HB_P_Set_ODR+0xb4>
 8001f76:	bf00      	nop
 8001f78:	42960000 	.word	0x42960000
 8001f7c:	41200000 	.word	0x41200000
 8001f80:	41c80000 	.word	0x41c80000
 8001f84:	42480000 	.word	0x42480000
 8001f88:	bf800000 	.word	0xbf800000

08001f8c <LPS22HB_T_Init>:
                                       handle->pData))->pComponentData))->comboData;
 8001f8c:	6883      	ldr	r3, [r0, #8]
{
 8001f8e:	b570      	push	{r4, r5, r6, lr}
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 8001f90:	681b      	ldr	r3, [r3, #0]
 8001f92:	681d      	ldr	r5, [r3, #0]
  if(comboData->isPressInitialized == 0)
 8001f94:	782e      	ldrb	r6, [r5, #0]
{
 8001f96:	b082      	sub	sp, #8
 8001f98:	4604      	mov	r4, r0
  if(comboData->isPressInitialized == 0)
 8001f9a:	b12e      	cbz	r6, 8001fa8 <LPS22HB_T_Init+0x1c>
  comboData->isTempInitialized = 1;
 8001f9c:	2301      	movs	r3, #1
  return COMPONENT_OK;
 8001f9e:	2000      	movs	r0, #0
  comboData->isTempInitialized = 1;
 8001fa0:	706b      	strb	r3, [r5, #1]
  handle->isInitialized = 1;
 8001fa2:	7163      	strb	r3, [r4, #5]
}
 8001fa4:	b002      	add	sp, #8
 8001fa6:	bd70      	pop	{r4, r5, r6, pc}
  uint8_t who_am_i = 0x00;
 8001fa8:	a902      	add	r1, sp, #8
 8001faa:	f801 6d01 	strb.w	r6, [r1, #-1]!
  if ( LPS22HB_Get_DeviceID( (void *)handle, who_am_i ) == LPS22HB_ERROR )
 8001fae:	f7ff fbdf 	bl	8001770 <LPS22HB_Get_DeviceID>
 8001fb2:	2801      	cmp	r0, #1
 8001fb4:	d004      	beq.n	8001fc0 <LPS22HB_T_Init+0x34>
  if ( who_am_i != handle->who_am_i )
 8001fb6:	7822      	ldrb	r2, [r4, #0]
 8001fb8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001fbc:	429a      	cmp	r2, r3
 8001fbe:	d002      	beq.n	8001fc6 <LPS22HB_T_Init+0x3a>
      return COMPONENT_ERROR;
 8001fc0:	2001      	movs	r0, #1
}
 8001fc2:	b002      	add	sp, #8
 8001fc4:	bd70      	pop	{r4, r5, r6, pc}
  combo->Last_ODR = 25.0f;
 8001fc6:	4b15      	ldr	r3, [pc, #84]	; (800201c <LPS22HB_T_Init+0x90>)
 8001fc8:	606b      	str	r3, [r5, #4]
  if ( LPS22HB_Set_PowerMode( (void *)handle, LPS22HB_LowPower) == LPS22HB_ERROR )
 8001fca:	2101      	movs	r1, #1
 8001fcc:	4620      	mov	r0, r4
 8001fce:	f7ff fbd9 	bl	8001784 <LPS22HB_Set_PowerMode>
 8001fd2:	2801      	cmp	r0, #1
 8001fd4:	d0f4      	beq.n	8001fc0 <LPS22HB_T_Init+0x34>
  if ( LPS22HB_Set_Odr( (void *)handle, LPS22HB_ODR_ONE_SHOT ) == LPS22HB_ERROR )
 8001fd6:	4631      	mov	r1, r6
 8001fd8:	4620      	mov	r0, r4
 8001fda:	f7ff fbf5 	bl	80017c8 <LPS22HB_Set_Odr>
 8001fde:	2801      	cmp	r0, #1
 8001fe0:	d0ee      	beq.n	8001fc0 <LPS22HB_T_Init+0x34>
  if( LPS22HB_Set_LowPassFilter( (void *)handle, LPS22HB_DISABLE) == LPS22HB_ERROR )
 8001fe2:	4631      	mov	r1, r6
 8001fe4:	4620      	mov	r0, r4
 8001fe6:	f7ff fc25 	bl	8001834 <LPS22HB_Set_LowPassFilter>
 8001fea:	2801      	cmp	r0, #1
 8001fec:	d0e8      	beq.n	8001fc0 <LPS22HB_T_Init+0x34>
  if( LPS22HB_Set_LowPassFilterCutoff( (void *)handle, LPS22HB_ODR_9) == LPS22HB_ERROR )
 8001fee:	4631      	mov	r1, r6
 8001ff0:	4620      	mov	r0, r4
 8001ff2:	f7ff fc41 	bl	8001878 <LPS22HB_Set_LowPassFilterCutoff>
 8001ff6:	2801      	cmp	r0, #1
 8001ff8:	d0e2      	beq.n	8001fc0 <LPS22HB_T_Init+0x34>
  if ( LPS22HB_Set_Bdu( (void *)handle, LPS22HB_BDU_NO_UPDATE ) == LPS22HB_ERROR )
 8001ffa:	2102      	movs	r1, #2
 8001ffc:	4620      	mov	r0, r4
 8001ffe:	f7ff fc5d 	bl	80018bc <LPS22HB_Set_Bdu>
 8002002:	2801      	cmp	r0, #1
 8002004:	d0dc      	beq.n	8001fc0 <LPS22HB_T_Init+0x34>
  if(handle->ifType == 0) // I2C mode
 8002006:	7861      	ldrb	r1, [r4, #1]
 8002008:	b109      	cbz	r1, 800200e <LPS22HB_T_Init+0x82>
    if(handle->ifType == 1) // SPI mode
 800200a:	2901      	cmp	r1, #1
 800200c:	d1c6      	bne.n	8001f9c <LPS22HB_T_Init+0x10>
      if( LPS22HB_Set_AutomaticIncrementRegAddress( (void *)handle, LPS22HB_ENABLE) == LPS22HB_ERROR )
 800200e:	4620      	mov	r0, r4
 8002010:	f7ff fcb8 	bl	8001984 <LPS22HB_Set_AutomaticIncrementRegAddress>
 8002014:	2801      	cmp	r0, #1
 8002016:	d1c1      	bne.n	8001f9c <LPS22HB_T_Init+0x10>
 8002018:	e7d2      	b.n	8001fc0 <LPS22HB_T_Init+0x34>
 800201a:	bf00      	nop
 800201c:	41c80000 	.word	0x41c80000

08002020 <LPS22HB_FIFO_Get_Data>:
{
 8002020:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002024:	b082      	sub	sp, #8
  int32_t int32data = 0;
 8002026:	ad02      	add	r5, sp, #8
 8002028:	2400      	movs	r4, #0
 800202a:	f845 4d04 	str.w	r4, [r5, #-4]!
{
 800202e:	460e      	mov	r6, r1
  if ( LPS22HB_Get_Pressure( (void *)handle, &int32data ) == LPS22HB_ERROR )
 8002030:	4629      	mov	r1, r5
{
 8002032:	4617      	mov	r7, r2
 8002034:	4680      	mov	r8, r0
  if ( LPS22HB_Get_Pressure( (void *)handle, &int32data ) == LPS22HB_ERROR )
 8002036:	f7ff fd51 	bl	8001adc <LPS22HB_Get_Pressure>
 800203a:	2801      	cmp	r0, #1
 800203c:	d01e      	beq.n	800207c <LPS22HB_FIFO_Get_Data+0x5c>
  *pressure = ( float )int32data / 100.0f;
 800203e:	eddd 7a01 	vldr	s15, [sp, #4]
 8002042:	eddf 6a10 	vldr	s13, [pc, #64]	; 8002084 <LPS22HB_FIFO_Get_Data+0x64>
  int16_t int16data = 0;
 8002046:	f8ad 4004 	strh.w	r4, [sp, #4]
  *pressure = ( float )int32data / 100.0f;
 800204a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  if ( LPS22HB_Get_Temperature( (void *)handle, &int16data ) == LPS22HB_ERROR )
 800204e:	4629      	mov	r1, r5
  *pressure = ( float )int32data / 100.0f;
 8002050:	ee87 7aa6 	vdiv.f32	s14, s15, s13
  if ( LPS22HB_Get_Temperature( (void *)handle, &int16data ) == LPS22HB_ERROR )
 8002054:	4640      	mov	r0, r8
  *pressure = ( float )int32data / 100.0f;
 8002056:	ed86 7a00 	vstr	s14, [r6]
  if ( LPS22HB_Get_Temperature( (void *)handle, &int16data ) == LPS22HB_ERROR )
 800205a:	f7ff fd65 	bl	8001b28 <LPS22HB_Get_Temperature>
 800205e:	2801      	cmp	r0, #1
 8002060:	d00c      	beq.n	800207c <LPS22HB_FIFO_Get_Data+0x5c>
  *temperature = ( float )int16data / 10.0f;
 8002062:	f9bd 3004 	ldrsh.w	r3, [sp, #4]
 8002066:	ee07 3a90 	vmov	s15, r3
 800206a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800206e:	eef2 6a04 	vmov.f32	s13, #36	; 0x41200000  10.0
 8002072:	ee87 7aa6 	vdiv.f32	s14, s15, s13
  return COMPONENT_OK;
 8002076:	4620      	mov	r0, r4
  *temperature = ( float )int16data / 10.0f;
 8002078:	ed87 7a00 	vstr	s14, [r7]
}
 800207c:	b002      	add	sp, #8
 800207e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002082:	bf00      	nop
 8002084:	42c80000 	.word	0x42c80000

08002088 <LPS22HB_FIFO_Reset_Interrupt>:
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LPS22HB_FIFO_Reset_Interrupt( DrvContextTypeDef *handle, uint8_t interrupt )
{

  switch( interrupt )
 8002088:	2901      	cmp	r1, #1
{
 800208a:	b508      	push	{r3, lr}
  switch( interrupt )
 800208c:	d016      	beq.n	80020bc <LPS22HB_FIFO_Reset_Interrupt+0x34>
 800208e:	d30c      	bcc.n	80020aa <LPS22HB_FIFO_Reset_Interrupt+0x22>
 8002090:	2902      	cmp	r1, #2
 8002092:	d108      	bne.n	80020a6 <LPS22HB_FIFO_Reset_Interrupt+0x1e>
      {
        return COMPONENT_ERROR;
      }
      break;
    case 2:
      if ( LPS22HB_Set_FIFO_OVR_Interrupt( handle, LPS22HB_DISABLE ) == LPS22HB_ERROR )
 8002094:	2100      	movs	r1, #0
 8002096:	f7ff fc97 	bl	80019c8 <LPS22HB_Set_FIFO_OVR_Interrupt>
      break;
    default:
      return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
 800209a:	f1a0 0001 	sub.w	r0, r0, #1
 800209e:	fab0 f080 	clz	r0, r0
 80020a2:	0940      	lsrs	r0, r0, #5
 80020a4:	bd08      	pop	{r3, pc}
      return COMPONENT_ERROR;
 80020a6:	2001      	movs	r0, #1
}
 80020a8:	bd08      	pop	{r3, pc}
      if ( LPS22HB_Set_FIFO_FTH_Interrupt( handle, LPS22HB_DISABLE ) == LPS22HB_ERROR )
 80020aa:	2100      	movs	r1, #0
 80020ac:	f7ff fcae 	bl	8001a0c <LPS22HB_Set_FIFO_FTH_Interrupt>
        return COMPONENT_ERROR;
 80020b0:	f1a0 0001 	sub.w	r0, r0, #1
 80020b4:	fab0 f080 	clz	r0, r0
 80020b8:	0940      	lsrs	r0, r0, #5
 80020ba:	bd08      	pop	{r3, pc}
      if ( LPS22HB_Set_FIFO_FULL_Interrupt( handle, LPS22HB_DISABLE ) == LPS22HB_ERROR )
 80020bc:	2100      	movs	r1, #0
 80020be:	f7ff fcc7 	bl	8001a50 <LPS22HB_Set_FIFO_FULL_Interrupt>
        return COMPONENT_ERROR;
 80020c2:	f1a0 0001 	sub.w	r0, r0, #1
 80020c6:	fab0 f080 	clz	r0, r0
 80020ca:	0940      	lsrs	r0, r0, #5
 80020cc:	bd08      	pop	{r3, pc}
 80020ce:	bf00      	nop

080020d0 <LPS22HB_FIFO_Set_Interrupt>:
  switch( interrupt )
 80020d0:	2901      	cmp	r1, #1
{
 80020d2:	b508      	push	{r3, lr}
  switch( interrupt )
 80020d4:	d016      	beq.n	8002104 <LPS22HB_FIFO_Set_Interrupt+0x34>
 80020d6:	d30c      	bcc.n	80020f2 <LPS22HB_FIFO_Set_Interrupt+0x22>
 80020d8:	2902      	cmp	r1, #2
 80020da:	d108      	bne.n	80020ee <LPS22HB_FIFO_Set_Interrupt+0x1e>
      if ( LPS22HB_Set_FIFO_OVR_Interrupt( handle, LPS22HB_ENABLE ) == LPS22HB_ERROR )
 80020dc:	2101      	movs	r1, #1
 80020de:	f7ff fc73 	bl	80019c8 <LPS22HB_Set_FIFO_OVR_Interrupt>
  return COMPONENT_OK;
 80020e2:	f1a0 0001 	sub.w	r0, r0, #1
 80020e6:	fab0 f080 	clz	r0, r0
 80020ea:	0940      	lsrs	r0, r0, #5
 80020ec:	bd08      	pop	{r3, pc}
      return COMPONENT_ERROR;
 80020ee:	2001      	movs	r0, #1
}
 80020f0:	bd08      	pop	{r3, pc}
      if ( LPS22HB_Set_FIFO_FTH_Interrupt( handle, LPS22HB_ENABLE ) == LPS22HB_ERROR )
 80020f2:	2101      	movs	r1, #1
 80020f4:	f7ff fc8a 	bl	8001a0c <LPS22HB_Set_FIFO_FTH_Interrupt>
        return COMPONENT_ERROR;
 80020f8:	f1a0 0001 	sub.w	r0, r0, #1
 80020fc:	fab0 f080 	clz	r0, r0
 8002100:	0940      	lsrs	r0, r0, #5
 8002102:	bd08      	pop	{r3, pc}
      if ( LPS22HB_Set_FIFO_FULL_Interrupt( handle, LPS22HB_ENABLE ) == LPS22HB_ERROR )
 8002104:	f7ff fca4 	bl	8001a50 <LPS22HB_Set_FIFO_FULL_Interrupt>
        return COMPONENT_ERROR;
 8002108:	f1a0 0001 	sub.w	r0, r0, #1
 800210c:	fab0 f080 	clz	r0, r0
 8002110:	0940      	lsrs	r0, r0, #5
 8002112:	bd08      	pop	{r3, pc}

08002114 <LPS22HB_FIFO_Watermark_Usage>:
  switch ( ( LPS22HB_State_et )usage )
 8002114:	2901      	cmp	r1, #1
 8002116:	d901      	bls.n	800211c <LPS22HB_FIFO_Watermark_Usage+0x8>
      return COMPONENT_ERROR;
 8002118:	2001      	movs	r0, #1
 800211a:	4770      	bx	lr
{
 800211c:	b508      	push	{r3, lr}
  if ( LPS22HB_Set_FifoWatermarkLevelUse( handle, ( LPS22HB_State_et )status ) == LPS22HB_ERROR )
 800211e:	f7ff fc0f 	bl	8001940 <LPS22HB_Set_FifoWatermarkLevelUse>
      return COMPONENT_ERROR;
 8002122:	f1a0 0001 	sub.w	r0, r0, #1
 8002126:	fab0 f080 	clz	r0, r0
 800212a:	0940      	lsrs	r0, r0, #5
 800212c:	bd08      	pop	{r3, pc}
 800212e:	bf00      	nop

08002130 <LPS22HB_FIFO_Set_Mode>:
  switch ( ( LPS22HB_FifoMode_et )mode )
 8002130:	2940      	cmp	r1, #64	; 0x40
 8002132:	d00b      	beq.n	800214c <LPS22HB_FIFO_Set_Mode+0x1c>
 8002134:	d907      	bls.n	8002146 <LPS22HB_FIFO_Set_Mode+0x16>
 8002136:	2980      	cmp	r1, #128	; 0x80
 8002138:	d008      	beq.n	800214c <LPS22HB_FIFO_Set_Mode+0x1c>
 800213a:	29e0      	cmp	r1, #224	; 0xe0
 800213c:	d006      	beq.n	800214c <LPS22HB_FIFO_Set_Mode+0x1c>
 800213e:	2960      	cmp	r1, #96	; 0x60
 8002140:	d004      	beq.n	800214c <LPS22HB_FIFO_Set_Mode+0x1c>
      return COMPONENT_ERROR;
 8002142:	2001      	movs	r0, #1
 8002144:	4770      	bx	lr
  switch ( ( LPS22HB_FifoMode_et )mode )
 8002146:	b109      	cbz	r1, 800214c <LPS22HB_FIFO_Set_Mode+0x1c>
 8002148:	2920      	cmp	r1, #32
 800214a:	d1fa      	bne.n	8002142 <LPS22HB_FIFO_Set_Mode+0x12>
{
 800214c:	b508      	push	{r3, lr}
  if ( LPS22HB_Set_FifoMode( handle, ( LPS22HB_FifoMode_et )mode ) == LPS22HB_ERROR )
 800214e:	f7ff fd09 	bl	8001b64 <LPS22HB_Set_FifoMode>
      return COMPONENT_ERROR;
 8002152:	f1a0 0001 	sub.w	r0, r0, #1
 8002156:	fab0 f080 	clz	r0, r0
 800215a:	0940      	lsrs	r0, r0, #5
 800215c:	bd08      	pop	{r3, pc}
 800215e:	bf00      	nop

08002160 <LPS22HB_FIFO_Usage>:
  switch ( ( LPS22HB_State_et )status )
 8002160:	2901      	cmp	r1, #1
 8002162:	d901      	bls.n	8002168 <LPS22HB_FIFO_Usage+0x8>
      return COMPONENT_ERROR;
 8002164:	2001      	movs	r0, #1
 8002166:	4770      	bx	lr
{
 8002168:	b508      	push	{r3, lr}
  if ( LPS22HB_Set_FifoModeUse( handle, ( LPS22HB_State_et )status ) == LPS22HB_ERROR )
 800216a:	f7ff fbc7 	bl	80018fc <LPS22HB_Set_FifoModeUse>
      return COMPONENT_ERROR;
 800216e:	f1a0 0001 	sub.w	r0, r0, #1
 8002172:	fab0 f080 	clz	r0, r0
 8002176:	0940      	lsrs	r0, r0, #5
 8002178:	bd08      	pop	{r3, pc}
 800217a:	bf00      	nop

0800217c <LPS22HB_FIFO_Stop_On_Fth>:
  switch ( ( LPS22HB_State_et )status )
 800217c:	2901      	cmp	r1, #1
 800217e:	d901      	bls.n	8002184 <LPS22HB_FIFO_Stop_On_Fth+0x8>
      return COMPONENT_ERROR;
 8002180:	2001      	movs	r0, #1
 8002182:	4770      	bx	lr
{
 8002184:	b508      	push	{r3, lr}
  if ( LPS22HB_Set_FifoWatermarkLevelUse( handle, ( LPS22HB_State_et )status ) == LPS22HB_ERROR )
 8002186:	f7ff fbdb 	bl	8001940 <LPS22HB_Set_FifoWatermarkLevelUse>
      return COMPONENT_ERROR;
 800218a:	f1a0 0001 	sub.w	r0, r0, #1
 800218e:	fab0 f080 	clz	r0, r0
 8002192:	0940      	lsrs	r0, r0, #5
 8002194:	bd08      	pop	{r3, pc}
 8002196:	bf00      	nop

08002198 <LPS22HB_P_Get_WhoAmI>:
 8002198:	b508      	push	{r3, lr}
 800219a:	f7ff fae9 	bl	8001770 <LPS22HB_Get_DeviceID>
 800219e:	f1a0 0001 	sub.w	r0, r0, #1
 80021a2:	fab0 f080 	clz	r0, r0
 80021a6:	0940      	lsrs	r0, r0, #5
 80021a8:	bd08      	pop	{r3, pc}
 80021aa:	bf00      	nop

080021ac <LPS22HB_P_Read_Reg>:
 80021ac:	b508      	push	{r3, lr}
 80021ae:	4613      	mov	r3, r2
 80021b0:	2201      	movs	r2, #1
 80021b2:	f7ff fac9 	bl	8001748 <LPS22HB_ReadReg>
 80021b6:	f1a0 0001 	sub.w	r0, r0, #1
 80021ba:	fab0 f080 	clz	r0, r0
 80021be:	0940      	lsrs	r0, r0, #5
 80021c0:	bd08      	pop	{r3, pc}
 80021c2:	bf00      	nop

080021c4 <LPS22HB_T_Check_WhoAmI>:
{
 80021c4:	b510      	push	{r4, lr}
 80021c6:	b082      	sub	sp, #8
  uint8_t who_am_i = 0x00;
 80021c8:	a902      	add	r1, sp, #8
 80021ca:	2300      	movs	r3, #0
 80021cc:	f801 3d01 	strb.w	r3, [r1, #-1]!
{
 80021d0:	4604      	mov	r4, r0
  if ( LPS22HB_Get_DeviceID( (void *)handle, who_am_i ) == LPS22HB_ERROR )
 80021d2:	f7ff facd 	bl	8001770 <LPS22HB_Get_DeviceID>
 80021d6:	2801      	cmp	r0, #1
 80021d8:	d005      	beq.n	80021e6 <LPS22HB_T_Check_WhoAmI+0x22>
  if ( who_am_i != handle->who_am_i )
 80021da:	7820      	ldrb	r0, [r4, #0]
 80021dc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80021e0:	1ac0      	subs	r0, r0, r3
 80021e2:	bf18      	it	ne
 80021e4:	2001      	movne	r0, #1
}
 80021e6:	b002      	add	sp, #8
 80021e8:	bd10      	pop	{r4, pc}
 80021ea:	bf00      	nop

080021ec <LPS22HB_P_Check_WhoAmI>:
 80021ec:	b510      	push	{r4, lr}
 80021ee:	b082      	sub	sp, #8
 80021f0:	a902      	add	r1, sp, #8
 80021f2:	2300      	movs	r3, #0
 80021f4:	f801 3d01 	strb.w	r3, [r1, #-1]!
 80021f8:	4604      	mov	r4, r0
 80021fa:	f7ff fab9 	bl	8001770 <LPS22HB_Get_DeviceID>
 80021fe:	2801      	cmp	r0, #1
 8002200:	d005      	beq.n	800220e <LPS22HB_P_Check_WhoAmI+0x22>
 8002202:	7820      	ldrb	r0, [r4, #0]
 8002204:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8002208:	1ac0      	subs	r0, r0, r3
 800220a:	bf18      	it	ne
 800220c:	2001      	movne	r0, #1
 800220e:	b002      	add	sp, #8
 8002210:	bd10      	pop	{r4, pc}
 8002212:	bf00      	nop

08002214 <LPS22HB_P_Write_Reg>:
 8002214:	b500      	push	{lr}
 8002216:	b083      	sub	sp, #12
 8002218:	ab02      	add	r3, sp, #8
 800221a:	f803 2d01 	strb.w	r2, [r3, #-1]!
 800221e:	2201      	movs	r2, #1
 8002220:	f7ff fa9c 	bl	800175c <LPS22HB_WriteReg>
 8002224:	f1a0 0001 	sub.w	r0, r0, #1
 8002228:	fab0 f080 	clz	r0, r0
 800222c:	0940      	lsrs	r0, r0, #5
 800222e:	b003      	add	sp, #12
 8002230:	f85d fb04 	ldr.w	pc, [sp], #4

08002234 <LPS22HB_T_DeInit>:
{
 8002234:	b538      	push	{r3, r4, r5, lr}
                                       handle->pData))->pComponentData))->comboData;
 8002236:	6883      	ldr	r3, [r0, #8]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 8002238:	681b      	ldr	r3, [r3, #0]
 800223a:	681d      	ldr	r5, [r3, #0]
  if(comboData->isPressInitialized == 0)
 800223c:	782b      	ldrb	r3, [r5, #0]
{
 800223e:	4604      	mov	r4, r0
  if(comboData->isPressInitialized == 0)
 8002240:	b123      	cbz	r3, 800224c <LPS22HB_T_DeInit+0x18>
  comboData->isTempInitialized = 0;
 8002242:	2300      	movs	r3, #0
 8002244:	706b      	strb	r3, [r5, #1]
  handle->isInitialized = 0;
 8002246:	7163      	strb	r3, [r4, #5]
  return COMPONENT_OK;
 8002248:	4618      	mov	r0, r3
}
 800224a:	bd38      	pop	{r3, r4, r5, pc}
  if ( handle->isEnabled == 0 )
 800224c:	7983      	ldrb	r3, [r0, #6]
 800224e:	2b00      	cmp	r3, #0
 8002250:	d0f7      	beq.n	8002242 <LPS22HB_T_DeInit+0xe>
  if(comboData->isPressEnabled == 0)
 8002252:	78a9      	ldrb	r1, [r5, #2]
 8002254:	b139      	cbz	r1, 8002266 <LPS22HB_T_DeInit+0x32>
  comboData->isTempEnabled = 0;
 8002256:	2300      	movs	r3, #0
 8002258:	70eb      	strb	r3, [r5, #3]
  handle->isEnabled = 0;
 800225a:	71a3      	strb	r3, [r4, #6]
  comboData->isTempInitialized = 0;
 800225c:	2300      	movs	r3, #0
 800225e:	706b      	strb	r3, [r5, #1]
  handle->isInitialized = 0;
 8002260:	7163      	strb	r3, [r4, #5]
  return COMPONENT_OK;
 8002262:	4618      	mov	r0, r3
}
 8002264:	bd38      	pop	{r3, r4, r5, pc}
    if ( LPS22HB_Set_Odr( (void *)handle, LPS22HB_ODR_ONE_SHOT ) == LPS22HB_ERROR )
 8002266:	f7ff faaf 	bl	80017c8 <LPS22HB_Set_Odr>
 800226a:	2801      	cmp	r0, #1
 800226c:	d1f3      	bne.n	8002256 <LPS22HB_T_DeInit+0x22>
 800226e:	bd38      	pop	{r3, r4, r5, pc}

08002270 <LPS22HB_P_DeInit>:
{
 8002270:	b538      	push	{r3, r4, r5, lr}
                                       handle->pData))->pComponentData))->comboData;
 8002272:	6883      	ldr	r3, [r0, #8]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 8002274:	681b      	ldr	r3, [r3, #0]
 8002276:	681d      	ldr	r5, [r3, #0]
  if(comboData->isTempInitialized == 0)
 8002278:	786b      	ldrb	r3, [r5, #1]
{
 800227a:	4604      	mov	r4, r0
  if(comboData->isTempInitialized == 0)
 800227c:	b123      	cbz	r3, 8002288 <LPS22HB_P_DeInit+0x18>
  comboData->isPressInitialized = 0;
 800227e:	2300      	movs	r3, #0
 8002280:	702b      	strb	r3, [r5, #0]
  handle->isInitialized = 0;
 8002282:	7163      	strb	r3, [r4, #5]
  return COMPONENT_OK;
 8002284:	4618      	mov	r0, r3
}
 8002286:	bd38      	pop	{r3, r4, r5, pc}
  if ( handle->isEnabled == 0 )
 8002288:	7983      	ldrb	r3, [r0, #6]
 800228a:	2b00      	cmp	r3, #0
 800228c:	d0f7      	beq.n	800227e <LPS22HB_P_DeInit+0xe>
  if(comboData->isTempEnabled == 0)
 800228e:	78e9      	ldrb	r1, [r5, #3]
 8002290:	b139      	cbz	r1, 80022a2 <LPS22HB_P_DeInit+0x32>
  comboData->isPressEnabled = 0;
 8002292:	2300      	movs	r3, #0
 8002294:	70ab      	strb	r3, [r5, #2]
  handle->isEnabled = 0;
 8002296:	71a3      	strb	r3, [r4, #6]
  comboData->isPressInitialized = 0;
 8002298:	2300      	movs	r3, #0
 800229a:	702b      	strb	r3, [r5, #0]
  handle->isInitialized = 0;
 800229c:	7163      	strb	r3, [r4, #5]
  return COMPONENT_OK;
 800229e:	4618      	mov	r0, r3
}
 80022a0:	bd38      	pop	{r3, r4, r5, pc}
    if ( LPS22HB_Set_Odr( (void *)handle, LPS22HB_ODR_ONE_SHOT ) == LPS22HB_ERROR )
 80022a2:	f7ff fa91 	bl	80017c8 <LPS22HB_Set_Odr>
 80022a6:	2801      	cmp	r0, #1
 80022a8:	d1f3      	bne.n	8002292 <LPS22HB_P_DeInit+0x22>
 80022aa:	bd38      	pop	{r3, r4, r5, pc}

080022ac <LPS22HB_T_Get_ODR>:
{
 80022ac:	b510      	push	{r4, lr}
 80022ae:	b082      	sub	sp, #8
 80022b0:	460c      	mov	r4, r1
  if ( LPS22HB_Get_Odr( (void *)handle, &odr_low_level ) == LPS22HB_ERROR )
 80022b2:	f10d 0107 	add.w	r1, sp, #7
 80022b6:	f7ff faa9 	bl	800180c <LPS22HB_Get_Odr>
 80022ba:	2801      	cmp	r0, #1
 80022bc:	d00d      	beq.n	80022da <LPS22HB_T_Get_ODR+0x2e>
  switch( odr_low_level )
 80022be:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80022c2:	2820      	cmp	r0, #32
 80022c4:	d027      	beq.n	8002316 <LPS22HB_T_Get_ODR+0x6a>
 80022c6:	d90a      	bls.n	80022de <LPS22HB_T_Get_ODR+0x32>
 80022c8:	2840      	cmp	r0, #64	; 0x40
 80022ca:	d01f      	beq.n	800230c <LPS22HB_T_Get_ODR+0x60>
 80022cc:	2850      	cmp	r0, #80	; 0x50
 80022ce:	d013      	beq.n	80022f8 <LPS22HB_T_Get_ODR+0x4c>
 80022d0:	2830      	cmp	r0, #48	; 0x30
 80022d2:	d016      	beq.n	8002302 <LPS22HB_T_Get_ODR+0x56>
      *odr = -1.0f;
 80022d4:	4b12      	ldr	r3, [pc, #72]	; (8002320 <LPS22HB_T_Get_ODR+0x74>)
 80022d6:	6023      	str	r3, [r4, #0]
      return COMPONENT_ERROR;
 80022d8:	2001      	movs	r0, #1
}
 80022da:	b002      	add	sp, #8
 80022dc:	bd10      	pop	{r4, pc}
  switch( odr_low_level )
 80022de:	b138      	cbz	r0, 80022f0 <LPS22HB_T_Get_ODR+0x44>
 80022e0:	2810      	cmp	r0, #16
 80022e2:	d1f7      	bne.n	80022d4 <LPS22HB_T_Get_ODR+0x28>
      *odr = 1.0f;
 80022e4:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
  return COMPONENT_OK;
 80022e8:	2000      	movs	r0, #0
      *odr = 1.0f;
 80022ea:	6023      	str	r3, [r4, #0]
}
 80022ec:	b002      	add	sp, #8
 80022ee:	bd10      	pop	{r4, pc}
      *odr = 0.0f;
 80022f0:	2300      	movs	r3, #0
 80022f2:	6023      	str	r3, [r4, #0]
}
 80022f4:	b002      	add	sp, #8
 80022f6:	bd10      	pop	{r4, pc}
      *odr = 75.0f;
 80022f8:	4b0a      	ldr	r3, [pc, #40]	; (8002324 <LPS22HB_T_Get_ODR+0x78>)
 80022fa:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80022fc:	2000      	movs	r0, #0
}
 80022fe:	b002      	add	sp, #8
 8002300:	bd10      	pop	{r4, pc}
      *odr = 25.0f;
 8002302:	4b09      	ldr	r3, [pc, #36]	; (8002328 <LPS22HB_T_Get_ODR+0x7c>)
 8002304:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8002306:	2000      	movs	r0, #0
}
 8002308:	b002      	add	sp, #8
 800230a:	bd10      	pop	{r4, pc}
      *odr = 50.0f;
 800230c:	4b07      	ldr	r3, [pc, #28]	; (800232c <LPS22HB_T_Get_ODR+0x80>)
 800230e:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8002310:	2000      	movs	r0, #0
}
 8002312:	b002      	add	sp, #8
 8002314:	bd10      	pop	{r4, pc}
      *odr = 10.0f;
 8002316:	4b06      	ldr	r3, [pc, #24]	; (8002330 <LPS22HB_T_Get_ODR+0x84>)
 8002318:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800231a:	2000      	movs	r0, #0
}
 800231c:	b002      	add	sp, #8
 800231e:	bd10      	pop	{r4, pc}
 8002320:	bf800000 	.word	0xbf800000
 8002324:	42960000 	.word	0x42960000
 8002328:	41c80000 	.word	0x41c80000
 800232c:	42480000 	.word	0x42480000
 8002330:	41200000 	.word	0x41200000

08002334 <LPS22HB_P_Get_ODR>:
 8002334:	b510      	push	{r4, lr}
 8002336:	b082      	sub	sp, #8
 8002338:	460c      	mov	r4, r1
 800233a:	f10d 0107 	add.w	r1, sp, #7
 800233e:	f7ff fa65 	bl	800180c <LPS22HB_Get_Odr>
 8002342:	2801      	cmp	r0, #1
 8002344:	d00d      	beq.n	8002362 <LPS22HB_P_Get_ODR+0x2e>
 8002346:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800234a:	2820      	cmp	r0, #32
 800234c:	d027      	beq.n	800239e <LPS22HB_P_Get_ODR+0x6a>
 800234e:	d90a      	bls.n	8002366 <LPS22HB_P_Get_ODR+0x32>
 8002350:	2840      	cmp	r0, #64	; 0x40
 8002352:	d01f      	beq.n	8002394 <LPS22HB_P_Get_ODR+0x60>
 8002354:	2850      	cmp	r0, #80	; 0x50
 8002356:	d013      	beq.n	8002380 <LPS22HB_P_Get_ODR+0x4c>
 8002358:	2830      	cmp	r0, #48	; 0x30
 800235a:	d016      	beq.n	800238a <LPS22HB_P_Get_ODR+0x56>
 800235c:	4b12      	ldr	r3, [pc, #72]	; (80023a8 <LPS22HB_P_Get_ODR+0x74>)
 800235e:	6023      	str	r3, [r4, #0]
 8002360:	2001      	movs	r0, #1
 8002362:	b002      	add	sp, #8
 8002364:	bd10      	pop	{r4, pc}
 8002366:	b138      	cbz	r0, 8002378 <LPS22HB_P_Get_ODR+0x44>
 8002368:	2810      	cmp	r0, #16
 800236a:	d1f7      	bne.n	800235c <LPS22HB_P_Get_ODR+0x28>
 800236c:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8002370:	2000      	movs	r0, #0
 8002372:	6023      	str	r3, [r4, #0]
 8002374:	b002      	add	sp, #8
 8002376:	bd10      	pop	{r4, pc}
 8002378:	2300      	movs	r3, #0
 800237a:	6023      	str	r3, [r4, #0]
 800237c:	b002      	add	sp, #8
 800237e:	bd10      	pop	{r4, pc}
 8002380:	4b0a      	ldr	r3, [pc, #40]	; (80023ac <LPS22HB_P_Get_ODR+0x78>)
 8002382:	6023      	str	r3, [r4, #0]
 8002384:	2000      	movs	r0, #0
 8002386:	b002      	add	sp, #8
 8002388:	bd10      	pop	{r4, pc}
 800238a:	4b09      	ldr	r3, [pc, #36]	; (80023b0 <LPS22HB_P_Get_ODR+0x7c>)
 800238c:	6023      	str	r3, [r4, #0]
 800238e:	2000      	movs	r0, #0
 8002390:	b002      	add	sp, #8
 8002392:	bd10      	pop	{r4, pc}
 8002394:	4b07      	ldr	r3, [pc, #28]	; (80023b4 <LPS22HB_P_Get_ODR+0x80>)
 8002396:	6023      	str	r3, [r4, #0]
 8002398:	2000      	movs	r0, #0
 800239a:	b002      	add	sp, #8
 800239c:	bd10      	pop	{r4, pc}
 800239e:	4b06      	ldr	r3, [pc, #24]	; (80023b8 <LPS22HB_P_Get_ODR+0x84>)
 80023a0:	6023      	str	r3, [r4, #0]
 80023a2:	2000      	movs	r0, #0
 80023a4:	b002      	add	sp, #8
 80023a6:	bd10      	pop	{r4, pc}
 80023a8:	bf800000 	.word	0xbf800000
 80023ac:	42960000 	.word	0x42960000
 80023b0:	41c80000 	.word	0x41c80000
 80023b4:	42480000 	.word	0x42480000
 80023b8:	41200000 	.word	0x41200000

080023bc <LPS22HB_T_Set_ODR_Value>:
{
 80023bc:	b530      	push	{r4, r5, lr}
                                       handle->pData))->pComponentData))->comboData;
 80023be:	6882      	ldr	r2, [r0, #8]
  if(handle->isEnabled == 1)
 80023c0:	7983      	ldrb	r3, [r0, #6]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 80023c2:	6812      	ldr	r2, [r2, #0]
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 80023c4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  if(handle->isEnabled == 1)
 80023c8:	2b01      	cmp	r3, #1
{
 80023ca:	b083      	sub	sp, #12
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 80023cc:	6815      	ldr	r5, [r2, #0]
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 80023ce:	eeb4 0ae7 	vcmpe.f32	s0, s15
  if(handle->isEnabled == 1)
 80023d2:	d021      	beq.n	8002418 <LPS22HB_T_Set_ODR_Value+0x5c>
                    : ( odr <= 10.0f ) ? 10.0f
 80023d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80023d8:	d906      	bls.n	80023e8 <LPS22HB_T_Set_ODR_Value+0x2c>
                    : ( odr <= 25.0f ) ? 25.0f
 80023da:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 80023de:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80023e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80023e6:	d804      	bhi.n	80023f2 <LPS22HB_T_Set_ODR_Value+0x36>
  combo->Last_ODR = ( odr <=  1.0f ) ? 1.0f
 80023e8:	edc5 7a01 	vstr	s15, [r5, #4]
  return COMPONENT_OK;
 80023ec:	2000      	movs	r0, #0
}
 80023ee:	b003      	add	sp, #12
 80023f0:	bd30      	pop	{r4, r5, pc}
                    : ( odr <= 50.0f ) ? 50.0f
 80023f2:	eef3 7a09 	vmov.f32	s15, #57	; 0x41c80000  25.0
 80023f6:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80023fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80023fe:	d9f3      	bls.n	80023e8 <LPS22HB_T_Set_ODR_Value+0x2c>
                    :                    75.0f;
 8002400:	eddf 7a2e 	vldr	s15, [pc, #184]	; 80024bc <LPS22HB_T_Set_ODR_Value+0x100>
 8002404:	ed9f 7a2e 	vldr	s14, [pc, #184]	; 80024c0 <LPS22HB_T_Set_ODR_Value+0x104>
 8002408:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800240c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002410:	bf88      	it	hi
 8002412:	eef0 7a47 	vmovhi.f32	s15, s14
 8002416:	e7e7      	b.n	80023e8 <LPS22HB_T_Set_ODR_Value+0x2c>
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 8002418:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800241c:	d93d      	bls.n	800249a <LPS22HB_T_Set_ODR_Value+0xde>
 800241e:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 8002422:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8002426:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800242a:	d908      	bls.n	800243e <LPS22HB_T_Set_ODR_Value+0x82>
 800242c:	eef3 7a09 	vmov.f32	s15, #57	; 0x41c80000  25.0
 8002430:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8002434:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002438:	d81d      	bhi.n	8002476 <LPS22HB_T_Set_ODR_Value+0xba>
 800243a:	2130      	movs	r1, #48	; 0x30
 800243c:	e000      	b.n	8002440 <LPS22HB_T_Set_ODR_Value+0x84>
 800243e:	2120      	movs	r1, #32
 8002440:	4604      	mov	r4, r0
  if ( LPS22HB_Set_Odr( (void *)handle, new_odr ) == LPS22HB_ERROR )
 8002442:	f7ff f9c1 	bl	80017c8 <LPS22HB_Set_Odr>
 8002446:	2801      	cmp	r0, #1
 8002448:	d0d1      	beq.n	80023ee <LPS22HB_T_Set_ODR_Value+0x32>
  if ( LPS22HB_Get_Odr( (void *)handle, &odr_low_level ) == LPS22HB_ERROR )
 800244a:	4620      	mov	r0, r4
 800244c:	f10d 0107 	add.w	r1, sp, #7
 8002450:	f7ff f9dc 	bl	800180c <LPS22HB_Get_Odr>
 8002454:	2801      	cmp	r0, #1
 8002456:	d00c      	beq.n	8002472 <LPS22HB_T_Set_ODR_Value+0xb6>
  switch( odr_low_level )
 8002458:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800245c:	2b20      	cmp	r3, #32
 800245e:	d021      	beq.n	80024a4 <LPS22HB_T_Set_ODR_Value+0xe8>
 8002460:	d913      	bls.n	800248a <LPS22HB_T_Set_ODR_Value+0xce>
 8002462:	2b40      	cmp	r3, #64	; 0x40
 8002464:	d027      	beq.n	80024b6 <LPS22HB_T_Set_ODR_Value+0xfa>
 8002466:	2b50      	cmp	r3, #80	; 0x50
 8002468:	d022      	beq.n	80024b0 <LPS22HB_T_Set_ODR_Value+0xf4>
 800246a:	2b30      	cmp	r3, #48	; 0x30
 800246c:	d01d      	beq.n	80024aa <LPS22HB_T_Set_ODR_Value+0xee>
      *odr = -1.0f;
 800246e:	4b15      	ldr	r3, [pc, #84]	; (80024c4 <LPS22HB_T_Set_ODR_Value+0x108>)
 8002470:	606b      	str	r3, [r5, #4]
    return COMPONENT_ERROR;
 8002472:	2001      	movs	r0, #1
 8002474:	e7bb      	b.n	80023ee <LPS22HB_T_Set_ODR_Value+0x32>
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 8002476:	eddf 7a11 	vldr	s15, [pc, #68]	; 80024bc <LPS22HB_T_Set_ODR_Value+0x100>
 800247a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800247e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002482:	bf94      	ite	ls
 8002484:	2140      	movls	r1, #64	; 0x40
 8002486:	2150      	movhi	r1, #80	; 0x50
 8002488:	e7da      	b.n	8002440 <LPS22HB_T_Set_ODR_Value+0x84>
  switch( odr_low_level )
 800248a:	b143      	cbz	r3, 800249e <LPS22HB_T_Set_ODR_Value+0xe2>
 800248c:	2b10      	cmp	r3, #16
 800248e:	d1ee      	bne.n	800246e <LPS22HB_T_Set_ODR_Value+0xb2>
      *odr = 1.0f;
 8002490:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8002494:	606b      	str	r3, [r5, #4]
  return COMPONENT_OK;
 8002496:	2000      	movs	r0, #0
 8002498:	e7a9      	b.n	80023ee <LPS22HB_T_Set_ODR_Value+0x32>
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 800249a:	2110      	movs	r1, #16
 800249c:	e7d0      	b.n	8002440 <LPS22HB_T_Set_ODR_Value+0x84>
      *odr = 0.0f;
 800249e:	2300      	movs	r3, #0
 80024a0:	606b      	str	r3, [r5, #4]
 80024a2:	e7f8      	b.n	8002496 <LPS22HB_T_Set_ODR_Value+0xda>
      *odr = 10.0f;
 80024a4:	4b08      	ldr	r3, [pc, #32]	; (80024c8 <LPS22HB_T_Set_ODR_Value+0x10c>)
 80024a6:	606b      	str	r3, [r5, #4]
 80024a8:	e7f5      	b.n	8002496 <LPS22HB_T_Set_ODR_Value+0xda>
      *odr = 25.0f;
 80024aa:	4b08      	ldr	r3, [pc, #32]	; (80024cc <LPS22HB_T_Set_ODR_Value+0x110>)
 80024ac:	606b      	str	r3, [r5, #4]
 80024ae:	e7f2      	b.n	8002496 <LPS22HB_T_Set_ODR_Value+0xda>
      *odr = 75.0f;
 80024b0:	4b07      	ldr	r3, [pc, #28]	; (80024d0 <LPS22HB_T_Set_ODR_Value+0x114>)
 80024b2:	606b      	str	r3, [r5, #4]
 80024b4:	e7ef      	b.n	8002496 <LPS22HB_T_Set_ODR_Value+0xda>
      *odr = 50.0f;
 80024b6:	4b07      	ldr	r3, [pc, #28]	; (80024d4 <LPS22HB_T_Set_ODR_Value+0x118>)
 80024b8:	606b      	str	r3, [r5, #4]
 80024ba:	e7ec      	b.n	8002496 <LPS22HB_T_Set_ODR_Value+0xda>
 80024bc:	42480000 	.word	0x42480000
 80024c0:	42960000 	.word	0x42960000
 80024c4:	bf800000 	.word	0xbf800000
 80024c8:	41200000 	.word	0x41200000
 80024cc:	41c80000 	.word	0x41c80000
 80024d0:	42960000 	.word	0x42960000
 80024d4:	42480000 	.word	0x42480000

080024d8 <LPS22HB_T_Sensor_Enable>:
  if ( handle->isEnabled == 1 )
 80024d8:	7983      	ldrb	r3, [r0, #6]
 80024da:	2b01      	cmp	r3, #1
 80024dc:	d023      	beq.n	8002526 <LPS22HB_T_Sensor_Enable+0x4e>
                                       handle->pData))->pComponentData))->comboData;
 80024de:	6883      	ldr	r3, [r0, #8]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 80024e0:	681b      	ldr	r3, [r3, #0]
{
 80024e2:	b530      	push	{r4, r5, lr}
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 80024e4:	681d      	ldr	r5, [r3, #0]
  if(LPS22HB_Set_ODR_Value_When_Enabled(handle, comboData->Last_ODR, comboData) == COMPONENT_ERROR)
 80024e6:	edd5 7a01 	vldr	s15, [r5, #4]
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 80024ea:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80024ee:	eef4 7ac7 	vcmpe.f32	s15, s14
 80024f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 80024f6:	b083      	sub	sp, #12
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 80024f8:	d934      	bls.n	8002564 <LPS22HB_T_Sensor_Enable+0x8c>
 80024fa:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 80024fe:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002502:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002506:	d910      	bls.n	800252a <LPS22HB_T_Sensor_Enable+0x52>
 8002508:	eeb3 7a09 	vmov.f32	s14, #57	; 0x41c80000  25.0
 800250c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002510:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002514:	d828      	bhi.n	8002568 <LPS22HB_T_Sensor_Enable+0x90>
 8002516:	2130      	movs	r1, #48	; 0x30
 8002518:	4604      	mov	r4, r0
  if ( LPS22HB_Set_Odr( (void *)handle, new_odr ) == LPS22HB_ERROR )
 800251a:	f7ff f955 	bl	80017c8 <LPS22HB_Set_Odr>
 800251e:	2801      	cmp	r0, #1
 8002520:	d109      	bne.n	8002536 <LPS22HB_T_Sensor_Enable+0x5e>
}
 8002522:	b003      	add	sp, #12
 8002524:	bd30      	pop	{r4, r5, pc}
    return COMPONENT_OK;
 8002526:	2000      	movs	r0, #0
 8002528:	4770      	bx	lr
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 800252a:	2120      	movs	r1, #32
 800252c:	4604      	mov	r4, r0
  if ( LPS22HB_Set_Odr( (void *)handle, new_odr ) == LPS22HB_ERROR )
 800252e:	f7ff f94b 	bl	80017c8 <LPS22HB_Set_Odr>
 8002532:	2801      	cmp	r0, #1
 8002534:	d0f5      	beq.n	8002522 <LPS22HB_T_Sensor_Enable+0x4a>
  if ( LPS22HB_Get_Odr( (void *)handle, &odr_low_level ) == LPS22HB_ERROR )
 8002536:	f10d 0107 	add.w	r1, sp, #7
 800253a:	4620      	mov	r0, r4
 800253c:	f7ff f966 	bl	800180c <LPS22HB_Get_Odr>
 8002540:	2801      	cmp	r0, #1
 8002542:	d00c      	beq.n	800255e <LPS22HB_T_Sensor_Enable+0x86>
  switch( odr_low_level )
 8002544:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8002548:	2b20      	cmp	r3, #32
 800254a:	d02f      	beq.n	80025ac <LPS22HB_T_Sensor_Enable+0xd4>
 800254c:	d916      	bls.n	800257c <LPS22HB_T_Sensor_Enable+0xa4>
 800254e:	2b40      	cmp	r3, #64	; 0x40
 8002550:	d029      	beq.n	80025a6 <LPS22HB_T_Sensor_Enable+0xce>
 8002552:	2b50      	cmp	r3, #80	; 0x50
 8002554:	d024      	beq.n	80025a0 <LPS22HB_T_Sensor_Enable+0xc8>
 8002556:	2b30      	cmp	r3, #48	; 0x30
 8002558:	d01c      	beq.n	8002594 <LPS22HB_T_Sensor_Enable+0xbc>
      *odr = -1.0f;
 800255a:	4b16      	ldr	r3, [pc, #88]	; (80025b4 <LPS22HB_T_Sensor_Enable+0xdc>)
 800255c:	606b      	str	r3, [r5, #4]
    return COMPONENT_ERROR;
 800255e:	2001      	movs	r0, #1
}
 8002560:	b003      	add	sp, #12
 8002562:	bd30      	pop	{r4, r5, pc}
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 8002564:	2110      	movs	r1, #16
 8002566:	e7e1      	b.n	800252c <LPS22HB_T_Sensor_Enable+0x54>
 8002568:	ed9f 7a13 	vldr	s14, [pc, #76]	; 80025b8 <LPS22HB_T_Sensor_Enable+0xe0>
 800256c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002570:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002574:	bf94      	ite	ls
 8002576:	2140      	movls	r1, #64	; 0x40
 8002578:	2150      	movhi	r1, #80	; 0x50
 800257a:	e7d7      	b.n	800252c <LPS22HB_T_Sensor_Enable+0x54>
  switch( odr_low_level )
 800257c:	b16b      	cbz	r3, 800259a <LPS22HB_T_Sensor_Enable+0xc2>
 800257e:	2b10      	cmp	r3, #16
 8002580:	d1eb      	bne.n	800255a <LPS22HB_T_Sensor_Enable+0x82>
      *odr = 1.0f;
 8002582:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8002586:	606b      	str	r3, [r5, #4]
  comboData->isTempEnabled = 1;
 8002588:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800258a:	2000      	movs	r0, #0
  comboData->isTempEnabled = 1;
 800258c:	70eb      	strb	r3, [r5, #3]
  handle->isEnabled = 1;
 800258e:	71a3      	strb	r3, [r4, #6]
}
 8002590:	b003      	add	sp, #12
 8002592:	bd30      	pop	{r4, r5, pc}
      *odr = 25.0f;
 8002594:	4b09      	ldr	r3, [pc, #36]	; (80025bc <LPS22HB_T_Sensor_Enable+0xe4>)
 8002596:	606b      	str	r3, [r5, #4]
 8002598:	e7f6      	b.n	8002588 <LPS22HB_T_Sensor_Enable+0xb0>
      *odr = 0.0f;
 800259a:	2300      	movs	r3, #0
 800259c:	606b      	str	r3, [r5, #4]
 800259e:	e7f3      	b.n	8002588 <LPS22HB_T_Sensor_Enable+0xb0>
      *odr = 75.0f;
 80025a0:	4b07      	ldr	r3, [pc, #28]	; (80025c0 <LPS22HB_T_Sensor_Enable+0xe8>)
 80025a2:	606b      	str	r3, [r5, #4]
 80025a4:	e7f0      	b.n	8002588 <LPS22HB_T_Sensor_Enable+0xb0>
      *odr = 50.0f;
 80025a6:	4b07      	ldr	r3, [pc, #28]	; (80025c4 <LPS22HB_T_Sensor_Enable+0xec>)
 80025a8:	606b      	str	r3, [r5, #4]
 80025aa:	e7ed      	b.n	8002588 <LPS22HB_T_Sensor_Enable+0xb0>
      *odr = 10.0f;
 80025ac:	4b06      	ldr	r3, [pc, #24]	; (80025c8 <LPS22HB_T_Sensor_Enable+0xf0>)
 80025ae:	606b      	str	r3, [r5, #4]
 80025b0:	e7ea      	b.n	8002588 <LPS22HB_T_Sensor_Enable+0xb0>
 80025b2:	bf00      	nop
 80025b4:	bf800000 	.word	0xbf800000
 80025b8:	42480000 	.word	0x42480000
 80025bc:	41c80000 	.word	0x41c80000
 80025c0:	42960000 	.word	0x42960000
 80025c4:	42480000 	.word	0x42480000
 80025c8:	41200000 	.word	0x41200000

080025cc <LPS22HB_P_Sensor_Enable>:
  if ( handle->isEnabled == 1 )
 80025cc:	7983      	ldrb	r3, [r0, #6]
 80025ce:	2b01      	cmp	r3, #1
 80025d0:	d023      	beq.n	800261a <LPS22HB_P_Sensor_Enable+0x4e>
                                       handle->pData))->pComponentData))->comboData;
 80025d2:	6883      	ldr	r3, [r0, #8]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 80025d4:	681b      	ldr	r3, [r3, #0]
{
 80025d6:	b530      	push	{r4, r5, lr}
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 80025d8:	681d      	ldr	r5, [r3, #0]
  if(LPS22HB_Set_ODR_Value_When_Enabled(handle, comboData->Last_ODR, comboData) == COMPONENT_ERROR)
 80025da:	edd5 7a01 	vldr	s15, [r5, #4]
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 80025de:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80025e2:	eef4 7ac7 	vcmpe.f32	s15, s14
 80025e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 80025ea:	b083      	sub	sp, #12
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 80025ec:	d934      	bls.n	8002658 <LPS22HB_P_Sensor_Enable+0x8c>
 80025ee:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 80025f2:	eef4 7ac7 	vcmpe.f32	s15, s14
 80025f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80025fa:	d910      	bls.n	800261e <LPS22HB_P_Sensor_Enable+0x52>
 80025fc:	eeb3 7a09 	vmov.f32	s14, #57	; 0x41c80000  25.0
 8002600:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002604:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002608:	d828      	bhi.n	800265c <LPS22HB_P_Sensor_Enable+0x90>
 800260a:	2130      	movs	r1, #48	; 0x30
 800260c:	4604      	mov	r4, r0
  if ( LPS22HB_Set_Odr( (void *)handle, new_odr ) == LPS22HB_ERROR )
 800260e:	f7ff f8db 	bl	80017c8 <LPS22HB_Set_Odr>
 8002612:	2801      	cmp	r0, #1
 8002614:	d109      	bne.n	800262a <LPS22HB_P_Sensor_Enable+0x5e>
}
 8002616:	b003      	add	sp, #12
 8002618:	bd30      	pop	{r4, r5, pc}
    return COMPONENT_OK;
 800261a:	2000      	movs	r0, #0
 800261c:	4770      	bx	lr
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 800261e:	2120      	movs	r1, #32
 8002620:	4604      	mov	r4, r0
  if ( LPS22HB_Set_Odr( (void *)handle, new_odr ) == LPS22HB_ERROR )
 8002622:	f7ff f8d1 	bl	80017c8 <LPS22HB_Set_Odr>
 8002626:	2801      	cmp	r0, #1
 8002628:	d0f5      	beq.n	8002616 <LPS22HB_P_Sensor_Enable+0x4a>
  if ( LPS22HB_Get_Odr( (void *)handle, &odr_low_level ) == LPS22HB_ERROR )
 800262a:	f10d 0107 	add.w	r1, sp, #7
 800262e:	4620      	mov	r0, r4
 8002630:	f7ff f8ec 	bl	800180c <LPS22HB_Get_Odr>
 8002634:	2801      	cmp	r0, #1
 8002636:	d00c      	beq.n	8002652 <LPS22HB_P_Sensor_Enable+0x86>
  switch( odr_low_level )
 8002638:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800263c:	2b20      	cmp	r3, #32
 800263e:	d02f      	beq.n	80026a0 <LPS22HB_P_Sensor_Enable+0xd4>
 8002640:	d916      	bls.n	8002670 <LPS22HB_P_Sensor_Enable+0xa4>
 8002642:	2b40      	cmp	r3, #64	; 0x40
 8002644:	d029      	beq.n	800269a <LPS22HB_P_Sensor_Enable+0xce>
 8002646:	2b50      	cmp	r3, #80	; 0x50
 8002648:	d024      	beq.n	8002694 <LPS22HB_P_Sensor_Enable+0xc8>
 800264a:	2b30      	cmp	r3, #48	; 0x30
 800264c:	d01c      	beq.n	8002688 <LPS22HB_P_Sensor_Enable+0xbc>
      *odr = -1.0f;
 800264e:	4b16      	ldr	r3, [pc, #88]	; (80026a8 <LPS22HB_P_Sensor_Enable+0xdc>)
 8002650:	606b      	str	r3, [r5, #4]
    return COMPONENT_ERROR;
 8002652:	2001      	movs	r0, #1
}
 8002654:	b003      	add	sp, #12
 8002656:	bd30      	pop	{r4, r5, pc}
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 8002658:	2110      	movs	r1, #16
 800265a:	e7e1      	b.n	8002620 <LPS22HB_P_Sensor_Enable+0x54>
 800265c:	ed9f 7a13 	vldr	s14, [pc, #76]	; 80026ac <LPS22HB_P_Sensor_Enable+0xe0>
 8002660:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002664:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002668:	bf94      	ite	ls
 800266a:	2140      	movls	r1, #64	; 0x40
 800266c:	2150      	movhi	r1, #80	; 0x50
 800266e:	e7d7      	b.n	8002620 <LPS22HB_P_Sensor_Enable+0x54>
  switch( odr_low_level )
 8002670:	b16b      	cbz	r3, 800268e <LPS22HB_P_Sensor_Enable+0xc2>
 8002672:	2b10      	cmp	r3, #16
 8002674:	d1eb      	bne.n	800264e <LPS22HB_P_Sensor_Enable+0x82>
      *odr = 1.0f;
 8002676:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800267a:	606b      	str	r3, [r5, #4]
  comboData->isPressEnabled = 1;
 800267c:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800267e:	2000      	movs	r0, #0
  comboData->isPressEnabled = 1;
 8002680:	70ab      	strb	r3, [r5, #2]
  handle->isEnabled = 1;
 8002682:	71a3      	strb	r3, [r4, #6]
}
 8002684:	b003      	add	sp, #12
 8002686:	bd30      	pop	{r4, r5, pc}
      *odr = 25.0f;
 8002688:	4b09      	ldr	r3, [pc, #36]	; (80026b0 <LPS22HB_P_Sensor_Enable+0xe4>)
 800268a:	606b      	str	r3, [r5, #4]
 800268c:	e7f6      	b.n	800267c <LPS22HB_P_Sensor_Enable+0xb0>
      *odr = 0.0f;
 800268e:	2300      	movs	r3, #0
 8002690:	606b      	str	r3, [r5, #4]
 8002692:	e7f3      	b.n	800267c <LPS22HB_P_Sensor_Enable+0xb0>
      *odr = 75.0f;
 8002694:	4b07      	ldr	r3, [pc, #28]	; (80026b4 <LPS22HB_P_Sensor_Enable+0xe8>)
 8002696:	606b      	str	r3, [r5, #4]
 8002698:	e7f0      	b.n	800267c <LPS22HB_P_Sensor_Enable+0xb0>
      *odr = 50.0f;
 800269a:	4b07      	ldr	r3, [pc, #28]	; (80026b8 <LPS22HB_P_Sensor_Enable+0xec>)
 800269c:	606b      	str	r3, [r5, #4]
 800269e:	e7ed      	b.n	800267c <LPS22HB_P_Sensor_Enable+0xb0>
      *odr = 10.0f;
 80026a0:	4b06      	ldr	r3, [pc, #24]	; (80026bc <LPS22HB_P_Sensor_Enable+0xf0>)
 80026a2:	606b      	str	r3, [r5, #4]
 80026a4:	e7ea      	b.n	800267c <LPS22HB_P_Sensor_Enable+0xb0>
 80026a6:	bf00      	nop
 80026a8:	bf800000 	.word	0xbf800000
 80026ac:	42480000 	.word	0x42480000
 80026b0:	41c80000 	.word	0x41c80000
 80026b4:	42960000 	.word	0x42960000
 80026b8:	42480000 	.word	0x42480000
 80026bc:	41200000 	.word	0x41200000

080026c0 <LPS22HB_P_Init>:
                                       handle->pData))->pComponentData))->comboData;
 80026c0:	6883      	ldr	r3, [r0, #8]
{
 80026c2:	b570      	push	{r4, r5, r6, lr}
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 80026c4:	681b      	ldr	r3, [r3, #0]
 80026c6:	681d      	ldr	r5, [r3, #0]
  if(comboData->isTempInitialized == 0)
 80026c8:	786e      	ldrb	r6, [r5, #1]
{
 80026ca:	b082      	sub	sp, #8
 80026cc:	4604      	mov	r4, r0
  if(comboData->isTempInitialized == 0)
 80026ce:	b12e      	cbz	r6, 80026dc <LPS22HB_P_Init+0x1c>
  comboData->isPressInitialized = 1;
 80026d0:	2301      	movs	r3, #1
  return COMPONENT_OK;
 80026d2:	2000      	movs	r0, #0
  comboData->isPressInitialized = 1;
 80026d4:	702b      	strb	r3, [r5, #0]
  handle->isInitialized = 1;
 80026d6:	7163      	strb	r3, [r4, #5]
}
 80026d8:	b002      	add	sp, #8
 80026da:	bd70      	pop	{r4, r5, r6, pc}
  uint8_t who_am_i = 0x00;
 80026dc:	a902      	add	r1, sp, #8
 80026de:	f801 6d01 	strb.w	r6, [r1, #-1]!
  if ( LPS22HB_Get_DeviceID( (void *)handle, who_am_i ) == LPS22HB_ERROR )
 80026e2:	f7ff f845 	bl	8001770 <LPS22HB_Get_DeviceID>
 80026e6:	2801      	cmp	r0, #1
 80026e8:	d004      	beq.n	80026f4 <LPS22HB_P_Init+0x34>
  if ( who_am_i != handle->who_am_i )
 80026ea:	7822      	ldrb	r2, [r4, #0]
 80026ec:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80026f0:	429a      	cmp	r2, r3
 80026f2:	d002      	beq.n	80026fa <LPS22HB_P_Init+0x3a>
      return COMPONENT_ERROR;
 80026f4:	2001      	movs	r0, #1
}
 80026f6:	b002      	add	sp, #8
 80026f8:	bd70      	pop	{r4, r5, r6, pc}
  combo->Last_ODR = 25.0f;
 80026fa:	4b15      	ldr	r3, [pc, #84]	; (8002750 <LPS22HB_P_Init+0x90>)
 80026fc:	606b      	str	r3, [r5, #4]
  if ( LPS22HB_Set_PowerMode( (void *)handle, LPS22HB_LowPower) == LPS22HB_ERROR )
 80026fe:	2101      	movs	r1, #1
 8002700:	4620      	mov	r0, r4
 8002702:	f7ff f83f 	bl	8001784 <LPS22HB_Set_PowerMode>
 8002706:	2801      	cmp	r0, #1
 8002708:	d0f4      	beq.n	80026f4 <LPS22HB_P_Init+0x34>
  if ( LPS22HB_Set_Odr( (void *)handle, LPS22HB_ODR_ONE_SHOT ) == LPS22HB_ERROR )
 800270a:	4631      	mov	r1, r6
 800270c:	4620      	mov	r0, r4
 800270e:	f7ff f85b 	bl	80017c8 <LPS22HB_Set_Odr>
 8002712:	2801      	cmp	r0, #1
 8002714:	d0ee      	beq.n	80026f4 <LPS22HB_P_Init+0x34>
  if( LPS22HB_Set_LowPassFilter( (void *)handle, LPS22HB_DISABLE) == LPS22HB_ERROR )
 8002716:	4631      	mov	r1, r6
 8002718:	4620      	mov	r0, r4
 800271a:	f7ff f88b 	bl	8001834 <LPS22HB_Set_LowPassFilter>
 800271e:	2801      	cmp	r0, #1
 8002720:	d0e8      	beq.n	80026f4 <LPS22HB_P_Init+0x34>
  if( LPS22HB_Set_LowPassFilterCutoff( (void *)handle, LPS22HB_ODR_9) == LPS22HB_ERROR )
 8002722:	4631      	mov	r1, r6
 8002724:	4620      	mov	r0, r4
 8002726:	f7ff f8a7 	bl	8001878 <LPS22HB_Set_LowPassFilterCutoff>
 800272a:	2801      	cmp	r0, #1
 800272c:	d0e2      	beq.n	80026f4 <LPS22HB_P_Init+0x34>
  if ( LPS22HB_Set_Bdu( (void *)handle, LPS22HB_BDU_NO_UPDATE ) == LPS22HB_ERROR )
 800272e:	2102      	movs	r1, #2
 8002730:	4620      	mov	r0, r4
 8002732:	f7ff f8c3 	bl	80018bc <LPS22HB_Set_Bdu>
 8002736:	2801      	cmp	r0, #1
 8002738:	d0dc      	beq.n	80026f4 <LPS22HB_P_Init+0x34>
  if(handle->ifType == 0) // I2C mode
 800273a:	7861      	ldrb	r1, [r4, #1]
 800273c:	b109      	cbz	r1, 8002742 <LPS22HB_P_Init+0x82>
    if(handle->ifType == 1) // SPI mode
 800273e:	2901      	cmp	r1, #1
 8002740:	d1c6      	bne.n	80026d0 <LPS22HB_P_Init+0x10>
      if( LPS22HB_Set_AutomaticIncrementRegAddress( (void *)handle, LPS22HB_ENABLE) == LPS22HB_ERROR )
 8002742:	4620      	mov	r0, r4
 8002744:	f7ff f91e 	bl	8001984 <LPS22HB_Set_AutomaticIncrementRegAddress>
 8002748:	2801      	cmp	r0, #1
 800274a:	d1c1      	bne.n	80026d0 <LPS22HB_P_Init+0x10>
 800274c:	e7d2      	b.n	80026f4 <LPS22HB_P_Init+0x34>
 800274e:	bf00      	nop
 8002750:	41c80000 	.word	0x41c80000

08002754 <LPS22HB_P_Set_ODR_Value>:
{
 8002754:	b530      	push	{r4, r5, lr}
                                       handle->pData))->pComponentData))->comboData;
 8002756:	6882      	ldr	r2, [r0, #8]
  if(handle->isEnabled == 1)
 8002758:	7983      	ldrb	r3, [r0, #6]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 800275a:	6812      	ldr	r2, [r2, #0]
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 800275c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  if(handle->isEnabled == 1)
 8002760:	2b01      	cmp	r3, #1
{
 8002762:	b083      	sub	sp, #12
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_P_Data_t *)(((PRESSURE_Data_t *)(
 8002764:	6815      	ldr	r5, [r2, #0]
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 8002766:	eeb4 0ae7 	vcmpe.f32	s0, s15
  if(handle->isEnabled == 1)
 800276a:	d021      	beq.n	80027b0 <LPS22HB_P_Set_ODR_Value+0x5c>
                    : ( odr <= 10.0f ) ? 10.0f
 800276c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002770:	d906      	bls.n	8002780 <LPS22HB_P_Set_ODR_Value+0x2c>
                    : ( odr <= 25.0f ) ? 25.0f
 8002772:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 8002776:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800277a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800277e:	d804      	bhi.n	800278a <LPS22HB_P_Set_ODR_Value+0x36>
  combo->Last_ODR = ( odr <=  1.0f ) ? 1.0f
 8002780:	edc5 7a01 	vstr	s15, [r5, #4]
  return COMPONENT_OK;
 8002784:	2000      	movs	r0, #0
}
 8002786:	b003      	add	sp, #12
 8002788:	bd30      	pop	{r4, r5, pc}
                    : ( odr <= 50.0f ) ? 50.0f
 800278a:	eef3 7a09 	vmov.f32	s15, #57	; 0x41c80000  25.0
 800278e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8002792:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002796:	d9f3      	bls.n	8002780 <LPS22HB_P_Set_ODR_Value+0x2c>
                    :                    75.0f;
 8002798:	eddf 7a2e 	vldr	s15, [pc, #184]	; 8002854 <LPS22HB_P_Set_ODR_Value+0x100>
 800279c:	ed9f 7a2e 	vldr	s14, [pc, #184]	; 8002858 <LPS22HB_P_Set_ODR_Value+0x104>
 80027a0:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80027a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80027a8:	bf88      	it	hi
 80027aa:	eef0 7a47 	vmovhi.f32	s15, s14
 80027ae:	e7e7      	b.n	8002780 <LPS22HB_P_Set_ODR_Value+0x2c>
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 80027b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80027b4:	d93d      	bls.n	8002832 <LPS22HB_P_Set_ODR_Value+0xde>
 80027b6:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 80027ba:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80027be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80027c2:	d908      	bls.n	80027d6 <LPS22HB_P_Set_ODR_Value+0x82>
 80027c4:	eef3 7a09 	vmov.f32	s15, #57	; 0x41c80000  25.0
 80027c8:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80027cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80027d0:	d81d      	bhi.n	800280e <LPS22HB_P_Set_ODR_Value+0xba>
 80027d2:	2130      	movs	r1, #48	; 0x30
 80027d4:	e000      	b.n	80027d8 <LPS22HB_P_Set_ODR_Value+0x84>
 80027d6:	2120      	movs	r1, #32
 80027d8:	4604      	mov	r4, r0
  if ( LPS22HB_Set_Odr( (void *)handle, new_odr ) == LPS22HB_ERROR )
 80027da:	f7fe fff5 	bl	80017c8 <LPS22HB_Set_Odr>
 80027de:	2801      	cmp	r0, #1
 80027e0:	d0d1      	beq.n	8002786 <LPS22HB_P_Set_ODR_Value+0x32>
  if ( LPS22HB_Get_Odr( (void *)handle, &odr_low_level ) == LPS22HB_ERROR )
 80027e2:	4620      	mov	r0, r4
 80027e4:	f10d 0107 	add.w	r1, sp, #7
 80027e8:	f7ff f810 	bl	800180c <LPS22HB_Get_Odr>
 80027ec:	2801      	cmp	r0, #1
 80027ee:	d00c      	beq.n	800280a <LPS22HB_P_Set_ODR_Value+0xb6>
  switch( odr_low_level )
 80027f0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80027f4:	2b20      	cmp	r3, #32
 80027f6:	d021      	beq.n	800283c <LPS22HB_P_Set_ODR_Value+0xe8>
 80027f8:	d913      	bls.n	8002822 <LPS22HB_P_Set_ODR_Value+0xce>
 80027fa:	2b40      	cmp	r3, #64	; 0x40
 80027fc:	d027      	beq.n	800284e <LPS22HB_P_Set_ODR_Value+0xfa>
 80027fe:	2b50      	cmp	r3, #80	; 0x50
 8002800:	d022      	beq.n	8002848 <LPS22HB_P_Set_ODR_Value+0xf4>
 8002802:	2b30      	cmp	r3, #48	; 0x30
 8002804:	d01d      	beq.n	8002842 <LPS22HB_P_Set_ODR_Value+0xee>
      *odr = -1.0f;
 8002806:	4b15      	ldr	r3, [pc, #84]	; (800285c <LPS22HB_P_Set_ODR_Value+0x108>)
 8002808:	606b      	str	r3, [r5, #4]
    return COMPONENT_ERROR;
 800280a:	2001      	movs	r0, #1
 800280c:	e7bb      	b.n	8002786 <LPS22HB_P_Set_ODR_Value+0x32>
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 800280e:	eddf 7a11 	vldr	s15, [pc, #68]	; 8002854 <LPS22HB_P_Set_ODR_Value+0x100>
 8002812:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8002816:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800281a:	bf94      	ite	ls
 800281c:	2140      	movls	r1, #64	; 0x40
 800281e:	2150      	movhi	r1, #80	; 0x50
 8002820:	e7da      	b.n	80027d8 <LPS22HB_P_Set_ODR_Value+0x84>
  switch( odr_low_level )
 8002822:	b143      	cbz	r3, 8002836 <LPS22HB_P_Set_ODR_Value+0xe2>
 8002824:	2b10      	cmp	r3, #16
 8002826:	d1ee      	bne.n	8002806 <LPS22HB_P_Set_ODR_Value+0xb2>
      *odr = 1.0f;
 8002828:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800282c:	606b      	str	r3, [r5, #4]
  return COMPONENT_OK;
 800282e:	2000      	movs	r0, #0
 8002830:	e7a9      	b.n	8002786 <LPS22HB_P_Set_ODR_Value+0x32>
            : ( odr <= 10.0f ) ? LPS22HB_ODR_10HZ
 8002832:	2110      	movs	r1, #16
 8002834:	e7d0      	b.n	80027d8 <LPS22HB_P_Set_ODR_Value+0x84>
      *odr = 0.0f;
 8002836:	2300      	movs	r3, #0
 8002838:	606b      	str	r3, [r5, #4]
 800283a:	e7f8      	b.n	800282e <LPS22HB_P_Set_ODR_Value+0xda>
      *odr = 10.0f;
 800283c:	4b08      	ldr	r3, [pc, #32]	; (8002860 <LPS22HB_P_Set_ODR_Value+0x10c>)
 800283e:	606b      	str	r3, [r5, #4]
 8002840:	e7f5      	b.n	800282e <LPS22HB_P_Set_ODR_Value+0xda>
      *odr = 25.0f;
 8002842:	4b08      	ldr	r3, [pc, #32]	; (8002864 <LPS22HB_P_Set_ODR_Value+0x110>)
 8002844:	606b      	str	r3, [r5, #4]
 8002846:	e7f2      	b.n	800282e <LPS22HB_P_Set_ODR_Value+0xda>
      *odr = 75.0f;
 8002848:	4b07      	ldr	r3, [pc, #28]	; (8002868 <LPS22HB_P_Set_ODR_Value+0x114>)
 800284a:	606b      	str	r3, [r5, #4]
 800284c:	e7ef      	b.n	800282e <LPS22HB_P_Set_ODR_Value+0xda>
      *odr = 50.0f;
 800284e:	4b07      	ldr	r3, [pc, #28]	; (800286c <LPS22HB_P_Set_ODR_Value+0x118>)
 8002850:	606b      	str	r3, [r5, #4]
 8002852:	e7ec      	b.n	800282e <LPS22HB_P_Set_ODR_Value+0xda>
 8002854:	42480000 	.word	0x42480000
 8002858:	42960000 	.word	0x42960000
 800285c:	bf800000 	.word	0xbf800000
 8002860:	41200000 	.word	0x41200000
 8002864:	41c80000 	.word	0x41c80000
 8002868:	42960000 	.word	0x42960000
 800286c:	42480000 	.word	0x42480000

08002870 <LPS22HB_T_Set_ODR>:
{
 8002870:	b530      	push	{r4, r5, lr}
                                       handle->pData))->pComponentData))->comboData;
 8002872:	6882      	ldr	r2, [r0, #8]
  if(handle->isEnabled == 1)
 8002874:	7983      	ldrb	r3, [r0, #6]
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 8002876:	6812      	ldr	r2, [r2, #0]
  if(handle->isEnabled == 1)
 8002878:	2b01      	cmp	r3, #1
{
 800287a:	b083      	sub	sp, #12
  LPS22HB_Combo_Data_t *comboData = ((LPS22HB_T_Data_t *)(((TEMPERATURE_Data_t *)(
 800287c:	6815      	ldr	r5, [r2, #0]
  if(handle->isEnabled == 1)
 800287e:	d020      	beq.n	80028c2 <LPS22HB_T_Set_ODR+0x52>
  switch( odr )
 8002880:	2904      	cmp	r1, #4
 8002882:	d83f      	bhi.n	8002904 <LPS22HB_T_Set_ODR+0x94>
 8002884:	e8df f001 	tbb	[pc, r1]
 8002888:	18130e08 	.word	0x18130e08
 800288c:	03          	.byte	0x03
 800288d:	00          	.byte	0x00
      combo->Last_ODR = 75.0f;
 800288e:	4b2e      	ldr	r3, [pc, #184]	; (8002948 <LPS22HB_T_Set_ODR+0xd8>)
 8002890:	606b      	str	r3, [r5, #4]
  return COMPONENT_OK;
 8002892:	2000      	movs	r0, #0
}
 8002894:	b003      	add	sp, #12
 8002896:	bd30      	pop	{r4, r5, pc}
      combo->Last_ODR = 1.0f;
 8002898:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
  return COMPONENT_OK;
 800289c:	2000      	movs	r0, #0
      combo->Last_ODR = 1.0f;
 800289e:	606b      	str	r3, [r5, #4]
}
 80028a0:	b003      	add	sp, #12
 80028a2:	bd30      	pop	{r4, r5, pc}
      combo->Last_ODR = 10.0f;
 80028a4:	4b29      	ldr	r3, [pc, #164]	; (800294c <LPS22HB_T_Set_ODR+0xdc>)
 80028a6:	606b      	str	r3, [r5, #4]
  return COMPONENT_OK;
 80028a8:	2000      	movs	r0, #0
}
 80028aa:	b003      	add	sp, #12
 80028ac:	bd30      	pop	{r4, r5, pc}
      combo->Last_ODR = 25.0f;
 80028ae:	4b28      	ldr	r3, [pc, #160]	; (8002950 <LPS22HB_T_Set_ODR+0xe0>)
 80028b0:	606b      	str	r3, [r5, #4]
  return COMPONENT_OK;
 80028b2:	2000      	movs	r0, #0
}
 80028b4:	b003      	add	sp, #12
 80028b6:	bd30      	pop	{r4, r5, pc}
      combo->Last_ODR = 50.0f;
 80028b8:	4b26      	ldr	r3, [pc, #152]	; (8002954 <LPS22HB_T_Set_ODR+0xe4>)
 80028ba:	606b      	str	r3, [r5, #4]
  return COMPONENT_OK;
 80028bc:	2000      	movs	r0, #0
}
 80028be:	b003      	add	sp, #12
 80028c0:	bd30      	pop	{r4, r5, pc}
  switch( odr )
 80028c2:	2904      	cmp	r1, #4
 80028c4:	d81e      	bhi.n	8002904 <LPS22HB_T_Set_ODR+0x94>
 80028c6:	e8df f001 	tbb	[pc, r1]
 80028ca:	031f      	.short	0x031f
 80028cc:	2325      	.short	0x2325
 80028ce:	21          	.byte	0x21
 80028cf:	00          	.byte	0x00
      new_odr = LPS22HB_ODR_10HZ;
 80028d0:	2120      	movs	r1, #32
 80028d2:	4604      	mov	r4, r0
  if ( LPS22HB_Set_Odr( (void *)handle, new_odr ) == LPS22HB_ERROR )
 80028d4:	f7fe ff78 	bl	80017c8 <LPS22HB_Set_Odr>
 80028d8:	2801      	cmp	r0, #1
 80028da:	d0db      	beq.n	8002894 <LPS22HB_T_Set_ODR+0x24>
  if ( LPS22HB_Get_Odr( (void *)handle, &odr_low_level ) == LPS22HB_ERROR )
 80028dc:	4620      	mov	r0, r4
 80028de:	f10d 0107 	add.w	r1, sp, #7
 80028e2:	f7fe ff93 	bl	800180c <LPS22HB_Get_Odr>
 80028e6:	2801      	cmp	r0, #1
 80028e8:	d00c      	beq.n	8002904 <LPS22HB_T_Set_ODR+0x94>
  switch( odr_low_level )
 80028ea:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80028ee:	2b20      	cmp	r3, #32
 80028f0:	d01a      	beq.n	8002928 <LPS22HB_T_Set_ODR+0xb8>
 80028f2:	d911      	bls.n	8002918 <LPS22HB_T_Set_ODR+0xa8>
 80028f4:	2b40      	cmp	r3, #64	; 0x40
 80028f6:	d020      	beq.n	800293a <LPS22HB_T_Set_ODR+0xca>
 80028f8:	2b50      	cmp	r3, #80	; 0x50
 80028fa:	d01b      	beq.n	8002934 <LPS22HB_T_Set_ODR+0xc4>
 80028fc:	2b30      	cmp	r3, #48	; 0x30
 80028fe:	d016      	beq.n	800292e <LPS22HB_T_Set_ODR+0xbe>
      *odr = -1.0f;
 8002900:	4b15      	ldr	r3, [pc, #84]	; (8002958 <LPS22HB_T_Set_ODR+0xe8>)
 8002902:	606b      	str	r3, [r5, #4]
    return COMPONENT_ERROR;
 8002904:	2001      	movs	r0, #1
 8002906:	e7c5      	b.n	8002894 <LPS22HB_T_Set_ODR+0x24>
      new_odr = LPS22HB_ODR_1HZ;
 8002908:	2110      	movs	r1, #16
 800290a:	e7e2      	b.n	80028d2 <LPS22HB_T_Set_ODR+0x62>
      new_odr = LPS22HB_ODR_75HZ;
 800290c:	2150      	movs	r1, #80	; 0x50
 800290e:	e7e0      	b.n	80028d2 <LPS22HB_T_Set_ODR+0x62>
      new_odr = LPS22HB_ODR_50HZ;
 8002910:	2140      	movs	r1, #64	; 0x40
 8002912:	e7de      	b.n	80028d2 <LPS22HB_T_Set_ODR+0x62>
      new_odr = LPS22HB_ODR_25HZ;
 8002914:	2130      	movs	r1, #48	; 0x30
 8002916:	e7dc      	b.n	80028d2 <LPS22HB_T_Set_ODR+0x62>
  switch( odr_low_level )
 8002918:	b193      	cbz	r3, 8002940 <LPS22HB_T_Set_ODR+0xd0>
 800291a:	2b10      	cmp	r3, #16
 800291c:	d1f0      	bne.n	8002900 <LPS22HB_T_Set_ODR+0x90>
      *odr = 1.0f;
 800291e:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8002922:	606b      	str	r3, [r5, #4]
  return COMPONENT_OK;
 8002924:	2000      	movs	r0, #0
 8002926:	e7b5      	b.n	8002894 <LPS22HB_T_Set_ODR+0x24>
      *odr = 10.0f;
 8002928:	4b08      	ldr	r3, [pc, #32]	; (800294c <LPS22HB_T_Set_ODR+0xdc>)
 800292a:	606b      	str	r3, [r5, #4]
 800292c:	e7fa      	b.n	8002924 <LPS22HB_T_Set_ODR+0xb4>
      *odr = 25.0f;
 800292e:	4b08      	ldr	r3, [pc, #32]	; (8002950 <LPS22HB_T_Set_ODR+0xe0>)
 8002930:	606b      	str	r3, [r5, #4]
 8002932:	e7f7      	b.n	8002924 <LPS22HB_T_Set_ODR+0xb4>
      *odr = 75.0f;
 8002934:	4b04      	ldr	r3, [pc, #16]	; (8002948 <LPS22HB_T_Set_ODR+0xd8>)
 8002936:	606b      	str	r3, [r5, #4]
 8002938:	e7f4      	b.n	8002924 <LPS22HB_T_Set_ODR+0xb4>
      *odr = 50.0f;
 800293a:	4b06      	ldr	r3, [pc, #24]	; (8002954 <LPS22HB_T_Set_ODR+0xe4>)
 800293c:	606b      	str	r3, [r5, #4]
 800293e:	e7f1      	b.n	8002924 <LPS22HB_T_Set_ODR+0xb4>
      *odr = 0.0f;
 8002940:	2300      	movs	r3, #0
 8002942:	606b      	str	r3, [r5, #4]
 8002944:	e7ee      	b.n	8002924 <LPS22HB_T_Set_ODR+0xb4>
 8002946:	bf00      	nop
 8002948:	42960000 	.word	0x42960000
 800294c:	41200000 	.word	0x41200000
 8002950:	41c80000 	.word	0x41c80000
 8002954:	42480000 	.word	0x42480000
 8002958:	bf800000 	.word	0xbf800000

0800295c <LSM303AGR_ACC_WriteReg>:
*                                 length of buffer
* Output      : None
* Return      : None
*******************************************************************************/
status_t LSM303AGR_ACC_WriteReg(void *handle, u8_t Reg, u8_t *Bufp, u16_t len)
{
 800295c:	b508      	push	{r3, lr}

  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 800295e:	f004 fdb7 	bl	80074d0 <Sensor_IO_Write>
  }
  else
  {
    return MEMS_SUCCESS;
  }
}
 8002962:	fab0 f080 	clz	r0, r0
 8002966:	0940      	lsrs	r0, r0, #5
 8002968:	bd08      	pop	{r3, pc}
 800296a:	bf00      	nop

0800296c <LSM303AGR_ACC_ReadReg>:
*                                 length of buffer
* Output      : None
* Return      : None
*******************************************************************************/
status_t LSM303AGR_ACC_ReadReg(void *handle, u8_t Reg, u8_t *Bufp, u16_t len)
{
 800296c:	b508      	push	{r3, lr}

  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800296e:	f004 fdfd 	bl	800756c <Sensor_IO_Read>
  }
  else
  {
    return MEMS_SUCCESS;
  }
}
 8002972:	fab0 f080 	clz	r0, r0
 8002976:	0940      	lsrs	r0, r0, #5
 8002978:	bd08      	pop	{r3, pc}
 800297a:	bf00      	nop

0800297c <LSM303AGR_ACC_R_WHO_AM_I>:
* Input          : Pointer to u8_t
* Output         : Status of WHO_AM_I
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_WHO_AM_I(void *handle, u8_t *value)
{
 800297c:	b508      	push	{r3, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800297e:	460a      	mov	r2, r1
 8002980:	2301      	movs	r3, #1
 8002982:	210f      	movs	r1, #15
 8002984:	f004 fdf2 	bl	800756c <Sensor_IO_Read>

  *value &= LSM303AGR_ACC_WHO_AM_I_MASK; //coerce
  *value = *value >> LSM303AGR_ACC_WHO_AM_I_POSITION; //mask

  return MEMS_SUCCESS;
}
 8002988:	fab0 f080 	clz	r0, r0
 800298c:	0940      	lsrs	r0, r0, #5
 800298e:	bd08      	pop	{r3, pc}

08002990 <LSM303AGR_ACC_W_BlockDataUpdate>:
* Input          : LSM303AGR_ACC_BDU_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_BlockDataUpdate(void *handle, LSM303AGR_ACC_BDU_t newValue)
{
 8002990:	b530      	push	{r4, r5, lr}
 8002992:	b083      	sub	sp, #12
 8002994:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002996:	f10d 0207 	add.w	r2, sp, #7
 800299a:	2301      	movs	r3, #1
 800299c:	2123      	movs	r1, #35	; 0x23
{
 800299e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80029a0:	f004 fde4 	bl	800756c <Sensor_IO_Read>
 80029a4:	b110      	cbz	r0, 80029ac <LSM303AGR_ACC_W_BlockDataUpdate+0x1c>
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
    return MEMS_ERROR;
 80029a6:	2000      	movs	r0, #0

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 80029a8:	b003      	add	sp, #12
 80029aa:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_ACC_BDU_MASK;
 80029ac:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80029b0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  value |= newValue;
 80029b4:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 80029b6:	f10d 0207 	add.w	r2, sp, #7
 80029ba:	4628      	mov	r0, r5
 80029bc:	2301      	movs	r3, #1
 80029be:	2123      	movs	r1, #35	; 0x23
  value |= newValue;
 80029c0:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 80029c4:	f004 fd84 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 80029c8:	fab0 f080 	clz	r0, r0
 80029cc:	0940      	lsrs	r0, r0, #5
}
 80029ce:	b003      	add	sp, #12
 80029d0:	bd30      	pop	{r4, r5, pc}
 80029d2:	bf00      	nop

080029d4 <LSM303AGR_ACC_W_FullScale>:
* Input          : LSM303AGR_ACC_FS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FullScale(void *handle, LSM303AGR_ACC_FS_t newValue)
{
 80029d4:	b530      	push	{r4, r5, lr}
 80029d6:	b083      	sub	sp, #12
 80029d8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80029da:	f10d 0207 	add.w	r2, sp, #7
 80029de:	2301      	movs	r3, #1
 80029e0:	2123      	movs	r1, #35	; 0x23
{
 80029e2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80029e4:	f004 fdc2 	bl	800756c <Sensor_IO_Read>
 80029e8:	b110      	cbz	r0, 80029f0 <LSM303AGR_ACC_W_FullScale+0x1c>
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
    return MEMS_ERROR;
 80029ea:	2000      	movs	r0, #0

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 80029ec:	b003      	add	sp, #12
 80029ee:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_ACC_FS_MASK;
 80029f0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80029f4:	f023 0330 	bic.w	r3, r3, #48	; 0x30
  value |= newValue;
 80029f8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 80029fa:	f10d 0207 	add.w	r2, sp, #7
 80029fe:	4628      	mov	r0, r5
 8002a00:	2301      	movs	r3, #1
 8002a02:	2123      	movs	r1, #35	; 0x23
  value |= newValue;
 8002a04:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8002a08:	f004 fd62 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8002a0c:	fab0 f080 	clz	r0, r0
 8002a10:	0940      	lsrs	r0, r0, #5
}
 8002a12:	b003      	add	sp, #12
 8002a14:	bd30      	pop	{r4, r5, pc}
 8002a16:	bf00      	nop

08002a18 <LSM303AGR_ACC_R_FullScale>:
* Input          : Pointer to LSM303AGR_ACC_FS_t
* Output         : Status of FS see LSM303AGR_ACC_FS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FullScale(void *handle, LSM303AGR_ACC_FS_t *value)
{
 8002a18:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002a1a:	460a      	mov	r2, r1
{
 8002a1c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002a1e:	2301      	movs	r3, #1
 8002a20:	2123      	movs	r1, #35	; 0x23
 8002a22:	f004 fda3 	bl	800756c <Sensor_IO_Read>
 8002a26:	b108      	cbz	r0, 8002a2c <LSM303AGR_ACC_R_FullScale+0x14>
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
    return MEMS_ERROR;
 8002a28:	2000      	movs	r0, #0
 8002a2a:	bd10      	pop	{r4, pc}

  *value &= LSM303AGR_ACC_FS_MASK; //mask
 8002a2c:	7823      	ldrb	r3, [r4, #0]
 8002a2e:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8002a32:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8002a34:	2001      	movs	r0, #1
}
 8002a36:	bd10      	pop	{r4, pc}

08002a38 <LSM303AGR_ACC_Get_Raw_Acceleration>:
* Input          : pointer to [u8_t]
* Output         : Acceleration buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_Get_Raw_Acceleration(void *handle, u8_t *buff)
{
 8002a38:	b508      	push	{r3, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002a3a:	460a      	mov	r2, r1
 8002a3c:	2306      	movs	r3, #6
 8002a3e:	2128      	movs	r1, #40	; 0x28
 8002a40:	f004 fd94 	bl	800756c <Sensor_IO_Read>
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_OUT_X_L, buff, 6 ) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8002a44:	fab0 f080 	clz	r0, r0
 8002a48:	0940      	lsrs	r0, r0, #5
 8002a4a:	bd08      	pop	{r3, pc}

08002a4c <LSM303AGR_ACC_Get_Acceleration>:
    62520,  /* FS @8g */
    187580, /* FS @16g */
  },
};
status_t LSM303AGR_ACC_Get_Acceleration(void *handle, int *buff)
{
 8002a4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002a50:	b084      	sub	sp, #16
 8002a52:	460d      	mov	r5, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002a54:	2301      	movs	r3, #1
 8002a56:	f10d 0206 	add.w	r2, sp, #6
 8002a5a:	2123      	movs	r1, #35	; 0x23
{
 8002a5c:	4607      	mov	r7, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002a5e:	f004 fd85 	bl	800756c <Sensor_IO_Read>
 8002a62:	b928      	cbnz	r0, 8002a70 <LSM303AGR_ACC_Get_Acceleration+0x24>
status_t LSM303AGR_ACC_R_HiRes(void *handle, LSM303AGR_ACC_HR_t *value)
{
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
    return MEMS_ERROR;

  *value &= LSM303AGR_ACC_HR_MASK; //mask
 8002a64:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8002a68:	f003 0308 	and.w	r3, r3, #8
 8002a6c:	f88d 3006 	strb.w	r3, [sp, #6]
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002a70:	2301      	movs	r3, #1
 8002a72:	f10d 0205 	add.w	r2, sp, #5
 8002a76:	2120      	movs	r1, #32
 8002a78:	4638      	mov	r0, r7
 8002a7a:	f004 fd77 	bl	800756c <Sensor_IO_Read>
 8002a7e:	2800      	cmp	r0, #0
 8002a80:	d07d      	beq.n	8002b7e <LSM303AGR_ACC_Get_Acceleration+0x132>
 8002a82:	f89d 0005 	ldrb.w	r0, [sp, #5]
  if (lp == LSM303AGR_ACC_LPEN_ENABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 8002a86:	2808      	cmp	r0, #8
 8002a88:	f000 8082 	beq.w	8002b90 <LSM303AGR_ACC_Get_Acceleration+0x144>
  else if (lp == LSM303AGR_ACC_LPEN_DISABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 8002a8c:	2800      	cmp	r0, #0
 8002a8e:	d171      	bne.n	8002b74 <LSM303AGR_ACC_Get_Acceleration+0x128>
 8002a90:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8002a94:	2b00      	cmp	r3, #0
 8002a96:	d16b      	bne.n	8002b70 <LSM303AGR_ACC_Get_Acceleration+0x124>
 8002a98:	2401      	movs	r4, #1
 8002a9a:	f04f 0806 	mov.w	r8, #6
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002a9e:	2301      	movs	r3, #1
 8002aa0:	f10d 0207 	add.w	r2, sp, #7
 8002aa4:	2123      	movs	r1, #35	; 0x23
 8002aa6:	4638      	mov	r0, r7
 8002aa8:	f004 fd60 	bl	800756c <Sensor_IO_Read>
 8002aac:	2800      	cmp	r0, #0
 8002aae:	d076      	beq.n	8002b9e <LSM303AGR_ACC_Get_Acceleration+0x152>
 8002ab0:	f89d 0007 	ldrb.w	r0, [sp, #7]
  switch (fs)
 8002ab4:	2820      	cmp	r0, #32
 8002ab6:	d07a      	beq.n	8002bae <LSM303AGR_ACC_Get_Acceleration+0x162>
 8002ab8:	2830      	cmp	r0, #48	; 0x30
 8002aba:	d07e      	beq.n	8002bba <LSM303AGR_ACC_Get_Acceleration+0x16e>
 8002abc:	f1a0 0610 	sub.w	r6, r0, #16
 8002ac0:	fab6 f686 	clz	r6, r6
 8002ac4:	0976      	lsrs	r6, r6, #5
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002ac6:	aa02      	add	r2, sp, #8
 8002ac8:	4638      	mov	r0, r7
 8002aca:	2306      	movs	r3, #6
 8002acc:	2128      	movs	r1, #40	; 0x28
 8002ace:	f004 fd4d 	bl	800756c <Sensor_IO_Read>
  buff[0] = ((raw_data_tmp.i16bit[0] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 8002ad2:	4a3b      	ldr	r2, [pc, #236]	; (8002bc0 <LSM303AGR_ACC_Get_Acceleration+0x174>)
 8002ad4:	f9bd 3008 	ldrsh.w	r3, [sp, #8]
 8002ad8:	eb06 0084 	add.w	r0, r6, r4, lsl #2
 8002adc:	eb02 01c0 	add.w	r1, r2, r0, lsl #3
 8002ae0:	f852 6030 	ldr.w	r6, [r2, r0, lsl #3]
 8002ae4:	684c      	ldr	r4, [r1, #4]
 8002ae6:	fa43 f008 	asr.w	r0, r3, r8
 8002aea:	fb00 f104 	mul.w	r1, r0, r4
 8002aee:	17c3      	asrs	r3, r0, #31
 8002af0:	fb06 1303 	mla	r3, r6, r3, r1
 8002af4:	fba0 0106 	umull	r0, r1, r0, r6
 8002af8:	f510 70fa 	adds.w	r0, r0, #500	; 0x1f4
 8002afc:	4419      	add	r1, r3
 8002afe:	f141 0100 	adc.w	r1, r1, #0
 8002b02:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8002b06:	2300      	movs	r3, #0
 8002b08:	f7fd ffb4 	bl	8000a74 <__aeabi_ldivmod>
  buff[1] = ((raw_data_tmp.i16bit[1] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 8002b0c:	f9bd 300a 	ldrsh.w	r3, [sp, #10]
  buff[0] = ((raw_data_tmp.i16bit[0] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 8002b10:	6028      	str	r0, [r5, #0]
  buff[1] = ((raw_data_tmp.i16bit[1] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 8002b12:	fa43 f008 	asr.w	r0, r3, r8
 8002b16:	fb00 f104 	mul.w	r1, r0, r4
 8002b1a:	17c3      	asrs	r3, r0, #31
 8002b1c:	fb06 1303 	mla	r3, r6, r3, r1
 8002b20:	fba0 0106 	umull	r0, r1, r0, r6
 8002b24:	f510 70fa 	adds.w	r0, r0, #500	; 0x1f4
 8002b28:	4419      	add	r1, r3
 8002b2a:	f141 0100 	adc.w	r1, r1, #0
 8002b2e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8002b32:	2300      	movs	r3, #0
 8002b34:	f7fd ff9e 	bl	8000a74 <__aeabi_ldivmod>
  buff[2] = ((raw_data_tmp.i16bit[2] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 8002b38:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
  buff[1] = ((raw_data_tmp.i16bit[1] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 8002b3c:	6068      	str	r0, [r5, #4]
  buff[2] = ((raw_data_tmp.i16bit[2] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 8002b3e:	fa43 f008 	asr.w	r0, r3, r8
 8002b42:	17c3      	asrs	r3, r0, #31
 8002b44:	fb00 f404 	mul.w	r4, r0, r4
 8002b48:	fb06 4403 	mla	r4, r6, r3, r4
 8002b4c:	fba0 0106 	umull	r0, r1, r0, r6
 8002b50:	f510 70fa 	adds.w	r0, r0, #500	; 0x1f4
 8002b54:	4421      	add	r1, r4
 8002b56:	f141 0100 	adc.w	r1, r1, #0
 8002b5a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8002b5e:	2300      	movs	r3, #0
 8002b60:	f7fd ff88 	bl	8000a74 <__aeabi_ldivmod>
  return MEMS_SUCCESS;
 8002b64:	2301      	movs	r3, #1
  buff[2] = ((raw_data_tmp.i16bit[2] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 8002b66:	60a8      	str	r0, [r5, #8]
}
 8002b68:	4618      	mov	r0, r3
 8002b6a:	b004      	add	sp, #16
 8002b6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if (lp == LSM303AGR_ACC_LPEN_DISABLED && hr == LSM303AGR_ACC_HR_ENABLED)
 8002b70:	2b08      	cmp	r3, #8
 8002b72:	d01e      	beq.n	8002bb2 <LSM303AGR_ACC_Get_Acceleration+0x166>
    return MEMS_ERROR;
 8002b74:	2300      	movs	r3, #0
}
 8002b76:	4618      	mov	r0, r3
 8002b78:	b004      	add	sp, #16
 8002b7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  *value &= LSM303AGR_ACC_LPEN_MASK; //mask
 8002b7e:	f89d 0005 	ldrb.w	r0, [sp, #5]
 8002b82:	f000 0008 	and.w	r0, r0, #8
  if (lp == LSM303AGR_ACC_LPEN_ENABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 8002b86:	2808      	cmp	r0, #8
  *value &= LSM303AGR_ACC_LPEN_MASK; //mask
 8002b88:	f88d 0005 	strb.w	r0, [sp, #5]
  if (lp == LSM303AGR_ACC_LPEN_ENABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 8002b8c:	f47f af7e 	bne.w	8002a8c <LSM303AGR_ACC_Get_Acceleration+0x40>
 8002b90:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8002b94:	2b00      	cmp	r3, #0
 8002b96:	d1ed      	bne.n	8002b74 <LSM303AGR_ACC_Get_Acceleration+0x128>
 8002b98:	4680      	mov	r8, r0
 8002b9a:	2402      	movs	r4, #2
 8002b9c:	e77f      	b.n	8002a9e <LSM303AGR_ACC_Get_Acceleration+0x52>
  *value &= LSM303AGR_ACC_FS_MASK; //mask
 8002b9e:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8002ba2:	f000 0030 	and.w	r0, r0, #48	; 0x30
  switch (fs)
 8002ba6:	2820      	cmp	r0, #32
  *value &= LSM303AGR_ACC_FS_MASK; //mask
 8002ba8:	f88d 0007 	strb.w	r0, [sp, #7]
  switch (fs)
 8002bac:	d184      	bne.n	8002ab8 <LSM303AGR_ACC_Get_Acceleration+0x6c>
      break;
 8002bae:	2602      	movs	r6, #2
 8002bb0:	e789      	b.n	8002ac6 <LSM303AGR_ACC_Get_Acceleration+0x7a>
 8002bb2:	4604      	mov	r4, r0
 8002bb4:	f04f 0804 	mov.w	r8, #4
 8002bb8:	e771      	b.n	8002a9e <LSM303AGR_ACC_Get_Acceleration+0x52>
      break;
 8002bba:	2603      	movs	r6, #3
 8002bbc:	e783      	b.n	8002ac6 <LSM303AGR_ACC_Get_Acceleration+0x7a>
 8002bbe:	bf00      	nop
 8002bc0:	0800d4e0 	.word	0x0800d4e0

08002bc4 <LSM303AGR_ACC_W_ODR>:
{
 8002bc4:	b530      	push	{r4, r5, lr}
 8002bc6:	b083      	sub	sp, #12
 8002bc8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002bca:	f10d 0207 	add.w	r2, sp, #7
 8002bce:	2301      	movs	r3, #1
 8002bd0:	2120      	movs	r1, #32
{
 8002bd2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002bd4:	f004 fcca 	bl	800756c <Sensor_IO_Read>
 8002bd8:	b110      	cbz	r0, 8002be0 <LSM303AGR_ACC_W_ODR+0x1c>
    return MEMS_ERROR;
 8002bda:	2000      	movs	r0, #0
}
 8002bdc:	b003      	add	sp, #12
 8002bde:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_ACC_ODR_MASK;
 8002be0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8002be4:	f003 030f 	and.w	r3, r3, #15
  value |= newValue;
 8002be8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8002bea:	f10d 0207 	add.w	r2, sp, #7
 8002bee:	4628      	mov	r0, r5
 8002bf0:	2301      	movs	r3, #1
 8002bf2:	2120      	movs	r1, #32
  value |= newValue;
 8002bf4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8002bf8:	f004 fc6a 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8002bfc:	fab0 f080 	clz	r0, r0
 8002c00:	0940      	lsrs	r0, r0, #5
}
 8002c02:	b003      	add	sp, #12
 8002c04:	bd30      	pop	{r4, r5, pc}
 8002c06:	bf00      	nop

08002c08 <LSM303AGR_ACC_R_ODR>:
{
 8002c08:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002c0a:	460a      	mov	r2, r1
{
 8002c0c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002c0e:	2301      	movs	r3, #1
 8002c10:	2120      	movs	r1, #32
 8002c12:	f004 fcab 	bl	800756c <Sensor_IO_Read>
 8002c16:	b108      	cbz	r0, 8002c1c <LSM303AGR_ACC_R_ODR+0x14>
    return MEMS_ERROR;
 8002c18:	2000      	movs	r0, #0
 8002c1a:	bd10      	pop	{r4, pc}
  *value &= LSM303AGR_ACC_ODR_MASK; //mask
 8002c1c:	7823      	ldrb	r3, [r4, #0]
 8002c1e:	f023 030f 	bic.w	r3, r3, #15
 8002c22:	7023      	strb	r3, [r4, #0]
  return MEMS_SUCCESS;
 8002c24:	2001      	movs	r0, #1
}
 8002c26:	bd10      	pop	{r4, pc}

08002c28 <LSM303AGR_ACC_W_XEN>:
{
 8002c28:	b530      	push	{r4, r5, lr}
 8002c2a:	b083      	sub	sp, #12
 8002c2c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002c2e:	f10d 0207 	add.w	r2, sp, #7
 8002c32:	2301      	movs	r3, #1
 8002c34:	2120      	movs	r1, #32
{
 8002c36:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002c38:	f004 fc98 	bl	800756c <Sensor_IO_Read>
 8002c3c:	b110      	cbz	r0, 8002c44 <LSM303AGR_ACC_W_XEN+0x1c>
    return MEMS_ERROR;
 8002c3e:	2000      	movs	r0, #0
}
 8002c40:	b003      	add	sp, #12
 8002c42:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_ACC_XEN_MASK;
 8002c44:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8002c48:	f023 0301 	bic.w	r3, r3, #1
  value |= newValue;
 8002c4c:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8002c4e:	f10d 0207 	add.w	r2, sp, #7
 8002c52:	4628      	mov	r0, r5
 8002c54:	2301      	movs	r3, #1
 8002c56:	2120      	movs	r1, #32
  value |= newValue;
 8002c58:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8002c5c:	f004 fc38 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8002c60:	fab0 f080 	clz	r0, r0
 8002c64:	0940      	lsrs	r0, r0, #5
}
 8002c66:	b003      	add	sp, #12
 8002c68:	bd30      	pop	{r4, r5, pc}
 8002c6a:	bf00      	nop

08002c6c <LSM303AGR_ACC_R_XEN>:
{
 8002c6c:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002c6e:	460a      	mov	r2, r1
{
 8002c70:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002c72:	2301      	movs	r3, #1
 8002c74:	2120      	movs	r1, #32
 8002c76:	f004 fc79 	bl	800756c <Sensor_IO_Read>
 8002c7a:	b108      	cbz	r0, 8002c80 <LSM303AGR_ACC_R_XEN+0x14>
    return MEMS_ERROR;
 8002c7c:	2000      	movs	r0, #0
 8002c7e:	bd10      	pop	{r4, pc}
  *value &= LSM303AGR_ACC_XEN_MASK; //mask
 8002c80:	7823      	ldrb	r3, [r4, #0]
 8002c82:	f003 0301 	and.w	r3, r3, #1
 8002c86:	7023      	strb	r3, [r4, #0]
  return MEMS_SUCCESS;
 8002c88:	2001      	movs	r0, #1
}
 8002c8a:	bd10      	pop	{r4, pc}

08002c8c <LSM303AGR_ACC_W_YEN>:
{
 8002c8c:	b530      	push	{r4, r5, lr}
 8002c8e:	b083      	sub	sp, #12
 8002c90:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002c92:	f10d 0207 	add.w	r2, sp, #7
 8002c96:	2301      	movs	r3, #1
 8002c98:	2120      	movs	r1, #32
{
 8002c9a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002c9c:	f004 fc66 	bl	800756c <Sensor_IO_Read>
 8002ca0:	b110      	cbz	r0, 8002ca8 <LSM303AGR_ACC_W_YEN+0x1c>
    return MEMS_ERROR;
 8002ca2:	2000      	movs	r0, #0
}
 8002ca4:	b003      	add	sp, #12
 8002ca6:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_ACC_YEN_MASK;
 8002ca8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8002cac:	f023 0302 	bic.w	r3, r3, #2
  value |= newValue;
 8002cb0:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8002cb2:	f10d 0207 	add.w	r2, sp, #7
 8002cb6:	4628      	mov	r0, r5
 8002cb8:	2301      	movs	r3, #1
 8002cba:	2120      	movs	r1, #32
  value |= newValue;
 8002cbc:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8002cc0:	f004 fc06 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8002cc4:	fab0 f080 	clz	r0, r0
 8002cc8:	0940      	lsrs	r0, r0, #5
}
 8002cca:	b003      	add	sp, #12
 8002ccc:	bd30      	pop	{r4, r5, pc}
 8002cce:	bf00      	nop

08002cd0 <LSM303AGR_ACC_R_YEN>:
{
 8002cd0:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002cd2:	460a      	mov	r2, r1
{
 8002cd4:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002cd6:	2301      	movs	r3, #1
 8002cd8:	2120      	movs	r1, #32
 8002cda:	f004 fc47 	bl	800756c <Sensor_IO_Read>
 8002cde:	b108      	cbz	r0, 8002ce4 <LSM303AGR_ACC_R_YEN+0x14>
    return MEMS_ERROR;
 8002ce0:	2000      	movs	r0, #0
 8002ce2:	bd10      	pop	{r4, pc}
  *value &= LSM303AGR_ACC_YEN_MASK; //mask
 8002ce4:	7823      	ldrb	r3, [r4, #0]
 8002ce6:	f003 0302 	and.w	r3, r3, #2
 8002cea:	7023      	strb	r3, [r4, #0]
  return MEMS_SUCCESS;
 8002cec:	2001      	movs	r0, #1
}
 8002cee:	bd10      	pop	{r4, pc}

08002cf0 <LSM303AGR_ACC_W_ZEN>:
{
 8002cf0:	b530      	push	{r4, r5, lr}
 8002cf2:	b083      	sub	sp, #12
 8002cf4:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002cf6:	f10d 0207 	add.w	r2, sp, #7
 8002cfa:	2301      	movs	r3, #1
 8002cfc:	2120      	movs	r1, #32
{
 8002cfe:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002d00:	f004 fc34 	bl	800756c <Sensor_IO_Read>
 8002d04:	b110      	cbz	r0, 8002d0c <LSM303AGR_ACC_W_ZEN+0x1c>
    return MEMS_ERROR;
 8002d06:	2000      	movs	r0, #0
}
 8002d08:	b003      	add	sp, #12
 8002d0a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_ACC_ZEN_MASK;
 8002d0c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8002d10:	f023 0304 	bic.w	r3, r3, #4
  value |= newValue;
 8002d14:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8002d16:	f10d 0207 	add.w	r2, sp, #7
 8002d1a:	4628      	mov	r0, r5
 8002d1c:	2301      	movs	r3, #1
 8002d1e:	2120      	movs	r1, #32
  value |= newValue;
 8002d20:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8002d24:	f004 fbd4 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8002d28:	fab0 f080 	clz	r0, r0
 8002d2c:	0940      	lsrs	r0, r0, #5
}
 8002d2e:	b003      	add	sp, #12
 8002d30:	bd30      	pop	{r4, r5, pc}
 8002d32:	bf00      	nop

08002d34 <LSM303AGR_ACC_R_ZEN>:
{
 8002d34:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002d36:	460a      	mov	r2, r1
{
 8002d38:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002d3a:	2301      	movs	r3, #1
 8002d3c:	2120      	movs	r1, #32
 8002d3e:	f004 fc15 	bl	800756c <Sensor_IO_Read>
 8002d42:	b108      	cbz	r0, 8002d48 <LSM303AGR_ACC_R_ZEN+0x14>
    return MEMS_ERROR;
 8002d44:	2000      	movs	r0, #0
 8002d46:	bd10      	pop	{r4, pc}
  *value &= LSM303AGR_ACC_ZEN_MASK; //mask
 8002d48:	7823      	ldrb	r3, [r4, #0]
 8002d4a:	f003 0304 	and.w	r3, r3, #4
 8002d4e:	7023      	strb	r3, [r4, #0]
  return MEMS_SUCCESS;
 8002d50:	2001      	movs	r0, #1
}
 8002d52:	bd10      	pop	{r4, pc}

08002d54 <LSM303AGR_ACC_R_LOWPWR_EN>:
{
 8002d54:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002d56:	460a      	mov	r2, r1
{
 8002d58:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002d5a:	2301      	movs	r3, #1
 8002d5c:	2120      	movs	r1, #32
 8002d5e:	f004 fc05 	bl	800756c <Sensor_IO_Read>
 8002d62:	b108      	cbz	r0, 8002d68 <LSM303AGR_ACC_R_LOWPWR_EN+0x14>
    return MEMS_ERROR;
 8002d64:	2000      	movs	r0, #0
 8002d66:	bd10      	pop	{r4, pc}
  *value &= LSM303AGR_ACC_LPEN_MASK; //mask
 8002d68:	7823      	ldrb	r3, [r4, #0]
 8002d6a:	f003 0308 	and.w	r3, r3, #8
 8002d6e:	7023      	strb	r3, [r4, #0]
  return MEMS_SUCCESS;
 8002d70:	2001      	movs	r0, #1
}
 8002d72:	bd10      	pop	{r4, pc}

08002d74 <LSM303AGR_ACC_R_HiRes>:
{
 8002d74:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002d76:	460a      	mov	r2, r1
{
 8002d78:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002d7a:	2301      	movs	r3, #1
 8002d7c:	2123      	movs	r1, #35	; 0x23
 8002d7e:	f004 fbf5 	bl	800756c <Sensor_IO_Read>
 8002d82:	b108      	cbz	r0, 8002d88 <LSM303AGR_ACC_R_HiRes+0x14>
    return MEMS_ERROR;
 8002d84:	2000      	movs	r0, #0
 8002d86:	bd10      	pop	{r4, pc}
  *value &= LSM303AGR_ACC_HR_MASK; //mask
 8002d88:	7823      	ldrb	r3, [r4, #0]
 8002d8a:	f003 0308 	and.w	r3, r3, #8
 8002d8e:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8002d90:	2001      	movs	r0, #1
}
 8002d92:	bd10      	pop	{r4, pc}

08002d94 <LSM303AGR_ACC_R_XDataAvail>:
* Input          : Pointer to LSM303AGR_ACC_XDA_t
* Output         : Status of XDA see LSM303AGR_ACC_XDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XDataAvail(void *handle, LSM303AGR_ACC_XDA_t *value)
{
 8002d94:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002d96:	460a      	mov	r2, r1
{
 8002d98:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002d9a:	2301      	movs	r3, #1
 8002d9c:	2127      	movs	r1, #39	; 0x27
 8002d9e:	f004 fbe5 	bl	800756c <Sensor_IO_Read>
 8002da2:	b108      	cbz	r0, 8002da8 <LSM303AGR_ACC_R_XDataAvail+0x14>
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
    return MEMS_ERROR;
 8002da4:	2000      	movs	r0, #0
 8002da6:	bd10      	pop	{r4, pc}

  *value &= LSM303AGR_ACC_XDA_MASK; //mask
 8002da8:	7823      	ldrb	r3, [r4, #0]
 8002daa:	f003 0301 	and.w	r3, r3, #1
 8002dae:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8002db0:	2001      	movs	r0, #1
}
 8002db2:	bd10      	pop	{r4, pc}

08002db4 <LSM303AGR_ACC_W_FifoMode>:
* Input          : LSM303AGR_ACC_FM_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FifoMode(void *handle, LSM303AGR_ACC_FM_t newValue)
{
 8002db4:	b530      	push	{r4, r5, lr}
 8002db6:	b083      	sub	sp, #12
 8002db8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002dba:	f10d 0207 	add.w	r2, sp, #7
 8002dbe:	2301      	movs	r3, #1
 8002dc0:	212e      	movs	r1, #46	; 0x2e
{
 8002dc2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8002dc4:	f004 fbd2 	bl	800756c <Sensor_IO_Read>
 8002dc8:	b110      	cbz	r0, 8002dd0 <LSM303AGR_ACC_W_FifoMode+0x1c>
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
    return MEMS_ERROR;
 8002dca:	2000      	movs	r0, #0

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8002dcc:	b003      	add	sp, #12
 8002dce:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_ACC_FM_MASK;
 8002dd0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8002dd4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  value |= newValue;
 8002dd8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8002dda:	f10d 0207 	add.w	r2, sp, #7
 8002dde:	4628      	mov	r0, r5
 8002de0:	2301      	movs	r3, #1
 8002de2:	212e      	movs	r1, #46	; 0x2e
  value |= newValue;
 8002de4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8002de8:	f004 fb72 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8002dec:	fab0 f080 	clz	r0, r0
 8002df0:	0940      	lsrs	r0, r0, #5
}
 8002df2:	b003      	add	sp, #12
 8002df4:	bd30      	pop	{r4, r5, pc}
 8002df6:	bf00      	nop

08002df8 <LSM303AGR_X_Get_DRDY_Status>:
 * @param status the data ready status
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LSM303AGR_X_Get_DRDY_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 8002df8:	b510      	push	{r4, lr}
 8002dfa:	b082      	sub	sp, #8
 8002dfc:	460c      	mov	r4, r1

  LSM303AGR_ACC_XDA_t status_raw;

  if ( LSM303AGR_ACC_R_XDataAvail( (void *)handle, &status_raw ) == MEMS_ERROR )
 8002dfe:	f10d 0107 	add.w	r1, sp, #7
 8002e02:	f7ff ffc7 	bl	8002d94 <LSM303AGR_ACC_R_XDataAvail>
 8002e06:	b140      	cbz	r0, 8002e1a <LSM303AGR_X_Get_DRDY_Status+0x22>
  {
    return COMPONENT_ERROR;
  }

  switch( status_raw )
 8002e08:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8002e0c:	b140      	cbz	r0, 8002e20 <LSM303AGR_X_Get_DRDY_Status+0x28>
 8002e0e:	2801      	cmp	r0, #1
 8002e10:	d103      	bne.n	8002e1a <LSM303AGR_X_Get_DRDY_Status+0x22>
  {
    case LSM303AGR_ACC_XDA_AVAILABLE:
      *status = 1;
 8002e12:	7020      	strb	r0, [r4, #0]
      break;
    default:
      return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
 8002e14:	2000      	movs	r0, #0
}
 8002e16:	b002      	add	sp, #8
 8002e18:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 8002e1a:	2001      	movs	r0, #1
}
 8002e1c:	b002      	add	sp, #8
 8002e1e:	bd10      	pop	{r4, pc}
      *status = 0;
 8002e20:	7020      	strb	r0, [r4, #0]
}
 8002e22:	b002      	add	sp, #8
 8002e24:	bd10      	pop	{r4, pc}
 8002e26:	bf00      	nop

08002e28 <LSM303AGR_X_Write_Reg>:
{
 8002e28:	b510      	push	{r4, lr}
 8002e2a:	b082      	sub	sp, #8
 8002e2c:	ac02      	add	r4, sp, #8
  if ( LSM303AGR_ACC_WriteReg( (void *)handle, reg, &data, 1 ) == MEMS_ERROR )
 8002e2e:	2301      	movs	r3, #1
{
 8002e30:	f804 2d01 	strb.w	r2, [r4, #-1]!
  if ( LSM303AGR_ACC_WriteReg( (void *)handle, reg, &data, 1 ) == MEMS_ERROR )
 8002e34:	4622      	mov	r2, r4
 8002e36:	f7ff fd91 	bl	800295c <LSM303AGR_ACC_WriteReg>
}
 8002e3a:	fab0 f080 	clz	r0, r0
 8002e3e:	0940      	lsrs	r0, r0, #5
 8002e40:	b002      	add	sp, #8
 8002e42:	bd10      	pop	{r4, pc}

08002e44 <LSM303AGR_X_Read_Reg>:
{
 8002e44:	b508      	push	{r3, lr}
  if ( LSM303AGR_ACC_ReadReg( (void *)handle, reg, data, 1 ) == MEMS_ERROR )
 8002e46:	2301      	movs	r3, #1
 8002e48:	f7ff fd90 	bl	800296c <LSM303AGR_ACC_ReadReg>
}
 8002e4c:	fab0 f080 	clz	r0, r0
 8002e50:	0940      	lsrs	r0, r0, #5
 8002e52:	bd08      	pop	{r3, pc}

08002e54 <LSM303AGR_X_Get_Axes_Status>:
{
 8002e54:	b530      	push	{r4, r5, lr}
 8002e56:	b083      	sub	sp, #12
 8002e58:	460d      	mov	r5, r1
  if ( LSM303AGR_ACC_R_XEN( (void *)handle, &xStatus ) == MEMS_ERROR )
 8002e5a:	f10d 0105 	add.w	r1, sp, #5
{
 8002e5e:	4604      	mov	r4, r0
  if ( LSM303AGR_ACC_R_XEN( (void *)handle, &xStatus ) == MEMS_ERROR )
 8002e60:	f7ff ff04 	bl	8002c6c <LSM303AGR_ACC_R_XEN>
 8002e64:	b910      	cbnz	r0, 8002e6c <LSM303AGR_X_Get_Axes_Status+0x18>
    return COMPONENT_ERROR;
 8002e66:	2001      	movs	r0, #1
}
 8002e68:	b003      	add	sp, #12
 8002e6a:	bd30      	pop	{r4, r5, pc}
  if ( LSM303AGR_ACC_R_YEN( (void *)handle, &yStatus ) == MEMS_ERROR )
 8002e6c:	f10d 0106 	add.w	r1, sp, #6
 8002e70:	4620      	mov	r0, r4
 8002e72:	f7ff ff2d 	bl	8002cd0 <LSM303AGR_ACC_R_YEN>
 8002e76:	2800      	cmp	r0, #0
 8002e78:	d0f5      	beq.n	8002e66 <LSM303AGR_X_Get_Axes_Status+0x12>
  if ( LSM303AGR_ACC_R_ZEN( (void *)handle, &zStatus ) == MEMS_ERROR )
 8002e7a:	4620      	mov	r0, r4
 8002e7c:	f10d 0107 	add.w	r1, sp, #7
 8002e80:	f7ff ff58 	bl	8002d34 <LSM303AGR_ACC_R_ZEN>
 8002e84:	2800      	cmp	r0, #0
 8002e86:	d0ee      	beq.n	8002e66 <LSM303AGR_X_Get_Axes_Status+0x12>
  xyz_enabled[0] = ( xStatus == LSM303AGR_ACC_XEN_ENABLED ) ? 1 : 0;
 8002e88:	f89d 1005 	ldrb.w	r1, [sp, #5]
  xyz_enabled[1] = ( yStatus == LSM303AGR_ACC_YEN_ENABLED ) ? 1 : 0;
 8002e8c:	f89d 2006 	ldrb.w	r2, [sp, #6]
  xyz_enabled[2] = ( zStatus == LSM303AGR_ACC_ZEN_ENABLED ) ? 1 : 0;
 8002e90:	f89d 3007 	ldrb.w	r3, [sp, #7]
  xyz_enabled[0] = ( xStatus == LSM303AGR_ACC_XEN_ENABLED ) ? 1 : 0;
 8002e94:	f1a1 0101 	sub.w	r1, r1, #1
  xyz_enabled[1] = ( yStatus == LSM303AGR_ACC_YEN_ENABLED ) ? 1 : 0;
 8002e98:	f1a2 0202 	sub.w	r2, r2, #2
  xyz_enabled[2] = ( zStatus == LSM303AGR_ACC_ZEN_ENABLED ) ? 1 : 0;
 8002e9c:	f1a3 0304 	sub.w	r3, r3, #4
  xyz_enabled[0] = ( xStatus == LSM303AGR_ACC_XEN_ENABLED ) ? 1 : 0;
 8002ea0:	fab1 f181 	clz	r1, r1
  xyz_enabled[1] = ( yStatus == LSM303AGR_ACC_YEN_ENABLED ) ? 1 : 0;
 8002ea4:	fab2 f282 	clz	r2, r2
  xyz_enabled[2] = ( zStatus == LSM303AGR_ACC_ZEN_ENABLED ) ? 1 : 0;
 8002ea8:	fab3 f383 	clz	r3, r3
  xyz_enabled[0] = ( xStatus == LSM303AGR_ACC_XEN_ENABLED ) ? 1 : 0;
 8002eac:	0949      	lsrs	r1, r1, #5
  xyz_enabled[1] = ( yStatus == LSM303AGR_ACC_YEN_ENABLED ) ? 1 : 0;
 8002eae:	0952      	lsrs	r2, r2, #5
  xyz_enabled[2] = ( zStatus == LSM303AGR_ACC_ZEN_ENABLED ) ? 1 : 0;
 8002eb0:	095b      	lsrs	r3, r3, #5
  xyz_enabled[0] = ( xStatus == LSM303AGR_ACC_XEN_ENABLED ) ? 1 : 0;
 8002eb2:	7029      	strb	r1, [r5, #0]
  xyz_enabled[1] = ( yStatus == LSM303AGR_ACC_YEN_ENABLED ) ? 1 : 0;
 8002eb4:	706a      	strb	r2, [r5, #1]
  xyz_enabled[2] = ( zStatus == LSM303AGR_ACC_ZEN_ENABLED ) ? 1 : 0;
 8002eb6:	70ab      	strb	r3, [r5, #2]
  return COMPONENT_OK;
 8002eb8:	2000      	movs	r0, #0
 8002eba:	e7d5      	b.n	8002e68 <LSM303AGR_X_Get_Axes_Status+0x14>

08002ebc <LSM303AGR_X_Set_FS_Value>:
           : ( fullScale <= 4.0f ) ? LSM303AGR_ACC_FS_4G
 8002ebc:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 8002ec0:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8002ec4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 8002ec8:	b508      	push	{r3, lr}
           : ( fullScale <= 4.0f ) ? LSM303AGR_ACC_FS_4G
 8002eca:	d90d      	bls.n	8002ee8 <LSM303AGR_X_Set_FS_Value+0x2c>
 8002ecc:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
 8002ed0:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8002ed4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002ed8:	d80d      	bhi.n	8002ef6 <LSM303AGR_X_Set_FS_Value+0x3a>
 8002eda:	2110      	movs	r1, #16
  if ( LSM303AGR_ACC_W_FullScale( (void *)handle, new_fs ) == MEMS_ERROR )
 8002edc:	f7ff fd7a 	bl	80029d4 <LSM303AGR_ACC_W_FullScale>
}
 8002ee0:	fab0 f080 	clz	r0, r0
 8002ee4:	0940      	lsrs	r0, r0, #5
 8002ee6:	bd08      	pop	{r3, pc}
           : ( fullScale <= 4.0f ) ? LSM303AGR_ACC_FS_4G
 8002ee8:	2100      	movs	r1, #0
  if ( LSM303AGR_ACC_W_FullScale( (void *)handle, new_fs ) == MEMS_ERROR )
 8002eea:	f7ff fd73 	bl	80029d4 <LSM303AGR_ACC_W_FullScale>
}
 8002eee:	fab0 f080 	clz	r0, r0
 8002ef2:	0940      	lsrs	r0, r0, #5
 8002ef4:	bd08      	pop	{r3, pc}
           : ( fullScale <= 4.0f ) ? LSM303AGR_ACC_FS_4G
 8002ef6:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
 8002efa:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8002efe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002f02:	bf94      	ite	ls
 8002f04:	2120      	movls	r1, #32
 8002f06:	2130      	movhi	r1, #48	; 0x30
  if ( LSM303AGR_ACC_W_FullScale( (void *)handle, new_fs ) == MEMS_ERROR )
 8002f08:	f7ff fd64 	bl	80029d4 <LSM303AGR_ACC_W_FullScale>
}
 8002f0c:	fab0 f080 	clz	r0, r0
 8002f10:	0940      	lsrs	r0, r0, #5
 8002f12:	bd08      	pop	{r3, pc}

08002f14 <LSM303AGR_X_Set_FS>:
  switch( fullScale )
 8002f14:	2902      	cmp	r1, #2
 8002f16:	d00c      	beq.n	8002f32 <LSM303AGR_X_Set_FS+0x1e>
 8002f18:	2904      	cmp	r1, #4
 8002f1a:	d002      	beq.n	8002f22 <LSM303AGR_X_Set_FS+0xe>
 8002f1c:	b111      	cbz	r1, 8002f24 <LSM303AGR_X_Set_FS+0x10>
      return COMPONENT_ERROR;
 8002f1e:	2001      	movs	r0, #1
 8002f20:	4770      	bx	lr
      new_fs = LSM303AGR_ACC_FS_8G;
 8002f22:	2120      	movs	r1, #32
{
 8002f24:	b508      	push	{r3, lr}
  if ( LSM303AGR_ACC_W_FullScale( (void *)handle, new_fs ) == MEMS_ERROR )
 8002f26:	f7ff fd55 	bl	80029d4 <LSM303AGR_ACC_W_FullScale>
      return COMPONENT_ERROR;
 8002f2a:	fab0 f080 	clz	r0, r0
 8002f2e:	0940      	lsrs	r0, r0, #5
 8002f30:	bd08      	pop	{r3, pc}
      new_fs = LSM303AGR_ACC_FS_4G;
 8002f32:	2110      	movs	r1, #16
 8002f34:	e7f6      	b.n	8002f24 <LSM303AGR_X_Set_FS+0x10>
 8002f36:	bf00      	nop

08002f38 <LSM303AGR_X_Get_FS>:
{
 8002f38:	b510      	push	{r4, lr}
 8002f3a:	b082      	sub	sp, #8
 8002f3c:	460c      	mov	r4, r1
  if ( LSM303AGR_ACC_R_FullScale( (void *)handle, &fs_low_level ) == MEMS_ERROR )
 8002f3e:	f10d 0107 	add.w	r1, sp, #7
 8002f42:	f7ff fd69 	bl	8002a18 <LSM303AGR_ACC_R_FullScale>
 8002f46:	b170      	cbz	r0, 8002f66 <LSM303AGR_X_Get_FS+0x2e>
  switch( fs_low_level )
 8002f48:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8002f4c:	2810      	cmp	r0, #16
 8002f4e:	d013      	beq.n	8002f78 <LSM303AGR_X_Get_FS+0x40>
 8002f50:	d918      	bls.n	8002f84 <LSM303AGR_X_Get_FS+0x4c>
 8002f52:	2820      	cmp	r0, #32
 8002f54:	d00a      	beq.n	8002f6c <LSM303AGR_X_Get_FS+0x34>
 8002f56:	2830      	cmp	r0, #48	; 0x30
 8002f58:	d11a      	bne.n	8002f90 <LSM303AGR_X_Get_FS+0x58>
      *fullScale = 16.0f;
 8002f5a:	f04f 4383 	mov.w	r3, #1098907648	; 0x41800000
  return COMPONENT_OK;
 8002f5e:	2000      	movs	r0, #0
      *fullScale = 16.0f;
 8002f60:	6023      	str	r3, [r4, #0]
}
 8002f62:	b002      	add	sp, #8
 8002f64:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 8002f66:	2001      	movs	r0, #1
}
 8002f68:	b002      	add	sp, #8
 8002f6a:	bd10      	pop	{r4, pc}
      *fullScale =  8.0f;
 8002f6c:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
  return COMPONENT_OK;
 8002f70:	2000      	movs	r0, #0
      *fullScale =  8.0f;
 8002f72:	6023      	str	r3, [r4, #0]
}
 8002f74:	b002      	add	sp, #8
 8002f76:	bd10      	pop	{r4, pc}
      *fullScale =  4.0f;
 8002f78:	f04f 4381 	mov.w	r3, #1082130432	; 0x40800000
  return COMPONENT_OK;
 8002f7c:	2000      	movs	r0, #0
      *fullScale =  4.0f;
 8002f7e:	6023      	str	r3, [r4, #0]
}
 8002f80:	b002      	add	sp, #8
 8002f82:	bd10      	pop	{r4, pc}
  switch( fs_low_level )
 8002f84:	b920      	cbnz	r0, 8002f90 <LSM303AGR_X_Get_FS+0x58>
      *fullScale =  2.0f;
 8002f86:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002f8a:	6023      	str	r3, [r4, #0]
}
 8002f8c:	b002      	add	sp, #8
 8002f8e:	bd10      	pop	{r4, pc}
      *fullScale = -1.0f;
 8002f90:	4b02      	ldr	r3, [pc, #8]	; (8002f9c <LSM303AGR_X_Get_FS+0x64>)
 8002f92:	6023      	str	r3, [r4, #0]
      return COMPONENT_ERROR;
 8002f94:	2001      	movs	r0, #1
}
 8002f96:	b002      	add	sp, #8
 8002f98:	bd10      	pop	{r4, pc}
 8002f9a:	bf00      	nop
 8002f9c:	bf800000 	.word	0xbf800000

08002fa0 <LSM303AGR_X_Get_ODR>:
{
 8002fa0:	b510      	push	{r4, lr}
 8002fa2:	b082      	sub	sp, #8
 8002fa4:	460c      	mov	r4, r1
  if ( LSM303AGR_ACC_R_ODR( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 8002fa6:	f10d 0107 	add.w	r1, sp, #7
 8002faa:	f7ff fe2d 	bl	8002c08 <LSM303AGR_ACC_R_ODR>
 8002fae:	b1c0      	cbz	r0, 8002fe2 <LSM303AGR_X_Get_ODR+0x42>
  switch( odr_low_level )
 8002fb0:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8002fb4:	2830      	cmp	r0, #48	; 0x30
 8002fb6:	d02a      	beq.n	800300e <LSM303AGR_X_Get_ODR+0x6e>
 8002fb8:	d90a      	bls.n	8002fd0 <LSM303AGR_X_Get_ODR+0x30>
 8002fba:	2850      	cmp	r0, #80	; 0x50
 8002fbc:	d023      	beq.n	8003006 <LSM303AGR_X_Get_ODR+0x66>
 8002fbe:	d913      	bls.n	8002fe8 <LSM303AGR_X_Get_ODR+0x48>
 8002fc0:	2860      	cmp	r0, #96	; 0x60
 8002fc2:	d01c      	beq.n	8002ffe <LSM303AGR_X_Get_ODR+0x5e>
 8002fc4:	2870      	cmp	r0, #112	; 0x70
 8002fc6:	d108      	bne.n	8002fda <LSM303AGR_X_Get_ODR+0x3a>
      *odr =   400.0f;
 8002fc8:	4b16      	ldr	r3, [pc, #88]	; (8003024 <LSM303AGR_X_Get_ODR+0x84>)
 8002fca:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8002fcc:	2000      	movs	r0, #0
      break;
 8002fce:	e009      	b.n	8002fe4 <LSM303AGR_X_Get_ODR+0x44>
  switch( odr_low_level )
 8002fd0:	2810      	cmp	r0, #16
 8002fd2:	d00f      	beq.n	8002ff4 <LSM303AGR_X_Get_ODR+0x54>
 8002fd4:	2820      	cmp	r0, #32
 8002fd6:	d021      	beq.n	800301c <LSM303AGR_X_Get_ODR+0x7c>
 8002fd8:	b1e8      	cbz	r0, 8003016 <LSM303AGR_X_Get_ODR+0x76>
      *odr =    -1.0f;
 8002fda:	4b13      	ldr	r3, [pc, #76]	; (8003028 <LSM303AGR_X_Get_ODR+0x88>)
 8002fdc:	6023      	str	r3, [r4, #0]
      return COMPONENT_ERROR;
 8002fde:	2001      	movs	r0, #1
 8002fe0:	e000      	b.n	8002fe4 <LSM303AGR_X_Get_ODR+0x44>
    return COMPONENT_ERROR;
 8002fe2:	2001      	movs	r0, #1
}
 8002fe4:	b002      	add	sp, #8
 8002fe6:	bd10      	pop	{r4, pc}
  switch( odr_low_level )
 8002fe8:	2840      	cmp	r0, #64	; 0x40
 8002fea:	d1f6      	bne.n	8002fda <LSM303AGR_X_Get_ODR+0x3a>
      *odr =    50.0f;
 8002fec:	4b0f      	ldr	r3, [pc, #60]	; (800302c <LSM303AGR_X_Get_ODR+0x8c>)
 8002fee:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8002ff0:	2000      	movs	r0, #0
      break;
 8002ff2:	e7f7      	b.n	8002fe4 <LSM303AGR_X_Get_ODR+0x44>
      *odr =    1.0f;
 8002ff4:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8002ff8:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8002ffa:	2000      	movs	r0, #0
      break;
 8002ffc:	e7f2      	b.n	8002fe4 <LSM303AGR_X_Get_ODR+0x44>
      *odr =   200.0f;
 8002ffe:	4b0c      	ldr	r3, [pc, #48]	; (8003030 <LSM303AGR_X_Get_ODR+0x90>)
 8003000:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8003002:	2000      	movs	r0, #0
      break;
 8003004:	e7ee      	b.n	8002fe4 <LSM303AGR_X_Get_ODR+0x44>
      *odr =   100.0f;
 8003006:	4b0b      	ldr	r3, [pc, #44]	; (8003034 <LSM303AGR_X_Get_ODR+0x94>)
 8003008:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800300a:	2000      	movs	r0, #0
      break;
 800300c:	e7ea      	b.n	8002fe4 <LSM303AGR_X_Get_ODR+0x44>
      *odr =    25.0f;
 800300e:	4b0a      	ldr	r3, [pc, #40]	; (8003038 <LSM303AGR_X_Get_ODR+0x98>)
 8003010:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8003012:	2000      	movs	r0, #0
      break;
 8003014:	e7e6      	b.n	8002fe4 <LSM303AGR_X_Get_ODR+0x44>
      *odr =     0.0f;
 8003016:	2300      	movs	r3, #0
 8003018:	6023      	str	r3, [r4, #0]
      break;
 800301a:	e7e3      	b.n	8002fe4 <LSM303AGR_X_Get_ODR+0x44>
      *odr =    10.0f;
 800301c:	4b07      	ldr	r3, [pc, #28]	; (800303c <LSM303AGR_X_Get_ODR+0x9c>)
 800301e:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8003020:	2000      	movs	r0, #0
      break;
 8003022:	e7df      	b.n	8002fe4 <LSM303AGR_X_Get_ODR+0x44>
 8003024:	43c80000 	.word	0x43c80000
 8003028:	bf800000 	.word	0xbf800000
 800302c:	42480000 	.word	0x42480000
 8003030:	43480000 	.word	0x43480000
 8003034:	42c80000 	.word	0x42c80000
 8003038:	41c80000 	.word	0x41c80000
 800303c:	41200000 	.word	0x41200000

08003040 <LSM303AGR_X_Get_Sensitivity>:
{
 8003040:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003042:	b083      	sub	sp, #12
 8003044:	460e      	mov	r6, r1
  if( LSM303AGR_ACC_R_LOWPWR_EN( (void *)handle, &lp_value ) == MEMS_ERROR )
 8003046:	f10d 0105 	add.w	r1, sp, #5
{
 800304a:	4605      	mov	r5, r0
  if( LSM303AGR_ACC_R_LOWPWR_EN( (void *)handle, &lp_value ) == MEMS_ERROR )
 800304c:	f7ff fe82 	bl	8002d54 <LSM303AGR_ACC_R_LOWPWR_EN>
 8003050:	b910      	cbnz	r0, 8003058 <LSM303AGR_X_Get_Sensitivity+0x18>
  LSM303AGR_ACC_FS_t fullScale;

  /* Read actual full scale selection from sensor. */
  if ( LSM303AGR_ACC_R_FullScale( (void *)handle, &fullScale ) == MEMS_ERROR )
  {
    return COMPONENT_ERROR;
 8003052:	2001      	movs	r0, #1
}
 8003054:	b003      	add	sp, #12
 8003056:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if( LSM303AGR_ACC_R_HiRes( (void *)handle, &hr_value ) == MEMS_ERROR )
 8003058:	f10d 0106 	add.w	r1, sp, #6
 800305c:	4628      	mov	r0, r5
 800305e:	f7ff fe89 	bl	8002d74 <LSM303AGR_ACC_R_HiRes>
 8003062:	2800      	cmp	r0, #0
 8003064:	d0f5      	beq.n	8003052 <LSM303AGR_X_Get_Sensitivity+0x12>
  if( lp_value == LSM303AGR_ACC_LPEN_DISABLED && hr_value == LSM303AGR_ACC_HR_DISABLED )
 8003066:	f89d 4005 	ldrb.w	r4, [sp, #5]
 800306a:	b9c4      	cbnz	r4, 800309e <LSM303AGR_X_Get_Sensitivity+0x5e>
 800306c:	f89d 7006 	ldrb.w	r7, [sp, #6]
 8003070:	b37f      	cbz	r7, 80030d2 <LSM303AGR_X_Get_Sensitivity+0x92>
  else if ( lp_value == LSM303AGR_ACC_LPEN_DISABLED && hr_value == LSM303AGR_ACC_HR_ENABLED )
 8003072:	2f08      	cmp	r7, #8
 8003074:	d1ed      	bne.n	8003052 <LSM303AGR_X_Get_Sensitivity+0x12>
  if ( LSM303AGR_ACC_R_FullScale( (void *)handle, &fullScale ) == MEMS_ERROR )
 8003076:	4628      	mov	r0, r5
 8003078:	f10d 0107 	add.w	r1, sp, #7
 800307c:	f7ff fccc 	bl	8002a18 <LSM303AGR_ACC_R_FullScale>
 8003080:	2800      	cmp	r0, #0
 8003082:	d0e6      	beq.n	8003052 <LSM303AGR_X_Get_Sensitivity+0x12>
  }

  /* Store the sensitivity based on actual full scale. */
  switch( fullScale )
 8003084:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8003088:	2810      	cmp	r0, #16
 800308a:	d050      	beq.n	800312e <LSM303AGR_X_Get_Sensitivity+0xee>
 800308c:	d939      	bls.n	8003102 <LSM303AGR_X_Get_Sensitivity+0xc2>
 800308e:	2820      	cmp	r0, #32
 8003090:	d045      	beq.n	800311e <LSM303AGR_X_Get_Sensitivity+0xde>
 8003092:	2830      	cmp	r0, #48	; 0x30
 8003094:	d131      	bne.n	80030fa <LSM303AGR_X_Get_Sensitivity+0xba>
      break;
    case LSM303AGR_ACC_FS_8G:
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_8G_HIGH_RESOLUTION_MODE;
      break;
    case LSM303AGR_ACC_FS_16G:
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_16G_HIGH_RESOLUTION_MODE;
 8003096:	4b2e      	ldr	r3, [pc, #184]	; (8003150 <LSM303AGR_X_Get_Sensitivity+0x110>)
 8003098:	6033      	str	r3, [r6, #0]
    default:
      *sensitivity = -1.0f;
      return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
 800309a:	2000      	movs	r0, #0
 800309c:	e7da      	b.n	8003054 <LSM303AGR_X_Get_Sensitivity+0x14>
  else if ( lp_value == LSM303AGR_ACC_LPEN_ENABLED && hr_value == LSM303AGR_ACC_HR_DISABLED )
 800309e:	2c08      	cmp	r4, #8
 80030a0:	d1d7      	bne.n	8003052 <LSM303AGR_X_Get_Sensitivity+0x12>
 80030a2:	f89d 4006 	ldrb.w	r4, [sp, #6]
 80030a6:	2c00      	cmp	r4, #0
 80030a8:	d1d3      	bne.n	8003052 <LSM303AGR_X_Get_Sensitivity+0x12>
  if ( LSM303AGR_ACC_R_FullScale( (void *)handle, &fullScale ) == MEMS_ERROR )
 80030aa:	4628      	mov	r0, r5
 80030ac:	f10d 0107 	add.w	r1, sp, #7
 80030b0:	f7ff fcb2 	bl	8002a18 <LSM303AGR_ACC_R_FullScale>
 80030b4:	2800      	cmp	r0, #0
 80030b6:	d0cc      	beq.n	8003052 <LSM303AGR_X_Get_Sensitivity+0x12>
  switch( fullScale )
 80030b8:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80030bc:	2810      	cmp	r0, #16
 80030be:	d043      	beq.n	8003148 <LSM303AGR_X_Get_Sensitivity+0x108>
 80030c0:	d939      	bls.n	8003136 <LSM303AGR_X_Get_Sensitivity+0xf6>
 80030c2:	2820      	cmp	r0, #32
 80030c4:	d03c      	beq.n	8003140 <LSM303AGR_X_Get_Sensitivity+0x100>
 80030c6:	2830      	cmp	r0, #48	; 0x30
 80030c8:	d117      	bne.n	80030fa <LSM303AGR_X_Get_Sensitivity+0xba>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_16G_LOW_POWER_MODE;
 80030ca:	4b22      	ldr	r3, [pc, #136]	; (8003154 <LSM303AGR_X_Get_Sensitivity+0x114>)
 80030cc:	6033      	str	r3, [r6, #0]
  return COMPONENT_OK;
 80030ce:	2000      	movs	r0, #0
 80030d0:	e7c0      	b.n	8003054 <LSM303AGR_X_Get_Sensitivity+0x14>
  if ( LSM303AGR_ACC_R_FullScale( (void *)handle, &fullScale ) == MEMS_ERROR )
 80030d2:	4628      	mov	r0, r5
 80030d4:	f10d 0107 	add.w	r1, sp, #7
 80030d8:	f7ff fc9e 	bl	8002a18 <LSM303AGR_ACC_R_FullScale>
 80030dc:	2800      	cmp	r0, #0
 80030de:	d0b8      	beq.n	8003052 <LSM303AGR_X_Get_Sensitivity+0x12>
  switch( fullScale )
 80030e0:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80030e4:	2810      	cmp	r0, #16
 80030e6:	d016      	beq.n	8003116 <LSM303AGR_X_Get_Sensitivity+0xd6>
 80030e8:	d910      	bls.n	800310c <LSM303AGR_X_Get_Sensitivity+0xcc>
 80030ea:	2820      	cmp	r0, #32
 80030ec:	d01b      	beq.n	8003126 <LSM303AGR_X_Get_Sensitivity+0xe6>
 80030ee:	2830      	cmp	r0, #48	; 0x30
 80030f0:	d103      	bne.n	80030fa <LSM303AGR_X_Get_Sensitivity+0xba>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_16G_NORMAL_MODE;
 80030f2:	4b19      	ldr	r3, [pc, #100]	; (8003158 <LSM303AGR_X_Get_Sensitivity+0x118>)
 80030f4:	6033      	str	r3, [r6, #0]
  return COMPONENT_OK;
 80030f6:	4638      	mov	r0, r7
 80030f8:	e7ac      	b.n	8003054 <LSM303AGR_X_Get_Sensitivity+0x14>
      *sensitivity = -1.0f;
 80030fa:	4b18      	ldr	r3, [pc, #96]	; (800315c <LSM303AGR_X_Get_Sensitivity+0x11c>)
 80030fc:	6033      	str	r3, [r6, #0]
      return COMPONENT_ERROR;
 80030fe:	2001      	movs	r0, #1
 8003100:	e7a8      	b.n	8003054 <LSM303AGR_X_Get_Sensitivity+0x14>
  switch( fullScale )
 8003102:	2800      	cmp	r0, #0
 8003104:	d1f9      	bne.n	80030fa <LSM303AGR_X_Get_Sensitivity+0xba>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_2G_HIGH_RESOLUTION_MODE;
 8003106:	4b16      	ldr	r3, [pc, #88]	; (8003160 <LSM303AGR_X_Get_Sensitivity+0x120>)
 8003108:	6033      	str	r3, [r6, #0]
 800310a:	e7a3      	b.n	8003054 <LSM303AGR_X_Get_Sensitivity+0x14>
  switch( fullScale )
 800310c:	2800      	cmp	r0, #0
 800310e:	d1f4      	bne.n	80030fa <LSM303AGR_X_Get_Sensitivity+0xba>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_2G_NORMAL_MODE;
 8003110:	4b14      	ldr	r3, [pc, #80]	; (8003164 <LSM303AGR_X_Get_Sensitivity+0x124>)
 8003112:	6033      	str	r3, [r6, #0]
 8003114:	e79e      	b.n	8003054 <LSM303AGR_X_Get_Sensitivity+0x14>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_4G_NORMAL_MODE;
 8003116:	4b14      	ldr	r3, [pc, #80]	; (8003168 <LSM303AGR_X_Get_Sensitivity+0x128>)
 8003118:	6033      	str	r3, [r6, #0]
  return COMPONENT_OK;
 800311a:	4638      	mov	r0, r7
 800311c:	e79a      	b.n	8003054 <LSM303AGR_X_Get_Sensitivity+0x14>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_8G_HIGH_RESOLUTION_MODE;
 800311e:	4b11      	ldr	r3, [pc, #68]	; (8003164 <LSM303AGR_X_Get_Sensitivity+0x124>)
 8003120:	6033      	str	r3, [r6, #0]
  return COMPONENT_OK;
 8003122:	4620      	mov	r0, r4
 8003124:	e796      	b.n	8003054 <LSM303AGR_X_Get_Sensitivity+0x14>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_8G_NORMAL_MODE;
 8003126:	4b11      	ldr	r3, [pc, #68]	; (800316c <LSM303AGR_X_Get_Sensitivity+0x12c>)
 8003128:	6033      	str	r3, [r6, #0]
  return COMPONENT_OK;
 800312a:	4638      	mov	r0, r7
 800312c:	e792      	b.n	8003054 <LSM303AGR_X_Get_Sensitivity+0x14>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_4G_HIGH_RESOLUTION_MODE;
 800312e:	4b10      	ldr	r3, [pc, #64]	; (8003170 <LSM303AGR_X_Get_Sensitivity+0x130>)
 8003130:	6033      	str	r3, [r6, #0]
  return COMPONENT_OK;
 8003132:	4620      	mov	r0, r4
 8003134:	e78e      	b.n	8003054 <LSM303AGR_X_Get_Sensitivity+0x14>
  switch( fullScale )
 8003136:	2800      	cmp	r0, #0
 8003138:	d1df      	bne.n	80030fa <LSM303AGR_X_Get_Sensitivity+0xba>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_2G_LOW_POWER_MODE;
 800313a:	4b0c      	ldr	r3, [pc, #48]	; (800316c <LSM303AGR_X_Get_Sensitivity+0x12c>)
 800313c:	6033      	str	r3, [r6, #0]
 800313e:	e789      	b.n	8003054 <LSM303AGR_X_Get_Sensitivity+0x14>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_8G_LOW_POWER_MODE;
 8003140:	4b0c      	ldr	r3, [pc, #48]	; (8003174 <LSM303AGR_X_Get_Sensitivity+0x134>)
 8003142:	6033      	str	r3, [r6, #0]
  return COMPONENT_OK;
 8003144:	4620      	mov	r0, r4
 8003146:	e785      	b.n	8003054 <LSM303AGR_X_Get_Sensitivity+0x14>
      *sensitivity = ( float )LSM303AGR_ACC_SENSITIVITY_FOR_FS_4G_LOW_POWER_MODE;
 8003148:	4b0b      	ldr	r3, [pc, #44]	; (8003178 <LSM303AGR_X_Get_Sensitivity+0x138>)
 800314a:	6033      	str	r3, [r6, #0]
  return COMPONENT_OK;
 800314c:	4620      	mov	r0, r4
 800314e:	e781      	b.n	8003054 <LSM303AGR_X_Get_Sensitivity+0x14>
 8003150:	413b851f 	.word	0x413b851f
 8003154:	433b947b 	.word	0x433b947b
 8003158:	423b999a 	.word	0x423b999a
 800315c:	bf800000 	.word	0xbf800000
 8003160:	3f7ae148 	.word	0x3f7ae148
 8003164:	4079999a 	.word	0x4079999a
 8003168:	40fa3d71 	.word	0x40fa3d71
 800316c:	417a147b 	.word	0x417a147b
 8003170:	3ff9999a 	.word	0x3ff9999a
 8003174:	427a147b 	.word	0x427a147b
 8003178:	41fa147b 	.word	0x41fa147b

0800317c <LSM303AGR_X_Get_AxesRaw>:
{
 800317c:	b570      	push	{r4, r5, r6, lr}
 800317e:	b084      	sub	sp, #16
 8003180:	460c      	mov	r4, r1
  if(!LSM303AGR_ACC_R_HiRes( (void *)handle, &hr ))
 8003182:	f10d 0107 	add.w	r1, sp, #7
{
 8003186:	4606      	mov	r6, r0
  if(!LSM303AGR_ACC_R_HiRes( (void *)handle, &hr ))
 8003188:	f7ff fdf4 	bl	8002d74 <LSM303AGR_ACC_R_HiRes>
 800318c:	b910      	cbnz	r0, 8003194 <LSM303AGR_X_Get_AxesRaw+0x18>
    return COMPONENT_ERROR;
 800318e:	2001      	movs	r0, #1
}
 8003190:	b004      	add	sp, #16
 8003192:	bd70      	pop	{r4, r5, r6, pc}
  if(!LSM303AGR_ACC_R_LOWPWR_EN( (void *)handle, &lp ))
 8003194:	f10d 0106 	add.w	r1, sp, #6
 8003198:	4630      	mov	r0, r6
 800319a:	f7ff fddb 	bl	8002d54 <LSM303AGR_ACC_R_LOWPWR_EN>
 800319e:	2800      	cmp	r0, #0
 80031a0:	d0f5      	beq.n	800318e <LSM303AGR_X_Get_AxesRaw+0x12>
  if (lp == LSM303AGR_ACC_LPEN_ENABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 80031a2:	f89d 5006 	ldrb.w	r5, [sp, #6]
 80031a6:	2d08      	cmp	r5, #8
 80031a8:	d01a      	beq.n	80031e0 <LSM303AGR_X_Get_AxesRaw+0x64>
  else if (lp == LSM303AGR_ACC_LPEN_DISABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 80031aa:	2d00      	cmp	r5, #0
 80031ac:	d1ef      	bne.n	800318e <LSM303AGR_X_Get_AxesRaw+0x12>
 80031ae:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80031b2:	b9d3      	cbnz	r3, 80031ea <LSM303AGR_X_Get_AxesRaw+0x6e>
 80031b4:	2506      	movs	r5, #6
  if (!LSM303AGR_ACC_Get_Raw_Acceleration( (void *)handle, raw_data_tmp.u8bit ))
 80031b6:	4630      	mov	r0, r6
 80031b8:	a902      	add	r1, sp, #8
 80031ba:	f7ff fc3d 	bl	8002a38 <LSM303AGR_ACC_Get_Raw_Acceleration>
 80031be:	2800      	cmp	r0, #0
 80031c0:	d0e5      	beq.n	800318e <LSM303AGR_X_Get_AxesRaw+0x12>
  pData[0] = ( raw_data_tmp.i16bit[0] >> shift );
 80031c2:	f9bd 1008 	ldrsh.w	r1, [sp, #8]
  pData[1] = ( raw_data_tmp.i16bit[1] >> shift );
 80031c6:	f9bd 200a 	ldrsh.w	r2, [sp, #10]
  pData[2] = ( raw_data_tmp.i16bit[2] >> shift );
 80031ca:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
  pData[0] = ( raw_data_tmp.i16bit[0] >> shift );
 80031ce:	4129      	asrs	r1, r5
  pData[1] = ( raw_data_tmp.i16bit[1] >> shift );
 80031d0:	412a      	asrs	r2, r5
  pData[2] = ( raw_data_tmp.i16bit[2] >> shift );
 80031d2:	412b      	asrs	r3, r5
  return COMPONENT_OK;
 80031d4:	2000      	movs	r0, #0
  value->AXIS_X = dataRaw[0];
 80031d6:	8021      	strh	r1, [r4, #0]
  value->AXIS_Y = dataRaw[1];
 80031d8:	8062      	strh	r2, [r4, #2]
  value->AXIS_Z = dataRaw[2];
 80031da:	80a3      	strh	r3, [r4, #4]
}
 80031dc:	b004      	add	sp, #16
 80031de:	bd70      	pop	{r4, r5, r6, pc}
  if (lp == LSM303AGR_ACC_LPEN_ENABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 80031e0:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80031e4:	2a00      	cmp	r2, #0
 80031e6:	d0e6      	beq.n	80031b6 <LSM303AGR_X_Get_AxesRaw+0x3a>
 80031e8:	e7d1      	b.n	800318e <LSM303AGR_X_Get_AxesRaw+0x12>
  else if (lp == LSM303AGR_ACC_LPEN_DISABLED && hr == LSM303AGR_ACC_HR_ENABLED)
 80031ea:	2b08      	cmp	r3, #8
 80031ec:	d1cf      	bne.n	800318e <LSM303AGR_X_Get_AxesRaw+0x12>
 80031ee:	2504      	movs	r5, #4
 80031f0:	e7e1      	b.n	80031b6 <LSM303AGR_X_Get_AxesRaw+0x3a>
 80031f2:	bf00      	nop

080031f4 <LSM303AGR_X_Get_Axes>:
{
 80031f4:	b510      	push	{r4, lr}
 80031f6:	b084      	sub	sp, #16
 80031f8:	460c      	mov	r4, r1
  if ( !LSM303AGR_ACC_Get_Acceleration((void *)handle, data) )
 80031fa:	a901      	add	r1, sp, #4
 80031fc:	f7ff fc26 	bl	8002a4c <LSM303AGR_ACC_Get_Acceleration>
 8003200:	b130      	cbz	r0, 8003210 <LSM303AGR_X_Get_Axes+0x1c>
  acceleration->AXIS_Z = data[2];
 8003202:	a901      	add	r1, sp, #4
 8003204:	c90e      	ldmia	r1, {r1, r2, r3}
  return COMPONENT_OK;
 8003206:	2000      	movs	r0, #0
  acceleration->AXIS_Z = data[2];
 8003208:	e884 000e 	stmia.w	r4, {r1, r2, r3}
}
 800320c:	b004      	add	sp, #16
 800320e:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 8003210:	2001      	movs	r0, #1
}
 8003212:	b004      	add	sp, #16
 8003214:	bd10      	pop	{r4, pc}
 8003216:	bf00      	nop

08003218 <LSM303AGR_X_Get_WhoAmI>:
{
 8003218:	b508      	push	{r3, lr}
  if ( LSM303AGR_ACC_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 800321a:	f7ff fbaf 	bl	800297c <LSM303AGR_ACC_R_WHO_AM_I>
}
 800321e:	fab0 f080 	clz	r0, r0
 8003222:	0940      	lsrs	r0, r0, #5
 8003224:	bd08      	pop	{r3, pc}
 8003226:	bf00      	nop

08003228 <LSM303AGR_X_Check_WhoAmI>:
{
 8003228:	b510      	push	{r4, lr}
 800322a:	b082      	sub	sp, #8
  uint8_t who_am_i = 0x00;
 800322c:	a902      	add	r1, sp, #8
 800322e:	2300      	movs	r3, #0
 8003230:	f801 3d01 	strb.w	r3, [r1, #-1]!
{
 8003234:	4604      	mov	r4, r0
  if ( LSM303AGR_ACC_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 8003236:	f7ff fba1 	bl	800297c <LSM303AGR_ACC_R_WHO_AM_I>
 800323a:	b910      	cbnz	r0, 8003242 <LSM303AGR_X_Check_WhoAmI+0x1a>
 800323c:	2001      	movs	r0, #1
}
 800323e:	b002      	add	sp, #8
 8003240:	bd10      	pop	{r4, pc}
  if ( who_am_i != handle->who_am_i )
 8003242:	7820      	ldrb	r0, [r4, #0]
 8003244:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003248:	1ac0      	subs	r0, r0, r3
 800324a:	bf18      	it	ne
 800324c:	2001      	movne	r0, #1
}
 800324e:	b002      	add	sp, #8
 8003250:	bd10      	pop	{r4, pc}
 8003252:	bf00      	nop

08003254 <LSM303AGR_X_Set_Axes_Status>:
{
 8003254:	b538      	push	{r3, r4, r5, lr}
 8003256:	460c      	mov	r4, r1
  if ( LSM303AGR_ACC_W_XEN( (void *)handle,
 8003258:	7809      	ldrb	r1, [r1, #0]
 800325a:	f1a1 0101 	sub.w	r1, r1, #1
 800325e:	fab1 f181 	clz	r1, r1
 8003262:	0949      	lsrs	r1, r1, #5
{
 8003264:	4605      	mov	r5, r0
  if ( LSM303AGR_ACC_W_XEN( (void *)handle,
 8003266:	f7ff fcdf 	bl	8002c28 <LSM303AGR_ACC_W_XEN>
 800326a:	b1a0      	cbz	r0, 8003296 <LSM303AGR_X_Set_Axes_Status+0x42>
  if ( LSM303AGR_ACC_W_YEN ( (void *)handle,
 800326c:	7863      	ldrb	r3, [r4, #1]
 800326e:	2b01      	cmp	r3, #1
 8003270:	bf0c      	ite	eq
 8003272:	2102      	moveq	r1, #2
 8003274:	2100      	movne	r1, #0
 8003276:	4628      	mov	r0, r5
 8003278:	f7ff fd08 	bl	8002c8c <LSM303AGR_ACC_W_YEN>
 800327c:	b158      	cbz	r0, 8003296 <LSM303AGR_X_Set_Axes_Status+0x42>
  if ( LSM303AGR_ACC_W_ZEN ( (void *)handle,
 800327e:	78a3      	ldrb	r3, [r4, #2]
 8003280:	2b01      	cmp	r3, #1
 8003282:	4628      	mov	r0, r5
 8003284:	bf0c      	ite	eq
 8003286:	2104      	moveq	r1, #4
 8003288:	2100      	movne	r1, #0
 800328a:	f7ff fd31 	bl	8002cf0 <LSM303AGR_ACC_W_ZEN>
    return COMPONENT_ERROR;
 800328e:	fab0 f080 	clz	r0, r0
 8003292:	0940      	lsrs	r0, r0, #5
}
 8003294:	bd38      	pop	{r3, r4, r5, pc}
    return COMPONENT_ERROR;
 8003296:	2001      	movs	r0, #1
 8003298:	bd38      	pop	{r3, r4, r5, pc}
 800329a:	bf00      	nop

0800329c <LSM303AGR_X_Set_ODR_Value>:
{
 800329c:	b508      	push	{r3, lr}
  if(handle->isEnabled == 1)
 800329e:	7983      	ldrb	r3, [r0, #6]
 80032a0:	2b01      	cmp	r3, #1
 80032a2:	d034      	beq.n	800330e <LSM303AGR_X_Set_ODR_Value+0x72>
                                 : ( odr <=   10.0f ) ? 10.0f
 80032a4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 80032a8:	6883      	ldr	r3, [r0, #8]
                                 : ( odr <=   10.0f ) ? 10.0f
 80032aa:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80032ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 80032b2:	681b      	ldr	r3, [r3, #0]
                                 : ( odr <=   10.0f ) ? 10.0f
 80032b4:	d906      	bls.n	80032c4 <LSM303AGR_X_Set_ODR_Value+0x28>
                                 : ( odr <=   25.0f ) ? 25.0f
 80032b6:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 80032ba:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80032be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80032c2:	d803      	bhi.n	80032cc <LSM303AGR_X_Set_ODR_Value+0x30>
  pComponentData->Previous_ODR = ( odr <=    1.0f ) ?  1.0f
 80032c4:	edc3 7a01 	vstr	s15, [r3, #4]
  return COMPONENT_OK;
 80032c8:	2000      	movs	r0, #0
}
 80032ca:	bd08      	pop	{r3, pc}
                                 : ( odr <=   50.0f ) ? 50.0f
 80032cc:	eef3 7a09 	vmov.f32	s15, #57	; 0x41c80000  25.0
 80032d0:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80032d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80032d8:	d9f4      	bls.n	80032c4 <LSM303AGR_X_Set_ODR_Value+0x28>
                                 : ( odr <=  100.0f ) ? 100.0f
 80032da:	eddf 7a2b 	vldr	s15, [pc, #172]	; 8003388 <LSM303AGR_X_Set_ODR_Value+0xec>
 80032de:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80032e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80032e6:	d9ed      	bls.n	80032c4 <LSM303AGR_X_Set_ODR_Value+0x28>
                                 : ( odr <=  200.0f ) ? 200.0f
 80032e8:	eddf 7a28 	vldr	s15, [pc, #160]	; 800338c <LSM303AGR_X_Set_ODR_Value+0xf0>
 80032ec:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80032f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80032f4:	d9e6      	bls.n	80032c4 <LSM303AGR_X_Set_ODR_Value+0x28>
                                 :                      400.0f;
 80032f6:	eddf 7a26 	vldr	s15, [pc, #152]	; 8003390 <LSM303AGR_X_Set_ODR_Value+0xf4>
 80032fa:	ed9f 7a26 	vldr	s14, [pc, #152]	; 8003394 <LSM303AGR_X_Set_ODR_Value+0xf8>
 80032fe:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8003302:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003306:	bf88      	it	hi
 8003308:	eef0 7a47 	vmovhi.f32	s15, s14
 800330c:	e7da      	b.n	80032c4 <LSM303AGR_X_Set_ODR_Value+0x28>
            : ( odr <=   10.0f ) ? LSM303AGR_ACC_ODR_DO_10Hz
 800330e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8003312:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8003316:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800331a:	d92e      	bls.n	800337a <LSM303AGR_X_Set_ODR_Value+0xde>
 800331c:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 8003320:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8003324:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003328:	d91e      	bls.n	8003368 <LSM303AGR_X_Set_ODR_Value+0xcc>
 800332a:	eef3 7a09 	vmov.f32	s15, #57	; 0x41c80000  25.0
 800332e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8003332:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003336:	d91e      	bls.n	8003376 <LSM303AGR_X_Set_ODR_Value+0xda>
 8003338:	eddf 7a13 	vldr	s15, [pc, #76]	; 8003388 <LSM303AGR_X_Set_ODR_Value+0xec>
 800333c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8003340:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003344:	d91b      	bls.n	800337e <LSM303AGR_X_Set_ODR_Value+0xe2>
 8003346:	eddf 7a11 	vldr	s15, [pc, #68]	; 800338c <LSM303AGR_X_Set_ODR_Value+0xf0>
 800334a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800334e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003352:	d916      	bls.n	8003382 <LSM303AGR_X_Set_ODR_Value+0xe6>
 8003354:	eddf 7a0e 	vldr	s15, [pc, #56]	; 8003390 <LSM303AGR_X_Set_ODR_Value+0xf4>
 8003358:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800335c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003360:	bf94      	ite	ls
 8003362:	2160      	movls	r1, #96	; 0x60
 8003364:	2170      	movhi	r1, #112	; 0x70
 8003366:	e000      	b.n	800336a <LSM303AGR_X_Set_ODR_Value+0xce>
 8003368:	2120      	movs	r1, #32
  if ( LSM303AGR_ACC_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 800336a:	f7ff fc2b 	bl	8002bc4 <LSM303AGR_ACC_W_ODR>
      return COMPONENT_ERROR;
 800336e:	fab0 f080 	clz	r0, r0
 8003372:	0940      	lsrs	r0, r0, #5
 8003374:	bd08      	pop	{r3, pc}
            : ( odr <=   10.0f ) ? LSM303AGR_ACC_ODR_DO_10Hz
 8003376:	2130      	movs	r1, #48	; 0x30
 8003378:	e7f7      	b.n	800336a <LSM303AGR_X_Set_ODR_Value+0xce>
 800337a:	2110      	movs	r1, #16
 800337c:	e7f5      	b.n	800336a <LSM303AGR_X_Set_ODR_Value+0xce>
 800337e:	2140      	movs	r1, #64	; 0x40
 8003380:	e7f3      	b.n	800336a <LSM303AGR_X_Set_ODR_Value+0xce>
 8003382:	2150      	movs	r1, #80	; 0x50
 8003384:	e7f1      	b.n	800336a <LSM303AGR_X_Set_ODR_Value+0xce>
 8003386:	bf00      	nop
 8003388:	42480000 	.word	0x42480000
 800338c:	42c80000 	.word	0x42c80000
 8003390:	43480000 	.word	0x43480000
 8003394:	43c80000 	.word	0x43c80000

08003398 <LSM303AGR_X_Set_ODR>:
{
 8003398:	b508      	push	{r3, lr}
  if(handle->isEnabled == 1)
 800339a:	7983      	ldrb	r3, [r0, #6]
 800339c:	2b01      	cmp	r3, #1
 800339e:	d01d      	beq.n	80033dc <LSM303AGR_X_Set_ODR+0x44>
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 80033a0:	6883      	ldr	r3, [r0, #8]
 80033a2:	681b      	ldr	r3, [r3, #0]
  switch( odr )
 80033a4:	2904      	cmp	r1, #4
 80033a6:	d82f      	bhi.n	8003408 <LSM303AGR_X_Set_ODR+0x70>
 80033a8:	e8df f001 	tbb	[pc, r1]
 80033ac:	14100c07 	.word	0x14100c07
 80033b0:	03          	.byte	0x03
 80033b1:	00          	.byte	0x00
      pComponentData->Previous_ODR = 100.0f;
 80033b2:	4a16      	ldr	r2, [pc, #88]	; (800340c <LSM303AGR_X_Set_ODR+0x74>)
 80033b4:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 80033b6:	2000      	movs	r0, #0
 80033b8:	bd08      	pop	{r3, pc}
      pComponentData->Previous_ODR = 1.0f;
 80033ba:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 80033be:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 80033c0:	2000      	movs	r0, #0
 80033c2:	bd08      	pop	{r3, pc}
      pComponentData->Previous_ODR = 10.0f;
 80033c4:	4a12      	ldr	r2, [pc, #72]	; (8003410 <LSM303AGR_X_Set_ODR+0x78>)
 80033c6:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 80033c8:	2000      	movs	r0, #0
 80033ca:	bd08      	pop	{r3, pc}
      pComponentData->Previous_ODR = 25.0f;
 80033cc:	4a11      	ldr	r2, [pc, #68]	; (8003414 <LSM303AGR_X_Set_ODR+0x7c>)
 80033ce:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 80033d0:	2000      	movs	r0, #0
 80033d2:	bd08      	pop	{r3, pc}
      pComponentData->Previous_ODR = 50.0f;
 80033d4:	4a10      	ldr	r2, [pc, #64]	; (8003418 <LSM303AGR_X_Set_ODR+0x80>)
 80033d6:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 80033d8:	2000      	movs	r0, #0
 80033da:	bd08      	pop	{r3, pc}
  switch( odr )
 80033dc:	2904      	cmp	r1, #4
 80033de:	d813      	bhi.n	8003408 <LSM303AGR_X_Set_ODR+0x70>
 80033e0:	e8df f001 	tbb	[pc, r1]
 80033e4:	100c0a03 	.word	0x100c0a03
 80033e8:	0e          	.byte	0x0e
 80033e9:	00          	.byte	0x00
      new_odr = LSM303AGR_ACC_ODR_DO_1Hz;
 80033ea:	2110      	movs	r1, #16
  if ( LSM303AGR_ACC_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 80033ec:	f7ff fbea 	bl	8002bc4 <LSM303AGR_ACC_W_ODR>
      return COMPONENT_ERROR;
 80033f0:	fab0 f080 	clz	r0, r0
 80033f4:	0940      	lsrs	r0, r0, #5
 80033f6:	bd08      	pop	{r3, pc}
      new_odr = LSM303AGR_ACC_ODR_DO_10Hz;
 80033f8:	2120      	movs	r1, #32
 80033fa:	e7f7      	b.n	80033ec <LSM303AGR_X_Set_ODR+0x54>
      new_odr = LSM303AGR_ACC_ODR_DO_25Hz;
 80033fc:	2130      	movs	r1, #48	; 0x30
 80033fe:	e7f5      	b.n	80033ec <LSM303AGR_X_Set_ODR+0x54>
      new_odr = LSM303AGR_ACC_ODR_DO_100Hz;
 8003400:	2150      	movs	r1, #80	; 0x50
 8003402:	e7f3      	b.n	80033ec <LSM303AGR_X_Set_ODR+0x54>
      new_odr = LSM303AGR_ACC_ODR_DO_50Hz;
 8003404:	2140      	movs	r1, #64	; 0x40
 8003406:	e7f1      	b.n	80033ec <LSM303AGR_X_Set_ODR+0x54>
      return COMPONENT_ERROR;
 8003408:	2001      	movs	r0, #1
}
 800340a:	bd08      	pop	{r3, pc}
 800340c:	42c80000 	.word	0x42c80000
 8003410:	41200000 	.word	0x41200000
 8003414:	41c80000 	.word	0x41c80000
 8003418:	42480000 	.word	0x42480000

0800341c <LSM303AGR_X_Sensor_Enable>:
  if ( handle->isEnabled == 1 )
 800341c:	7983      	ldrb	r3, [r0, #6]
 800341e:	2b01      	cmp	r3, #1
 8003420:	d029      	beq.n	8003476 <LSM303AGR_X_Sensor_Enable+0x5a>
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 8003422:	6883      	ldr	r3, [r0, #8]
  if ( LSM303AGR_X_Set_ODR_Value_When_Enabled( handle, pComponentData->Previous_ODR ) == COMPONENT_ERROR )
 8003424:	681b      	ldr	r3, [r3, #0]
 8003426:	edd3 7a01 	vldr	s15, [r3, #4]
            : ( odr <=   10.0f ) ? LSM303AGR_ACC_ODR_DO_10Hz
 800342a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 800342e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8003432:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 8003436:	b510      	push	{r4, lr}
            : ( odr <=   10.0f ) ? LSM303AGR_ACC_ODR_DO_10Hz
 8003438:	d92a      	bls.n	8003490 <LSM303AGR_X_Sensor_Enable+0x74>
 800343a:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 800343e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8003442:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003446:	d918      	bls.n	800347a <LSM303AGR_X_Sensor_Enable+0x5e>
 8003448:	eeb3 7a09 	vmov.f32	s14, #57	; 0x41c80000  25.0
 800344c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8003450:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003454:	d91e      	bls.n	8003494 <LSM303AGR_X_Sensor_Enable+0x78>
 8003456:	ed9f 7a16 	vldr	s14, [pc, #88]	; 80034b0 <LSM303AGR_X_Sensor_Enable+0x94>
 800345a:	eef4 7ac7 	vcmpe.f32	s15, s14
 800345e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003462:	d919      	bls.n	8003498 <LSM303AGR_X_Sensor_Enable+0x7c>
 8003464:	ed9f 7a13 	vldr	s14, [pc, #76]	; 80034b4 <LSM303AGR_X_Sensor_Enable+0x98>
 8003468:	eef4 7ac7 	vcmpe.f32	s15, s14
 800346c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003470:	d814      	bhi.n	800349c <LSM303AGR_X_Sensor_Enable+0x80>
 8003472:	2150      	movs	r1, #80	; 0x50
 8003474:	e002      	b.n	800347c <LSM303AGR_X_Sensor_Enable+0x60>
    return COMPONENT_OK;
 8003476:	2000      	movs	r0, #0
 8003478:	4770      	bx	lr
            : ( odr <=   10.0f ) ? LSM303AGR_ACC_ODR_DO_10Hz
 800347a:	2120      	movs	r1, #32
 800347c:	4604      	mov	r4, r0
  if ( LSM303AGR_ACC_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 800347e:	f7ff fba1 	bl	8002bc4 <LSM303AGR_ACC_W_ODR>
 8003482:	b118      	cbz	r0, 800348c <LSM303AGR_X_Sensor_Enable+0x70>
  handle->isEnabled = 1;
 8003484:	2301      	movs	r3, #1
 8003486:	71a3      	strb	r3, [r4, #6]
  return COMPONENT_OK;
 8003488:	2000      	movs	r0, #0
}
 800348a:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 800348c:	2001      	movs	r0, #1
 800348e:	bd10      	pop	{r4, pc}
            : ( odr <=   10.0f ) ? LSM303AGR_ACC_ODR_DO_10Hz
 8003490:	2110      	movs	r1, #16
 8003492:	e7f3      	b.n	800347c <LSM303AGR_X_Sensor_Enable+0x60>
 8003494:	2130      	movs	r1, #48	; 0x30
 8003496:	e7f1      	b.n	800347c <LSM303AGR_X_Sensor_Enable+0x60>
 8003498:	2140      	movs	r1, #64	; 0x40
 800349a:	e7ef      	b.n	800347c <LSM303AGR_X_Sensor_Enable+0x60>
 800349c:	ed9f 7a06 	vldr	s14, [pc, #24]	; 80034b8 <LSM303AGR_X_Sensor_Enable+0x9c>
 80034a0:	eef4 7ac7 	vcmpe.f32	s15, s14
 80034a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80034a8:	bf94      	ite	ls
 80034aa:	2160      	movls	r1, #96	; 0x60
 80034ac:	2170      	movhi	r1, #112	; 0x70
 80034ae:	e7e5      	b.n	800347c <LSM303AGR_X_Sensor_Enable+0x60>
 80034b0:	42480000 	.word	0x42480000
 80034b4:	42c80000 	.word	0x42c80000
 80034b8:	43480000 	.word	0x43480000

080034bc <LSM303AGR_X_Sensor_Disable>:
  if ( handle->isEnabled == 0 )
 80034bc:	7983      	ldrb	r3, [r0, #6]
 80034be:	b90b      	cbnz	r3, 80034c4 <LSM303AGR_X_Sensor_Disable+0x8>
    return COMPONENT_OK;
 80034c0:	4618      	mov	r0, r3
 80034c2:	4770      	bx	lr
{
 80034c4:	b530      	push	{r4, r5, lr}
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 80034c6:	6883      	ldr	r3, [r0, #8]
{
 80034c8:	b083      	sub	sp, #12
  if ( LSM303AGR_ACC_R_ODR( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 80034ca:	f10d 0107 	add.w	r1, sp, #7
 80034ce:	4604      	mov	r4, r0
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 80034d0:	681d      	ldr	r5, [r3, #0]
  if ( LSM303AGR_ACC_R_ODR( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 80034d2:	f7ff fb99 	bl	8002c08 <LSM303AGR_ACC_R_ODR>
 80034d6:	b1f0      	cbz	r0, 8003516 <LSM303AGR_X_Sensor_Disable+0x5a>
  switch( odr_low_level )
 80034d8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80034dc:	2b30      	cmp	r3, #48	; 0x30
 80034de:	d032      	beq.n	8003546 <LSM303AGR_X_Sensor_Disable+0x8a>
 80034e0:	d912      	bls.n	8003508 <LSM303AGR_X_Sensor_Disable+0x4c>
 80034e2:	2b50      	cmp	r3, #80	; 0x50
 80034e4:	d02c      	beq.n	8003540 <LSM303AGR_X_Sensor_Disable+0x84>
 80034e6:	d91f      	bls.n	8003528 <LSM303AGR_X_Sensor_Disable+0x6c>
 80034e8:	2b60      	cmp	r3, #96	; 0x60
 80034ea:	d01a      	beq.n	8003522 <LSM303AGR_X_Sensor_Disable+0x66>
 80034ec:	2b70      	cmp	r3, #112	; 0x70
 80034ee:	d110      	bne.n	8003512 <LSM303AGR_X_Sensor_Disable+0x56>
      *odr =   400.0f;
 80034f0:	4b16      	ldr	r3, [pc, #88]	; (800354c <LSM303AGR_X_Sensor_Disable+0x90>)
 80034f2:	606b      	str	r3, [r5, #4]
  if ( LSM303AGR_ACC_W_ODR( (void *)handle, LSM303AGR_ACC_ODR_DO_PWR_DOWN ) == MEMS_ERROR )
 80034f4:	2100      	movs	r1, #0
 80034f6:	4620      	mov	r0, r4
 80034f8:	f7ff fb64 	bl	8002bc4 <LSM303AGR_ACC_W_ODR>
 80034fc:	b158      	cbz	r0, 8003516 <LSM303AGR_X_Sensor_Disable+0x5a>
  handle->isEnabled = 0;
 80034fe:	2300      	movs	r3, #0
  return COMPONENT_OK;
 8003500:	4618      	mov	r0, r3
  handle->isEnabled = 0;
 8003502:	71a3      	strb	r3, [r4, #6]
}
 8003504:	b003      	add	sp, #12
 8003506:	bd30      	pop	{r4, r5, pc}
  switch( odr_low_level )
 8003508:	2b10      	cmp	r3, #16
 800350a:	d012      	beq.n	8003532 <LSM303AGR_X_Sensor_Disable+0x76>
 800350c:	2b20      	cmp	r3, #32
 800350e:	d005      	beq.n	800351c <LSM303AGR_X_Sensor_Disable+0x60>
 8003510:	b19b      	cbz	r3, 800353a <LSM303AGR_X_Sensor_Disable+0x7e>
      *odr =    -1.0f;
 8003512:	4b0f      	ldr	r3, [pc, #60]	; (8003550 <LSM303AGR_X_Sensor_Disable+0x94>)
 8003514:	606b      	str	r3, [r5, #4]
    return COMPONENT_ERROR;
 8003516:	2001      	movs	r0, #1
}
 8003518:	b003      	add	sp, #12
 800351a:	bd30      	pop	{r4, r5, pc}
      *odr =    10.0f;
 800351c:	4b0d      	ldr	r3, [pc, #52]	; (8003554 <LSM303AGR_X_Sensor_Disable+0x98>)
 800351e:	606b      	str	r3, [r5, #4]
 8003520:	e7e8      	b.n	80034f4 <LSM303AGR_X_Sensor_Disable+0x38>
      *odr =   200.0f;
 8003522:	4b0d      	ldr	r3, [pc, #52]	; (8003558 <LSM303AGR_X_Sensor_Disable+0x9c>)
 8003524:	606b      	str	r3, [r5, #4]
 8003526:	e7e5      	b.n	80034f4 <LSM303AGR_X_Sensor_Disable+0x38>
  switch( odr_low_level )
 8003528:	2b40      	cmp	r3, #64	; 0x40
 800352a:	d1f2      	bne.n	8003512 <LSM303AGR_X_Sensor_Disable+0x56>
      *odr =    50.0f;
 800352c:	4b0b      	ldr	r3, [pc, #44]	; (800355c <LSM303AGR_X_Sensor_Disable+0xa0>)
 800352e:	606b      	str	r3, [r5, #4]
 8003530:	e7e0      	b.n	80034f4 <LSM303AGR_X_Sensor_Disable+0x38>
      *odr =    1.0f;
 8003532:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8003536:	606b      	str	r3, [r5, #4]
 8003538:	e7dc      	b.n	80034f4 <LSM303AGR_X_Sensor_Disable+0x38>
      *odr =     0.0f;
 800353a:	2300      	movs	r3, #0
 800353c:	606b      	str	r3, [r5, #4]
 800353e:	e7d9      	b.n	80034f4 <LSM303AGR_X_Sensor_Disable+0x38>
      *odr =   100.0f;
 8003540:	4b07      	ldr	r3, [pc, #28]	; (8003560 <LSM303AGR_X_Sensor_Disable+0xa4>)
 8003542:	606b      	str	r3, [r5, #4]
 8003544:	e7d6      	b.n	80034f4 <LSM303AGR_X_Sensor_Disable+0x38>
      *odr =    25.0f;
 8003546:	4b07      	ldr	r3, [pc, #28]	; (8003564 <LSM303AGR_X_Sensor_Disable+0xa8>)
 8003548:	606b      	str	r3, [r5, #4]
 800354a:	e7d3      	b.n	80034f4 <LSM303AGR_X_Sensor_Disable+0x38>
 800354c:	43c80000 	.word	0x43c80000
 8003550:	bf800000 	.word	0xbf800000
 8003554:	41200000 	.word	0x41200000
 8003558:	43480000 	.word	0x43480000
 800355c:	42480000 	.word	0x42480000
 8003560:	42c80000 	.word	0x42c80000
 8003564:	41c80000 	.word	0x41c80000

08003568 <LSM303AGR_X_DeInit>:
{
 8003568:	b5f0      	push	{r4, r5, r6, r7, lr}
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 800356a:	6883      	ldr	r3, [r0, #8]
{
 800356c:	b083      	sub	sp, #12
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 800356e:	681e      	ldr	r6, [r3, #0]
  uint8_t who_am_i = 0x00;
 8003570:	ad02      	add	r5, sp, #8
 8003572:	2300      	movs	r3, #0
  LSM303AGR_Combo_Data_t *comboData = pComponentData->comboData;
 8003574:	6837      	ldr	r7, [r6, #0]
  uint8_t who_am_i = 0x00;
 8003576:	f805 3d01 	strb.w	r3, [r5, #-1]!
  if ( LSM303AGR_ACC_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 800357a:	4629      	mov	r1, r5
{
 800357c:	4604      	mov	r4, r0
  if ( LSM303AGR_ACC_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 800357e:	f7ff f9fd 	bl	800297c <LSM303AGR_ACC_R_WHO_AM_I>
 8003582:	b910      	cbnz	r0, 800358a <LSM303AGR_X_DeInit+0x22>
    return COMPONENT_ERROR;
 8003584:	2001      	movs	r0, #1
}
 8003586:	b003      	add	sp, #12
 8003588:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ( who_am_i != handle->who_am_i )
 800358a:	7822      	ldrb	r2, [r4, #0]
 800358c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003590:	429a      	cmp	r2, r3
 8003592:	d1f7      	bne.n	8003584 <LSM303AGR_X_DeInit+0x1c>
  if ( handle->isEnabled == 0 )
 8003594:	79a3      	ldrb	r3, [r4, #6]
 8003596:	b93b      	cbnz	r3, 80035a8 <LSM303AGR_X_DeInit+0x40>
  comboData->isAccInitialized = 0;
 8003598:	2300      	movs	r3, #0
  pComponentData->Previous_ODR = 0.0f;
 800359a:	2200      	movs	r2, #0
  return COMPONENT_OK;
 800359c:	4618      	mov	r0, r3
  pComponentData->Previous_ODR = 0.0f;
 800359e:	6072      	str	r2, [r6, #4]
  comboData->isAccInitialized = 0;
 80035a0:	703b      	strb	r3, [r7, #0]
  handle->isInitialized = 0;
 80035a2:	7163      	strb	r3, [r4, #5]
}
 80035a4:	b003      	add	sp, #12
 80035a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 80035a8:	68a3      	ldr	r3, [r4, #8]
  if ( LSM303AGR_ACC_R_ODR( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 80035aa:	4629      	mov	r1, r5
 80035ac:	4620      	mov	r0, r4
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 80035ae:	681d      	ldr	r5, [r3, #0]
  if ( LSM303AGR_ACC_R_ODR( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 80035b0:	f7ff fb2a 	bl	8002c08 <LSM303AGR_ACC_R_ODR>
 80035b4:	2800      	cmp	r0, #0
 80035b6:	d0e5      	beq.n	8003584 <LSM303AGR_X_DeInit+0x1c>
  switch( odr_low_level )
 80035b8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80035bc:	2b30      	cmp	r3, #48	; 0x30
 80035be:	d029      	beq.n	8003614 <LSM303AGR_X_DeInit+0xac>
 80035c0:	d911      	bls.n	80035e6 <LSM303AGR_X_DeInit+0x7e>
 80035c2:	2b50      	cmp	r3, #80	; 0x50
 80035c4:	d023      	beq.n	800360e <LSM303AGR_X_DeInit+0xa6>
 80035c6:	d916      	bls.n	80035f6 <LSM303AGR_X_DeInit+0x8e>
 80035c8:	2b60      	cmp	r3, #96	; 0x60
 80035ca:	d01d      	beq.n	8003608 <LSM303AGR_X_DeInit+0xa0>
 80035cc:	2b70      	cmp	r3, #112	; 0x70
 80035ce:	d10f      	bne.n	80035f0 <LSM303AGR_X_DeInit+0x88>
      *odr =   400.0f;
 80035d0:	4b15      	ldr	r3, [pc, #84]	; (8003628 <LSM303AGR_X_DeInit+0xc0>)
 80035d2:	606b      	str	r3, [r5, #4]
  if ( LSM303AGR_ACC_W_ODR( (void *)handle, LSM303AGR_ACC_ODR_DO_PWR_DOWN ) == MEMS_ERROR )
 80035d4:	2100      	movs	r1, #0
 80035d6:	4620      	mov	r0, r4
 80035d8:	f7ff faf4 	bl	8002bc4 <LSM303AGR_ACC_W_ODR>
 80035dc:	2800      	cmp	r0, #0
 80035de:	d0d1      	beq.n	8003584 <LSM303AGR_X_DeInit+0x1c>
  handle->isEnabled = 0;
 80035e0:	2300      	movs	r3, #0
 80035e2:	71a3      	strb	r3, [r4, #6]
 80035e4:	e7d8      	b.n	8003598 <LSM303AGR_X_DeInit+0x30>
  switch( odr_low_level )
 80035e6:	2b10      	cmp	r3, #16
 80035e8:	d00a      	beq.n	8003600 <LSM303AGR_X_DeInit+0x98>
 80035ea:	2b20      	cmp	r3, #32
 80035ec:	d018      	beq.n	8003620 <LSM303AGR_X_DeInit+0xb8>
 80035ee:	b1a3      	cbz	r3, 800361a <LSM303AGR_X_DeInit+0xb2>
      *odr =    -1.0f;
 80035f0:	4b0e      	ldr	r3, [pc, #56]	; (800362c <LSM303AGR_X_DeInit+0xc4>)
 80035f2:	606b      	str	r3, [r5, #4]
 80035f4:	e7c6      	b.n	8003584 <LSM303AGR_X_DeInit+0x1c>
  switch( odr_low_level )
 80035f6:	2b40      	cmp	r3, #64	; 0x40
 80035f8:	d1fa      	bne.n	80035f0 <LSM303AGR_X_DeInit+0x88>
      *odr =    50.0f;
 80035fa:	4b0d      	ldr	r3, [pc, #52]	; (8003630 <LSM303AGR_X_DeInit+0xc8>)
 80035fc:	606b      	str	r3, [r5, #4]
 80035fe:	e7e9      	b.n	80035d4 <LSM303AGR_X_DeInit+0x6c>
      *odr =    1.0f;
 8003600:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8003604:	606b      	str	r3, [r5, #4]
 8003606:	e7e5      	b.n	80035d4 <LSM303AGR_X_DeInit+0x6c>
      *odr =   200.0f;
 8003608:	4b0a      	ldr	r3, [pc, #40]	; (8003634 <LSM303AGR_X_DeInit+0xcc>)
 800360a:	606b      	str	r3, [r5, #4]
 800360c:	e7e2      	b.n	80035d4 <LSM303AGR_X_DeInit+0x6c>
      *odr =   100.0f;
 800360e:	4b0a      	ldr	r3, [pc, #40]	; (8003638 <LSM303AGR_X_DeInit+0xd0>)
 8003610:	606b      	str	r3, [r5, #4]
 8003612:	e7df      	b.n	80035d4 <LSM303AGR_X_DeInit+0x6c>
      *odr =    25.0f;
 8003614:	4b09      	ldr	r3, [pc, #36]	; (800363c <LSM303AGR_X_DeInit+0xd4>)
 8003616:	606b      	str	r3, [r5, #4]
 8003618:	e7dc      	b.n	80035d4 <LSM303AGR_X_DeInit+0x6c>
      *odr =     0.0f;
 800361a:	2300      	movs	r3, #0
 800361c:	606b      	str	r3, [r5, #4]
 800361e:	e7d9      	b.n	80035d4 <LSM303AGR_X_DeInit+0x6c>
      *odr =    10.0f;
 8003620:	4b07      	ldr	r3, [pc, #28]	; (8003640 <LSM303AGR_X_DeInit+0xd8>)
 8003622:	606b      	str	r3, [r5, #4]
 8003624:	e7d6      	b.n	80035d4 <LSM303AGR_X_DeInit+0x6c>
 8003626:	bf00      	nop
 8003628:	43c80000 	.word	0x43c80000
 800362c:	bf800000 	.word	0xbf800000
 8003630:	42480000 	.word	0x42480000
 8003634:	43480000 	.word	0x43480000
 8003638:	42c80000 	.word	0x42c80000
 800363c:	41c80000 	.word	0x41c80000
 8003640:	41200000 	.word	0x41200000

08003644 <LSM303AGR_X_Init>:
{
 8003644:	b5f0      	push	{r4, r5, r6, r7, lr}
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 8003646:	6883      	ldr	r3, [r0, #8]
{
 8003648:	b083      	sub	sp, #12
  LSM303AGR_X_Data_t *pComponentData = ( LSM303AGR_X_Data_t * )pData->pComponentData;
 800364a:	681e      	ldr	r6, [r3, #0]
  uint8_t who_am_i = 0x00;
 800364c:	a902      	add	r1, sp, #8
 800364e:	2400      	movs	r4, #0
  LSM303AGR_Combo_Data_t *comboData = pComponentData->comboData;
 8003650:	6837      	ldr	r7, [r6, #0]
  uint8_t who_am_i = 0x00;
 8003652:	f801 4d01 	strb.w	r4, [r1, #-1]!
{
 8003656:	4605      	mov	r5, r0
  if ( LSM303AGR_ACC_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 8003658:	f7ff f990 	bl	800297c <LSM303AGR_ACC_R_WHO_AM_I>
 800365c:	b120      	cbz	r0, 8003668 <LSM303AGR_X_Init+0x24>
  if ( who_am_i != handle->who_am_i )
 800365e:	782a      	ldrb	r2, [r5, #0]
 8003660:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003664:	429a      	cmp	r2, r3
 8003666:	d002      	beq.n	800366e <LSM303AGR_X_Init+0x2a>
    return COMPONENT_ERROR;
 8003668:	2001      	movs	r0, #1
}
 800366a:	b003      	add	sp, #12
 800366c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ( LSM303AGR_ACC_W_BlockDataUpdate( (void *)handle, LSM303AGR_ACC_BDU_ENABLED ) == MEMS_ERROR )
 800366e:	2180      	movs	r1, #128	; 0x80
 8003670:	4628      	mov	r0, r5
 8003672:	f7ff f98d 	bl	8002990 <LSM303AGR_ACC_W_BlockDataUpdate>
 8003676:	2800      	cmp	r0, #0
 8003678:	d0f6      	beq.n	8003668 <LSM303AGR_X_Init+0x24>
  if ( LSM303AGR_ACC_W_FifoMode( (void *)handle, LSM303AGR_ACC_FM_BYPASS ) == MEMS_ERROR )
 800367a:	4621      	mov	r1, r4
 800367c:	4628      	mov	r0, r5
 800367e:	f7ff fb99 	bl	8002db4 <LSM303AGR_ACC_W_FifoMode>
 8003682:	2800      	cmp	r0, #0
 8003684:	d0f0      	beq.n	8003668 <LSM303AGR_X_Init+0x24>
  pComponentData->Previous_ODR = 100.0f;
 8003686:	4b12      	ldr	r3, [pc, #72]	; (80036d0 <LSM303AGR_X_Init+0x8c>)
 8003688:	6073      	str	r3, [r6, #4]
  if ( LSM303AGR_ACC_W_ODR( (void *)handle, LSM303AGR_ACC_ODR_DO_PWR_DOWN ) == MEMS_ERROR )
 800368a:	4621      	mov	r1, r4
 800368c:	4628      	mov	r0, r5
 800368e:	f7ff fa99 	bl	8002bc4 <LSM303AGR_ACC_W_ODR>
 8003692:	2800      	cmp	r0, #0
 8003694:	d0e8      	beq.n	8003668 <LSM303AGR_X_Init+0x24>
  if ( LSM303AGR_ACC_W_FullScale( (void *)handle, new_fs ) == MEMS_ERROR )
 8003696:	4621      	mov	r1, r4
 8003698:	4628      	mov	r0, r5
 800369a:	f7ff f99b 	bl	80029d4 <LSM303AGR_ACC_W_FullScale>
 800369e:	2800      	cmp	r0, #0
 80036a0:	d0e2      	beq.n	8003668 <LSM303AGR_X_Init+0x24>
  if ( LSM303AGR_ACC_W_XEN( (void *)handle,
 80036a2:	2101      	movs	r1, #1
 80036a4:	4628      	mov	r0, r5
 80036a6:	f7ff fabf 	bl	8002c28 <LSM303AGR_ACC_W_XEN>
 80036aa:	2800      	cmp	r0, #0
 80036ac:	d0dc      	beq.n	8003668 <LSM303AGR_X_Init+0x24>
  if ( LSM303AGR_ACC_W_YEN ( (void *)handle,
 80036ae:	2102      	movs	r1, #2
 80036b0:	4628      	mov	r0, r5
 80036b2:	f7ff faeb 	bl	8002c8c <LSM303AGR_ACC_W_YEN>
 80036b6:	2800      	cmp	r0, #0
 80036b8:	d0d6      	beq.n	8003668 <LSM303AGR_X_Init+0x24>
  if ( LSM303AGR_ACC_W_ZEN ( (void *)handle,
 80036ba:	2104      	movs	r1, #4
 80036bc:	4628      	mov	r0, r5
 80036be:	f7ff fb17 	bl	8002cf0 <LSM303AGR_ACC_W_ZEN>
 80036c2:	2800      	cmp	r0, #0
 80036c4:	d0d0      	beq.n	8003668 <LSM303AGR_X_Init+0x24>
  comboData->isAccInitialized = 1;
 80036c6:	2301      	movs	r3, #1
 80036c8:	703b      	strb	r3, [r7, #0]
  return COMPONENT_OK;
 80036ca:	4620      	mov	r0, r4
  handle->isInitialized = 1;
 80036cc:	716b      	strb	r3, [r5, #5]
  return COMPONENT_OK;
 80036ce:	e7cc      	b.n	800366a <LSM303AGR_X_Init+0x26>
 80036d0:	42c80000 	.word	0x42c80000

080036d4 <LSM303AGR_MAG_WriteReg>:
*                                 length of buffer
* Output      : None
* Return      : None
*******************************************************************************/
status_t LSM303AGR_MAG_WriteReg(void *handle, u8_t Reg, u8_t *Bufp, u16_t len)
{
 80036d4:	b508      	push	{r3, lr}

  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 80036d6:	f003 fefb 	bl	80074d0 <Sensor_IO_Write>
  }
  else
  {
    return MEMS_SUCCESS;
  }
}
 80036da:	fab0 f080 	clz	r0, r0
 80036de:	0940      	lsrs	r0, r0, #5
 80036e0:	bd08      	pop	{r3, pc}
 80036e2:	bf00      	nop

080036e4 <LSM303AGR_MAG_ReadReg>:
*                                 length of buffer
* Output      : None
* Return      : None
*******************************************************************************/
status_t LSM303AGR_MAG_ReadReg(void *handle, u8_t Reg, u8_t *Bufp, u16_t len)
{
 80036e4:	b508      	push	{r3, lr}

  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80036e6:	f003 ff41 	bl	800756c <Sensor_IO_Read>
  }
  else
  {
    return MEMS_SUCCESS;
  }
}
 80036ea:	fab0 f080 	clz	r0, r0
 80036ee:	0940      	lsrs	r0, r0, #5
 80036f0:	bd08      	pop	{r3, pc}
 80036f2:	bf00      	nop

080036f4 <LSM303AGR_MAG_R_WHO_AM_I>:
* Input          : Pointer to u8_t
* Output         : Status of WHO_AM_I
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_MAG_R_WHO_AM_I(void *handle, u8_t *value)
{
 80036f4:	b508      	push	{r3, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80036f6:	460a      	mov	r2, r1
 80036f8:	2301      	movs	r3, #1
 80036fa:	214f      	movs	r1, #79	; 0x4f
 80036fc:	f003 ff36 	bl	800756c <Sensor_IO_Read>

  *value &= LSM303AGR_MAG_WHO_AM_I_MASK; //coerce
  *value = *value >> LSM303AGR_MAG_WHO_AM_I_POSITION; //mask

  return MEMS_SUCCESS;
}
 8003700:	fab0 f080 	clz	r0, r0
 8003704:	0940      	lsrs	r0, r0, #5
 8003706:	bd08      	pop	{r3, pc}

08003708 <LSM303AGR_MAG_W_BDU>:
* Input          : LSM303AGR_MAG_BDU_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_MAG_W_BDU(void *handle, LSM303AGR_MAG_BDU_t newValue)
{
 8003708:	b530      	push	{r4, r5, lr}
 800370a:	b083      	sub	sp, #12
 800370c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800370e:	f10d 0207 	add.w	r2, sp, #7
 8003712:	2301      	movs	r3, #1
 8003714:	2162      	movs	r1, #98	; 0x62
{
 8003716:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8003718:	f003 ff28 	bl	800756c <Sensor_IO_Read>
 800371c:	b110      	cbz	r0, 8003724 <LSM303AGR_MAG_W_BDU+0x1c>
  u8_t value;

  if( !LSM303AGR_MAG_ReadReg(handle, LSM303AGR_MAG_CFG_REG_C, &value, 1) )
    return MEMS_ERROR;
 800371e:	2000      	movs	r0, #0

  if( !LSM303AGR_MAG_WriteReg( handle, LSM303AGR_MAG_CFG_REG_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8003720:	b003      	add	sp, #12
 8003722:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_MAG_BDU_MASK;
 8003724:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003728:	f023 0310 	bic.w	r3, r3, #16
  value |= newValue;
 800372c:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 800372e:	f10d 0207 	add.w	r2, sp, #7
 8003732:	4628      	mov	r0, r5
 8003734:	2301      	movs	r3, #1
 8003736:	2162      	movs	r1, #98	; 0x62
  value |= newValue;
 8003738:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 800373c:	f003 fec8 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8003740:	fab0 f080 	clz	r0, r0
 8003744:	0940      	lsrs	r0, r0, #5
}
 8003746:	b003      	add	sp, #12
 8003748:	bd30      	pop	{r4, r5, pc}
 800374a:	bf00      	nop

0800374c <LSM303AGR_MAG_W_MD>:
* Input          : LSM303AGR_MAG_MD_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_MAG_W_MD(void *handle, LSM303AGR_MAG_MD_t newValue)
{
 800374c:	b530      	push	{r4, r5, lr}
 800374e:	b083      	sub	sp, #12
 8003750:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8003752:	f10d 0207 	add.w	r2, sp, #7
 8003756:	2301      	movs	r3, #1
 8003758:	2160      	movs	r1, #96	; 0x60
{
 800375a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800375c:	f003 ff06 	bl	800756c <Sensor_IO_Read>
 8003760:	b110      	cbz	r0, 8003768 <LSM303AGR_MAG_W_MD+0x1c>
  u8_t value;

  if( !LSM303AGR_MAG_ReadReg(handle, LSM303AGR_MAG_CFG_REG_A, &value, 1) )
    return MEMS_ERROR;
 8003762:	2000      	movs	r0, #0

  if( !LSM303AGR_MAG_WriteReg( handle, LSM303AGR_MAG_CFG_REG_A, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8003764:	b003      	add	sp, #12
 8003766:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_MAG_MD_MASK;
 8003768:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800376c:	f023 0303 	bic.w	r3, r3, #3
  value |= newValue;
 8003770:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8003772:	f10d 0207 	add.w	r2, sp, #7
 8003776:	4628      	mov	r0, r5
 8003778:	2301      	movs	r3, #1
 800377a:	2160      	movs	r1, #96	; 0x60
  value |= newValue;
 800377c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 8003780:	f003 fea6 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8003784:	fab0 f080 	clz	r0, r0
 8003788:	0940      	lsrs	r0, r0, #5
}
 800378a:	b003      	add	sp, #12
 800378c:	bd30      	pop	{r4, r5, pc}
 800378e:	bf00      	nop

08003790 <LSM303AGR_MAG_Get_Raw_Magnetic>:
* Input          : pointer to [u8_t]
* Output         : Magnetic buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_MAG_Get_Raw_Magnetic(void *handle, u8_t *buff)
{
 8003790:	b508      	push	{r3, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8003792:	460a      	mov	r2, r1
 8003794:	2306      	movs	r3, #6
 8003796:	2168      	movs	r1, #104	; 0x68
 8003798:	f003 fee8 	bl	800756c <Sensor_IO_Read>
  if( !LSM303AGR_MAG_ReadReg( handle, LSM303AGR_MAG_OUTX_L_REG, buff, 6 ) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800379c:	fab0 f080 	clz	r0, r0
 80037a0:	0940      	lsrs	r0, r0, #5
 80037a2:	bd08      	pop	{r3, pc}

080037a4 <LSM303AGR_MAG_W_ODR>:
* Input          : LSM303AGR_MAG_ODR_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_MAG_W_ODR(void *handle, LSM303AGR_MAG_ODR_t newValue)
{
 80037a4:	b530      	push	{r4, r5, lr}
 80037a6:	b083      	sub	sp, #12
 80037a8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80037aa:	f10d 0207 	add.w	r2, sp, #7
 80037ae:	2301      	movs	r3, #1
 80037b0:	2160      	movs	r1, #96	; 0x60
{
 80037b2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80037b4:	f003 feda 	bl	800756c <Sensor_IO_Read>
 80037b8:	b110      	cbz	r0, 80037c0 <LSM303AGR_MAG_W_ODR+0x1c>
  u8_t value;

  if( !LSM303AGR_MAG_ReadReg(handle, LSM303AGR_MAG_CFG_REG_A, &value, 1) )
    return MEMS_ERROR;
 80037ba:	2000      	movs	r0, #0

  if( !LSM303AGR_MAG_WriteReg( handle, LSM303AGR_MAG_CFG_REG_A, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 80037bc:	b003      	add	sp, #12
 80037be:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_MAG_ODR_MASK;
 80037c0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80037c4:	f023 030c 	bic.w	r3, r3, #12
  value |= newValue;
 80037c8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 80037ca:	f10d 0207 	add.w	r2, sp, #7
 80037ce:	4628      	mov	r0, r5
 80037d0:	2301      	movs	r3, #1
 80037d2:	2160      	movs	r1, #96	; 0x60
  value |= newValue;
 80037d4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 80037d8:	f003 fe7a 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 80037dc:	fab0 f080 	clz	r0, r0
 80037e0:	0940      	lsrs	r0, r0, #5
}
 80037e2:	b003      	add	sp, #12
 80037e4:	bd30      	pop	{r4, r5, pc}
 80037e6:	bf00      	nop

080037e8 <LSM303AGR_MAG_R_ODR>:
* Input          : Pointer to LSM303AGR_MAG_ODR_t
* Output         : Status of ODR see LSM303AGR_MAG_ODR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_MAG_R_ODR(void *handle, LSM303AGR_MAG_ODR_t *value)
{
 80037e8:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80037ea:	460a      	mov	r2, r1
{
 80037ec:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 80037ee:	2301      	movs	r3, #1
 80037f0:	2160      	movs	r1, #96	; 0x60
 80037f2:	f003 febb 	bl	800756c <Sensor_IO_Read>
 80037f6:	b108      	cbz	r0, 80037fc <LSM303AGR_MAG_R_ODR+0x14>
  if( !LSM303AGR_MAG_ReadReg(handle, LSM303AGR_MAG_CFG_REG_A, (u8_t *)value, 1) )
    return MEMS_ERROR;
 80037f8:	2000      	movs	r0, #0
 80037fa:	bd10      	pop	{r4, pc}

  *value &= LSM303AGR_MAG_ODR_MASK; //mask
 80037fc:	7823      	ldrb	r3, [r4, #0]
 80037fe:	f003 030c 	and.w	r3, r3, #12
 8003802:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8003804:	2001      	movs	r0, #1
}
 8003806:	bd10      	pop	{r4, pc}

08003808 <LSM303AGR_MAG_W_ST>:
* Input          : LSM303AGR_MAG_ST_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_MAG_W_ST(void *handle, LSM303AGR_MAG_ST_t newValue)
{
 8003808:	b530      	push	{r4, r5, lr}
 800380a:	b083      	sub	sp, #12
 800380c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800380e:	f10d 0207 	add.w	r2, sp, #7
 8003812:	2301      	movs	r3, #1
 8003814:	2162      	movs	r1, #98	; 0x62
{
 8003816:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8003818:	f003 fea8 	bl	800756c <Sensor_IO_Read>
 800381c:	b110      	cbz	r0, 8003824 <LSM303AGR_MAG_W_ST+0x1c>
  u8_t value;

  if( !LSM303AGR_MAG_ReadReg(handle, LSM303AGR_MAG_CFG_REG_C, &value, 1) )
    return MEMS_ERROR;
 800381e:	2000      	movs	r0, #0

  if( !LSM303AGR_MAG_WriteReg( handle, LSM303AGR_MAG_CFG_REG_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8003820:	b003      	add	sp, #12
 8003822:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM303AGR_MAG_ST_MASK;
 8003824:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003828:	f023 0302 	bic.w	r3, r3, #2
  value |= newValue;
 800382c:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 800382e:	f10d 0207 	add.w	r2, sp, #7
 8003832:	4628      	mov	r0, r5
 8003834:	2301      	movs	r3, #1
 8003836:	2162      	movs	r1, #98	; 0x62
  value |= newValue;
 8003838:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Bufp, len))
 800383c:	f003 fe48 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8003840:	fab0 f080 	clz	r0, r0
 8003844:	0940      	lsrs	r0, r0, #5
}
 8003846:	b003      	add	sp, #12
 8003848:	bd30      	pop	{r4, r5, pc}
 800384a:	bf00      	nop

0800384c <LSM303AGR_MAG_R_ZYXDA>:
* Input          : Pointer to LSM303AGR_MAG_ZYXDA_t
* Output         : Status of ZYXDA see LSM303AGR_MAG_ZYXDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_MAG_R_ZYXDA(void *handle, LSM303AGR_MAG_ZYXDA_t *value)
{
 800384c:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 800384e:	460a      	mov	r2, r1
{
 8003850:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Bufp, len))
 8003852:	2301      	movs	r3, #1
 8003854:	2167      	movs	r1, #103	; 0x67
 8003856:	f003 fe89 	bl	800756c <Sensor_IO_Read>
 800385a:	b108      	cbz	r0, 8003860 <LSM303AGR_MAG_R_ZYXDA+0x14>
  if( !LSM303AGR_MAG_ReadReg(handle, LSM303AGR_MAG_STATUS_REG, (u8_t *)value, 1) )
    return MEMS_ERROR;
 800385c:	2000      	movs	r0, #0
 800385e:	bd10      	pop	{r4, pc}

  *value &= LSM303AGR_MAG_ZYXDA_MASK; //mask
 8003860:	7823      	ldrb	r3, [r4, #0]
 8003862:	f003 0308 	and.w	r3, r3, #8
 8003866:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8003868:	2001      	movs	r0, #1
}
 800386a:	bd10      	pop	{r4, pc}

0800386c <LSM303AGR_M_Get_Sensitivity>:
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LSM303AGR_M_Get_Sensitivity( DrvContextTypeDef *handle, float *sensitivity )
{
  *sensitivity = ( float )LSM303AGR_MAG_SENSITIVITY_FOR_FS_50G;
 800386c:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
 8003870:	600b      	str	r3, [r1, #0]

  return COMPONENT_OK;
}
 8003872:	2000      	movs	r0, #0
 8003874:	4770      	bx	lr
 8003876:	bf00      	nop

08003878 <LSM303AGR_M_Get_FS>:
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LSM303AGR_M_Get_FS( DrvContextTypeDef *handle, float *fullScale )
{
  *fullScale = 50.0f;
 8003878:	4b01      	ldr	r3, [pc, #4]	; (8003880 <LSM303AGR_M_Get_FS+0x8>)
 800387a:	600b      	str	r3, [r1, #0]

  return COMPONENT_OK;
}
 800387c:	2000      	movs	r0, #0
 800387e:	4770      	bx	lr
 8003880:	42480000 	.word	0x42480000

08003884 <LSM303AGR_M_Set_FS>:
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LSM303AGR_M_Set_FS( DrvContextTypeDef *handle, SensorFs_t fullScale )
{
  return COMPONENT_OK;
}
 8003884:	2000      	movs	r0, #0
 8003886:	4770      	bx	lr

08003888 <LSM303AGR_M_Set_FS_Value>:
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LSM303AGR_M_Set_FS_Value( DrvContextTypeDef *handle, float fullScale )
{
  return COMPONENT_OK;
}
 8003888:	2000      	movs	r0, #0
 800388a:	4770      	bx	lr

0800388c <LSM303AGR_M_Get_DRDY_Status>:
 * @param status the data ready status
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LSM303AGR_M_Get_DRDY_Status( DrvContextTypeDef *handle, uint8_t *status )
{
 800388c:	b510      	push	{r4, lr}
 800388e:	b082      	sub	sp, #8
 8003890:	460c      	mov	r4, r1

  LSM303AGR_MAG_ZYXDA_t status_raw;

  if ( LSM303AGR_MAG_R_ZYXDA( (void *)handle, &status_raw ) == MEMS_ERROR )
 8003892:	f10d 0107 	add.w	r1, sp, #7
 8003896:	f7ff ffd9 	bl	800384c <LSM303AGR_MAG_R_ZYXDA>
 800389a:	b148      	cbz	r0, 80038b0 <LSM303AGR_M_Get_DRDY_Status+0x24>
  {
    return COMPONENT_ERROR;
  }

  switch( status_raw )
 800389c:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80038a0:	b148      	cbz	r0, 80038b6 <LSM303AGR_M_Get_DRDY_Status+0x2a>
 80038a2:	2808      	cmp	r0, #8
 80038a4:	d104      	bne.n	80038b0 <LSM303AGR_M_Get_DRDY_Status+0x24>
  {
    case LSM303AGR_MAG_ZYXDA_EV_ON:
      *status = 1;
 80038a6:	2301      	movs	r3, #1
      break;
    default:
      return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
 80038a8:	2000      	movs	r0, #0
      *status = 1;
 80038aa:	7023      	strb	r3, [r4, #0]
}
 80038ac:	b002      	add	sp, #8
 80038ae:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 80038b0:	2001      	movs	r0, #1
}
 80038b2:	b002      	add	sp, #8
 80038b4:	bd10      	pop	{r4, pc}
      *status = 0;
 80038b6:	7020      	strb	r0, [r4, #0]
}
 80038b8:	b002      	add	sp, #8
 80038ba:	bd10      	pop	{r4, pc}

080038bc <LSM303AGR_M_Write_Reg>:
{
 80038bc:	b510      	push	{r4, lr}
 80038be:	b082      	sub	sp, #8
 80038c0:	ac02      	add	r4, sp, #8
  if ( LSM303AGR_MAG_WriteReg( (void *)handle, reg, &data, 1 ) == MEMS_ERROR )
 80038c2:	2301      	movs	r3, #1
{
 80038c4:	f804 2d01 	strb.w	r2, [r4, #-1]!
  if ( LSM303AGR_MAG_WriteReg( (void *)handle, reg, &data, 1 ) == MEMS_ERROR )
 80038c8:	4622      	mov	r2, r4
 80038ca:	f7ff ff03 	bl	80036d4 <LSM303AGR_MAG_WriteReg>
}
 80038ce:	fab0 f080 	clz	r0, r0
 80038d2:	0940      	lsrs	r0, r0, #5
 80038d4:	b002      	add	sp, #8
 80038d6:	bd10      	pop	{r4, pc}

080038d8 <LSM303AGR_M_Read_Reg>:
{
 80038d8:	b508      	push	{r3, lr}
  if ( LSM303AGR_MAG_ReadReg( (void *)handle, reg, data, 1 ) == MEMS_ERROR )
 80038da:	2301      	movs	r3, #1
 80038dc:	f7ff ff02 	bl	80036e4 <LSM303AGR_MAG_ReadReg>
}
 80038e0:	fab0 f080 	clz	r0, r0
 80038e4:	0940      	lsrs	r0, r0, #5
 80038e6:	bd08      	pop	{r3, pc}

080038e8 <LSM303AGR_M_Set_ODR_Value>:
              : ( odr <= 20.000f ) ? LSM303AGR_MAG_ODR_20Hz
 80038e8:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 80038ec:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80038f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 80038f4:	b508      	push	{r3, lr}
              : ( odr <= 20.000f ) ? LSM303AGR_MAG_ODR_20Hz
 80038f6:	d90d      	bls.n	8003914 <LSM303AGR_M_Set_ODR_Value+0x2c>
 80038f8:	eef3 7a04 	vmov.f32	s15, #52	; 0x41a00000  20.0
 80038fc:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8003900:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003904:	d80d      	bhi.n	8003922 <LSM303AGR_M_Set_ODR_Value+0x3a>
 8003906:	2104      	movs	r1, #4
  if ( LSM303AGR_MAG_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 8003908:	f7ff ff4c 	bl	80037a4 <LSM303AGR_MAG_W_ODR>
}
 800390c:	fab0 f080 	clz	r0, r0
 8003910:	0940      	lsrs	r0, r0, #5
 8003912:	bd08      	pop	{r3, pc}
              : ( odr <= 20.000f ) ? LSM303AGR_MAG_ODR_20Hz
 8003914:	2100      	movs	r1, #0
  if ( LSM303AGR_MAG_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 8003916:	f7ff ff45 	bl	80037a4 <LSM303AGR_MAG_W_ODR>
}
 800391a:	fab0 f080 	clz	r0, r0
 800391e:	0940      	lsrs	r0, r0, #5
 8003920:	bd08      	pop	{r3, pc}
              : ( odr <= 20.000f ) ? LSM303AGR_MAG_ODR_20Hz
 8003922:	eddf 7a07 	vldr	s15, [pc, #28]	; 8003940 <LSM303AGR_M_Set_ODR_Value+0x58>
 8003926:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800392a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800392e:	bf94      	ite	ls
 8003930:	2108      	movls	r1, #8
 8003932:	210c      	movhi	r1, #12
  if ( LSM303AGR_MAG_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 8003934:	f7ff ff36 	bl	80037a4 <LSM303AGR_MAG_W_ODR>
}
 8003938:	fab0 f080 	clz	r0, r0
 800393c:	0940      	lsrs	r0, r0, #5
 800393e:	bd08      	pop	{r3, pc}
 8003940:	42480000 	.word	0x42480000

08003944 <LSM303AGR_M_Set_ODR>:
{
 8003944:	b508      	push	{r3, lr}
  switch( odr )
 8003946:	2904      	cmp	r1, #4
 8003948:	d820      	bhi.n	800398c <LSM303AGR_M_Set_ODR+0x48>
 800394a:	e8df f001 	tbb	[pc, r1]
 800394e:	180a      	.short	0x180a
 8003950:	0311      	.short	0x0311
 8003952:	03          	.byte	0x03
 8003953:	00          	.byte	0x00
      new_odr = LSM303AGR_MAG_ODR_100Hz;
 8003954:	210c      	movs	r1, #12
  if ( LSM303AGR_MAG_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 8003956:	f7ff ff25 	bl	80037a4 <LSM303AGR_MAG_W_ODR>
      return COMPONENT_ERROR;
 800395a:	fab0 f080 	clz	r0, r0
 800395e:	0940      	lsrs	r0, r0, #5
 8003960:	bd08      	pop	{r3, pc}
      new_odr = LSM303AGR_MAG_ODR_10Hz;
 8003962:	2100      	movs	r1, #0
  if ( LSM303AGR_MAG_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 8003964:	f7ff ff1e 	bl	80037a4 <LSM303AGR_MAG_W_ODR>
      return COMPONENT_ERROR;
 8003968:	fab0 f080 	clz	r0, r0
 800396c:	0940      	lsrs	r0, r0, #5
 800396e:	bd08      	pop	{r3, pc}
      new_odr = LSM303AGR_MAG_ODR_50Hz;
 8003970:	2108      	movs	r1, #8
  if ( LSM303AGR_MAG_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 8003972:	f7ff ff17 	bl	80037a4 <LSM303AGR_MAG_W_ODR>
      return COMPONENT_ERROR;
 8003976:	fab0 f080 	clz	r0, r0
 800397a:	0940      	lsrs	r0, r0, #5
 800397c:	bd08      	pop	{r3, pc}
      new_odr = LSM303AGR_MAG_ODR_20Hz;
 800397e:	2104      	movs	r1, #4
  if ( LSM303AGR_MAG_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 8003980:	f7ff ff10 	bl	80037a4 <LSM303AGR_MAG_W_ODR>
      return COMPONENT_ERROR;
 8003984:	fab0 f080 	clz	r0, r0
 8003988:	0940      	lsrs	r0, r0, #5
 800398a:	bd08      	pop	{r3, pc}
 800398c:	2001      	movs	r0, #1
}
 800398e:	bd08      	pop	{r3, pc}

08003990 <LSM303AGR_M_Get_ODR>:
{
 8003990:	b510      	push	{r4, lr}
 8003992:	b082      	sub	sp, #8
 8003994:	460c      	mov	r4, r1
  if ( LSM303AGR_MAG_R_ODR( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 8003996:	f10d 0107 	add.w	r1, sp, #7
 800399a:	f7ff ff25 	bl	80037e8 <LSM303AGR_MAG_R_ODR>
 800399e:	b160      	cbz	r0, 80039ba <LSM303AGR_M_Get_ODR+0x2a>
  switch( odr_low_level )
 80039a0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80039a4:	2b0c      	cmp	r3, #12
 80039a6:	d81f      	bhi.n	80039e8 <LSM303AGR_M_Get_ODR+0x58>
 80039a8:	e8df f003 	tbb	[pc, r3]
 80039ac:	1e1e1e0f 	.word	0x1e1e1e0f
 80039b0:	1e1e1e14 	.word	0x1e1e1e14
 80039b4:	1e1e1e19 	.word	0x1e1e1e19
 80039b8:	0a          	.byte	0x0a
 80039b9:	00          	.byte	0x00
    return COMPONENT_ERROR;
 80039ba:	2001      	movs	r0, #1
}
 80039bc:	b002      	add	sp, #8
 80039be:	bd10      	pop	{r4, pc}
      *odr = 100.000f;
 80039c0:	4b0c      	ldr	r3, [pc, #48]	; (80039f4 <LSM303AGR_M_Get_ODR+0x64>)
 80039c2:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80039c4:	2000      	movs	r0, #0
}
 80039c6:	b002      	add	sp, #8
 80039c8:	bd10      	pop	{r4, pc}
      *odr = 10.000f;
 80039ca:	4b0b      	ldr	r3, [pc, #44]	; (80039f8 <LSM303AGR_M_Get_ODR+0x68>)
 80039cc:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80039ce:	2000      	movs	r0, #0
}
 80039d0:	b002      	add	sp, #8
 80039d2:	bd10      	pop	{r4, pc}
      *odr = 20.000f;
 80039d4:	4b09      	ldr	r3, [pc, #36]	; (80039fc <LSM303AGR_M_Get_ODR+0x6c>)
 80039d6:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80039d8:	2000      	movs	r0, #0
}
 80039da:	b002      	add	sp, #8
 80039dc:	bd10      	pop	{r4, pc}
      *odr = 50.000f;
 80039de:	4b08      	ldr	r3, [pc, #32]	; (8003a00 <LSM303AGR_M_Get_ODR+0x70>)
 80039e0:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80039e2:	2000      	movs	r0, #0
}
 80039e4:	b002      	add	sp, #8
 80039e6:	bd10      	pop	{r4, pc}
      *odr = -1.000f;
 80039e8:	4b06      	ldr	r3, [pc, #24]	; (8003a04 <LSM303AGR_M_Get_ODR+0x74>)
 80039ea:	6023      	str	r3, [r4, #0]
      return COMPONENT_ERROR;
 80039ec:	2001      	movs	r0, #1
}
 80039ee:	b002      	add	sp, #8
 80039f0:	bd10      	pop	{r4, pc}
 80039f2:	bf00      	nop
 80039f4:	42c80000 	.word	0x42c80000
 80039f8:	41200000 	.word	0x41200000
 80039fc:	41a00000 	.word	0x41a00000
 8003a00:	42480000 	.word	0x42480000
 8003a04:	bf800000 	.word	0xbf800000

08003a08 <LSM303AGR_M_Get_Axes>:
{
 8003a08:	b530      	push	{r4, r5, lr}
 8003a0a:	b083      	sub	sp, #12
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef LSM303AGR_M_Get_Axes_Raw( DrvContextTypeDef *handle, int16_t* pData )
{

  uint8_t regValue[6] = {0, 0, 0, 0, 0, 0};
 8003a0c:	2400      	movs	r4, #0
{
 8003a0e:	460d      	mov	r5, r1
  int16_t *regValueInt16;

  /* Read output registers from LSM303AGR_MAG_OUTX_L to LSM303AGR_MAG_OUTZ_H. */
  if ( LSM303AGR_MAG_Get_Raw_Magnetic( (void *)handle, regValue ) == MEMS_ERROR )
 8003a10:	4669      	mov	r1, sp
  uint8_t regValue[6] = {0, 0, 0, 0, 0, 0};
 8003a12:	f8ad 4004 	strh.w	r4, [sp, #4]
 8003a16:	9400      	str	r4, [sp, #0]
  if ( LSM303AGR_MAG_Get_Raw_Magnetic( (void *)handle, regValue ) == MEMS_ERROR )
 8003a18:	f7ff feba 	bl	8003790 <LSM303AGR_MAG_Get_Raw_Magnetic>
 8003a1c:	b340      	cbz	r0, 8003a70 <LSM303AGR_M_Get_Axes+0x68>
  }

  regValueInt16 = (int16_t *)regValue;

  /* Format the data. */
  pData[0] = regValueInt16[0];
 8003a1e:	f9bd 3000 	ldrsh.w	r3, [sp]
 8003a22:	ee06 3a90 	vmov	s13, r3
  pData[1] = regValueInt16[1];
 8003a26:	f9bd 3002 	ldrsh.w	r3, [sp, #2]
 8003a2a:	ee07 3a10 	vmov	s14, r3
  pData[2] = regValueInt16[2];
 8003a2e:	f9bd 3004 	ldrsh.w	r3, [sp, #4]
 8003a32:	ee07 3a90 	vmov	s15, r3
  magnetic_field->AXIS_X = ( int32_t )( pDataRaw[0] * sensitivity );
 8003a36:	eef8 6ae6 	vcvt.f32.s32	s13, s13
  magnetic_field->AXIS_Y = ( int32_t )( pDataRaw[1] * sensitivity );
 8003a3a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  magnetic_field->AXIS_Z = ( int32_t )( pDataRaw[2] * sensitivity );
 8003a3e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  magnetic_field->AXIS_X = ( int32_t )( pDataRaw[0] * sensitivity );
 8003a42:	eeb7 6a08 	vmov.f32	s12, #120	; 0x3fc00000  1.5
 8003a46:	ee66 6a86 	vmul.f32	s13, s13, s12
  magnetic_field->AXIS_Y = ( int32_t )( pDataRaw[1] * sensitivity );
 8003a4a:	ee27 7a06 	vmul.f32	s14, s14, s12
  magnetic_field->AXIS_Z = ( int32_t )( pDataRaw[2] * sensitivity );
 8003a4e:	ee67 7a86 	vmul.f32	s15, s15, s12
  magnetic_field->AXIS_X = ( int32_t )( pDataRaw[0] * sensitivity );
 8003a52:	eefd 6ae6 	vcvt.s32.f32	s13, s13
  magnetic_field->AXIS_Y = ( int32_t )( pDataRaw[1] * sensitivity );
 8003a56:	eebd 7ac7 	vcvt.s32.f32	s14, s14
  magnetic_field->AXIS_Z = ( int32_t )( pDataRaw[2] * sensitivity );
 8003a5a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  return COMPONENT_OK;
 8003a5e:	4620      	mov	r0, r4
  magnetic_field->AXIS_X = ( int32_t )( pDataRaw[0] * sensitivity );
 8003a60:	edc5 6a00 	vstr	s13, [r5]
  magnetic_field->AXIS_Y = ( int32_t )( pDataRaw[1] * sensitivity );
 8003a64:	ed85 7a01 	vstr	s14, [r5, #4]
  magnetic_field->AXIS_Z = ( int32_t )( pDataRaw[2] * sensitivity );
 8003a68:	edc5 7a02 	vstr	s15, [r5, #8]
}
 8003a6c:	b003      	add	sp, #12
 8003a6e:	bd30      	pop	{r4, r5, pc}
    return COMPONENT_ERROR;
 8003a70:	2001      	movs	r0, #1
}
 8003a72:	b003      	add	sp, #12
 8003a74:	bd30      	pop	{r4, r5, pc}
 8003a76:	bf00      	nop

08003a78 <LSM303AGR_M_Get_WhoAmI>:
{
 8003a78:	b508      	push	{r3, lr}
  if ( LSM303AGR_MAG_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 8003a7a:	f7ff fe3b 	bl	80036f4 <LSM303AGR_MAG_R_WHO_AM_I>
}
 8003a7e:	fab0 f080 	clz	r0, r0
 8003a82:	0940      	lsrs	r0, r0, #5
 8003a84:	bd08      	pop	{r3, pc}
 8003a86:	bf00      	nop

08003a88 <LSM303AGR_M_Check_WhoAmI>:
{
 8003a88:	b510      	push	{r4, lr}
 8003a8a:	b082      	sub	sp, #8
  uint8_t who_am_i = 0x00;
 8003a8c:	a902      	add	r1, sp, #8
 8003a8e:	2300      	movs	r3, #0
 8003a90:	f801 3d01 	strb.w	r3, [r1, #-1]!
{
 8003a94:	4604      	mov	r4, r0
  if ( LSM303AGR_MAG_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 8003a96:	f7ff fe2d 	bl	80036f4 <LSM303AGR_MAG_R_WHO_AM_I>
 8003a9a:	b910      	cbnz	r0, 8003aa2 <LSM303AGR_M_Check_WhoAmI+0x1a>
 8003a9c:	2001      	movs	r0, #1
}
 8003a9e:	b002      	add	sp, #8
 8003aa0:	bd10      	pop	{r4, pc}
  if ( who_am_i != handle->who_am_i )
 8003aa2:	7820      	ldrb	r0, [r4, #0]
 8003aa4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003aa8:	1ac0      	subs	r0, r0, r3
 8003aaa:	bf18      	it	ne
 8003aac:	2001      	movne	r0, #1
}
 8003aae:	b002      	add	sp, #8
 8003ab0:	bd10      	pop	{r4, pc}
 8003ab2:	bf00      	nop

08003ab4 <LSM303AGR_M_Sensor_Enable>:
  if ( handle->isEnabled == 1 )
 8003ab4:	7982      	ldrb	r2, [r0, #6]
 8003ab6:	2a01      	cmp	r2, #1
 8003ab8:	d00b      	beq.n	8003ad2 <LSM303AGR_M_Sensor_Enable+0x1e>
{
 8003aba:	b510      	push	{r4, lr}
  if ( LSM303AGR_MAG_W_MD( (void *)handle, LSM303AGR_MAG_MD_CONTINUOS_MODE ) == MEMS_ERROR )
 8003abc:	2100      	movs	r1, #0
 8003abe:	4604      	mov	r4, r0
 8003ac0:	f7ff fe44 	bl	800374c <LSM303AGR_MAG_W_MD>
 8003ac4:	b118      	cbz	r0, 8003ace <LSM303AGR_M_Sensor_Enable+0x1a>
  handle->isEnabled = 1;
 8003ac6:	2301      	movs	r3, #1
 8003ac8:	71a3      	strb	r3, [r4, #6]
  return COMPONENT_OK;
 8003aca:	2000      	movs	r0, #0
 8003acc:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 8003ace:	2001      	movs	r0, #1
}
 8003ad0:	bd10      	pop	{r4, pc}
    return COMPONENT_OK;
 8003ad2:	2000      	movs	r0, #0
 8003ad4:	4770      	bx	lr
 8003ad6:	bf00      	nop

08003ad8 <LSM303AGR_M_Sensor_Disable>:
  if ( handle->isEnabled == 0 )
 8003ad8:	7983      	ldrb	r3, [r0, #6]
 8003ada:	b90b      	cbnz	r3, 8003ae0 <LSM303AGR_M_Sensor_Disable+0x8>
    return COMPONENT_OK;
 8003adc:	4618      	mov	r0, r3
 8003ade:	4770      	bx	lr
{
 8003ae0:	b510      	push	{r4, lr}
  if ( LSM303AGR_MAG_W_MD( (void *)handle, LSM303AGR_MAG_MD_IDLE1_MODE ) == MEMS_ERROR )
 8003ae2:	2102      	movs	r1, #2
 8003ae4:	4604      	mov	r4, r0
 8003ae6:	f7ff fe31 	bl	800374c <LSM303AGR_MAG_W_MD>
 8003aea:	b118      	cbz	r0, 8003af4 <LSM303AGR_M_Sensor_Disable+0x1c>
  handle->isEnabled = 0;
 8003aec:	2300      	movs	r3, #0
 8003aee:	71a3      	strb	r3, [r4, #6]
  return COMPONENT_OK;
 8003af0:	4618      	mov	r0, r3
 8003af2:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 8003af4:	2001      	movs	r0, #1
}
 8003af6:	bd10      	pop	{r4, pc}

08003af8 <LSM303AGR_M_Get_AxesRaw>:
{
 8003af8:	b530      	push	{r4, r5, lr}
 8003afa:	b083      	sub	sp, #12
  uint8_t regValue[6] = {0, 0, 0, 0, 0, 0};
 8003afc:	2400      	movs	r4, #0
{
 8003afe:	460d      	mov	r5, r1
  if ( LSM303AGR_MAG_Get_Raw_Magnetic( (void *)handle, regValue ) == MEMS_ERROR )
 8003b00:	4669      	mov	r1, sp
  uint8_t regValue[6] = {0, 0, 0, 0, 0, 0};
 8003b02:	f8ad 4004 	strh.w	r4, [sp, #4]
 8003b06:	9400      	str	r4, [sp, #0]
  if ( LSM303AGR_MAG_Get_Raw_Magnetic( (void *)handle, regValue ) == MEMS_ERROR )
 8003b08:	f7ff fe42 	bl	8003790 <LSM303AGR_MAG_Get_Raw_Magnetic>
 8003b0c:	b158      	cbz	r0, 8003b26 <LSM303AGR_M_Get_AxesRaw+0x2e>
  pData[0] = regValueInt16[0];
 8003b0e:	f9bd 1000 	ldrsh.w	r1, [sp]
  pData[1] = regValueInt16[1];
 8003b12:	f9bd 2002 	ldrsh.w	r2, [sp, #2]
  pData[2] = regValueInt16[2];
 8003b16:	f9bd 3004 	ldrsh.w	r3, [sp, #4]
  value->AXIS_X = pDataRaw[0];
 8003b1a:	8029      	strh	r1, [r5, #0]
  return COMPONENT_OK;
 8003b1c:	4620      	mov	r0, r4
  value->AXIS_Y = pDataRaw[1];
 8003b1e:	806a      	strh	r2, [r5, #2]
  value->AXIS_Z = pDataRaw[2];
 8003b20:	80ab      	strh	r3, [r5, #4]
}
 8003b22:	b003      	add	sp, #12
 8003b24:	bd30      	pop	{r4, r5, pc}
    return COMPONENT_ERROR;
 8003b26:	2001      	movs	r0, #1
}
 8003b28:	b003      	add	sp, #12
 8003b2a:	bd30      	pop	{r4, r5, pc}

08003b2c <LSM303AGR_M_DeInit>:
{
 8003b2c:	b570      	push	{r4, r5, r6, lr}
  LSM303AGR_M_Data_t *pComponentData = ( LSM303AGR_M_Data_t * )pData->pComponentData;
 8003b2e:	6883      	ldr	r3, [r0, #8]
{
 8003b30:	b082      	sub	sp, #8
  LSM303AGR_Combo_Data_t *comboData = pComponentData->comboData;
 8003b32:	681b      	ldr	r3, [r3, #0]
  uint8_t who_am_i = 0x00;
 8003b34:	a902      	add	r1, sp, #8
 8003b36:	2500      	movs	r5, #0
  LSM303AGR_Combo_Data_t *comboData = pComponentData->comboData;
 8003b38:	681e      	ldr	r6, [r3, #0]
  uint8_t who_am_i = 0x00;
 8003b3a:	f801 5d01 	strb.w	r5, [r1, #-1]!
{
 8003b3e:	4604      	mov	r4, r0
  if ( LSM303AGR_MAG_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 8003b40:	f7ff fdd8 	bl	80036f4 <LSM303AGR_MAG_R_WHO_AM_I>
 8003b44:	b910      	cbnz	r0, 8003b4c <LSM303AGR_M_DeInit+0x20>
    return COMPONENT_ERROR;
 8003b46:	2001      	movs	r0, #1
}
 8003b48:	b002      	add	sp, #8
 8003b4a:	bd70      	pop	{r4, r5, r6, pc}
  if ( who_am_i != handle->who_am_i )
 8003b4c:	7822      	ldrb	r2, [r4, #0]
 8003b4e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003b52:	429a      	cmp	r2, r3
 8003b54:	d1f7      	bne.n	8003b46 <LSM303AGR_M_DeInit+0x1a>
  if ( handle->isEnabled == 0 )
 8003b56:	79a3      	ldrb	r3, [r4, #6]
 8003b58:	b92b      	cbnz	r3, 8003b66 <LSM303AGR_M_DeInit+0x3a>
  comboData->isMagInitialized = 0;
 8003b5a:	2300      	movs	r3, #0
  return COMPONENT_OK;
 8003b5c:	4618      	mov	r0, r3
  comboData->isMagInitialized = 0;
 8003b5e:	7073      	strb	r3, [r6, #1]
  handle->isInitialized = 0;
 8003b60:	7163      	strb	r3, [r4, #5]
}
 8003b62:	b002      	add	sp, #8
 8003b64:	bd70      	pop	{r4, r5, r6, pc}
  if ( LSM303AGR_MAG_W_MD( (void *)handle, LSM303AGR_MAG_MD_IDLE1_MODE ) == MEMS_ERROR )
 8003b66:	2102      	movs	r1, #2
 8003b68:	4620      	mov	r0, r4
 8003b6a:	f7ff fdef 	bl	800374c <LSM303AGR_MAG_W_MD>
 8003b6e:	2800      	cmp	r0, #0
 8003b70:	d0e9      	beq.n	8003b46 <LSM303AGR_M_DeInit+0x1a>
  handle->isEnabled = 0;
 8003b72:	71a5      	strb	r5, [r4, #6]
 8003b74:	e7f1      	b.n	8003b5a <LSM303AGR_M_DeInit+0x2e>
 8003b76:	bf00      	nop

08003b78 <LSM303AGR_M_Init>:
{
 8003b78:	b570      	push	{r4, r5, r6, lr}
  LSM303AGR_M_Data_t *pComponentData = ( LSM303AGR_M_Data_t * )pData->pComponentData;
 8003b7a:	6883      	ldr	r3, [r0, #8]
{
 8003b7c:	b082      	sub	sp, #8
  LSM303AGR_Combo_Data_t *comboData = pComponentData->comboData;
 8003b7e:	681b      	ldr	r3, [r3, #0]
  uint8_t who_am_i = 0x00;
 8003b80:	a902      	add	r1, sp, #8
 8003b82:	2400      	movs	r4, #0
  LSM303AGR_Combo_Data_t *comboData = pComponentData->comboData;
 8003b84:	681e      	ldr	r6, [r3, #0]
  uint8_t who_am_i = 0x00;
 8003b86:	f801 4d01 	strb.w	r4, [r1, #-1]!
{
 8003b8a:	4605      	mov	r5, r0
  if ( LSM303AGR_MAG_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 8003b8c:	f7ff fdb2 	bl	80036f4 <LSM303AGR_MAG_R_WHO_AM_I>
 8003b90:	b120      	cbz	r0, 8003b9c <LSM303AGR_M_Init+0x24>
  if ( who_am_i != handle->who_am_i )
 8003b92:	782a      	ldrb	r2, [r5, #0]
 8003b94:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003b98:	429a      	cmp	r2, r3
 8003b9a:	d002      	beq.n	8003ba2 <LSM303AGR_M_Init+0x2a>
    return COMPONENT_ERROR;
 8003b9c:	2001      	movs	r0, #1
}
 8003b9e:	b002      	add	sp, #8
 8003ba0:	bd70      	pop	{r4, r5, r6, pc}
  if ( LSM303AGR_MAG_W_MD( (void *)handle, LSM303AGR_MAG_MD_IDLE1_MODE ) == MEMS_ERROR )
 8003ba2:	2102      	movs	r1, #2
 8003ba4:	4628      	mov	r0, r5
 8003ba6:	f7ff fdd1 	bl	800374c <LSM303AGR_MAG_W_MD>
 8003baa:	2800      	cmp	r0, #0
 8003bac:	d0f6      	beq.n	8003b9c <LSM303AGR_M_Init+0x24>
  if ( LSM303AGR_MAG_W_BDU( (void *)handle, LSM303AGR_MAG_BDU_ENABLED ) == MEMS_ERROR )
 8003bae:	2110      	movs	r1, #16
 8003bb0:	4628      	mov	r0, r5
 8003bb2:	f7ff fda9 	bl	8003708 <LSM303AGR_MAG_W_BDU>
 8003bb6:	2800      	cmp	r0, #0
 8003bb8:	d0f0      	beq.n	8003b9c <LSM303AGR_M_Init+0x24>
  if ( LSM303AGR_MAG_W_ODR( (void *)handle, new_odr ) == MEMS_ERROR )
 8003bba:	210c      	movs	r1, #12
 8003bbc:	4628      	mov	r0, r5
 8003bbe:	f7ff fdf1 	bl	80037a4 <LSM303AGR_MAG_W_ODR>
 8003bc2:	2800      	cmp	r0, #0
 8003bc4:	d0ea      	beq.n	8003b9c <LSM303AGR_M_Init+0x24>
  if ( LSM303AGR_MAG_W_ST( (void *)handle, LSM303AGR_MAG_ST_DISABLED ) == MEMS_ERROR )
 8003bc6:	4621      	mov	r1, r4
 8003bc8:	4628      	mov	r0, r5
 8003bca:	f7ff fe1d 	bl	8003808 <LSM303AGR_MAG_W_ST>
 8003bce:	2800      	cmp	r0, #0
 8003bd0:	d0e4      	beq.n	8003b9c <LSM303AGR_M_Init+0x24>
  comboData->isMagInitialized = 1;
 8003bd2:	2301      	movs	r3, #1
 8003bd4:	7073      	strb	r3, [r6, #1]
  return COMPONENT_OK;
 8003bd6:	4620      	mov	r0, r4
  handle->isInitialized = 1;
 8003bd8:	716b      	strb	r3, [r5, #5]
  return COMPONENT_OK;
 8003bda:	e7e0      	b.n	8003b9e <LSM303AGR_M_Init+0x26>

08003bdc <LSM6DSL_ACC_GYRO_ReadReg>:
* Input       : Register Address, length of buffer
* Output      : Data REad
* Return      : None
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_ReadReg(void *handle, u8_t Reg, u8_t* Data, u16_t len)
{
 8003bdc:	b508      	push	{r3, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003bde:	f003 fcc5 	bl	800756c <Sensor_IO_Read>
  }
  else
  {
    return MEMS_SUCCESS;
  }
}
 8003be2:	fab0 f080 	clz	r0, r0
 8003be6:	0940      	lsrs	r0, r0, #5
 8003be8:	bd08      	pop	{r3, pc}
 8003bea:	bf00      	nop

08003bec <LSM6DSL_ACC_GYRO_WriteReg>:
* Input       : Register Address, Data to be written, length of buffer
* Output      : None
* Return      : None
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_WriteReg(void *handle, u8_t Reg, u8_t *Data, u16_t len)
{
 8003bec:	b508      	push	{r3, lr}
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003bee:	f003 fc6f 	bl	80074d0 <Sensor_IO_Write>
  }
  else
  {
    return MEMS_SUCCESS;
  }
}
 8003bf2:	fab0 f080 	clz	r0, r0
 8003bf6:	0940      	lsrs	r0, r0, #5
 8003bf8:	bd08      	pop	{r3, pc}
 8003bfa:	bf00      	nop

08003bfc <LSM6DSL_ACC_GYRO_R_WHO_AM_I>:
* Input          : Pointer to u8_t
* Output         : Status of WHO_AM_I_BIT
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_WHO_AM_I(void *handle, u8_t *value)
{
 8003bfc:	b508      	push	{r3, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003bfe:	460a      	mov	r2, r1
 8003c00:	2301      	movs	r3, #1
 8003c02:	210f      	movs	r1, #15
 8003c04:	f003 fcb2 	bl	800756c <Sensor_IO_Read>

  *value &= LSM6DSL_ACC_GYRO_WHO_AM_I_BIT_MASK; //coerce
  *value = *value >> LSM6DSL_ACC_GYRO_WHO_AM_I_BIT_POSITION; //mask

  return MEMS_SUCCESS;
}
 8003c08:	fab0 f080 	clz	r0, r0
 8003c0c:	0940      	lsrs	r0, r0, #5
 8003c0e:	bd08      	pop	{r3, pc}

08003c10 <LSM6DSL_ACC_GYRO_W_BDU>:
* Input          : LSM6DSL_ACC_GYRO_BDU_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_BDU(void *handle, LSM6DSL_ACC_GYRO_BDU_t newValue)
{
 8003c10:	b530      	push	{r4, r5, lr}
 8003c12:	b083      	sub	sp, #12
 8003c14:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003c16:	f10d 0207 	add.w	r2, sp, #7
 8003c1a:	2301      	movs	r3, #1
 8003c1c:	2112      	movs	r1, #18
{
 8003c1e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003c20:	f003 fca4 	bl	800756c <Sensor_IO_Read>
 8003c24:	b110      	cbz	r0, 8003c2c <LSM6DSL_ACC_GYRO_W_BDU+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CTRL3_C, &value, 1))
    return MEMS_ERROR;
 8003c26:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_CTRL3_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8003c28:	b003      	add	sp, #12
 8003c2a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_BDU_MASK;
 8003c2c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003c30:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  value |= newValue;
 8003c34:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003c36:	f10d 0207 	add.w	r2, sp, #7
 8003c3a:	4628      	mov	r0, r5
 8003c3c:	2301      	movs	r3, #1
 8003c3e:	2112      	movs	r1, #18
  value |= newValue;
 8003c40:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003c44:	f003 fc44 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8003c48:	fab0 f080 	clz	r0, r0
 8003c4c:	0940      	lsrs	r0, r0, #5
}
 8003c4e:	b003      	add	sp, #12
 8003c50:	bd30      	pop	{r4, r5, pc}
 8003c52:	bf00      	nop

08003c54 <LSM6DSL_ACC_GYRO_W_FS_XL>:
* Input          : LSM6DSL_ACC_GYRO_FS_XL_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_FS_XL(void *handle, LSM6DSL_ACC_GYRO_FS_XL_t newValue)
{
 8003c54:	b530      	push	{r4, r5, lr}
 8003c56:	b083      	sub	sp, #12
 8003c58:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003c5a:	f10d 0207 	add.w	r2, sp, #7
 8003c5e:	2301      	movs	r3, #1
 8003c60:	2110      	movs	r1, #16
{
 8003c62:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003c64:	f003 fc82 	bl	800756c <Sensor_IO_Read>
 8003c68:	b110      	cbz	r0, 8003c70 <LSM6DSL_ACC_GYRO_W_FS_XL+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CTRL1_XL, &value, 1))
    return MEMS_ERROR;
 8003c6a:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_CTRL1_XL, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8003c6c:	b003      	add	sp, #12
 8003c6e:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_FS_XL_MASK;
 8003c70:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003c74:	f023 030c 	bic.w	r3, r3, #12
  value |= newValue;
 8003c78:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003c7a:	f10d 0207 	add.w	r2, sp, #7
 8003c7e:	4628      	mov	r0, r5
 8003c80:	2301      	movs	r3, #1
 8003c82:	2110      	movs	r1, #16
  value |= newValue;
 8003c84:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003c88:	f003 fc22 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8003c8c:	fab0 f080 	clz	r0, r0
 8003c90:	0940      	lsrs	r0, r0, #5
}
 8003c92:	b003      	add	sp, #12
 8003c94:	bd30      	pop	{r4, r5, pc}
 8003c96:	bf00      	nop

08003c98 <LSM6DSL_ACC_GYRO_R_FS_XL>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_FS_XL_t
* Output         : Status of FS_XL see LSM6DSL_ACC_GYRO_FS_XL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_FS_XL(void *handle, LSM6DSL_ACC_GYRO_FS_XL_t *value)
{
 8003c98:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003c9a:	460a      	mov	r2, r1
{
 8003c9c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003c9e:	2301      	movs	r3, #1
 8003ca0:	2110      	movs	r1, #16
 8003ca2:	f003 fc63 	bl	800756c <Sensor_IO_Read>
 8003ca6:	b108      	cbz	r0, 8003cac <LSM6DSL_ACC_GYRO_R_FS_XL+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CTRL1_XL, (u8_t *)value, 1))
    return MEMS_ERROR;
 8003ca8:	2000      	movs	r0, #0
 8003caa:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_FS_XL_MASK; //mask
 8003cac:	7823      	ldrb	r3, [r4, #0]
 8003cae:	f003 030c 	and.w	r3, r3, #12
 8003cb2:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8003cb4:	2001      	movs	r0, #1
}
 8003cb6:	bd10      	pop	{r4, pc}

08003cb8 <LSM6DSL_ACC_GYRO_GetRawAccData>:
* Input          : pointer to [u8_t]
* Output         : GetAccData buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_GetRawAccData(void *handle, u8_t *buff)
{
 8003cb8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003cbc:	4680      	mov	r8, r0
 8003cbe:	460f      	mov	r7, r1
 8003cc0:	2503      	movs	r5, #3
  u8_t i, j, k;
  u8_t numberOfByteForDimension;

  numberOfByteForDimension = 6 / 3;

  k = 0;
 8003cc2:	2400      	movs	r4, #0
 8003cc4:	1ca6      	adds	r6, r4, #2
 8003cc6:	b2f6      	uxtb	r6, r6
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003cc8:	f104 0128 	add.w	r1, r4, #40	; 0x28
 8003ccc:	193a      	adds	r2, r7, r4
 8003cce:	b2c9      	uxtb	r1, r1
 8003cd0:	2301      	movs	r3, #1
 8003cd2:	4640      	mov	r0, r8
 8003cd4:	f003 fc4a 	bl	800756c <Sensor_IO_Read>
  {
    for (j = 0; j < numberOfByteForDimension; j++ )
    {
      if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_OUTX_L_XL + k, &buff[k], 1))
        return MEMS_ERROR;
      k++;
 8003cd8:	3401      	adds	r4, #1
 8003cda:	b2e4      	uxtb	r4, r4
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003cdc:	b940      	cbnz	r0, 8003cf0 <LSM6DSL_ACC_GYRO_GetRawAccData+0x38>
    for (j = 0; j < numberOfByteForDimension; j++ )
 8003cde:	42b4      	cmp	r4, r6
 8003ce0:	d1f2      	bne.n	8003cc8 <LSM6DSL_ACC_GYRO_GetRawAccData+0x10>
 8003ce2:	1e6b      	subs	r3, r5, #1
  for (i = 0; i < 3; i++ )
 8003ce4:	f013 05ff 	ands.w	r5, r3, #255	; 0xff
 8003ce8:	d1ec      	bne.n	8003cc4 <LSM6DSL_ACC_GYRO_GetRawAccData+0xc>
    }
  }

  return MEMS_SUCCESS;
 8003cea:	2001      	movs	r0, #1
 8003cec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return MEMS_ERROR;
 8003cf0:	2000      	movs	r0, #0
 8003cf2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003cf6:	bf00      	nop

08003cf8 <LSM6DSL_ACC_GYRO_W_ODR_XL>:
* Input          : LSM6DSL_ACC_GYRO_ODR_XL_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_ODR_XL(void *handle, LSM6DSL_ACC_GYRO_ODR_XL_t newValue)
{
 8003cf8:	b530      	push	{r4, r5, lr}
 8003cfa:	b083      	sub	sp, #12
 8003cfc:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003cfe:	f10d 0207 	add.w	r2, sp, #7
 8003d02:	2301      	movs	r3, #1
 8003d04:	2110      	movs	r1, #16
{
 8003d06:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003d08:	f003 fc30 	bl	800756c <Sensor_IO_Read>
 8003d0c:	b110      	cbz	r0, 8003d14 <LSM6DSL_ACC_GYRO_W_ODR_XL+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CTRL1_XL, &value, 1))
    return MEMS_ERROR;
 8003d0e:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_CTRL1_XL, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8003d10:	b003      	add	sp, #12
 8003d12:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_ODR_XL_MASK;
 8003d14:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003d18:	f003 030f 	and.w	r3, r3, #15
  value |= newValue;
 8003d1c:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003d1e:	f10d 0207 	add.w	r2, sp, #7
 8003d22:	4628      	mov	r0, r5
 8003d24:	2301      	movs	r3, #1
 8003d26:	2110      	movs	r1, #16
  value |= newValue;
 8003d28:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003d2c:	f003 fbd0 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8003d30:	fab0 f080 	clz	r0, r0
 8003d34:	0940      	lsrs	r0, r0, #5
}
 8003d36:	b003      	add	sp, #12
 8003d38:	bd30      	pop	{r4, r5, pc}
 8003d3a:	bf00      	nop

08003d3c <LSM6DSL_ACC_GYRO_R_ODR_XL>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_ODR_XL_t
* Output         : Status of ODR_XL see LSM6DSL_ACC_GYRO_ODR_XL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_ODR_XL(void *handle, LSM6DSL_ACC_GYRO_ODR_XL_t *value)
{
 8003d3c:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003d3e:	460a      	mov	r2, r1
{
 8003d40:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003d42:	2301      	movs	r3, #1
 8003d44:	2110      	movs	r1, #16
 8003d46:	f003 fc11 	bl	800756c <Sensor_IO_Read>
 8003d4a:	b108      	cbz	r0, 8003d50 <LSM6DSL_ACC_GYRO_R_ODR_XL+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CTRL1_XL, (u8_t *)value, 1))
    return MEMS_ERROR;
 8003d4c:	2000      	movs	r0, #0
 8003d4e:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_ODR_XL_MASK; //mask
 8003d50:	7823      	ldrb	r3, [r4, #0]
 8003d52:	f023 030f 	bic.w	r3, r3, #15
 8003d56:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8003d58:	2001      	movs	r0, #1
}
 8003d5a:	bd10      	pop	{r4, pc}

08003d5c <LSM6DSL_ACC_GYRO_W_FS_G>:
* Input          : LSM6DSL_ACC_GYRO_FS_G_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_FS_G(void *handle, LSM6DSL_ACC_GYRO_FS_G_t newValue)
{
 8003d5c:	b530      	push	{r4, r5, lr}
 8003d5e:	b083      	sub	sp, #12
 8003d60:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003d62:	f10d 0207 	add.w	r2, sp, #7
 8003d66:	2301      	movs	r3, #1
 8003d68:	2111      	movs	r1, #17
{
 8003d6a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003d6c:	f003 fbfe 	bl	800756c <Sensor_IO_Read>
 8003d70:	b110      	cbz	r0, 8003d78 <LSM6DSL_ACC_GYRO_W_FS_G+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CTRL2_G, &value, 1))
    return MEMS_ERROR;
 8003d72:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_CTRL2_G, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8003d74:	b003      	add	sp, #12
 8003d76:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_FS_G_MASK;
 8003d78:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003d7c:	f023 030c 	bic.w	r3, r3, #12
  value |= newValue;
 8003d80:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003d82:	f10d 0207 	add.w	r2, sp, #7
 8003d86:	4628      	mov	r0, r5
 8003d88:	2301      	movs	r3, #1
 8003d8a:	2111      	movs	r1, #17
  value |= newValue;
 8003d8c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003d90:	f003 fb9e 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8003d94:	fab0 f080 	clz	r0, r0
 8003d98:	0940      	lsrs	r0, r0, #5
}
 8003d9a:	b003      	add	sp, #12
 8003d9c:	bd30      	pop	{r4, r5, pc}
 8003d9e:	bf00      	nop

08003da0 <LSM6DSL_ACC_GYRO_R_FS_G>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_FS_G_t
* Output         : Status of FS_G see LSM6DSL_ACC_GYRO_FS_G_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_FS_G(void *handle, LSM6DSL_ACC_GYRO_FS_G_t *value)
{
 8003da0:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003da2:	460a      	mov	r2, r1
{
 8003da4:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003da6:	2301      	movs	r3, #1
 8003da8:	2111      	movs	r1, #17
 8003daa:	f003 fbdf 	bl	800756c <Sensor_IO_Read>
 8003dae:	b108      	cbz	r0, 8003db4 <LSM6DSL_ACC_GYRO_R_FS_G+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CTRL2_G, (u8_t *)value, 1))
    return MEMS_ERROR;
 8003db0:	2000      	movs	r0, #0
 8003db2:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_FS_G_MASK; //mask
 8003db4:	7823      	ldrb	r3, [r4, #0]
 8003db6:	f003 030c 	and.w	r3, r3, #12
 8003dba:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8003dbc:	2001      	movs	r0, #1
}
 8003dbe:	bd10      	pop	{r4, pc}

08003dc0 <LSM6DSL_ACC_GYRO_GetRawGyroData>:
* Input          : pointer to [u8_t]
* Output         : GetGyroData buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_GetRawGyroData(void *handle, u8_t *buff)
{
 8003dc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003dc4:	4680      	mov	r8, r0
 8003dc6:	460f      	mov	r7, r1
 8003dc8:	2503      	movs	r5, #3
  u8_t i, j, k;
  u8_t numberOfByteForDimension;

  numberOfByteForDimension = 6 / 3;

  k = 0;
 8003dca:	2400      	movs	r4, #0
 8003dcc:	1ca6      	adds	r6, r4, #2
 8003dce:	b2f6      	uxtb	r6, r6
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003dd0:	f104 0122 	add.w	r1, r4, #34	; 0x22
 8003dd4:	193a      	adds	r2, r7, r4
 8003dd6:	b2c9      	uxtb	r1, r1
 8003dd8:	2301      	movs	r3, #1
 8003dda:	4640      	mov	r0, r8
 8003ddc:	f003 fbc6 	bl	800756c <Sensor_IO_Read>
  {
    for (j = 0; j < numberOfByteForDimension; j++ )
    {
      if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_OUTX_L_G + k, &buff[k], 1))
        return MEMS_ERROR;
      k++;
 8003de0:	3401      	adds	r4, #1
 8003de2:	b2e4      	uxtb	r4, r4
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003de4:	b940      	cbnz	r0, 8003df8 <LSM6DSL_ACC_GYRO_GetRawGyroData+0x38>
    for (j = 0; j < numberOfByteForDimension; j++ )
 8003de6:	42b4      	cmp	r4, r6
 8003de8:	d1f2      	bne.n	8003dd0 <LSM6DSL_ACC_GYRO_GetRawGyroData+0x10>
 8003dea:	1e6b      	subs	r3, r5, #1
  for (i = 0; i < 3; i++ )
 8003dec:	f013 05ff 	ands.w	r5, r3, #255	; 0xff
 8003df0:	d1ec      	bne.n	8003dcc <LSM6DSL_ACC_GYRO_GetRawGyroData+0xc>
    }
  }

  return MEMS_SUCCESS;
 8003df2:	2001      	movs	r0, #1
 8003df4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return MEMS_ERROR;
 8003df8:	2000      	movs	r0, #0
 8003dfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003dfe:	bf00      	nop

08003e00 <LSM6DSL_ACC_GYRO_W_ODR_G>:
* Input          : LSM6DSL_ACC_GYRO_ODR_G_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_ODR_G(void *handle, LSM6DSL_ACC_GYRO_ODR_G_t newValue)
{
 8003e00:	b530      	push	{r4, r5, lr}
 8003e02:	b083      	sub	sp, #12
 8003e04:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003e06:	f10d 0207 	add.w	r2, sp, #7
 8003e0a:	2301      	movs	r3, #1
 8003e0c:	2111      	movs	r1, #17
{
 8003e0e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003e10:	f003 fbac 	bl	800756c <Sensor_IO_Read>
 8003e14:	b110      	cbz	r0, 8003e1c <LSM6DSL_ACC_GYRO_W_ODR_G+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CTRL2_G, &value, 1))
    return MEMS_ERROR;
 8003e16:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_CTRL2_G, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8003e18:	b003      	add	sp, #12
 8003e1a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_ODR_G_MASK;
 8003e1c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003e20:	f003 030f 	and.w	r3, r3, #15
  value |= newValue;
 8003e24:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003e26:	f10d 0207 	add.w	r2, sp, #7
 8003e2a:	4628      	mov	r0, r5
 8003e2c:	2301      	movs	r3, #1
 8003e2e:	2111      	movs	r1, #17
  value |= newValue;
 8003e30:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003e34:	f003 fb4c 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8003e38:	fab0 f080 	clz	r0, r0
 8003e3c:	0940      	lsrs	r0, r0, #5
}
 8003e3e:	b003      	add	sp, #12
 8003e40:	bd30      	pop	{r4, r5, pc}
 8003e42:	bf00      	nop

08003e44 <LSM6DSL_ACC_GYRO_R_ODR_G>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_ODR_G_t
* Output         : Status of ODR_G see LSM6DSL_ACC_GYRO_ODR_G_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_ODR_G(void *handle, LSM6DSL_ACC_GYRO_ODR_G_t *value)
{
 8003e44:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003e46:	460a      	mov	r2, r1
{
 8003e48:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003e4a:	2301      	movs	r3, #1
 8003e4c:	2111      	movs	r1, #17
 8003e4e:	f003 fb8d 	bl	800756c <Sensor_IO_Read>
 8003e52:	b108      	cbz	r0, 8003e58 <LSM6DSL_ACC_GYRO_R_ODR_G+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CTRL2_G, (u8_t *)value, 1))
    return MEMS_ERROR;
 8003e54:	2000      	movs	r0, #0
 8003e56:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_ODR_G_MASK; //mask
 8003e58:	7823      	ldrb	r3, [r4, #0]
 8003e5a:	f023 030f 	bic.w	r3, r3, #15
 8003e5e:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8003e60:	2001      	movs	r0, #1
}
 8003e62:	bd10      	pop	{r4, pc}

08003e64 <LSM6DSL_ACC_GYRO_W_FS_125>:
* Input          : LSM6DSL_ACC_GYRO_FS_125_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_FS_125(void *handle, LSM6DSL_ACC_GYRO_FS_125_t newValue)
{
 8003e64:	b530      	push	{r4, r5, lr}
 8003e66:	b083      	sub	sp, #12
 8003e68:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003e6a:	f10d 0207 	add.w	r2, sp, #7
 8003e6e:	2301      	movs	r3, #1
 8003e70:	2111      	movs	r1, #17
{
 8003e72:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003e74:	f003 fb7a 	bl	800756c <Sensor_IO_Read>
 8003e78:	b110      	cbz	r0, 8003e80 <LSM6DSL_ACC_GYRO_W_FS_125+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CTRL2_G, &value, 1))
    return MEMS_ERROR;
 8003e7a:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_CTRL2_G, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8003e7c:	b003      	add	sp, #12
 8003e7e:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_FS_125_MASK;
 8003e80:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003e84:	f023 0302 	bic.w	r3, r3, #2
  value |= newValue;
 8003e88:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003e8a:	f10d 0207 	add.w	r2, sp, #7
 8003e8e:	4628      	mov	r0, r5
 8003e90:	2301      	movs	r3, #1
 8003e92:	2111      	movs	r1, #17
  value |= newValue;
 8003e94:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003e98:	f003 fb1a 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8003e9c:	fab0 f080 	clz	r0, r0
 8003ea0:	0940      	lsrs	r0, r0, #5
}
 8003ea2:	b003      	add	sp, #12
 8003ea4:	bd30      	pop	{r4, r5, pc}
 8003ea6:	bf00      	nop

08003ea8 <LSM6DSL_ACC_GYRO_R_FS_125>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_FS_125_t
* Output         : Status of FS_125 see LSM6DSL_ACC_GYRO_FS_125_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_FS_125(void *handle, LSM6DSL_ACC_GYRO_FS_125_t *value)
{
 8003ea8:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003eaa:	460a      	mov	r2, r1
{
 8003eac:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003eae:	2301      	movs	r3, #1
 8003eb0:	2111      	movs	r1, #17
 8003eb2:	f003 fb5b 	bl	800756c <Sensor_IO_Read>
 8003eb6:	b108      	cbz	r0, 8003ebc <LSM6DSL_ACC_GYRO_R_FS_125+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CTRL2_G, (u8_t *)value, 1))
    return MEMS_ERROR;
 8003eb8:	2000      	movs	r0, #0
 8003eba:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_FS_125_MASK; //mask
 8003ebc:	7823      	ldrb	r3, [r4, #0]
 8003ebe:	f003 0302 	and.w	r3, r3, #2
 8003ec2:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8003ec4:	2001      	movs	r0, #1
}
 8003ec6:	bd10      	pop	{r4, pc}

08003ec8 <LSM6DSL_ACC_GYRO_W_FIFO_Watermark>:
* Input          : u16_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_FIFO_Watermark(void *handle, u16_t newValue)
{
 8003ec8:	b530      	push	{r4, r5, lr}
 8003eca:	b083      	sub	sp, #12
 8003ecc:	460d      	mov	r5, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003ece:	f10d 0207 	add.w	r2, sp, #7
 8003ed2:	2301      	movs	r3, #1
 8003ed4:	2106      	movs	r1, #6
{
 8003ed6:	4604      	mov	r4, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003ed8:	f003 fb48 	bl	800756c <Sensor_IO_Read>
 8003edc:	b948      	cbnz	r0, 8003ef2 <LSM6DSL_ACC_GYRO_W_FIFO_Watermark+0x2a>
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003ede:	2301      	movs	r3, #1
 8003ee0:	f10d 0207 	add.w	r2, sp, #7
 8003ee4:	2106      	movs	r1, #6
 8003ee6:	4620      	mov	r0, r4
  u8_t valueH, valueL;
  u8_t value;

  valueL = newValue & 0xFF;
 8003ee8:	f88d 5007 	strb.w	r5, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003eec:	f003 faf0 	bl	80074d0 <Sensor_IO_Write>
 8003ef0:	b110      	cbz	r0, 8003ef8 <LSM6DSL_ACC_GYRO_W_FIFO_Watermark+0x30>
  /* Low part goes in FIFO_CTRL1 */
  valueL = valueL << LSM6DSL_ACC_GYRO_WTM_FIFO_CTRL1_POSITION; //mask
  valueL &= LSM6DSL_ACC_GYRO_WTM_FIFO_CTRL1_MASK; //coerce

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_FIFO_CTRL1, &value, 1) )
    return MEMS_ERROR;
 8003ef2:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_FIFO_CTRL2, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8003ef4:	b003      	add	sp, #12
 8003ef6:	bd30      	pop	{r4, r5, pc}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003ef8:	2301      	movs	r3, #1
 8003efa:	f10d 0207 	add.w	r2, sp, #7
 8003efe:	2107      	movs	r1, #7
 8003f00:	4620      	mov	r0, r4
 8003f02:	f003 fb33 	bl	800756c <Sensor_IO_Read>
 8003f06:	2800      	cmp	r0, #0
 8003f08:	d1f3      	bne.n	8003ef2 <LSM6DSL_ACC_GYRO_W_FIFO_Watermark+0x2a>
  value &= ~LSM6DSL_ACC_GYRO_WTM_FIFO_CTRL2_MASK;
 8003f0a:	f89d 3007 	ldrb.w	r3, [sp, #7]
  valueH &= LSM6DSL_ACC_GYRO_WTM_FIFO_CTRL2_MASK; //coerce
 8003f0e:	f3c5 2502 	ubfx	r5, r5, #8, #3
  value &= ~LSM6DSL_ACC_GYRO_WTM_FIFO_CTRL2_MASK;
 8003f12:	f023 0307 	bic.w	r3, r3, #7
  value |= valueH;
 8003f16:	431d      	orrs	r5, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003f18:	f10d 0207 	add.w	r2, sp, #7
 8003f1c:	4620      	mov	r0, r4
 8003f1e:	2301      	movs	r3, #1
 8003f20:	2107      	movs	r1, #7
  value |= valueH;
 8003f22:	f88d 5007 	strb.w	r5, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003f26:	f003 fad3 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8003f2a:	fab0 f080 	clz	r0, r0
 8003f2e:	0940      	lsrs	r0, r0, #5
 8003f30:	e7e0      	b.n	8003ef4 <LSM6DSL_ACC_GYRO_W_FIFO_Watermark+0x2c>
 8003f32:	bf00      	nop

08003f34 <LSM6DSL_ACC_GYRO_W_DEC_FIFO_XL>:
* Input          : LSM6DSL_ACC_GYRO_DEC_FIFO_XL_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_DEC_FIFO_XL(void *handle, LSM6DSL_ACC_GYRO_DEC_FIFO_XL_t newValue)
{
 8003f34:	b530      	push	{r4, r5, lr}
 8003f36:	b083      	sub	sp, #12
 8003f38:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003f3a:	f10d 0207 	add.w	r2, sp, #7
 8003f3e:	2301      	movs	r3, #1
 8003f40:	2108      	movs	r1, #8
{
 8003f42:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003f44:	f003 fb12 	bl	800756c <Sensor_IO_Read>
 8003f48:	b110      	cbz	r0, 8003f50 <LSM6DSL_ACC_GYRO_W_DEC_FIFO_XL+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_FIFO_CTRL3, &value, 1) )
    return MEMS_ERROR;
 8003f4a:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_FIFO_CTRL3, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8003f4c:	b003      	add	sp, #12
 8003f4e:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_DEC_FIFO_XL_MASK;
 8003f50:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003f54:	f023 0307 	bic.w	r3, r3, #7
  value |= newValue;
 8003f58:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003f5a:	f10d 0207 	add.w	r2, sp, #7
 8003f5e:	4628      	mov	r0, r5
 8003f60:	2301      	movs	r3, #1
 8003f62:	2108      	movs	r1, #8
  value |= newValue;
 8003f64:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003f68:	f003 fab2 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8003f6c:	fab0 f080 	clz	r0, r0
 8003f70:	0940      	lsrs	r0, r0, #5
}
 8003f72:	b003      	add	sp, #12
 8003f74:	bd30      	pop	{r4, r5, pc}
 8003f76:	bf00      	nop

08003f78 <LSM6DSL_ACC_GYRO_W_DEC_FIFO_G>:
* Input          : LSM6DSL_ACC_GYRO_DEC_FIFO_G_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_DEC_FIFO_G(void *handle, LSM6DSL_ACC_GYRO_DEC_FIFO_G_t newValue)
{
 8003f78:	b530      	push	{r4, r5, lr}
 8003f7a:	b083      	sub	sp, #12
 8003f7c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003f7e:	f10d 0207 	add.w	r2, sp, #7
 8003f82:	2301      	movs	r3, #1
 8003f84:	2108      	movs	r1, #8
{
 8003f86:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003f88:	f003 faf0 	bl	800756c <Sensor_IO_Read>
 8003f8c:	b110      	cbz	r0, 8003f94 <LSM6DSL_ACC_GYRO_W_DEC_FIFO_G+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_FIFO_CTRL3, &value, 1))
    return MEMS_ERROR;
 8003f8e:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_FIFO_CTRL3, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8003f90:	b003      	add	sp, #12
 8003f92:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_DEC_FIFO_G_MASK;
 8003f94:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003f98:	f023 0338 	bic.w	r3, r3, #56	; 0x38
  value |= newValue;
 8003f9c:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003f9e:	f10d 0207 	add.w	r2, sp, #7
 8003fa2:	4628      	mov	r0, r5
 8003fa4:	2301      	movs	r3, #1
 8003fa6:	2108      	movs	r1, #8
  value |= newValue;
 8003fa8:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003fac:	f003 fa90 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8003fb0:	fab0 f080 	clz	r0, r0
 8003fb4:	0940      	lsrs	r0, r0, #5
}
 8003fb6:	b003      	add	sp, #12
 8003fb8:	bd30      	pop	{r4, r5, pc}
 8003fba:	bf00      	nop

08003fbc <LSM6DSL_ACC_GYRO_W_STOP_ON_FTH>:
* Input          : LSM6DSL_ACC_GYRO_STOP_ON_FTH_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_STOP_ON_FTH(void *handle, LSM6DSL_ACC_GYRO_STOP_ON_FTH_t newValue)
{
 8003fbc:	b530      	push	{r4, r5, lr}
 8003fbe:	b083      	sub	sp, #12
 8003fc0:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003fc2:	f10d 0207 	add.w	r2, sp, #7
 8003fc6:	2301      	movs	r3, #1
 8003fc8:	2109      	movs	r1, #9
{
 8003fca:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8003fcc:	f003 face 	bl	800756c <Sensor_IO_Read>
 8003fd0:	b110      	cbz	r0, 8003fd8 <LSM6DSL_ACC_GYRO_W_STOP_ON_FTH+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_FIFO_CTRL4, &value, 1))
    return MEMS_ERROR;
 8003fd2:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_FIFO_CTRL4, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8003fd4:	b003      	add	sp, #12
 8003fd6:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_STOP_ON_FTH_MASK;
 8003fd8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003fdc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  value |= newValue;
 8003fe0:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003fe2:	f10d 0207 	add.w	r2, sp, #7
 8003fe6:	4628      	mov	r0, r5
 8003fe8:	2301      	movs	r3, #1
 8003fea:	2109      	movs	r1, #9
  value |= newValue;
 8003fec:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8003ff0:	f003 fa6e 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8003ff4:	fab0 f080 	clz	r0, r0
 8003ff8:	0940      	lsrs	r0, r0, #5
}
 8003ffa:	b003      	add	sp, #12
 8003ffc:	bd30      	pop	{r4, r5, pc}
 8003ffe:	bf00      	nop

08004000 <LSM6DSL_ACC_GYRO_W_FIFO_MODE>:
* Input          : LSM6DSL_ACC_GYRO_FIFO_MODE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_FIFO_MODE(void *handle, LSM6DSL_ACC_GYRO_FIFO_MODE_t newValue)
{
 8004000:	b530      	push	{r4, r5, lr}
 8004002:	b083      	sub	sp, #12
 8004004:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004006:	f10d 0207 	add.w	r2, sp, #7
 800400a:	2301      	movs	r3, #1
 800400c:	210a      	movs	r1, #10
{
 800400e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004010:	f003 faac 	bl	800756c <Sensor_IO_Read>
 8004014:	b110      	cbz	r0, 800401c <LSM6DSL_ACC_GYRO_W_FIFO_MODE+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_FIFO_CTRL5, &value, 1))
    return MEMS_ERROR;
 8004016:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_FIFO_CTRL5, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004018:	b003      	add	sp, #12
 800401a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_FIFO_MODE_MASK;
 800401c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004020:	f023 0307 	bic.w	r3, r3, #7
  value |= newValue;
 8004024:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004026:	f10d 0207 	add.w	r2, sp, #7
 800402a:	4628      	mov	r0, r5
 800402c:	2301      	movs	r3, #1
 800402e:	210a      	movs	r1, #10
  value |= newValue;
 8004030:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004034:	f003 fa4c 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004038:	fab0 f080 	clz	r0, r0
 800403c:	0940      	lsrs	r0, r0, #5
}
 800403e:	b003      	add	sp, #12
 8004040:	bd30      	pop	{r4, r5, pc}
 8004042:	bf00      	nop

08004044 <LSM6DSL_ACC_GYRO_W_ODR_FIFO>:
* Input          : LSM6DSL_ACC_GYRO_ODR_FIFO_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_ODR_FIFO(void *handle, LSM6DSL_ACC_GYRO_ODR_FIFO_t newValue)
{
 8004044:	b530      	push	{r4, r5, lr}
 8004046:	b083      	sub	sp, #12
 8004048:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800404a:	f10d 0207 	add.w	r2, sp, #7
 800404e:	2301      	movs	r3, #1
 8004050:	210a      	movs	r1, #10
{
 8004052:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004054:	f003 fa8a 	bl	800756c <Sensor_IO_Read>
 8004058:	b110      	cbz	r0, 8004060 <LSM6DSL_ACC_GYRO_W_ODR_FIFO+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_FIFO_CTRL5, &value, 1))
    return MEMS_ERROR;
 800405a:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_FIFO_CTRL5, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800405c:	b003      	add	sp, #12
 800405e:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_ODR_FIFO_MASK;
 8004060:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004064:	f023 0378 	bic.w	r3, r3, #120	; 0x78
  value |= newValue;
 8004068:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800406a:	f10d 0207 	add.w	r2, sp, #7
 800406e:	4628      	mov	r0, r5
 8004070:	2301      	movs	r3, #1
 8004072:	210a      	movs	r1, #10
  value |= newValue;
 8004074:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004078:	f003 fa2a 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 800407c:	fab0 f080 	clz	r0, r0
 8004080:	0940      	lsrs	r0, r0, #5
}
 8004082:	b003      	add	sp, #12
 8004084:	bd30      	pop	{r4, r5, pc}
 8004086:	bf00      	nop

08004088 <LSM6DSL_ACC_GYRO_W_FULL_FLAG_on_INT1>:
* Input          : LSM6DSL_ACC_GYRO_INT1_FULL_FLAG_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_FULL_FLAG_on_INT1(void *handle, LSM6DSL_ACC_GYRO_INT1_FULL_FLAG_t newValue)
{
 8004088:	b530      	push	{r4, r5, lr}
 800408a:	b083      	sub	sp, #12
 800408c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800408e:	f10d 0207 	add.w	r2, sp, #7
 8004092:	2301      	movs	r3, #1
 8004094:	210d      	movs	r1, #13
{
 8004096:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004098:	f003 fa68 	bl	800756c <Sensor_IO_Read>
 800409c:	b110      	cbz	r0, 80040a4 <LSM6DSL_ACC_GYRO_W_FULL_FLAG_on_INT1+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_INT1_CTRL, &value, 1))
    return MEMS_ERROR;
 800409e:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_INT1_CTRL, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 80040a0:	b003      	add	sp, #12
 80040a2:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_INT1_FULL_FLAG_MASK;
 80040a4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80040a8:	f023 0320 	bic.w	r3, r3, #32
  value |= newValue;
 80040ac:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80040ae:	f10d 0207 	add.w	r2, sp, #7
 80040b2:	4628      	mov	r0, r5
 80040b4:	2301      	movs	r3, #1
 80040b6:	210d      	movs	r1, #13
  value |= newValue;
 80040b8:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80040bc:	f003 fa08 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 80040c0:	fab0 f080 	clz	r0, r0
 80040c4:	0940      	lsrs	r0, r0, #5
}
 80040c6:	b003      	add	sp, #12
 80040c8:	bd30      	pop	{r4, r5, pc}
 80040ca:	bf00      	nop

080040cc <LSM6DSL_ACC_GYRO_W_STEP_DET_on_INT1>:
* Input          : LSM6DSL_ACC_GYRO_INT1_PEDO_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_STEP_DET_on_INT1(void *handle, LSM6DSL_ACC_GYRO_INT1_PEDO_t newValue)
{
 80040cc:	b530      	push	{r4, r5, lr}
 80040ce:	b083      	sub	sp, #12
 80040d0:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80040d2:	f10d 0207 	add.w	r2, sp, #7
 80040d6:	2301      	movs	r3, #1
 80040d8:	210d      	movs	r1, #13
{
 80040da:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80040dc:	f003 fa46 	bl	800756c <Sensor_IO_Read>
 80040e0:	b110      	cbz	r0, 80040e8 <LSM6DSL_ACC_GYRO_W_STEP_DET_on_INT1+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_INT1_CTRL, &value, 1))
    return MEMS_ERROR;
 80040e2:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_INT1_CTRL, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 80040e4:	b003      	add	sp, #12
 80040e6:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_INT1_PEDO_MASK;
 80040e8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80040ec:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  value |= newValue;
 80040f0:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80040f2:	f10d 0207 	add.w	r2, sp, #7
 80040f6:	4628      	mov	r0, r5
 80040f8:	2301      	movs	r3, #1
 80040fa:	210d      	movs	r1, #13
  value |= newValue;
 80040fc:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004100:	f003 f9e6 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004104:	fab0 f080 	clz	r0, r0
 8004108:	0940      	lsrs	r0, r0, #5
}
 800410a:	b003      	add	sp, #12
 800410c:	bd30      	pop	{r4, r5, pc}
 800410e:	bf00      	nop

08004110 <LSM6DSL_ACC_GYRO_W_IF_Addr_Incr>:
* Input          : LSM6DSL_ACC_GYRO_IF_INC_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_IF_Addr_Incr(void *handle, LSM6DSL_ACC_GYRO_IF_INC_t newValue)
{
 8004110:	b530      	push	{r4, r5, lr}
 8004112:	b083      	sub	sp, #12
 8004114:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004116:	f10d 0207 	add.w	r2, sp, #7
 800411a:	2301      	movs	r3, #1
 800411c:	2112      	movs	r1, #18
{
 800411e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004120:	f003 fa24 	bl	800756c <Sensor_IO_Read>
 8004124:	b110      	cbz	r0, 800412c <LSM6DSL_ACC_GYRO_W_IF_Addr_Incr+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CTRL3_C, &value, 1))
    return MEMS_ERROR;
 8004126:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_CTRL3_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004128:	b003      	add	sp, #12
 800412a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_IF_INC_MASK;
 800412c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004130:	f023 0304 	bic.w	r3, r3, #4
  value |= newValue;
 8004134:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004136:	f10d 0207 	add.w	r2, sp, #7
 800413a:	4628      	mov	r0, r5
 800413c:	2301      	movs	r3, #1
 800413e:	2112      	movs	r1, #18
  value |= newValue;
 8004140:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004144:	f003 f9c4 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004148:	fab0 f080 	clz	r0, r0
 800414c:	0940      	lsrs	r0, r0, #5
}
 800414e:	b003      	add	sp, #12
 8004150:	bd30      	pop	{r4, r5, pc}
 8004152:	bf00      	nop

08004154 <LSM6DSL_ACC_GYRO_W_SelfTest_XL>:
* Input          : LSM6DSL_ACC_GYRO_ST_XL_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_SelfTest_XL(void *handle, LSM6DSL_ACC_GYRO_ST_XL_t newValue)
{
 8004154:	b530      	push	{r4, r5, lr}
 8004156:	b083      	sub	sp, #12
 8004158:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800415a:	f10d 0207 	add.w	r2, sp, #7
 800415e:	2301      	movs	r3, #1
 8004160:	2114      	movs	r1, #20
{
 8004162:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004164:	f003 fa02 	bl	800756c <Sensor_IO_Read>
 8004168:	b110      	cbz	r0, 8004170 <LSM6DSL_ACC_GYRO_W_SelfTest_XL+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CTRL5_C, &value, 1))
    return MEMS_ERROR;
 800416a:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_CTRL5_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800416c:	b003      	add	sp, #12
 800416e:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_ST_XL_MASK;
 8004170:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004174:	f023 0303 	bic.w	r3, r3, #3
  value |= newValue;
 8004178:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800417a:	f10d 0207 	add.w	r2, sp, #7
 800417e:	4628      	mov	r0, r5
 8004180:	2301      	movs	r3, #1
 8004182:	2114      	movs	r1, #20
  value |= newValue;
 8004184:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004188:	f003 f9a2 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 800418c:	fab0 f080 	clz	r0, r0
 8004190:	0940      	lsrs	r0, r0, #5
}
 8004192:	b003      	add	sp, #12
 8004194:	bd30      	pop	{r4, r5, pc}
 8004196:	bf00      	nop

08004198 <LSM6DSL_ACC_GYRO_W_SelfTest_G>:
* Input          : LSM6DSL_ACC_GYRO_ST_G_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_SelfTest_G(void *handle, LSM6DSL_ACC_GYRO_ST_G_t newValue)
{
 8004198:	b530      	push	{r4, r5, lr}
 800419a:	b083      	sub	sp, #12
 800419c:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800419e:	f10d 0207 	add.w	r2, sp, #7
 80041a2:	2301      	movs	r3, #1
 80041a4:	2114      	movs	r1, #20
{
 80041a6:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80041a8:	f003 f9e0 	bl	800756c <Sensor_IO_Read>
 80041ac:	b110      	cbz	r0, 80041b4 <LSM6DSL_ACC_GYRO_W_SelfTest_G+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CTRL5_C, &value, 1))
    return MEMS_ERROR;
 80041ae:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_CTRL5_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 80041b0:	b003      	add	sp, #12
 80041b2:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_ST_G_MASK;
 80041b4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80041b8:	f023 030c 	bic.w	r3, r3, #12
  value |= newValue;
 80041bc:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80041be:	f10d 0207 	add.w	r2, sp, #7
 80041c2:	4628      	mov	r0, r5
 80041c4:	2301      	movs	r3, #1
 80041c6:	2114      	movs	r1, #20
  value |= newValue;
 80041c8:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80041cc:	f003 f980 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 80041d0:	fab0 f080 	clz	r0, r0
 80041d4:	0940      	lsrs	r0, r0, #5
}
 80041d6:	b003      	add	sp, #12
 80041d8:	bd30      	pop	{r4, r5, pc}
 80041da:	bf00      	nop

080041dc <LSM6DSL_ACC_GYRO_W_PedoStepReset>:
* Input          : LSM6DSL_ACC_GYRO_PEDO_RST_STEP_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_PedoStepReset(void *handle, LSM6DSL_ACC_GYRO_PEDO_RST_STEP_t newValue)
{
 80041dc:	b530      	push	{r4, r5, lr}
 80041de:	b083      	sub	sp, #12
 80041e0:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80041e2:	f10d 0207 	add.w	r2, sp, #7
 80041e6:	2301      	movs	r3, #1
 80041e8:	2119      	movs	r1, #25
{
 80041ea:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80041ec:	f003 f9be 	bl	800756c <Sensor_IO_Read>
 80041f0:	b110      	cbz	r0, 80041f8 <LSM6DSL_ACC_GYRO_W_PedoStepReset+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CTRL10_C, &value, 1) )
    return MEMS_ERROR;
 80041f2:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_CTRL10_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 80041f4:	b003      	add	sp, #12
 80041f6:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_PEDO_RST_STEP_MASK;
 80041f8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80041fc:	f023 0302 	bic.w	r3, r3, #2
  value |= newValue;
 8004200:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004202:	f10d 0207 	add.w	r2, sp, #7
 8004206:	4628      	mov	r0, r5
 8004208:	2301      	movs	r3, #1
 800420a:	2119      	movs	r1, #25
  value |= newValue;
 800420c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004210:	f003 f95e 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004214:	fab0 f080 	clz	r0, r0
 8004218:	0940      	lsrs	r0, r0, #5
}
 800421a:	b003      	add	sp, #12
 800421c:	bd30      	pop	{r4, r5, pc}
 800421e:	bf00      	nop

08004220 <LSM6DSL_ACC_GYRO_W_TILT>:
* Input          : LSM6DSL_ACC_GYRO_TILT_G_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_TILT(void *handle, LSM6DSL_ACC_GYRO_TILT_G_t newValue)
{
 8004220:	b530      	push	{r4, r5, lr}
 8004222:	b083      	sub	sp, #12
 8004224:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004226:	f10d 0207 	add.w	r2, sp, #7
 800422a:	2301      	movs	r3, #1
 800422c:	2119      	movs	r1, #25
{
 800422e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004230:	f003 f99c 	bl	800756c <Sensor_IO_Read>
 8004234:	b110      	cbz	r0, 800423c <LSM6DSL_ACC_GYRO_W_TILT+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CTRL10_C, &value, 1) )
    return MEMS_ERROR;
 8004236:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_CTRL10_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004238:	b003      	add	sp, #12
 800423a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_TILT_MASK;
 800423c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004240:	f023 0308 	bic.w	r3, r3, #8
  value |= newValue;
 8004244:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004246:	f10d 0207 	add.w	r2, sp, #7
 800424a:	4628      	mov	r0, r5
 800424c:	2301      	movs	r3, #1
 800424e:	2119      	movs	r1, #25
  value |= newValue;
 8004250:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004254:	f003 f93c 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004258:	fab0 f080 	clz	r0, r0
 800425c:	0940      	lsrs	r0, r0, #5
}
 800425e:	b003      	add	sp, #12
 8004260:	bd30      	pop	{r4, r5, pc}
 8004262:	bf00      	nop

08004264 <LSM6DSL_ACC_GYRO_W_PEDO>:
* Input          : LSM6DSL_ACC_GYRO_PEDO_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_PEDO(void *handle, LSM6DSL_ACC_GYRO_PEDO_t newValue)
{
 8004264:	b530      	push	{r4, r5, lr}
 8004266:	b083      	sub	sp, #12
 8004268:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800426a:	f10d 0207 	add.w	r2, sp, #7
 800426e:	2301      	movs	r3, #1
 8004270:	2119      	movs	r1, #25
{
 8004272:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004274:	f003 f97a 	bl	800756c <Sensor_IO_Read>
 8004278:	b110      	cbz	r0, 8004280 <LSM6DSL_ACC_GYRO_W_PEDO+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CTRL10_C, &value, 1) )
    return MEMS_ERROR;
 800427a:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_CTRL10_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800427c:	b003      	add	sp, #12
 800427e:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_PEDO_MASK;
 8004280:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004284:	f023 0310 	bic.w	r3, r3, #16
  value |= newValue;
 8004288:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800428a:	f10d 0207 	add.w	r2, sp, #7
 800428e:	4628      	mov	r0, r5
 8004290:	2301      	movs	r3, #1
 8004292:	2119      	movs	r1, #25
  value |= newValue;
 8004294:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004298:	f003 f91a 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 800429c:	fab0 f080 	clz	r0, r0
 80042a0:	0940      	lsrs	r0, r0, #5
}
 80042a2:	b003      	add	sp, #12
 80042a4:	bd30      	pop	{r4, r5, pc}
 80042a6:	bf00      	nop

080042a8 <LSM6DSL_ACC_GYRO_W_FUNC_EN>:
* Input          : LSM6DSL_ACC_GYRO_FUNC_EN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_FUNC_EN(void *handle, LSM6DSL_ACC_GYRO_FUNC_EN_t newValue)
{
 80042a8:	b530      	push	{r4, r5, lr}
 80042aa:	b083      	sub	sp, #12
 80042ac:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80042ae:	f10d 0207 	add.w	r2, sp, #7
 80042b2:	2301      	movs	r3, #1
 80042b4:	2119      	movs	r1, #25
{
 80042b6:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80042b8:	f003 f958 	bl	800756c <Sensor_IO_Read>
 80042bc:	b110      	cbz	r0, 80042c4 <LSM6DSL_ACC_GYRO_W_FUNC_EN+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CTRL10_C, &value, 1) )
    return MEMS_ERROR;
 80042be:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_CTRL10_C, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 80042c0:	b003      	add	sp, #12
 80042c2:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_FUNC_EN_MASK;
 80042c4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80042c8:	f023 0304 	bic.w	r3, r3, #4
  value |= newValue;
 80042cc:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80042ce:	f10d 0207 	add.w	r2, sp, #7
 80042d2:	4628      	mov	r0, r5
 80042d4:	2301      	movs	r3, #1
 80042d6:	2119      	movs	r1, #25
  value |= newValue;
 80042d8:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80042dc:	f003 f8f8 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 80042e0:	fab0 f080 	clz	r0, r0
 80042e4:	0940      	lsrs	r0, r0, #5
}
 80042e6:	b003      	add	sp, #12
 80042e8:	bd30      	pop	{r4, r5, pc}
 80042ea:	bf00      	nop

080042ec <LSM6DSL_ACC_GYRO_R_WU_EV_STATUS>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_WU_EV_STATUS_t
* Output         : Status of WU_EV_STATUS see LSM6DSL_ACC_GYRO_WU_EV_STATUS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_WU_EV_STATUS(void *handle, LSM6DSL_ACC_GYRO_WU_EV_STATUS_t *value)
{
 80042ec:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80042ee:	460a      	mov	r2, r1
{
 80042f0:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80042f2:	2301      	movs	r3, #1
 80042f4:	211b      	movs	r1, #27
 80042f6:	f003 f939 	bl	800756c <Sensor_IO_Read>
 80042fa:	b108      	cbz	r0, 8004300 <LSM6DSL_ACC_GYRO_R_WU_EV_STATUS+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_WAKE_UP_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;
 80042fc:	2000      	movs	r0, #0
 80042fe:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_WU_EV_STATUS_MASK; //mask
 8004300:	7823      	ldrb	r3, [r4, #0]
 8004302:	f003 0308 	and.w	r3, r3, #8
 8004306:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8004308:	2001      	movs	r0, #1
}
 800430a:	bd10      	pop	{r4, pc}

0800430c <LSM6DSL_ACC_GYRO_R_FF_EV_STATUS>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_FF_EV_STATUS_t
* Output         : Status of FF_EV_STATUS see LSM6DSL_ACC_GYRO_FF_EV_STATUS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_FF_EV_STATUS(void *handle, LSM6DSL_ACC_GYRO_FF_EV_STATUS_t *value)
{
 800430c:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800430e:	460a      	mov	r2, r1
{
 8004310:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004312:	2301      	movs	r3, #1
 8004314:	211b      	movs	r1, #27
 8004316:	f003 f929 	bl	800756c <Sensor_IO_Read>
 800431a:	b108      	cbz	r0, 8004320 <LSM6DSL_ACC_GYRO_R_FF_EV_STATUS+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_WAKE_UP_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;
 800431c:	2000      	movs	r0, #0
 800431e:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_FF_EV_STATUS_MASK; //mask
 8004320:	7823      	ldrb	r3, [r4, #0]
 8004322:	f003 0320 	and.w	r3, r3, #32
 8004326:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8004328:	2001      	movs	r0, #1
}
 800432a:	bd10      	pop	{r4, pc}

0800432c <LSM6DSL_ACC_GYRO_R_DOUBLE_TAP_EV_STATUS>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_DOUBLE_TAP_EV_STATUS_t
* Output         : Status of DOUBLE_TAP_EV_STATUS see LSM6DSL_ACC_GYRO_DOUBLE_TAP_EV_STATUS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_DOUBLE_TAP_EV_STATUS(void *handle, LSM6DSL_ACC_GYRO_DOUBLE_TAP_EV_STATUS_t *value)
{
 800432c:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800432e:	460a      	mov	r2, r1
{
 8004330:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004332:	2301      	movs	r3, #1
 8004334:	211c      	movs	r1, #28
 8004336:	f003 f919 	bl	800756c <Sensor_IO_Read>
 800433a:	b108      	cbz	r0, 8004340 <LSM6DSL_ACC_GYRO_R_DOUBLE_TAP_EV_STATUS+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_TAP_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;
 800433c:	2000      	movs	r0, #0
 800433e:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_DOUBLE_TAP_EV_STATUS_MASK; //mask
 8004340:	7823      	ldrb	r3, [r4, #0]
 8004342:	f003 0310 	and.w	r3, r3, #16
 8004346:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8004348:	2001      	movs	r0, #1
}
 800434a:	bd10      	pop	{r4, pc}

0800434c <LSM6DSL_ACC_GYRO_R_SINGLE_TAP_EV_STATUS>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_SINGLE_TAP_EV_STATUS_t
* Output         : Status of SINGLE_TAP_EV_STATUS see LSM6DSL_ACC_GYRO_SINGLE_TAP_EV_STATUS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_SINGLE_TAP_EV_STATUS(void *handle, LSM6DSL_ACC_GYRO_SINGLE_TAP_EV_STATUS_t *value)
{
 800434c:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800434e:	460a      	mov	r2, r1
{
 8004350:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004352:	2301      	movs	r3, #1
 8004354:	211c      	movs	r1, #28
 8004356:	f003 f909 	bl	800756c <Sensor_IO_Read>
 800435a:	b108      	cbz	r0, 8004360 <LSM6DSL_ACC_GYRO_R_SINGLE_TAP_EV_STATUS+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_TAP_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;
 800435c:	2000      	movs	r0, #0
 800435e:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_SINGLE_TAP_EV_STATUS_MASK; //mask
 8004360:	7823      	ldrb	r3, [r4, #0]
 8004362:	f003 0320 	and.w	r3, r3, #32
 8004366:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8004368:	2001      	movs	r0, #1
}
 800436a:	bd10      	pop	{r4, pc}

0800436c <LSM6DSL_ACC_GYRO_R_DSD_XL>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_DSD_XL_t
* Output         : Status of DSD_XL see LSM6DSL_ACC_GYRO_DSD_XL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_DSD_XL(void *handle, LSM6DSL_ACC_GYRO_DSD_XL_t *value)
{
 800436c:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800436e:	460a      	mov	r2, r1
{
 8004370:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004372:	2301      	movs	r3, #1
 8004374:	211d      	movs	r1, #29
 8004376:	f003 f8f9 	bl	800756c <Sensor_IO_Read>
 800437a:	b108      	cbz	r0, 8004380 <LSM6DSL_ACC_GYRO_R_DSD_XL+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_D6D_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;
 800437c:	2000      	movs	r0, #0
 800437e:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_DSD_XL_MASK; //mask
 8004380:	7823      	ldrb	r3, [r4, #0]
 8004382:	f003 0301 	and.w	r3, r3, #1
 8004386:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8004388:	2001      	movs	r0, #1
}
 800438a:	bd10      	pop	{r4, pc}

0800438c <LSM6DSL_ACC_GYRO_R_DSD_XH>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_DSD_XH_t
* Output         : Status of DSD_XH see LSM6DSL_ACC_GYRO_DSD_XH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_DSD_XH(void *handle, LSM6DSL_ACC_GYRO_DSD_XH_t *value)
{
 800438c:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800438e:	460a      	mov	r2, r1
{
 8004390:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004392:	2301      	movs	r3, #1
 8004394:	211d      	movs	r1, #29
 8004396:	f003 f8e9 	bl	800756c <Sensor_IO_Read>
 800439a:	b108      	cbz	r0, 80043a0 <LSM6DSL_ACC_GYRO_R_DSD_XH+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_D6D_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;
 800439c:	2000      	movs	r0, #0
 800439e:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_DSD_XH_MASK; //mask
 80043a0:	7823      	ldrb	r3, [r4, #0]
 80043a2:	f003 0302 	and.w	r3, r3, #2
 80043a6:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 80043a8:	2001      	movs	r0, #1
}
 80043aa:	bd10      	pop	{r4, pc}

080043ac <LSM6DSL_ACC_GYRO_R_DSD_YL>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_DSD_YL_t
* Output         : Status of DSD_YL see LSM6DSL_ACC_GYRO_DSD_YL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_DSD_YL(void *handle, LSM6DSL_ACC_GYRO_DSD_YL_t *value)
{
 80043ac:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80043ae:	460a      	mov	r2, r1
{
 80043b0:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80043b2:	2301      	movs	r3, #1
 80043b4:	211d      	movs	r1, #29
 80043b6:	f003 f8d9 	bl	800756c <Sensor_IO_Read>
 80043ba:	b108      	cbz	r0, 80043c0 <LSM6DSL_ACC_GYRO_R_DSD_YL+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_D6D_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;
 80043bc:	2000      	movs	r0, #0
 80043be:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_DSD_YL_MASK; //mask
 80043c0:	7823      	ldrb	r3, [r4, #0]
 80043c2:	f003 0304 	and.w	r3, r3, #4
 80043c6:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 80043c8:	2001      	movs	r0, #1
}
 80043ca:	bd10      	pop	{r4, pc}

080043cc <LSM6DSL_ACC_GYRO_R_DSD_YH>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_DSD_YH_t
* Output         : Status of DSD_YH see LSM6DSL_ACC_GYRO_DSD_YH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_DSD_YH(void *handle, LSM6DSL_ACC_GYRO_DSD_YH_t *value)
{
 80043cc:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80043ce:	460a      	mov	r2, r1
{
 80043d0:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80043d2:	2301      	movs	r3, #1
 80043d4:	211d      	movs	r1, #29
 80043d6:	f003 f8c9 	bl	800756c <Sensor_IO_Read>
 80043da:	b108      	cbz	r0, 80043e0 <LSM6DSL_ACC_GYRO_R_DSD_YH+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_D6D_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;
 80043dc:	2000      	movs	r0, #0
 80043de:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_DSD_YH_MASK; //mask
 80043e0:	7823      	ldrb	r3, [r4, #0]
 80043e2:	f003 0308 	and.w	r3, r3, #8
 80043e6:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 80043e8:	2001      	movs	r0, #1
}
 80043ea:	bd10      	pop	{r4, pc}

080043ec <LSM6DSL_ACC_GYRO_R_DSD_ZL>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_DSD_ZL_t
* Output         : Status of DSD_ZL see LSM6DSL_ACC_GYRO_DSD_ZL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_DSD_ZL(void *handle, LSM6DSL_ACC_GYRO_DSD_ZL_t *value)
{
 80043ec:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80043ee:	460a      	mov	r2, r1
{
 80043f0:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80043f2:	2301      	movs	r3, #1
 80043f4:	211d      	movs	r1, #29
 80043f6:	f003 f8b9 	bl	800756c <Sensor_IO_Read>
 80043fa:	b108      	cbz	r0, 8004400 <LSM6DSL_ACC_GYRO_R_DSD_ZL+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_D6D_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;
 80043fc:	2000      	movs	r0, #0
 80043fe:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_DSD_ZL_MASK; //mask
 8004400:	7823      	ldrb	r3, [r4, #0]
 8004402:	f003 0310 	and.w	r3, r3, #16
 8004406:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8004408:	2001      	movs	r0, #1
}
 800440a:	bd10      	pop	{r4, pc}

0800440c <LSM6DSL_ACC_GYRO_R_DSD_ZH>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_DSD_ZH_t
* Output         : Status of DSD_ZH see LSM6DSL_ACC_GYRO_DSD_ZH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_DSD_ZH(void *handle, LSM6DSL_ACC_GYRO_DSD_ZH_t *value)
{
 800440c:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800440e:	460a      	mov	r2, r1
{
 8004410:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004412:	2301      	movs	r3, #1
 8004414:	211d      	movs	r1, #29
 8004416:	f003 f8a9 	bl	800756c <Sensor_IO_Read>
 800441a:	b108      	cbz	r0, 8004420 <LSM6DSL_ACC_GYRO_R_DSD_ZH+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_D6D_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;
 800441c:	2000      	movs	r0, #0
 800441e:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_DSD_ZH_MASK; //mask
 8004420:	7823      	ldrb	r3, [r4, #0]
 8004422:	f003 0320 	and.w	r3, r3, #32
 8004426:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8004428:	2001      	movs	r0, #1
}
 800442a:	bd10      	pop	{r4, pc}

0800442c <LSM6DSL_ACC_GYRO_R_D6D_EV_STATUS>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_D6D_EV_STATUS_t
* Output         : Status of D6D_EV_STATUS see LSM6DSL_ACC_GYRO_D6D_EV_STATUS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_D6D_EV_STATUS(void *handle, LSM6DSL_ACC_GYRO_D6D_EV_STATUS_t *value)
{
 800442c:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800442e:	460a      	mov	r2, r1
{
 8004430:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004432:	2301      	movs	r3, #1
 8004434:	211d      	movs	r1, #29
 8004436:	f003 f899 	bl	800756c <Sensor_IO_Read>
 800443a:	b108      	cbz	r0, 8004440 <LSM6DSL_ACC_GYRO_R_D6D_EV_STATUS+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_D6D_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;
 800443c:	2000      	movs	r0, #0
 800443e:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_D6D_EV_STATUS_MASK; //mask
 8004440:	7823      	ldrb	r3, [r4, #0]
 8004442:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8004446:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8004448:	2001      	movs	r0, #1
}
 800444a:	bd10      	pop	{r4, pc}

0800444c <LSM6DSL_ACC_GYRO_R_XLDA>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_XLDA_t
* Output         : Status of XLDA see LSM6DSL_ACC_GYRO_XLDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_XLDA(void *handle, LSM6DSL_ACC_GYRO_XLDA_t *value)
{
 800444c:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800444e:	460a      	mov	r2, r1
{
 8004450:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004452:	2301      	movs	r3, #1
 8004454:	211e      	movs	r1, #30
 8004456:	f003 f889 	bl	800756c <Sensor_IO_Read>
 800445a:	b108      	cbz	r0, 8004460 <LSM6DSL_ACC_GYRO_R_XLDA+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_STATUS_REG, (u8_t *)value, 1) )
    return MEMS_ERROR;
 800445c:	2000      	movs	r0, #0
 800445e:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_XLDA_MASK; //mask
 8004460:	7823      	ldrb	r3, [r4, #0]
 8004462:	f003 0301 	and.w	r3, r3, #1
 8004466:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8004468:	2001      	movs	r0, #1
}
 800446a:	bd10      	pop	{r4, pc}

0800446c <LSM6DSL_ACC_GYRO_R_GDA>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_GDA_t
* Output         : Status of GDA see LSM6DSL_ACC_GYRO_GDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_GDA(void *handle, LSM6DSL_ACC_GYRO_GDA_t *value)
{
 800446c:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800446e:	460a      	mov	r2, r1
{
 8004470:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004472:	2301      	movs	r3, #1
 8004474:	211e      	movs	r1, #30
 8004476:	f003 f879 	bl	800756c <Sensor_IO_Read>
 800447a:	b108      	cbz	r0, 8004480 <LSM6DSL_ACC_GYRO_R_GDA+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_STATUS_REG, (u8_t *)value, 1) )
    return MEMS_ERROR;
 800447c:	2000      	movs	r0, #0
 800447e:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_GDA_MASK; //mask
 8004480:	7823      	ldrb	r3, [r4, #0]
 8004482:	f003 0302 	and.w	r3, r3, #2
 8004486:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8004488:	2001      	movs	r0, #1
}
 800448a:	bd10      	pop	{r4, pc}

0800448c <LSM6DSL_ACC_GYRO_R_FIFONumOfEntries>:
* Input          : Pointer to u16_t
* Output         : Status of DIFF_FIFO
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_FIFONumOfEntries(void *handle, u16_t *value)
{
 800448c:	b530      	push	{r4, r5, lr}
 800448e:	b083      	sub	sp, #12
 8004490:	460d      	mov	r5, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004492:	2301      	movs	r3, #1
 8004494:	f10d 0207 	add.w	r2, sp, #7
 8004498:	213a      	movs	r1, #58	; 0x3a
{
 800449a:	4604      	mov	r4, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800449c:	f003 f866 	bl	800756c <Sensor_IO_Read>
 80044a0:	b938      	cbnz	r0, 80044b2 <LSM6DSL_ACC_GYRO_R_FIFONumOfEntries+0x26>
 80044a2:	4620      	mov	r0, r4
 80044a4:	2301      	movs	r3, #1
 80044a6:	f10d 0206 	add.w	r2, sp, #6
 80044aa:	213b      	movs	r1, #59	; 0x3b
 80044ac:	f003 f85e 	bl	800756c <Sensor_IO_Read>
 80044b0:	b110      	cbz	r0, 80044b8 <LSM6DSL_ACC_GYRO_R_FIFONumOfEntries+0x2c>
  u8_t valueH, valueL;

  /* Low part from FIFO_STATUS1 */
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_FIFO_STATUS1, (u8_t *)&valueL, 1) )
    return MEMS_ERROR;
 80044b2:	2000      	movs	r0, #0
  valueH = valueH >> LSM6DSL_ACC_GYRO_DIFF_FIFO_STATUS2_POSITION; //mask

  *value = ((valueH << 8) & 0xFF00) | valueL;

  return MEMS_SUCCESS;
}
 80044b4:	b003      	add	sp, #12
 80044b6:	bd30      	pop	{r4, r5, pc}
  valueH &= LSM6DSL_ACC_GYRO_DIFF_FIFO_STATUS2_MASK; //coerce
 80044b8:	f89d 2006 	ldrb.w	r2, [sp, #6]
  *value = ((valueH << 8) & 0xFF00) | valueL;
 80044bc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80044c0:	f002 020f 	and.w	r2, r2, #15
 80044c4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  return MEMS_SUCCESS;
 80044c8:	2001      	movs	r0, #1
  *value = ((valueH << 8) & 0xFF00) | valueL;
 80044ca:	802b      	strh	r3, [r5, #0]
}
 80044cc:	b003      	add	sp, #12
 80044ce:	bd30      	pop	{r4, r5, pc}

080044d0 <LSM6DSL_ACC_GYRO_R_FIFOEmpty>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_FIFO_EMPTY_t
* Output         : Status of FIFO_EMPTY see LSM6DSL_ACC_GYRO_FIFO_EMPTY_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_FIFOEmpty(void *handle, LSM6DSL_ACC_GYRO_FIFO_EMPTY_t *value)
{
 80044d0:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80044d2:	460a      	mov	r2, r1
{
 80044d4:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80044d6:	2301      	movs	r3, #1
 80044d8:	213b      	movs	r1, #59	; 0x3b
 80044da:	f003 f847 	bl	800756c <Sensor_IO_Read>
 80044de:	b108      	cbz	r0, 80044e4 <LSM6DSL_ACC_GYRO_R_FIFOEmpty+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_FIFO_STATUS2, (u8_t *)value, 1) )
    return MEMS_ERROR;
 80044e0:	2000      	movs	r0, #0
 80044e2:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_FIFO_EMPTY_MASK; //mask
 80044e4:	7823      	ldrb	r3, [r4, #0]
 80044e6:	f003 0310 	and.w	r3, r3, #16
 80044ea:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 80044ec:	2001      	movs	r0, #1
}
 80044ee:	bd10      	pop	{r4, pc}

080044f0 <LSM6DSL_ACC_GYRO_R_FIFOFull>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_FIFO_FULL_t
* Output         : Status of FIFO_FULL see LSM6DSL_ACC_GYRO_FIFO_FULL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_FIFOFull(void *handle, LSM6DSL_ACC_GYRO_FIFO_FULL_t *value)
{
 80044f0:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80044f2:	460a      	mov	r2, r1
{
 80044f4:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80044f6:	2301      	movs	r3, #1
 80044f8:	213b      	movs	r1, #59	; 0x3b
 80044fa:	f003 f837 	bl	800756c <Sensor_IO_Read>
 80044fe:	b108      	cbz	r0, 8004504 <LSM6DSL_ACC_GYRO_R_FIFOFull+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_FIFO_STATUS2, (u8_t *)value, 1) )
    return MEMS_ERROR;
 8004500:	2000      	movs	r0, #0
 8004502:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_FIFO_FULL_MASK; //mask
 8004504:	7823      	ldrb	r3, [r4, #0]
 8004506:	f003 0320 	and.w	r3, r3, #32
 800450a:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800450c:	2001      	movs	r0, #1
}
 800450e:	bd10      	pop	{r4, pc}

08004510 <LSM6DSL_ACC_GYRO_R_OVERRUN>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_OVERRUN_t
* Output         : Status of OVERRUN see LSM6DSL_ACC_GYRO_OVERRUN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_OVERRUN(void *handle, LSM6DSL_ACC_GYRO_OVERRUN_t *value)
{
 8004510:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004512:	460a      	mov	r2, r1
{
 8004514:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004516:	2301      	movs	r3, #1
 8004518:	213b      	movs	r1, #59	; 0x3b
 800451a:	f003 f827 	bl	800756c <Sensor_IO_Read>
 800451e:	b108      	cbz	r0, 8004524 <LSM6DSL_ACC_GYRO_R_OVERRUN+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_FIFO_STATUS2, (u8_t *)value, 1) )
    return MEMS_ERROR;
 8004520:	2000      	movs	r0, #0
 8004522:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_OVERRUN_MASK; //mask
 8004524:	7823      	ldrb	r3, [r4, #0]
 8004526:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800452a:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 800452c:	2001      	movs	r0, #1
}
 800452e:	bd10      	pop	{r4, pc}

08004530 <LSM6DSL_ACC_GYRO_R_FIFOPattern>:
* Input          : Pointer to u16_t
* Output         : Status of FIFO_PATTERN
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_FIFOPattern(void *handle, u16_t *value)
{
 8004530:	b530      	push	{r4, r5, lr}
 8004532:	b083      	sub	sp, #12
 8004534:	460d      	mov	r5, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004536:	2301      	movs	r3, #1
 8004538:	f10d 0207 	add.w	r2, sp, #7
 800453c:	213c      	movs	r1, #60	; 0x3c
{
 800453e:	4604      	mov	r4, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004540:	f003 f814 	bl	800756c <Sensor_IO_Read>
 8004544:	b938      	cbnz	r0, 8004556 <LSM6DSL_ACC_GYRO_R_FIFOPattern+0x26>
 8004546:	4620      	mov	r0, r4
 8004548:	2301      	movs	r3, #1
 800454a:	f10d 0206 	add.w	r2, sp, #6
 800454e:	213d      	movs	r1, #61	; 0x3d
 8004550:	f003 f80c 	bl	800756c <Sensor_IO_Read>
 8004554:	b110      	cbz	r0, 800455c <LSM6DSL_ACC_GYRO_R_FIFOPattern+0x2c>
  u8_t valueH, valueL;

  /* Low part from FIFO_STATUS3 */
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_FIFO_STATUS3, (u8_t *)&valueL, 1) )
    return MEMS_ERROR;
 8004556:	2000      	movs	r0, #0
  valueH = valueH >> LSM6DSL_ACC_GYRO_FIFO_STATUS4_PATTERN_POSITION; //mask

  *value = ((valueH << 8) & 0xFF00) | valueL;

  return MEMS_SUCCESS;
}
 8004558:	b003      	add	sp, #12
 800455a:	bd30      	pop	{r4, r5, pc}
  valueH &= LSM6DSL_ACC_GYRO_FIFO_STATUS4_PATTERN_MASK; //coerce
 800455c:	f89d 2006 	ldrb.w	r2, [sp, #6]
  *value = ((valueH << 8) & 0xFF00) | valueL;
 8004560:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004564:	f002 0203 	and.w	r2, r2, #3
 8004568:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  return MEMS_SUCCESS;
 800456c:	2001      	movs	r0, #1
  *value = ((valueH << 8) & 0xFF00) | valueL;
 800456e:	802b      	strh	r3, [r5, #0]
}
 8004570:	b003      	add	sp, #12
 8004572:	bd30      	pop	{r4, r5, pc}

08004574 <LSM6DSL_ACC_GYRO_R_PEDO_EV_STATUS>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_PEDO_EV_STATUS_t
* Output         : Status of PEDO_EV_STATUS see LSM6DSL_ACC_GYRO_PEDO_EV_STATUS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_PEDO_EV_STATUS(void *handle, LSM6DSL_ACC_GYRO_PEDO_EV_STATUS_t *value)
{
 8004574:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004576:	460a      	mov	r2, r1
{
 8004578:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800457a:	2301      	movs	r3, #1
 800457c:	2153      	movs	r1, #83	; 0x53
 800457e:	f002 fff5 	bl	800756c <Sensor_IO_Read>
 8004582:	b108      	cbz	r0, 8004588 <LSM6DSL_ACC_GYRO_R_PEDO_EV_STATUS+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_FUNC_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;
 8004584:	2000      	movs	r0, #0
 8004586:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_PEDO_EV_STATUS_MASK; //mask
 8004588:	7823      	ldrb	r3, [r4, #0]
 800458a:	f003 0310 	and.w	r3, r3, #16
 800458e:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 8004590:	2001      	movs	r0, #1
}
 8004592:	bd10      	pop	{r4, pc}

08004594 <LSM6DSL_ACC_GYRO_R_TILT_EV_STATUS>:
* Input          : Pointer to LSM6DSL_ACC_GYRO_TILT_EV_STATUS_t
* Output         : Status of TILT_EV_STATUS see LSM6DSL_ACC_GYRO_TILT_EV_STATUS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_R_TILT_EV_STATUS(void *handle, LSM6DSL_ACC_GYRO_TILT_EV_STATUS_t *value)
{
 8004594:	b510      	push	{r4, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004596:	460a      	mov	r2, r1
{
 8004598:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800459a:	2301      	movs	r3, #1
 800459c:	2153      	movs	r1, #83	; 0x53
 800459e:	f002 ffe5 	bl	800756c <Sensor_IO_Read>
 80045a2:	b108      	cbz	r0, 80045a8 <LSM6DSL_ACC_GYRO_R_TILT_EV_STATUS+0x14>
  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_FUNC_SRC, (u8_t *)value, 1) )
    return MEMS_ERROR;
 80045a4:	2000      	movs	r0, #0
 80045a6:	bd10      	pop	{r4, pc}

  *value &= LSM6DSL_ACC_GYRO_TILT_EV_STATUS_MASK; //mask
 80045a8:	7823      	ldrb	r3, [r4, #0]
 80045aa:	f003 0320 	and.w	r3, r3, #32
 80045ae:	7023      	strb	r3, [r4, #0]

  return MEMS_SUCCESS;
 80045b0:	2001      	movs	r0, #1
}
 80045b2:	bd10      	pop	{r4, pc}

080045b4 <LSM6DSL_ACC_GYRO_W_LIR>:
* Input          : LSM6DSL_ACC_GYRO_LIR_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_LIR(void *handle, LSM6DSL_ACC_GYRO_LIR_t newValue)
{
 80045b4:	b530      	push	{r4, r5, lr}
 80045b6:	b083      	sub	sp, #12
 80045b8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80045ba:	f10d 0207 	add.w	r2, sp, #7
 80045be:	2301      	movs	r3, #1
 80045c0:	2158      	movs	r1, #88	; 0x58
{
 80045c2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80045c4:	f002 ffd2 	bl	800756c <Sensor_IO_Read>
 80045c8:	b110      	cbz	r0, 80045d0 <LSM6DSL_ACC_GYRO_W_LIR+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;
 80045ca:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 80045cc:	b003      	add	sp, #12
 80045ce:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_LIR_MASK;
 80045d0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80045d4:	f023 0301 	bic.w	r3, r3, #1
  value |= newValue;
 80045d8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80045da:	f10d 0207 	add.w	r2, sp, #7
 80045de:	4628      	mov	r0, r5
 80045e0:	2301      	movs	r3, #1
 80045e2:	2158      	movs	r1, #88	; 0x58
  value |= newValue;
 80045e4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80045e8:	f002 ff72 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 80045ec:	fab0 f080 	clz	r0, r0
 80045f0:	0940      	lsrs	r0, r0, #5
}
 80045f2:	b003      	add	sp, #12
 80045f4:	bd30      	pop	{r4, r5, pc}
 80045f6:	bf00      	nop

080045f8 <LSM6DSL_ACC_GYRO_W_TAP_Z_EN>:
* Input          : LSM6DSL_ACC_GYRO_TAP_Z_EN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_TAP_Z_EN(void *handle, LSM6DSL_ACC_GYRO_TAP_Z_EN_t newValue)
{
 80045f8:	b530      	push	{r4, r5, lr}
 80045fa:	b083      	sub	sp, #12
 80045fc:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80045fe:	f10d 0207 	add.w	r2, sp, #7
 8004602:	2301      	movs	r3, #1
 8004604:	2158      	movs	r1, #88	; 0x58
{
 8004606:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004608:	f002 ffb0 	bl	800756c <Sensor_IO_Read>
 800460c:	b110      	cbz	r0, 8004614 <LSM6DSL_ACC_GYRO_W_TAP_Z_EN+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;
 800460e:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004610:	b003      	add	sp, #12
 8004612:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_TAP_Z_EN_MASK;
 8004614:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004618:	f023 0302 	bic.w	r3, r3, #2
  value |= newValue;
 800461c:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800461e:	f10d 0207 	add.w	r2, sp, #7
 8004622:	4628      	mov	r0, r5
 8004624:	2301      	movs	r3, #1
 8004626:	2158      	movs	r1, #88	; 0x58
  value |= newValue;
 8004628:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800462c:	f002 ff50 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004630:	fab0 f080 	clz	r0, r0
 8004634:	0940      	lsrs	r0, r0, #5
}
 8004636:	b003      	add	sp, #12
 8004638:	bd30      	pop	{r4, r5, pc}
 800463a:	bf00      	nop

0800463c <LSM6DSL_ACC_GYRO_W_TAP_Y_EN>:
* Input          : LSM6DSL_ACC_GYRO_TAP_Y_EN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_TAP_Y_EN(void *handle, LSM6DSL_ACC_GYRO_TAP_Y_EN_t newValue)
{
 800463c:	b530      	push	{r4, r5, lr}
 800463e:	b083      	sub	sp, #12
 8004640:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004642:	f10d 0207 	add.w	r2, sp, #7
 8004646:	2301      	movs	r3, #1
 8004648:	2158      	movs	r1, #88	; 0x58
{
 800464a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800464c:	f002 ff8e 	bl	800756c <Sensor_IO_Read>
 8004650:	b110      	cbz	r0, 8004658 <LSM6DSL_ACC_GYRO_W_TAP_Y_EN+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;
 8004652:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004654:	b003      	add	sp, #12
 8004656:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_TAP_Y_EN_MASK;
 8004658:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800465c:	f023 0304 	bic.w	r3, r3, #4
  value |= newValue;
 8004660:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004662:	f10d 0207 	add.w	r2, sp, #7
 8004666:	4628      	mov	r0, r5
 8004668:	2301      	movs	r3, #1
 800466a:	2158      	movs	r1, #88	; 0x58
  value |= newValue;
 800466c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004670:	f002 ff2e 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004674:	fab0 f080 	clz	r0, r0
 8004678:	0940      	lsrs	r0, r0, #5
}
 800467a:	b003      	add	sp, #12
 800467c:	bd30      	pop	{r4, r5, pc}
 800467e:	bf00      	nop

08004680 <LSM6DSL_ACC_GYRO_W_TAP_X_EN>:
* Input          : LSM6DSL_ACC_GYRO_TAP_X_EN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_TAP_X_EN(void *handle, LSM6DSL_ACC_GYRO_TAP_X_EN_t newValue)
{
 8004680:	b530      	push	{r4, r5, lr}
 8004682:	b083      	sub	sp, #12
 8004684:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004686:	f10d 0207 	add.w	r2, sp, #7
 800468a:	2301      	movs	r3, #1
 800468c:	2158      	movs	r1, #88	; 0x58
{
 800468e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004690:	f002 ff6c 	bl	800756c <Sensor_IO_Read>
 8004694:	b110      	cbz	r0, 800469c <LSM6DSL_ACC_GYRO_W_TAP_X_EN+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;
 8004696:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004698:	b003      	add	sp, #12
 800469a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_TAP_X_EN_MASK;
 800469c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80046a0:	f023 0308 	bic.w	r3, r3, #8
  value |= newValue;
 80046a4:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80046a6:	f10d 0207 	add.w	r2, sp, #7
 80046aa:	4628      	mov	r0, r5
 80046ac:	2301      	movs	r3, #1
 80046ae:	2158      	movs	r1, #88	; 0x58
  value |= newValue;
 80046b0:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80046b4:	f002 ff0c 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 80046b8:	fab0 f080 	clz	r0, r0
 80046bc:	0940      	lsrs	r0, r0, #5
}
 80046be:	b003      	add	sp, #12
 80046c0:	bd30      	pop	{r4, r5, pc}
 80046c2:	bf00      	nop

080046c4 <LSM6DSL_ACC_GYRO_W_BASIC_INT>:
* Input          : LSM6DSL_ACC_GYRO_INT_EN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_BASIC_INT(void *handle, LSM6DSL_ACC_GYRO_INT_EN_t newValue)
{
 80046c4:	b530      	push	{r4, r5, lr}
 80046c6:	b083      	sub	sp, #12
 80046c8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80046ca:	f10d 0207 	add.w	r2, sp, #7
 80046ce:	2301      	movs	r3, #1
 80046d0:	2158      	movs	r1, #88	; 0x58
{
 80046d2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80046d4:	f002 ff4a 	bl	800756c <Sensor_IO_Read>
 80046d8:	b110      	cbz	r0, 80046e0 <LSM6DSL_ACC_GYRO_W_BASIC_INT+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;
 80046da:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_TAP_CFG1, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 80046dc:	b003      	add	sp, #12
 80046de:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_INT_EN_MASK;
 80046e0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80046e4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  value |= newValue;
 80046e8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80046ea:	f10d 0207 	add.w	r2, sp, #7
 80046ee:	4628      	mov	r0, r5
 80046f0:	2301      	movs	r3, #1
 80046f2:	2158      	movs	r1, #88	; 0x58
  value |= newValue;
 80046f4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80046f8:	f002 feea 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 80046fc:	fab0 f080 	clz	r0, r0
 8004700:	0940      	lsrs	r0, r0, #5
}
 8004702:	b003      	add	sp, #12
 8004704:	bd30      	pop	{r4, r5, pc}
 8004706:	bf00      	nop

08004708 <LSM6DSL_ACC_GYRO_W_TAP_THS>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_TAP_THS(void *handle, u8_t newValue)
{
 8004708:	b570      	push	{r4, r5, r6, lr}
 800470a:	b082      	sub	sp, #8
 800470c:	460d      	mov	r5, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800470e:	f10d 0207 	add.w	r2, sp, #7
 8004712:	2301      	movs	r3, #1
 8004714:	2159      	movs	r1, #89	; 0x59
{
 8004716:	4606      	mov	r6, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004718:	f002 ff28 	bl	800756c <Sensor_IO_Read>
 800471c:	b110      	cbz	r0, 8004724 <LSM6DSL_ACC_GYRO_W_TAP_THS+0x1c>

  newValue = newValue << LSM6DSL_ACC_GYRO_TAP_THS_POSITION; //mask
  newValue &= LSM6DSL_ACC_GYRO_TAP_THS_MASK; //coerce

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_TAP_THS_6D, &value, 1) )
    return MEMS_ERROR;
 800471e:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_TAP_THS_6D, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004720:	b002      	add	sp, #8
 8004722:	bd70      	pop	{r4, r5, r6, pc}
  value &= ~LSM6DSL_ACC_GYRO_TAP_THS_MASK;
 8004724:	f89d 4007 	ldrb.w	r4, [sp, #7]
  newValue &= LSM6DSL_ACC_GYRO_TAP_THS_MASK; //coerce
 8004728:	f005 051f 	and.w	r5, r5, #31
  value &= ~LSM6DSL_ACC_GYRO_TAP_THS_MASK;
 800472c:	f024 041f 	bic.w	r4, r4, #31
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004730:	f10d 0207 	add.w	r2, sp, #7
 8004734:	4630      	mov	r0, r6
  value |= newValue;
 8004736:	432c      	orrs	r4, r5
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004738:	2301      	movs	r3, #1
 800473a:	2159      	movs	r1, #89	; 0x59
  value |= newValue;
 800473c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004740:	f002 fec6 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004744:	fab0 f080 	clz	r0, r0
 8004748:	0940      	lsrs	r0, r0, #5
}
 800474a:	b002      	add	sp, #8
 800474c:	bd70      	pop	{r4, r5, r6, pc}
 800474e:	bf00      	nop

08004750 <LSM6DSL_ACC_GYRO_W_SIXD_THS>:
* Input          : LSM6DSL_ACC_GYRO_SIXD_THS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_SIXD_THS(void *handle, LSM6DSL_ACC_GYRO_SIXD_THS_t newValue)
{
 8004750:	b530      	push	{r4, r5, lr}
 8004752:	b083      	sub	sp, #12
 8004754:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004756:	f10d 0207 	add.w	r2, sp, #7
 800475a:	2301      	movs	r3, #1
 800475c:	2159      	movs	r1, #89	; 0x59
{
 800475e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004760:	f002 ff04 	bl	800756c <Sensor_IO_Read>
 8004764:	b110      	cbz	r0, 800476c <LSM6DSL_ACC_GYRO_W_SIXD_THS+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_TAP_THS_6D, &value, 1) )
    return MEMS_ERROR;
 8004766:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_TAP_THS_6D, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004768:	b003      	add	sp, #12
 800476a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_SIXD_THS_MASK;
 800476c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004770:	f023 0360 	bic.w	r3, r3, #96	; 0x60
  value |= newValue;
 8004774:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004776:	f10d 0207 	add.w	r2, sp, #7
 800477a:	4628      	mov	r0, r5
 800477c:	2301      	movs	r3, #1
 800477e:	2159      	movs	r1, #89	; 0x59
  value |= newValue;
 8004780:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004784:	f002 fea4 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004788:	fab0 f080 	clz	r0, r0
 800478c:	0940      	lsrs	r0, r0, #5
}
 800478e:	b003      	add	sp, #12
 8004790:	bd30      	pop	{r4, r5, pc}
 8004792:	bf00      	nop

08004794 <LSM6DSL_ACC_GYRO_W_SHOCK_Duration>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_SHOCK_Duration(void *handle, u8_t newValue)
{
 8004794:	b570      	push	{r4, r5, r6, lr}
 8004796:	b082      	sub	sp, #8
 8004798:	460d      	mov	r5, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800479a:	f10d 0207 	add.w	r2, sp, #7
 800479e:	2301      	movs	r3, #1
 80047a0:	215a      	movs	r1, #90	; 0x5a
{
 80047a2:	4606      	mov	r6, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80047a4:	f002 fee2 	bl	800756c <Sensor_IO_Read>
 80047a8:	b110      	cbz	r0, 80047b0 <LSM6DSL_ACC_GYRO_W_SHOCK_Duration+0x1c>

  newValue = newValue << LSM6DSL_ACC_GYRO_SHOCK_POSITION; //mask
  newValue &= LSM6DSL_ACC_GYRO_SHOCK_MASK; //coerce

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_INT_DUR2, &value, 1) )
    return MEMS_ERROR;
 80047aa:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_INT_DUR2, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 80047ac:	b002      	add	sp, #8
 80047ae:	bd70      	pop	{r4, r5, r6, pc}
  value &= ~LSM6DSL_ACC_GYRO_SHOCK_MASK;
 80047b0:	f89d 4007 	ldrb.w	r4, [sp, #7]
  newValue &= LSM6DSL_ACC_GYRO_SHOCK_MASK; //coerce
 80047b4:	f005 0503 	and.w	r5, r5, #3
  value &= ~LSM6DSL_ACC_GYRO_SHOCK_MASK;
 80047b8:	f024 0403 	bic.w	r4, r4, #3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80047bc:	f10d 0207 	add.w	r2, sp, #7
 80047c0:	4630      	mov	r0, r6
  value |= newValue;
 80047c2:	432c      	orrs	r4, r5
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80047c4:	2301      	movs	r3, #1
 80047c6:	215a      	movs	r1, #90	; 0x5a
  value |= newValue;
 80047c8:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80047cc:	f002 fe80 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 80047d0:	fab0 f080 	clz	r0, r0
 80047d4:	0940      	lsrs	r0, r0, #5
}
 80047d6:	b002      	add	sp, #8
 80047d8:	bd70      	pop	{r4, r5, r6, pc}
 80047da:	bf00      	nop

080047dc <LSM6DSL_ACC_GYRO_W_QUIET_Duration>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_QUIET_Duration(void *handle, u8_t newValue)
{
 80047dc:	b530      	push	{r4, r5, lr}
 80047de:	b083      	sub	sp, #12
 80047e0:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80047e2:	f10d 0207 	add.w	r2, sp, #7
 80047e6:	2301      	movs	r3, #1
 80047e8:	215a      	movs	r1, #90	; 0x5a
{
 80047ea:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80047ec:	f002 febe 	bl	800756c <Sensor_IO_Read>
 80047f0:	b110      	cbz	r0, 80047f8 <LSM6DSL_ACC_GYRO_W_QUIET_Duration+0x1c>

  newValue = newValue << LSM6DSL_ACC_GYRO_QUIET_POSITION; //mask
  newValue &= LSM6DSL_ACC_GYRO_QUIET_MASK; //coerce

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_INT_DUR2, &value, 1) )
    return MEMS_ERROR;
 80047f2:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_INT_DUR2, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 80047f4:	b003      	add	sp, #12
 80047f6:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_QUIET_MASK;
 80047f8:	f89d 3007 	ldrb.w	r3, [sp, #7]
  newValue = newValue << LSM6DSL_ACC_GYRO_QUIET_POSITION; //mask
 80047fc:	00a4      	lsls	r4, r4, #2
  value &= ~LSM6DSL_ACC_GYRO_QUIET_MASK;
 80047fe:	f023 030c 	bic.w	r3, r3, #12
  newValue &= LSM6DSL_ACC_GYRO_QUIET_MASK; //coerce
 8004802:	f004 040c 	and.w	r4, r4, #12
  value |= newValue;
 8004806:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004808:	f10d 0207 	add.w	r2, sp, #7
 800480c:	4628      	mov	r0, r5
 800480e:	2301      	movs	r3, #1
 8004810:	215a      	movs	r1, #90	; 0x5a
  value |= newValue;
 8004812:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004816:	f002 fe5b 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 800481a:	fab0 f080 	clz	r0, r0
 800481e:	0940      	lsrs	r0, r0, #5
}
 8004820:	b003      	add	sp, #12
 8004822:	bd30      	pop	{r4, r5, pc}

08004824 <LSM6DSL_ACC_GYRO_W_DUR>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_DUR(void *handle, u8_t newValue)
{
 8004824:	b570      	push	{r4, r5, r6, lr}
 8004826:	b082      	sub	sp, #8
 8004828:	460d      	mov	r5, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800482a:	f10d 0207 	add.w	r2, sp, #7
 800482e:	2301      	movs	r3, #1
 8004830:	215a      	movs	r1, #90	; 0x5a
{
 8004832:	4606      	mov	r6, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004834:	f002 fe9a 	bl	800756c <Sensor_IO_Read>
 8004838:	b110      	cbz	r0, 8004840 <LSM6DSL_ACC_GYRO_W_DUR+0x1c>

  newValue = newValue << LSM6DSL_ACC_GYRO_DUR_POSITION; //mask
  newValue &= LSM6DSL_ACC_GYRO_DUR_MASK; //coerce

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_INT_DUR2, &value, 1) )
    return MEMS_ERROR;
 800483a:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_INT_DUR2, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800483c:	b002      	add	sp, #8
 800483e:	bd70      	pop	{r4, r5, r6, pc}
  value &= ~LSM6DSL_ACC_GYRO_DUR_MASK;
 8004840:	f89d 4007 	ldrb.w	r4, [sp, #7]
 8004844:	f004 040f 	and.w	r4, r4, #15
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004848:	f10d 0207 	add.w	r2, sp, #7
 800484c:	4630      	mov	r0, r6
  value |= newValue;
 800484e:	ea44 1405 	orr.w	r4, r4, r5, lsl #4
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004852:	2301      	movs	r3, #1
 8004854:	215a      	movs	r1, #90	; 0x5a
  value |= newValue;
 8004856:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800485a:	f002 fe39 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 800485e:	fab0 f080 	clz	r0, r0
 8004862:	0940      	lsrs	r0, r0, #5
}
 8004864:	b002      	add	sp, #8
 8004866:	bd70      	pop	{r4, r5, r6, pc}

08004868 <LSM6DSL_ACC_GYRO_W_WK_THS>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_WK_THS(void *handle, u8_t newValue)
{
 8004868:	b570      	push	{r4, r5, r6, lr}
 800486a:	b082      	sub	sp, #8
 800486c:	460d      	mov	r5, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800486e:	f10d 0207 	add.w	r2, sp, #7
 8004872:	2301      	movs	r3, #1
 8004874:	215b      	movs	r1, #91	; 0x5b
{
 8004876:	4606      	mov	r6, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004878:	f002 fe78 	bl	800756c <Sensor_IO_Read>
 800487c:	b110      	cbz	r0, 8004884 <LSM6DSL_ACC_GYRO_W_WK_THS+0x1c>

  newValue = newValue << LSM6DSL_ACC_GYRO_WK_THS_POSITION; //mask
  newValue &= LSM6DSL_ACC_GYRO_WK_THS_MASK; //coerce

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_WAKE_UP_THS, &value, 1) )
    return MEMS_ERROR;
 800487e:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_WAKE_UP_THS, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004880:	b002      	add	sp, #8
 8004882:	bd70      	pop	{r4, r5, r6, pc}
  value &= ~LSM6DSL_ACC_GYRO_WK_THS_MASK;
 8004884:	f89d 4007 	ldrb.w	r4, [sp, #7]
  newValue &= LSM6DSL_ACC_GYRO_WK_THS_MASK; //coerce
 8004888:	f005 053f 	and.w	r5, r5, #63	; 0x3f
  value &= ~LSM6DSL_ACC_GYRO_WK_THS_MASK;
 800488c:	f024 043f 	bic.w	r4, r4, #63	; 0x3f
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004890:	f10d 0207 	add.w	r2, sp, #7
 8004894:	4630      	mov	r0, r6
  value |= newValue;
 8004896:	432c      	orrs	r4, r5
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004898:	2301      	movs	r3, #1
 800489a:	215b      	movs	r1, #91	; 0x5b
  value |= newValue;
 800489c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80048a0:	f002 fe16 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 80048a4:	fab0 f080 	clz	r0, r0
 80048a8:	0940      	lsrs	r0, r0, #5
}
 80048aa:	b002      	add	sp, #8
 80048ac:	bd70      	pop	{r4, r5, r6, pc}
 80048ae:	bf00      	nop

080048b0 <LSM6DSL_ACC_GYRO_W_SINGLE_DOUBLE_TAP_EV>:
* Input          : LSM6DSL_ACC_GYRO_SINGLE_DOUBLE_TAP_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_SINGLE_DOUBLE_TAP_EV(void *handle, LSM6DSL_ACC_GYRO_SINGLE_DOUBLE_TAP_t newValue)
{
 80048b0:	b530      	push	{r4, r5, lr}
 80048b2:	b083      	sub	sp, #12
 80048b4:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80048b6:	f10d 0207 	add.w	r2, sp, #7
 80048ba:	2301      	movs	r3, #1
 80048bc:	215b      	movs	r1, #91	; 0x5b
{
 80048be:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80048c0:	f002 fe54 	bl	800756c <Sensor_IO_Read>
 80048c4:	b110      	cbz	r0, 80048cc <LSM6DSL_ACC_GYRO_W_SINGLE_DOUBLE_TAP_EV+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_WAKE_UP_THS, &value, 1) )
    return MEMS_ERROR;
 80048c6:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_WAKE_UP_THS, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 80048c8:	b003      	add	sp, #12
 80048ca:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_SINGLE_DOUBLE_TAP_MASK;
 80048cc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80048d0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  value |= newValue;
 80048d4:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80048d6:	f10d 0207 	add.w	r2, sp, #7
 80048da:	4628      	mov	r0, r5
 80048dc:	2301      	movs	r3, #1
 80048de:	215b      	movs	r1, #91	; 0x5b
  value |= newValue;
 80048e0:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80048e4:	f002 fdf4 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 80048e8:	fab0 f080 	clz	r0, r0
 80048ec:	0940      	lsrs	r0, r0, #5
}
 80048ee:	b003      	add	sp, #12
 80048f0:	bd30      	pop	{r4, r5, pc}
 80048f2:	bf00      	nop

080048f4 <LSM6DSL_ACC_GYRO_W_SLEEP_DUR>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_SLEEP_DUR(void *handle, u8_t newValue)
{
 80048f4:	b570      	push	{r4, r5, r6, lr}
 80048f6:	b082      	sub	sp, #8
 80048f8:	460d      	mov	r5, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80048fa:	f10d 0207 	add.w	r2, sp, #7
 80048fe:	2301      	movs	r3, #1
 8004900:	215c      	movs	r1, #92	; 0x5c
{
 8004902:	4606      	mov	r6, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004904:	f002 fe32 	bl	800756c <Sensor_IO_Read>
 8004908:	b110      	cbz	r0, 8004910 <LSM6DSL_ACC_GYRO_W_SLEEP_DUR+0x1c>

  newValue = newValue << LSM6DSL_ACC_GYRO_SLEEP_DUR_POSITION; //mask
  newValue &= LSM6DSL_ACC_GYRO_SLEEP_DUR_MASK; //coerce

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_WAKE_UP_DUR, &value, 1) )
    return MEMS_ERROR;
 800490a:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_WAKE_UP_DUR, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 800490c:	b002      	add	sp, #8
 800490e:	bd70      	pop	{r4, r5, r6, pc}
  value &= ~LSM6DSL_ACC_GYRO_SLEEP_DUR_MASK;
 8004910:	f89d 4007 	ldrb.w	r4, [sp, #7]
  newValue &= LSM6DSL_ACC_GYRO_SLEEP_DUR_MASK; //coerce
 8004914:	f005 050f 	and.w	r5, r5, #15
  value &= ~LSM6DSL_ACC_GYRO_SLEEP_DUR_MASK;
 8004918:	f024 040f 	bic.w	r4, r4, #15
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800491c:	f10d 0207 	add.w	r2, sp, #7
 8004920:	4630      	mov	r0, r6
  value |= newValue;
 8004922:	432c      	orrs	r4, r5
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004924:	2301      	movs	r3, #1
 8004926:	215c      	movs	r1, #92	; 0x5c
  value |= newValue;
 8004928:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 800492c:	f002 fdd0 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004930:	fab0 f080 	clz	r0, r0
 8004934:	0940      	lsrs	r0, r0, #5
}
 8004936:	b002      	add	sp, #8
 8004938:	bd70      	pop	{r4, r5, r6, pc}
 800493a:	bf00      	nop

0800493c <LSM6DSL_ACC_GYRO_W_TIMER_HR>:
* Input          : LSM6DSL_ACC_GYRO_TIMER_HR_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_TIMER_HR(void *handle, LSM6DSL_ACC_GYRO_TIMER_HR_t newValue)
{
 800493c:	b530      	push	{r4, r5, lr}
 800493e:	b083      	sub	sp, #12
 8004940:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004942:	f10d 0207 	add.w	r2, sp, #7
 8004946:	2301      	movs	r3, #1
 8004948:	215c      	movs	r1, #92	; 0x5c
{
 800494a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 800494c:	f002 fe0e 	bl	800756c <Sensor_IO_Read>
 8004950:	b110      	cbz	r0, 8004958 <LSM6DSL_ACC_GYRO_W_TIMER_HR+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_WAKE_UP_DUR, &value, 1) )
    return MEMS_ERROR;
 8004952:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_WAKE_UP_DUR, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004954:	b003      	add	sp, #12
 8004956:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_TIMER_HR_MASK;
 8004958:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800495c:	f023 0310 	bic.w	r3, r3, #16
  value |= newValue;
 8004960:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004962:	f10d 0207 	add.w	r2, sp, #7
 8004966:	4628      	mov	r0, r5
 8004968:	2301      	movs	r3, #1
 800496a:	215c      	movs	r1, #92	; 0x5c
  value |= newValue;
 800496c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004970:	f002 fdae 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004974:	fab0 f080 	clz	r0, r0
 8004978:	0940      	lsrs	r0, r0, #5
}
 800497a:	b003      	add	sp, #12
 800497c:	bd30      	pop	{r4, r5, pc}
 800497e:	bf00      	nop

08004980 <LSM6DSL_ACC_GYRO_W_WAKE_DUR>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_WAKE_DUR(void *handle, u8_t newValue)
{
 8004980:	b530      	push	{r4, r5, lr}
 8004982:	b083      	sub	sp, #12
 8004984:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004986:	f10d 0207 	add.w	r2, sp, #7
 800498a:	2301      	movs	r3, #1
 800498c:	215c      	movs	r1, #92	; 0x5c
{
 800498e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004990:	f002 fdec 	bl	800756c <Sensor_IO_Read>
 8004994:	b110      	cbz	r0, 800499c <LSM6DSL_ACC_GYRO_W_WAKE_DUR+0x1c>

  newValue = newValue << LSM6DSL_ACC_GYRO_WAKE_DUR_POSITION; //mask
  newValue &= LSM6DSL_ACC_GYRO_WAKE_DUR_MASK; //coerce

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_WAKE_UP_DUR, &value, 1) )
    return MEMS_ERROR;
 8004996:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_WAKE_UP_DUR, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004998:	b003      	add	sp, #12
 800499a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_WAKE_DUR_MASK;
 800499c:	f89d 3007 	ldrb.w	r3, [sp, #7]
  newValue = newValue << LSM6DSL_ACC_GYRO_WAKE_DUR_POSITION; //mask
 80049a0:	0164      	lsls	r4, r4, #5
  value &= ~LSM6DSL_ACC_GYRO_WAKE_DUR_MASK;
 80049a2:	f023 0360 	bic.w	r3, r3, #96	; 0x60
  newValue &= LSM6DSL_ACC_GYRO_WAKE_DUR_MASK; //coerce
 80049a6:	f004 0460 	and.w	r4, r4, #96	; 0x60
  value |= newValue;
 80049aa:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80049ac:	f10d 0207 	add.w	r2, sp, #7
 80049b0:	4628      	mov	r0, r5
 80049b2:	2301      	movs	r3, #1
 80049b4:	215c      	movs	r1, #92	; 0x5c
  value |= newValue;
 80049b6:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80049ba:	f002 fd89 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 80049be:	fab0 f080 	clz	r0, r0
 80049c2:	0940      	lsrs	r0, r0, #5
}
 80049c4:	b003      	add	sp, #12
 80049c6:	bd30      	pop	{r4, r5, pc}

080049c8 <LSM6DSL_ACC_GYRO_W_FF_THS>:
* Input          : LSM6DSL_ACC_GYRO_FF_THS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_FF_THS(void *handle, LSM6DSL_ACC_GYRO_FF_THS_t newValue)
{
 80049c8:	b530      	push	{r4, r5, lr}
 80049ca:	b083      	sub	sp, #12
 80049cc:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80049ce:	f10d 0207 	add.w	r2, sp, #7
 80049d2:	2301      	movs	r3, #1
 80049d4:	215d      	movs	r1, #93	; 0x5d
{
 80049d6:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 80049d8:	f002 fdc8 	bl	800756c <Sensor_IO_Read>
 80049dc:	b110      	cbz	r0, 80049e4 <LSM6DSL_ACC_GYRO_W_FF_THS+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_FREE_FALL, &value, 1) )
    return MEMS_ERROR;
 80049de:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_FREE_FALL, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 80049e0:	b003      	add	sp, #12
 80049e2:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_FF_THS_MASK;
 80049e4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80049e8:	f023 0307 	bic.w	r3, r3, #7
  value |= newValue;
 80049ec:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80049ee:	f10d 0207 	add.w	r2, sp, #7
 80049f2:	4628      	mov	r0, r5
 80049f4:	2301      	movs	r3, #1
 80049f6:	215d      	movs	r1, #93	; 0x5d
  value |= newValue;
 80049f8:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 80049fc:	f002 fd68 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004a00:	fab0 f080 	clz	r0, r0
 8004a04:	0940      	lsrs	r0, r0, #5
}
 8004a06:	b003      	add	sp, #12
 8004a08:	bd30      	pop	{r4, r5, pc}
 8004a0a:	bf00      	nop

08004a0c <LSM6DSL_ACC_GYRO_W_FF_Duration>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_FF_Duration(void *handle, u8_t newValue)
{
 8004a0c:	b570      	push	{r4, r5, r6, lr}
 8004a0e:	b082      	sub	sp, #8
 8004a10:	460e      	mov	r6, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004a12:	f10d 0207 	add.w	r2, sp, #7
 8004a16:	2301      	movs	r3, #1
 8004a18:	215d      	movs	r1, #93	; 0x5d
{
 8004a1a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004a1c:	f002 fda6 	bl	800756c <Sensor_IO_Read>
 8004a20:	b978      	cbnz	r0, 8004a42 <LSM6DSL_ACC_GYRO_W_FF_Duration+0x36>
  valueL &= LSM6DSL_ACC_GYRO_FF_FREE_FALL_DUR_MASK; //coerce

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_FREE_FALL, &value, 1) )
    return MEMS_ERROR;

  value &= ~LSM6DSL_ACC_GYRO_FF_FREE_FALL_DUR_MASK;
 8004a22:	f89d 4007 	ldrb.w	r4, [sp, #7]
 8004a26:	f004 0407 	and.w	r4, r4, #7
  value |= valueL;
 8004a2a:	ea44 04c6 	orr.w	r4, r4, r6, lsl #3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004a2e:	2301      	movs	r3, #1
 8004a30:	f10d 0207 	add.w	r2, sp, #7
 8004a34:	215d      	movs	r1, #93	; 0x5d
 8004a36:	4628      	mov	r0, r5
  value |= valueL;
 8004a38:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004a3c:	f002 fd48 	bl	80074d0 <Sensor_IO_Write>
 8004a40:	b110      	cbz	r0, 8004a48 <LSM6DSL_ACC_GYRO_W_FF_Duration+0x3c>
    return MEMS_ERROR;
 8004a42:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_WAKE_UP_DUR, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004a44:	b002      	add	sp, #8
 8004a46:	bd70      	pop	{r4, r5, r6, pc}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004a48:	2301      	movs	r3, #1
 8004a4a:	f10d 0207 	add.w	r2, sp, #7
 8004a4e:	215c      	movs	r1, #92	; 0x5c
 8004a50:	4628      	mov	r0, r5
 8004a52:	f002 fd8b 	bl	800756c <Sensor_IO_Read>
 8004a56:	2800      	cmp	r0, #0
 8004a58:	d1f3      	bne.n	8004a42 <LSM6DSL_ACC_GYRO_W_FF_Duration+0x36>
  value &= ~LSM6DSL_ACC_GYRO_FF_WAKE_UP_DUR_MASK;
 8004a5a:	f89d 3007 	ldrb.w	r3, [sp, #7]
  valueH = (newValue >> 5) & 0x1;
 8004a5e:	0976      	lsrs	r6, r6, #5
  value &= ~LSM6DSL_ACC_GYRO_FF_WAKE_UP_DUR_MASK;
 8004a60:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  value |= valueH;
 8004a64:	ea43 16c6 	orr.w	r6, r3, r6, lsl #7
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004a68:	f10d 0207 	add.w	r2, sp, #7
 8004a6c:	4628      	mov	r0, r5
 8004a6e:	2301      	movs	r3, #1
 8004a70:	215c      	movs	r1, #92	; 0x5c
  value |= valueH;
 8004a72:	f88d 6007 	strb.w	r6, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004a76:	f002 fd2b 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004a7a:	fab0 f080 	clz	r0, r0
 8004a7e:	0940      	lsrs	r0, r0, #5
 8004a80:	e7e0      	b.n	8004a44 <LSM6DSL_ACC_GYRO_W_FF_Duration+0x38>
 8004a82:	bf00      	nop

08004a84 <LSM6DSL_ACC_GYRO_W_TiltEvOnInt1>:
* Input          : LSM6DSL_ACC_GYRO_INT1_TILT_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_TiltEvOnInt1(void *handle, LSM6DSL_ACC_GYRO_INT1_TILT_t newValue)
{
 8004a84:	b530      	push	{r4, r5, lr}
 8004a86:	b083      	sub	sp, #12
 8004a88:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004a8a:	f10d 0207 	add.w	r2, sp, #7
 8004a8e:	2301      	movs	r3, #1
 8004a90:	215e      	movs	r1, #94	; 0x5e
{
 8004a92:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004a94:	f002 fd6a 	bl	800756c <Sensor_IO_Read>
 8004a98:	b110      	cbz	r0, 8004aa0 <LSM6DSL_ACC_GYRO_W_TiltEvOnInt1+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;
 8004a9a:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004a9c:	b003      	add	sp, #12
 8004a9e:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_INT1_TILT_MASK;
 8004aa0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004aa4:	f023 0302 	bic.w	r3, r3, #2
  value |= newValue;
 8004aa8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004aaa:	f10d 0207 	add.w	r2, sp, #7
 8004aae:	4628      	mov	r0, r5
 8004ab0:	2301      	movs	r3, #1
 8004ab2:	215e      	movs	r1, #94	; 0x5e
  value |= newValue;
 8004ab4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004ab8:	f002 fd0a 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004abc:	fab0 f080 	clz	r0, r0
 8004ac0:	0940      	lsrs	r0, r0, #5
}
 8004ac2:	b003      	add	sp, #12
 8004ac4:	bd30      	pop	{r4, r5, pc}
 8004ac6:	bf00      	nop

08004ac8 <LSM6DSL_ACC_GYRO_W_6DEvOnInt1>:
* Input          : LSM6DSL_ACC_GYRO_INT1_6D_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_6DEvOnInt1(void *handle, LSM6DSL_ACC_GYRO_INT1_6D_t newValue)
{
 8004ac8:	b530      	push	{r4, r5, lr}
 8004aca:	b083      	sub	sp, #12
 8004acc:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004ace:	f10d 0207 	add.w	r2, sp, #7
 8004ad2:	2301      	movs	r3, #1
 8004ad4:	215e      	movs	r1, #94	; 0x5e
{
 8004ad6:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004ad8:	f002 fd48 	bl	800756c <Sensor_IO_Read>
 8004adc:	b110      	cbz	r0, 8004ae4 <LSM6DSL_ACC_GYRO_W_6DEvOnInt1+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;
 8004ade:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004ae0:	b003      	add	sp, #12
 8004ae2:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_INT1_6D_MASK;
 8004ae4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004ae8:	f023 0304 	bic.w	r3, r3, #4
  value |= newValue;
 8004aec:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004aee:	f10d 0207 	add.w	r2, sp, #7
 8004af2:	4628      	mov	r0, r5
 8004af4:	2301      	movs	r3, #1
 8004af6:	215e      	movs	r1, #94	; 0x5e
  value |= newValue;
 8004af8:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004afc:	f002 fce8 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004b00:	fab0 f080 	clz	r0, r0
 8004b04:	0940      	lsrs	r0, r0, #5
}
 8004b06:	b003      	add	sp, #12
 8004b08:	bd30      	pop	{r4, r5, pc}
 8004b0a:	bf00      	nop

08004b0c <LSM6DSL_ACC_GYRO_W_TapEvOnInt1>:
* Input          : LSM6DSL_ACC_GYRO_INT1_TAP_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_TapEvOnInt1(void *handle, LSM6DSL_ACC_GYRO_INT1_TAP_t newValue)
{
 8004b0c:	b530      	push	{r4, r5, lr}
 8004b0e:	b083      	sub	sp, #12
 8004b10:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004b12:	f10d 0207 	add.w	r2, sp, #7
 8004b16:	2301      	movs	r3, #1
 8004b18:	215e      	movs	r1, #94	; 0x5e
{
 8004b1a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004b1c:	f002 fd26 	bl	800756c <Sensor_IO_Read>
 8004b20:	b110      	cbz	r0, 8004b28 <LSM6DSL_ACC_GYRO_W_TapEvOnInt1+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;
 8004b22:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004b24:	b003      	add	sp, #12
 8004b26:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_INT1_TAP_MASK;
 8004b28:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004b2c:	f023 0308 	bic.w	r3, r3, #8
  value |= newValue;
 8004b30:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004b32:	f10d 0207 	add.w	r2, sp, #7
 8004b36:	4628      	mov	r0, r5
 8004b38:	2301      	movs	r3, #1
 8004b3a:	215e      	movs	r1, #94	; 0x5e
  value |= newValue;
 8004b3c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004b40:	f002 fcc6 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004b44:	fab0 f080 	clz	r0, r0
 8004b48:	0940      	lsrs	r0, r0, #5
}
 8004b4a:	b003      	add	sp, #12
 8004b4c:	bd30      	pop	{r4, r5, pc}
 8004b4e:	bf00      	nop

08004b50 <LSM6DSL_ACC_GYRO_W_FFEvOnInt1>:
* Input          : LSM6DSL_ACC_GYRO_INT1_FF_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_FFEvOnInt1(void *handle, LSM6DSL_ACC_GYRO_INT1_FF_t newValue)
{
 8004b50:	b530      	push	{r4, r5, lr}
 8004b52:	b083      	sub	sp, #12
 8004b54:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004b56:	f10d 0207 	add.w	r2, sp, #7
 8004b5a:	2301      	movs	r3, #1
 8004b5c:	215e      	movs	r1, #94	; 0x5e
{
 8004b5e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004b60:	f002 fd04 	bl	800756c <Sensor_IO_Read>
 8004b64:	b110      	cbz	r0, 8004b6c <LSM6DSL_ACC_GYRO_W_FFEvOnInt1+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;
 8004b66:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004b68:	b003      	add	sp, #12
 8004b6a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_INT1_FF_MASK;
 8004b6c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004b70:	f023 0310 	bic.w	r3, r3, #16
  value |= newValue;
 8004b74:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004b76:	f10d 0207 	add.w	r2, sp, #7
 8004b7a:	4628      	mov	r0, r5
 8004b7c:	2301      	movs	r3, #1
 8004b7e:	215e      	movs	r1, #94	; 0x5e
  value |= newValue;
 8004b80:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004b84:	f002 fca4 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004b88:	fab0 f080 	clz	r0, r0
 8004b8c:	0940      	lsrs	r0, r0, #5
}
 8004b8e:	b003      	add	sp, #12
 8004b90:	bd30      	pop	{r4, r5, pc}
 8004b92:	bf00      	nop

08004b94 <LSM6DSL_ACC_GYRO_W_WUEvOnInt1>:
* Input          : LSM6DSL_ACC_GYRO_INT1_WU_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_WUEvOnInt1(void *handle, LSM6DSL_ACC_GYRO_INT1_WU_t newValue)
{
 8004b94:	b530      	push	{r4, r5, lr}
 8004b96:	b083      	sub	sp, #12
 8004b98:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004b9a:	f10d 0207 	add.w	r2, sp, #7
 8004b9e:	2301      	movs	r3, #1
 8004ba0:	215e      	movs	r1, #94	; 0x5e
{
 8004ba2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004ba4:	f002 fce2 	bl	800756c <Sensor_IO_Read>
 8004ba8:	b110      	cbz	r0, 8004bb0 <LSM6DSL_ACC_GYRO_W_WUEvOnInt1+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;
 8004baa:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004bac:	b003      	add	sp, #12
 8004bae:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_INT1_WU_MASK;
 8004bb0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004bb4:	f023 0320 	bic.w	r3, r3, #32
  value |= newValue;
 8004bb8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004bba:	f10d 0207 	add.w	r2, sp, #7
 8004bbe:	4628      	mov	r0, r5
 8004bc0:	2301      	movs	r3, #1
 8004bc2:	215e      	movs	r1, #94	; 0x5e
  value |= newValue;
 8004bc4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004bc8:	f002 fc82 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004bcc:	fab0 f080 	clz	r0, r0
 8004bd0:	0940      	lsrs	r0, r0, #5
}
 8004bd2:	b003      	add	sp, #12
 8004bd4:	bd30      	pop	{r4, r5, pc}
 8004bd6:	bf00      	nop

08004bd8 <LSM6DSL_ACC_GYRO_W_SingleTapOnInt1>:
* Input          : LSM6DSL_ACC_GYRO_INT1_SINGLE_TAP_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_SingleTapOnInt1(void *handle, LSM6DSL_ACC_GYRO_INT1_SINGLE_TAP_t newValue)
{
 8004bd8:	b530      	push	{r4, r5, lr}
 8004bda:	b083      	sub	sp, #12
 8004bdc:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004bde:	f10d 0207 	add.w	r2, sp, #7
 8004be2:	2301      	movs	r3, #1
 8004be4:	215e      	movs	r1, #94	; 0x5e
{
 8004be6:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004be8:	f002 fcc0 	bl	800756c <Sensor_IO_Read>
 8004bec:	b110      	cbz	r0, 8004bf4 <LSM6DSL_ACC_GYRO_W_SingleTapOnInt1+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;
 8004bee:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_MD1_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004bf0:	b003      	add	sp, #12
 8004bf2:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_INT1_SINGLE_TAP_MASK;
 8004bf4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004bf8:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  value |= newValue;
 8004bfc:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004bfe:	f10d 0207 	add.w	r2, sp, #7
 8004c02:	4628      	mov	r0, r5
 8004c04:	2301      	movs	r3, #1
 8004c06:	215e      	movs	r1, #94	; 0x5e
  value |= newValue;
 8004c08:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004c0c:	f002 fc60 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004c10:	fab0 f080 	clz	r0, r0
 8004c14:	0940      	lsrs	r0, r0, #5
}
 8004c16:	b003      	add	sp, #12
 8004c18:	bd30      	pop	{r4, r5, pc}
 8004c1a:	bf00      	nop

08004c1c <LSM6DSL_ACC_GYRO_W_TiltEvOnInt2>:
* Input          : LSM6DSL_ACC_GYRO_INT2_TILT_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_TiltEvOnInt2(void *handle, LSM6DSL_ACC_GYRO_INT2_TILT_t newValue)
{
 8004c1c:	b530      	push	{r4, r5, lr}
 8004c1e:	b083      	sub	sp, #12
 8004c20:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004c22:	f10d 0207 	add.w	r2, sp, #7
 8004c26:	2301      	movs	r3, #1
 8004c28:	215f      	movs	r1, #95	; 0x5f
{
 8004c2a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004c2c:	f002 fc9e 	bl	800756c <Sensor_IO_Read>
 8004c30:	b110      	cbz	r0, 8004c38 <LSM6DSL_ACC_GYRO_W_TiltEvOnInt2+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;
 8004c32:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004c34:	b003      	add	sp, #12
 8004c36:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_INT2_TILT_MASK;
 8004c38:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004c3c:	f023 0302 	bic.w	r3, r3, #2
  value |= newValue;
 8004c40:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004c42:	f10d 0207 	add.w	r2, sp, #7
 8004c46:	4628      	mov	r0, r5
 8004c48:	2301      	movs	r3, #1
 8004c4a:	215f      	movs	r1, #95	; 0x5f
  value |= newValue;
 8004c4c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004c50:	f002 fc3e 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004c54:	fab0 f080 	clz	r0, r0
 8004c58:	0940      	lsrs	r0, r0, #5
}
 8004c5a:	b003      	add	sp, #12
 8004c5c:	bd30      	pop	{r4, r5, pc}
 8004c5e:	bf00      	nop

08004c60 <LSM6DSL_ACC_GYRO_W_6DEvOnInt2>:
* Input          : LSM6DSL_ACC_GYRO_INT2_6D_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_6DEvOnInt2(void *handle, LSM6DSL_ACC_GYRO_INT2_6D_t newValue)
{
 8004c60:	b530      	push	{r4, r5, lr}
 8004c62:	b083      	sub	sp, #12
 8004c64:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004c66:	f10d 0207 	add.w	r2, sp, #7
 8004c6a:	2301      	movs	r3, #1
 8004c6c:	215f      	movs	r1, #95	; 0x5f
{
 8004c6e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004c70:	f002 fc7c 	bl	800756c <Sensor_IO_Read>
 8004c74:	b110      	cbz	r0, 8004c7c <LSM6DSL_ACC_GYRO_W_6DEvOnInt2+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;
 8004c76:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004c78:	b003      	add	sp, #12
 8004c7a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_INT2_6D_MASK;
 8004c7c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004c80:	f023 0304 	bic.w	r3, r3, #4
  value |= newValue;
 8004c84:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004c86:	f10d 0207 	add.w	r2, sp, #7
 8004c8a:	4628      	mov	r0, r5
 8004c8c:	2301      	movs	r3, #1
 8004c8e:	215f      	movs	r1, #95	; 0x5f
  value |= newValue;
 8004c90:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004c94:	f002 fc1c 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004c98:	fab0 f080 	clz	r0, r0
 8004c9c:	0940      	lsrs	r0, r0, #5
}
 8004c9e:	b003      	add	sp, #12
 8004ca0:	bd30      	pop	{r4, r5, pc}
 8004ca2:	bf00      	nop

08004ca4 <LSM6DSL_ACC_GYRO_W_TapEvOnInt2>:
* Input          : LSM6DSL_ACC_GYRO_INT2_TAP_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_TapEvOnInt2(void *handle, LSM6DSL_ACC_GYRO_INT2_TAP_t newValue)
{
 8004ca4:	b530      	push	{r4, r5, lr}
 8004ca6:	b083      	sub	sp, #12
 8004ca8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004caa:	f10d 0207 	add.w	r2, sp, #7
 8004cae:	2301      	movs	r3, #1
 8004cb0:	215f      	movs	r1, #95	; 0x5f
{
 8004cb2:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004cb4:	f002 fc5a 	bl	800756c <Sensor_IO_Read>
 8004cb8:	b110      	cbz	r0, 8004cc0 <LSM6DSL_ACC_GYRO_W_TapEvOnInt2+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;
 8004cba:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004cbc:	b003      	add	sp, #12
 8004cbe:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_INT2_TAP_MASK;
 8004cc0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004cc4:	f023 0308 	bic.w	r3, r3, #8
  value |= newValue;
 8004cc8:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004cca:	f10d 0207 	add.w	r2, sp, #7
 8004cce:	4628      	mov	r0, r5
 8004cd0:	2301      	movs	r3, #1
 8004cd2:	215f      	movs	r1, #95	; 0x5f
  value |= newValue;
 8004cd4:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004cd8:	f002 fbfa 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004cdc:	fab0 f080 	clz	r0, r0
 8004ce0:	0940      	lsrs	r0, r0, #5
}
 8004ce2:	b003      	add	sp, #12
 8004ce4:	bd30      	pop	{r4, r5, pc}
 8004ce6:	bf00      	nop

08004ce8 <LSM6DSL_ACC_GYRO_W_FFEvOnInt2>:
* Input          : LSM6DSL_ACC_GYRO_INT2_FF_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_FFEvOnInt2(void *handle, LSM6DSL_ACC_GYRO_INT2_FF_t newValue)
{
 8004ce8:	b530      	push	{r4, r5, lr}
 8004cea:	b083      	sub	sp, #12
 8004cec:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004cee:	f10d 0207 	add.w	r2, sp, #7
 8004cf2:	2301      	movs	r3, #1
 8004cf4:	215f      	movs	r1, #95	; 0x5f
{
 8004cf6:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004cf8:	f002 fc38 	bl	800756c <Sensor_IO_Read>
 8004cfc:	b110      	cbz	r0, 8004d04 <LSM6DSL_ACC_GYRO_W_FFEvOnInt2+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;
 8004cfe:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004d00:	b003      	add	sp, #12
 8004d02:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_INT2_FF_MASK;
 8004d04:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004d08:	f023 0310 	bic.w	r3, r3, #16
  value |= newValue;
 8004d0c:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004d0e:	f10d 0207 	add.w	r2, sp, #7
 8004d12:	4628      	mov	r0, r5
 8004d14:	2301      	movs	r3, #1
 8004d16:	215f      	movs	r1, #95	; 0x5f
  value |= newValue;
 8004d18:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004d1c:	f002 fbd8 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004d20:	fab0 f080 	clz	r0, r0
 8004d24:	0940      	lsrs	r0, r0, #5
}
 8004d26:	b003      	add	sp, #12
 8004d28:	bd30      	pop	{r4, r5, pc}
 8004d2a:	bf00      	nop

08004d2c <LSM6DSL_ACC_GYRO_W_WUEvOnInt2>:
* Input          : LSM6DSL_ACC_GYRO_INT2_WU_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_WUEvOnInt2(void *handle, LSM6DSL_ACC_GYRO_INT2_WU_t newValue)
{
 8004d2c:	b530      	push	{r4, r5, lr}
 8004d2e:	b083      	sub	sp, #12
 8004d30:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004d32:	f10d 0207 	add.w	r2, sp, #7
 8004d36:	2301      	movs	r3, #1
 8004d38:	215f      	movs	r1, #95	; 0x5f
{
 8004d3a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004d3c:	f002 fc16 	bl	800756c <Sensor_IO_Read>
 8004d40:	b110      	cbz	r0, 8004d48 <LSM6DSL_ACC_GYRO_W_WUEvOnInt2+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;
 8004d42:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004d44:	b003      	add	sp, #12
 8004d46:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_INT2_WU_MASK;
 8004d48:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004d4c:	f023 0320 	bic.w	r3, r3, #32
  value |= newValue;
 8004d50:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004d52:	f10d 0207 	add.w	r2, sp, #7
 8004d56:	4628      	mov	r0, r5
 8004d58:	2301      	movs	r3, #1
 8004d5a:	215f      	movs	r1, #95	; 0x5f
  value |= newValue;
 8004d5c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004d60:	f002 fbb6 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004d64:	fab0 f080 	clz	r0, r0
 8004d68:	0940      	lsrs	r0, r0, #5
}
 8004d6a:	b003      	add	sp, #12
 8004d6c:	bd30      	pop	{r4, r5, pc}
 8004d6e:	bf00      	nop

08004d70 <LSM6DSL_ACC_GYRO_W_SingleTapOnInt2>:
* Input          : LSM6DSL_ACC_GYRO_INT2_SINGLE_TAP_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_SingleTapOnInt2(void *handle, LSM6DSL_ACC_GYRO_INT2_SINGLE_TAP_t newValue)
{
 8004d70:	b530      	push	{r4, r5, lr}
 8004d72:	b083      	sub	sp, #12
 8004d74:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004d76:	f10d 0207 	add.w	r2, sp, #7
 8004d7a:	2301      	movs	r3, #1
 8004d7c:	215f      	movs	r1, #95	; 0x5f
{
 8004d7e:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004d80:	f002 fbf4 	bl	800756c <Sensor_IO_Read>
 8004d84:	b110      	cbz	r0, 8004d8c <LSM6DSL_ACC_GYRO_W_SingleTapOnInt2+0x1c>
  u8_t value;

  if( !LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;
 8004d86:	2000      	movs	r0, #0

  if( !LSM6DSL_ACC_GYRO_WriteReg(handle, LSM6DSL_ACC_GYRO_MD2_CFG, &value, 1) )
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
 8004d88:	b003      	add	sp, #12
 8004d8a:	bd30      	pop	{r4, r5, pc}
  value &= ~LSM6DSL_ACC_GYRO_INT2_SINGLE_TAP_MASK;
 8004d8c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004d90:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  value |= newValue;
 8004d94:	431c      	orrs	r4, r3
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004d96:	f10d 0207 	add.w	r2, sp, #7
 8004d9a:	4628      	mov	r0, r5
 8004d9c:	2301      	movs	r3, #1
 8004d9e:	215f      	movs	r1, #95	; 0x5f
  value |= newValue;
 8004da0:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004da4:	f002 fb94 	bl	80074d0 <Sensor_IO_Write>
    return MEMS_ERROR;
 8004da8:	fab0 f080 	clz	r0, r0
 8004dac:	0940      	lsrs	r0, r0, #5
}
 8004dae:	b003      	add	sp, #12
 8004db0:	bd30      	pop	{r4, r5, pc}
 8004db2:	bf00      	nop

08004db4 <LSM6DSL_ACC_GYRO_Get_GetFIFOData>:
* Input          : pointer to [u8_t]
* Output         : GetFIFOData buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_Get_GetFIFOData(void *handle, u8_t *buff)
{
 8004db4:	b538      	push	{r3, r4, r5, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004db6:	460a      	mov	r2, r1
{
 8004db8:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004dba:	2301      	movs	r3, #1
 8004dbc:	213e      	movs	r1, #62	; 0x3e
{
 8004dbe:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004dc0:	f002 fbd4 	bl	800756c <Sensor_IO_Read>
 8004dc4:	b948      	cbnz	r0, 8004dda <LSM6DSL_ACC_GYRO_Get_GetFIFOData+0x26>
 8004dc6:	1c62      	adds	r2, r4, #1
 8004dc8:	4628      	mov	r0, r5
 8004dca:	2301      	movs	r3, #1
 8004dcc:	213f      	movs	r1, #63	; 0x3f
 8004dce:	f002 fbcd 	bl	800756c <Sensor_IO_Read>
        return MEMS_ERROR;
      k++;
    }
  }

  return MEMS_SUCCESS;
 8004dd2:	fab0 f080 	clz	r0, r0
 8004dd6:	0940      	lsrs	r0, r0, #5
 8004dd8:	bd38      	pop	{r3, r4, r5, pc}
        return MEMS_ERROR;
 8004dda:	2000      	movs	r0, #0
}
 8004ddc:	bd38      	pop	{r3, r4, r5, pc}
 8004dde:	bf00      	nop

08004de0 <LSM6DSL_ACC_GYRO_Get_GetStepCounter>:
* Input          : pointer to [u8_t]
* Output         : GetStepCounter buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM6DSL_ACC_GYRO_Get_GetStepCounter(void *handle, u8_t *buff)
{
 8004de0:	b538      	push	{r3, r4, r5, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004de2:	460a      	mov	r2, r1
{
 8004de4:	460c      	mov	r4, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004de6:	2301      	movs	r3, #1
 8004de8:	214b      	movs	r1, #75	; 0x4b
{
 8004dea:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004dec:	f002 fbbe 	bl	800756c <Sensor_IO_Read>
 8004df0:	b948      	cbnz	r0, 8004e06 <LSM6DSL_ACC_GYRO_Get_GetStepCounter+0x26>
 8004df2:	1c62      	adds	r2, r4, #1
 8004df4:	4628      	mov	r0, r5
 8004df6:	2301      	movs	r3, #1
 8004df8:	214c      	movs	r1, #76	; 0x4c
 8004dfa:	f002 fbb7 	bl	800756c <Sensor_IO_Read>
        return MEMS_ERROR;
      k++;
    }
  }

  return MEMS_SUCCESS;
 8004dfe:	fab0 f080 	clz	r0, r0
 8004e02:	0940      	lsrs	r0, r0, #5
 8004e04:	bd38      	pop	{r3, r4, r5, pc}
        return MEMS_ERROR;
 8004e06:	2000      	movs	r0, #0
}
 8004e08:	bd38      	pop	{r3, r4, r5, pc}
 8004e0a:	bf00      	nop

08004e0c <LSM6DSL_ACC_GYRO_W_PedoThreshold>:
* Input          : pointer to [u8_t]
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM6DSL_ACC_GYRO_W_PedoThreshold(void *handle, u8_t newValue)
{
 8004e0c:	b570      	push	{r4, r5, r6, lr}
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004e0e:	2301      	movs	r3, #1
{
 8004e10:	b082      	sub	sp, #8
 8004e12:	460e      	mov	r6, r1
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004e14:	f10d 0207 	add.w	r2, sp, #7
 8004e18:	4619      	mov	r1, r3
{
 8004e1a:	4605      	mov	r5, r0
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004e1c:	f002 fba6 	bl	800756c <Sensor_IO_Read>
 8004e20:	b960      	cbnz	r0, 8004e3c <LSM6DSL_ACC_GYRO_W_PedoThreshold+0x30>
  value &= ~LSM6DSL_ACC_GYRO_EMB_ACC_MASK;
 8004e22:	f89d 4007 	ldrb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004e26:	2301      	movs	r3, #1
  value |= newValue;
 8004e28:	f064 047f 	orn	r4, r4, #127	; 0x7f
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004e2c:	4619      	mov	r1, r3
 8004e2e:	f10d 0207 	add.w	r2, sp, #7
 8004e32:	4628      	mov	r0, r5
  value |= newValue;
 8004e34:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004e38:	f002 fb4a 	bl	80074d0 <Sensor_IO_Write>
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004e3c:	f10d 0206 	add.w	r2, sp, #6
 8004e40:	2301      	movs	r3, #1
 8004e42:	210f      	movs	r1, #15
 8004e44:	4628      	mov	r0, r5
 8004e46:	f002 fb91 	bl	800756c <Sensor_IO_Read>
  LSM6DSL_ACC_GYRO_W_EmbeddedAccess(handle, LSM6DSL_ACC_GYRO_EMBEDDED_ACCESS_ENABLED);

  /* read current value */
  LSM6DSL_ACC_GYRO_ReadReg(handle, LSM6DSL_ACC_GYRO_CONFIG_PEDO_THS_MIN, &value, 1);

  value &= ~0x1F;
 8004e4a:	f89d 4006 	ldrb.w	r4, [sp, #6]
  value |= (newValue & 0x1F);
 8004e4e:	f006 061f 	and.w	r6, r6, #31
  value &= ~0x1F;
 8004e52:	f024 041f 	bic.w	r4, r4, #31
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004e56:	f10d 0206 	add.w	r2, sp, #6
 8004e5a:	2301      	movs	r3, #1
 8004e5c:	210f      	movs	r1, #15
  value |= (newValue & 0x1F);
 8004e5e:	4334      	orrs	r4, r6
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004e60:	4628      	mov	r0, r5
  value |= (newValue & 0x1F);
 8004e62:	f88d 4006 	strb.w	r4, [sp, #6]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004e66:	f002 fb33 	bl	80074d0 <Sensor_IO_Write>
  if (Sensor_IO_Read(handle, Reg, Data, len))
 8004e6a:	2301      	movs	r3, #1
 8004e6c:	4619      	mov	r1, r3
 8004e6e:	f10d 0207 	add.w	r2, sp, #7
 8004e72:	4628      	mov	r0, r5
 8004e74:	f002 fb7a 	bl	800756c <Sensor_IO_Read>
 8004e78:	b960      	cbnz	r0, 8004e94 <LSM6DSL_ACC_GYRO_W_PedoThreshold+0x88>
  value &= ~LSM6DSL_ACC_GYRO_EMB_ACC_MASK;
 8004e7a:	f89d 4007 	ldrb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004e7e:	2301      	movs	r3, #1
  value &= ~LSM6DSL_ACC_GYRO_EMB_ACC_MASK;
 8004e80:	f004 047f 	and.w	r4, r4, #127	; 0x7f
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004e84:	f10d 0207 	add.w	r2, sp, #7
 8004e88:	4628      	mov	r0, r5
 8004e8a:	4619      	mov	r1, r3
  value |= newValue;
 8004e8c:	f88d 4007 	strb.w	r4, [sp, #7]
  if (Sensor_IO_Write(handle, Reg, Data, len))
 8004e90:	f002 fb1e 	bl	80074d0 <Sensor_IO_Write>

  /* Close Embedded Function Register page*/
  LSM6DSL_ACC_GYRO_W_EmbeddedAccess(handle, LSM6DSL_ACC_GYRO_EMBEDDED_ACCESS_DISABLED);

  return MEMS_SUCCESS;
}
 8004e94:	2001      	movs	r0, #1
 8004e96:	b002      	add	sp, #8
 8004e98:	bd70      	pop	{r4, r5, r6, pc}
 8004e9a:	bf00      	nop

08004e9c <LSM6DSL_FIFO_Set_Watermark_Level>:
 * @param watermark FIFO watermark level
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LSM6DSL_FIFO_Set_Watermark_Level( DrvContextTypeDef *handle, uint16_t watermark )
{
 8004e9c:	b508      	push	{r3, lr}

  if ( LSM6DSL_ACC_GYRO_W_FIFO_Watermark( handle, watermark ) == MEMS_ERROR )
 8004e9e:	f7ff f813 	bl	8003ec8 <LSM6DSL_ACC_GYRO_W_FIFO_Watermark>
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8004ea2:	fab0 f080 	clz	r0, r0
 8004ea6:	0940      	lsrs	r0, r0, #5
 8004ea8:	bd08      	pop	{r3, pc}
 8004eaa:	bf00      	nop

08004eac <LSM6DSL_X_Get_Sensitivity>:
{
 8004eac:	b510      	push	{r4, lr}
 8004eae:	b082      	sub	sp, #8
 8004eb0:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_FS_XL( (void *)handle, &fullScale ) == MEMS_ERROR )
 8004eb2:	f10d 0107 	add.w	r1, sp, #7
 8004eb6:	f7fe feef 	bl	8003c98 <LSM6DSL_ACC_GYRO_R_FS_XL>
 8004eba:	b160      	cbz	r0, 8004ed6 <LSM6DSL_X_Get_Sensitivity+0x2a>
  switch( fullScale )
 8004ebc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004ec0:	2b0c      	cmp	r3, #12
 8004ec2:	d81f      	bhi.n	8004f04 <LSM6DSL_X_Get_Sensitivity+0x58>
 8004ec4:	e8df f003 	tbb	[pc, r3]
 8004ec8:	1e1e1e0f 	.word	0x1e1e1e0f
 8004ecc:	1e1e1e14 	.word	0x1e1e1e14
 8004ed0:	1e1e1e19 	.word	0x1e1e1e19
 8004ed4:	0a          	.byte	0x0a
 8004ed5:	00          	.byte	0x00
    return COMPONENT_ERROR;
 8004ed6:	2001      	movs	r0, #1
}
 8004ed8:	b002      	add	sp, #8
 8004eda:	bd10      	pop	{r4, pc}
      *sensitivity = ( float )LSM6DSL_ACC_SENSITIVITY_FOR_FS_8G;
 8004edc:	4b0c      	ldr	r3, [pc, #48]	; (8004f10 <LSM6DSL_X_Get_Sensitivity+0x64>)
 8004ede:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8004ee0:	2000      	movs	r0, #0
}
 8004ee2:	b002      	add	sp, #8
 8004ee4:	bd10      	pop	{r4, pc}
      *sensitivity = ( float )LSM6DSL_ACC_SENSITIVITY_FOR_FS_2G;
 8004ee6:	4b0b      	ldr	r3, [pc, #44]	; (8004f14 <LSM6DSL_X_Get_Sensitivity+0x68>)
 8004ee8:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8004eea:	2000      	movs	r0, #0
}
 8004eec:	b002      	add	sp, #8
 8004eee:	bd10      	pop	{r4, pc}
      *sensitivity = ( float )LSM6DSL_ACC_SENSITIVITY_FOR_FS_16G;
 8004ef0:	4b09      	ldr	r3, [pc, #36]	; (8004f18 <LSM6DSL_X_Get_Sensitivity+0x6c>)
 8004ef2:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8004ef4:	2000      	movs	r0, #0
}
 8004ef6:	b002      	add	sp, #8
 8004ef8:	bd10      	pop	{r4, pc}
      *sensitivity = ( float )LSM6DSL_ACC_SENSITIVITY_FOR_FS_4G;
 8004efa:	4b08      	ldr	r3, [pc, #32]	; (8004f1c <LSM6DSL_X_Get_Sensitivity+0x70>)
 8004efc:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8004efe:	2000      	movs	r0, #0
}
 8004f00:	b002      	add	sp, #8
 8004f02:	bd10      	pop	{r4, pc}
      *sensitivity = -1.0f;
 8004f04:	4b06      	ldr	r3, [pc, #24]	; (8004f20 <LSM6DSL_X_Get_Sensitivity+0x74>)
 8004f06:	6023      	str	r3, [r4, #0]
      return COMPONENT_ERROR;
 8004f08:	2001      	movs	r0, #1
}
 8004f0a:	b002      	add	sp, #8
 8004f0c:	bd10      	pop	{r4, pc}
 8004f0e:	bf00      	nop
 8004f10:	3e79db23 	.word	0x3e79db23
 8004f14:	3d79db23 	.word	0x3d79db23
 8004f18:	3ef9db23 	.word	0x3ef9db23
 8004f1c:	3df9db23 	.word	0x3df9db23
 8004f20:	bf800000 	.word	0xbf800000

08004f24 <LSM6DSL_X_Get_FS>:
{
 8004f24:	b510      	push	{r4, lr}
 8004f26:	b082      	sub	sp, #8
 8004f28:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_FS_XL( (void *)handle, &fs_low_level ) == MEMS_ERROR )
 8004f2a:	f10d 0107 	add.w	r1, sp, #7
 8004f2e:	f7fe feb3 	bl	8003c98 <LSM6DSL_ACC_GYRO_R_FS_XL>
 8004f32:	b160      	cbz	r0, 8004f4e <LSM6DSL_X_Get_FS+0x2a>
  switch( fs_low_level )
 8004f34:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004f38:	2b0c      	cmp	r3, #12
 8004f3a:	d823      	bhi.n	8004f84 <LSM6DSL_X_Get_FS+0x60>
 8004f3c:	e8df f003 	tbb	[pc, r3]
 8004f40:	22222210 	.word	0x22222210
 8004f44:	22222216 	.word	0x22222216
 8004f48:	2222221c 	.word	0x2222221c
 8004f4c:	0a          	.byte	0x0a
 8004f4d:	00          	.byte	0x00
    return COMPONENT_ERROR;
 8004f4e:	2001      	movs	r0, #1
}
 8004f50:	b002      	add	sp, #8
 8004f52:	bd10      	pop	{r4, pc}
      *fullScale =  8.0f;
 8004f54:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
  return COMPONENT_OK;
 8004f58:	2000      	movs	r0, #0
      *fullScale =  8.0f;
 8004f5a:	6023      	str	r3, [r4, #0]
}
 8004f5c:	b002      	add	sp, #8
 8004f5e:	bd10      	pop	{r4, pc}
      *fullScale =  2.0f;
 8004f60:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  return COMPONENT_OK;
 8004f64:	2000      	movs	r0, #0
      *fullScale =  2.0f;
 8004f66:	6023      	str	r3, [r4, #0]
}
 8004f68:	b002      	add	sp, #8
 8004f6a:	bd10      	pop	{r4, pc}
      *fullScale = 16.0f;
 8004f6c:	f04f 4383 	mov.w	r3, #1098907648	; 0x41800000
  return COMPONENT_OK;
 8004f70:	2000      	movs	r0, #0
      *fullScale = 16.0f;
 8004f72:	6023      	str	r3, [r4, #0]
}
 8004f74:	b002      	add	sp, #8
 8004f76:	bd10      	pop	{r4, pc}
      *fullScale =  4.0f;
 8004f78:	f04f 4381 	mov.w	r3, #1082130432	; 0x40800000
  return COMPONENT_OK;
 8004f7c:	2000      	movs	r0, #0
      *fullScale =  4.0f;
 8004f7e:	6023      	str	r3, [r4, #0]
}
 8004f80:	b002      	add	sp, #8
 8004f82:	bd10      	pop	{r4, pc}
      *fullScale = -1.0f;
 8004f84:	4b02      	ldr	r3, [pc, #8]	; (8004f90 <LSM6DSL_X_Get_FS+0x6c>)
 8004f86:	6023      	str	r3, [r4, #0]
      return COMPONENT_ERROR;
 8004f88:	2001      	movs	r0, #1
}
 8004f8a:	b002      	add	sp, #8
 8004f8c:	bd10      	pop	{r4, pc}
 8004f8e:	bf00      	nop
 8004f90:	bf800000 	.word	0xbf800000

08004f94 <LSM6DSL_FIFO_Get_Num_Of_Samples>:
{
 8004f94:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_R_FIFONumOfEntries( handle, nSamples ) == MEMS_ERROR )
 8004f96:	f7ff fa79 	bl	800448c <LSM6DSL_ACC_GYRO_R_FIFONumOfEntries>
}
 8004f9a:	fab0 f080 	clz	r0, r0
 8004f9e:	0940      	lsrs	r0, r0, #5
 8004fa0:	bd08      	pop	{r3, pc}
 8004fa2:	bf00      	nop

08004fa4 <LSM6DSL_FIFO_Get_Data>:
{
 8004fa4:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_Get_GetFIFOData( handle, aData ) == MEMS_ERROR )
 8004fa6:	f7ff ff05 	bl	8004db4 <LSM6DSL_ACC_GYRO_Get_GetFIFOData>
}
 8004faa:	fab0 f080 	clz	r0, r0
 8004fae:	0940      	lsrs	r0, r0, #5
 8004fb0:	bd08      	pop	{r3, pc}
 8004fb2:	bf00      	nop

08004fb4 <LSM6DSL_FIFO_Get_Pattern>:
{
 8004fb4:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_R_FIFOPattern( handle, pattern ) == MEMS_ERROR )
 8004fb6:	f7ff fabb 	bl	8004530 <LSM6DSL_ACC_GYRO_R_FIFOPattern>
}
 8004fba:	fab0 f080 	clz	r0, r0
 8004fbe:	0940      	lsrs	r0, r0, #5
 8004fc0:	bd08      	pop	{r3, pc}
 8004fc2:	bf00      	nop

08004fc4 <LSM6DSL_FIFO_Get_Overrun_Status>:
{
 8004fc4:	b510      	push	{r4, lr}
 8004fc6:	b082      	sub	sp, #8
 8004fc8:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_OVERRUN( handle, &status_raw ) == MEMS_ERROR )
 8004fca:	f10d 0107 	add.w	r1, sp, #7
 8004fce:	f7ff fa9f 	bl	8004510 <LSM6DSL_ACC_GYRO_R_OVERRUN>
 8004fd2:	b148      	cbz	r0, 8004fe8 <LSM6DSL_FIFO_Get_Overrun_Status+0x24>
  switch( status_raw )
 8004fd4:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8004fd8:	b148      	cbz	r0, 8004fee <LSM6DSL_FIFO_Get_Overrun_Status+0x2a>
 8004fda:	2840      	cmp	r0, #64	; 0x40
 8004fdc:	d104      	bne.n	8004fe8 <LSM6DSL_FIFO_Get_Overrun_Status+0x24>
      *status = 1;
 8004fde:	2301      	movs	r3, #1
  return COMPONENT_OK;
 8004fe0:	2000      	movs	r0, #0
      *status = 1;
 8004fe2:	7023      	strb	r3, [r4, #0]
}
 8004fe4:	b002      	add	sp, #8
 8004fe6:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 8004fe8:	2001      	movs	r0, #1
}
 8004fea:	b002      	add	sp, #8
 8004fec:	bd10      	pop	{r4, pc}
      *status = 0;
 8004fee:	7020      	strb	r0, [r4, #0]
}
 8004ff0:	b002      	add	sp, #8
 8004ff2:	bd10      	pop	{r4, pc}

08004ff4 <LSM6DSL_FIFO_Get_Empty_Status>:
{
 8004ff4:	b510      	push	{r4, lr}
 8004ff6:	b082      	sub	sp, #8
 8004ff8:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_FIFOEmpty( handle, &status_raw ) == MEMS_ERROR )
 8004ffa:	f10d 0107 	add.w	r1, sp, #7
 8004ffe:	f7ff fa67 	bl	80044d0 <LSM6DSL_ACC_GYRO_R_FIFOEmpty>
 8005002:	b148      	cbz	r0, 8005018 <LSM6DSL_FIFO_Get_Empty_Status+0x24>
  switch( status_raw )
 8005004:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8005008:	b148      	cbz	r0, 800501e <LSM6DSL_FIFO_Get_Empty_Status+0x2a>
 800500a:	2810      	cmp	r0, #16
 800500c:	d104      	bne.n	8005018 <LSM6DSL_FIFO_Get_Empty_Status+0x24>
      *status = 1;
 800500e:	2301      	movs	r3, #1
  return COMPONENT_OK;
 8005010:	2000      	movs	r0, #0
      *status = 1;
 8005012:	7023      	strb	r3, [r4, #0]
}
 8005014:	b002      	add	sp, #8
 8005016:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 8005018:	2001      	movs	r0, #1
}
 800501a:	b002      	add	sp, #8
 800501c:	bd10      	pop	{r4, pc}
      *status = 0;
 800501e:	7020      	strb	r0, [r4, #0]
}
 8005020:	b002      	add	sp, #8
 8005022:	bd10      	pop	{r4, pc}

08005024 <LSM6DSL_FIFO_Get_Full_Status>:
{
 8005024:	b510      	push	{r4, lr}
 8005026:	b082      	sub	sp, #8
 8005028:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_FIFOFull( handle, &status_raw ) == MEMS_ERROR )
 800502a:	f10d 0107 	add.w	r1, sp, #7
 800502e:	f7ff fa5f 	bl	80044f0 <LSM6DSL_ACC_GYRO_R_FIFOFull>
 8005032:	b148      	cbz	r0, 8005048 <LSM6DSL_FIFO_Get_Full_Status+0x24>
  switch( status_raw )
 8005034:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8005038:	b148      	cbz	r0, 800504e <LSM6DSL_FIFO_Get_Full_Status+0x2a>
 800503a:	2820      	cmp	r0, #32
 800503c:	d104      	bne.n	8005048 <LSM6DSL_FIFO_Get_Full_Status+0x24>
      *status = 1;
 800503e:	2301      	movs	r3, #1
  return COMPONENT_OK;
 8005040:	2000      	movs	r0, #0
      *status = 1;
 8005042:	7023      	strb	r3, [r4, #0]
}
 8005044:	b002      	add	sp, #8
 8005046:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 8005048:	2001      	movs	r0, #1
}
 800504a:	b002      	add	sp, #8
 800504c:	bd10      	pop	{r4, pc}
      *status = 0;
 800504e:	7020      	strb	r0, [r4, #0]
}
 8005050:	b002      	add	sp, #8
 8005052:	bd10      	pop	{r4, pc}

08005054 <LSM6DSL_FIFO_Set_ODR_Value>:
            : ( odr <=   25.0f ) ? LSM6DSL_ACC_GYRO_ODR_FIFO_25Hz
 8005054:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 8005058:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800505c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 8005060:	b508      	push	{r3, lr}
            : ( odr <=   25.0f ) ? LSM6DSL_ACC_GYRO_ODR_FIFO_25Hz
 8005062:	d90d      	bls.n	8005080 <LSM6DSL_FIFO_Set_ODR_Value+0x2c>
 8005064:	eef3 7a09 	vmov.f32	s15, #57	; 0x41c80000  25.0
 8005068:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800506c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005070:	d80d      	bhi.n	800508e <LSM6DSL_FIFO_Set_ODR_Value+0x3a>
 8005072:	2110      	movs	r1, #16
  if ( LSM6DSL_ACC_GYRO_W_ODR_FIFO( handle, new_odr ) == MEMS_ERROR )
 8005074:	f7fe ffe6 	bl	8004044 <LSM6DSL_ACC_GYRO_W_ODR_FIFO>
}
 8005078:	fab0 f080 	clz	r0, r0
 800507c:	0940      	lsrs	r0, r0, #5
 800507e:	bd08      	pop	{r3, pc}
            : ( odr <=   25.0f ) ? LSM6DSL_ACC_GYRO_ODR_FIFO_25Hz
 8005080:	2108      	movs	r1, #8
  if ( LSM6DSL_ACC_GYRO_W_ODR_FIFO( handle, new_odr ) == MEMS_ERROR )
 8005082:	f7fe ffdf 	bl	8004044 <LSM6DSL_ACC_GYRO_W_ODR_FIFO>
}
 8005086:	fab0 f080 	clz	r0, r0
 800508a:	0940      	lsrs	r0, r0, #5
 800508c:	bd08      	pop	{r3, pc}
            : ( odr <=   25.0f ) ? LSM6DSL_ACC_GYRO_ODR_FIFO_25Hz
 800508e:	eddf 7a22 	vldr	s15, [pc, #136]	; 8005118 <LSM6DSL_FIFO_Set_ODR_Value+0xc4>
 8005092:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005096:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800509a:	d92c      	bls.n	80050f6 <LSM6DSL_FIFO_Set_ODR_Value+0xa2>
 800509c:	eddf 7a1f 	vldr	s15, [pc, #124]	; 800511c <LSM6DSL_FIFO_Set_ODR_Value+0xc8>
 80050a0:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80050a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80050a8:	d92c      	bls.n	8005104 <LSM6DSL_FIFO_Set_ODR_Value+0xb0>
 80050aa:	eddf 7a1d 	vldr	s15, [pc, #116]	; 8005120 <LSM6DSL_FIFO_Set_ODR_Value+0xcc>
 80050ae:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80050b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80050b6:	d927      	bls.n	8005108 <LSM6DSL_FIFO_Set_ODR_Value+0xb4>
 80050b8:	eddf 7a1a 	vldr	s15, [pc, #104]	; 8005124 <LSM6DSL_FIFO_Set_ODR_Value+0xd0>
 80050bc:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80050c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80050c4:	d922      	bls.n	800510c <LSM6DSL_FIFO_Set_ODR_Value+0xb8>
 80050c6:	eddf 7a18 	vldr	s15, [pc, #96]	; 8005128 <LSM6DSL_FIFO_Set_ODR_Value+0xd4>
 80050ca:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80050ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80050d2:	d91d      	bls.n	8005110 <LSM6DSL_FIFO_Set_ODR_Value+0xbc>
 80050d4:	eddf 7a15 	vldr	s15, [pc, #84]	; 800512c <LSM6DSL_FIFO_Set_ODR_Value+0xd8>
 80050d8:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80050dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80050e0:	d918      	bls.n	8005114 <LSM6DSL_FIFO_Set_ODR_Value+0xc0>
 80050e2:	eddf 7a13 	vldr	s15, [pc, #76]	; 8005130 <LSM6DSL_FIFO_Set_ODR_Value+0xdc>
 80050e6:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80050ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80050ee:	bf94      	ite	ls
 80050f0:	2148      	movls	r1, #72	; 0x48
 80050f2:	2150      	movhi	r1, #80	; 0x50
 80050f4:	e7c5      	b.n	8005082 <LSM6DSL_FIFO_Set_ODR_Value+0x2e>
 80050f6:	2118      	movs	r1, #24
  if ( LSM6DSL_ACC_GYRO_W_ODR_FIFO( handle, new_odr ) == MEMS_ERROR )
 80050f8:	f7fe ffa4 	bl	8004044 <LSM6DSL_ACC_GYRO_W_ODR_FIFO>
}
 80050fc:	fab0 f080 	clz	r0, r0
 8005100:	0940      	lsrs	r0, r0, #5
 8005102:	bd08      	pop	{r3, pc}
            : ( odr <=   25.0f ) ? LSM6DSL_ACC_GYRO_ODR_FIFO_25Hz
 8005104:	2120      	movs	r1, #32
 8005106:	e7bc      	b.n	8005082 <LSM6DSL_FIFO_Set_ODR_Value+0x2e>
 8005108:	2128      	movs	r1, #40	; 0x28
 800510a:	e7ba      	b.n	8005082 <LSM6DSL_FIFO_Set_ODR_Value+0x2e>
 800510c:	2130      	movs	r1, #48	; 0x30
 800510e:	e7b8      	b.n	8005082 <LSM6DSL_FIFO_Set_ODR_Value+0x2e>
 8005110:	2138      	movs	r1, #56	; 0x38
 8005112:	e7b6      	b.n	8005082 <LSM6DSL_FIFO_Set_ODR_Value+0x2e>
 8005114:	2140      	movs	r1, #64	; 0x40
 8005116:	e7b4      	b.n	8005082 <LSM6DSL_FIFO_Set_ODR_Value+0x2e>
 8005118:	42480000 	.word	0x42480000
 800511c:	42c80000 	.word	0x42c80000
 8005120:	43480000 	.word	0x43480000
 8005124:	43c80000 	.word	0x43c80000
 8005128:	44480000 	.word	0x44480000
 800512c:	44c80000 	.word	0x44c80000
 8005130:	454e4000 	.word	0x454e4000

08005134 <LSM6DSL_X_Get_Event_Status>:
{
 8005134:	b530      	push	{r4, r5, lr}
  if ( LSM6DSL_ACC_GYRO_ReadReg( (void *)handle, reg, data, 1 ) == MEMS_ERROR )
 8005136:	2301      	movs	r3, #1
{
 8005138:	b083      	sub	sp, #12
  uint8_t Wake_Up_Src = 0, Tap_Src = 0, D6D_Src = 0, Func_Src = 0, Md1_Cfg = 0, Md2_Cfg = 0, Int1_Ctrl = 0;
 800513a:	2400      	movs	r4, #0
  memset((void *)status, 0x0, sizeof(ACCELERO_Event_Status_t));
 800513c:	600c      	str	r4, [r1, #0]
{
 800513e:	460d      	mov	r5, r1
  if ( LSM6DSL_ACC_GYRO_ReadReg( (void *)handle, reg, data, 1 ) == MEMS_ERROR )
 8005140:	eb0d 0203 	add.w	r2, sp, r3
 8005144:	211b      	movs	r1, #27
  uint8_t Wake_Up_Src = 0, Tap_Src = 0, D6D_Src = 0, Func_Src = 0, Md1_Cfg = 0, Md2_Cfg = 0, Int1_Ctrl = 0;
 8005146:	f88d 4001 	strb.w	r4, [sp, #1]
 800514a:	f88d 4002 	strb.w	r4, [sp, #2]
 800514e:	f88d 4003 	strb.w	r4, [sp, #3]
 8005152:	f88d 4004 	strb.w	r4, [sp, #4]
 8005156:	f88d 4005 	strb.w	r4, [sp, #5]
 800515a:	f88d 4006 	strb.w	r4, [sp, #6]
 800515e:	f88d 4007 	strb.w	r4, [sp, #7]
{
 8005162:	4604      	mov	r4, r0
  if ( LSM6DSL_ACC_GYRO_ReadReg( (void *)handle, reg, data, 1 ) == MEMS_ERROR )
 8005164:	f7fe fd3a 	bl	8003bdc <LSM6DSL_ACC_GYRO_ReadReg>
  if(LSM6DSL_X_Read_Reg(handle, LSM6DSL_ACC_GYRO_WAKE_UP_SRC, &Wake_Up_Src ) == COMPONENT_ERROR )
 8005168:	2800      	cmp	r0, #0
 800516a:	f000 8095 	beq.w	8005298 <LSM6DSL_X_Get_Event_Status+0x164>
  if ( LSM6DSL_ACC_GYRO_ReadReg( (void *)handle, reg, data, 1 ) == MEMS_ERROR )
 800516e:	2301      	movs	r3, #1
 8005170:	f10d 0202 	add.w	r2, sp, #2
 8005174:	211c      	movs	r1, #28
 8005176:	4620      	mov	r0, r4
 8005178:	f7fe fd30 	bl	8003bdc <LSM6DSL_ACC_GYRO_ReadReg>
  if(LSM6DSL_X_Read_Reg(handle, LSM6DSL_ACC_GYRO_TAP_SRC, &Tap_Src ) == COMPONENT_ERROR )
 800517c:	2800      	cmp	r0, #0
 800517e:	f000 808b 	beq.w	8005298 <LSM6DSL_X_Get_Event_Status+0x164>
  if ( LSM6DSL_ACC_GYRO_ReadReg( (void *)handle, reg, data, 1 ) == MEMS_ERROR )
 8005182:	2301      	movs	r3, #1
 8005184:	f10d 0203 	add.w	r2, sp, #3
 8005188:	211d      	movs	r1, #29
 800518a:	4620      	mov	r0, r4
 800518c:	f7fe fd26 	bl	8003bdc <LSM6DSL_ACC_GYRO_ReadReg>
  if(LSM6DSL_X_Read_Reg(handle, LSM6DSL_ACC_GYRO_D6D_SRC, &D6D_Src ) == COMPONENT_ERROR )
 8005190:	2800      	cmp	r0, #0
 8005192:	f000 8081 	beq.w	8005298 <LSM6DSL_X_Get_Event_Status+0x164>
  if ( LSM6DSL_ACC_GYRO_ReadReg( (void *)handle, reg, data, 1 ) == MEMS_ERROR )
 8005196:	2301      	movs	r3, #1
 8005198:	aa01      	add	r2, sp, #4
 800519a:	2153      	movs	r1, #83	; 0x53
 800519c:	4620      	mov	r0, r4
 800519e:	f7fe fd1d 	bl	8003bdc <LSM6DSL_ACC_GYRO_ReadReg>
  if(LSM6DSL_X_Read_Reg(handle, LSM6DSL_ACC_GYRO_FUNC_SRC, &Func_Src ) == COMPONENT_ERROR )
 80051a2:	2800      	cmp	r0, #0
 80051a4:	d078      	beq.n	8005298 <LSM6DSL_X_Get_Event_Status+0x164>
  if ( LSM6DSL_ACC_GYRO_ReadReg( (void *)handle, reg, data, 1 ) == MEMS_ERROR )
 80051a6:	2301      	movs	r3, #1
 80051a8:	f10d 0205 	add.w	r2, sp, #5
 80051ac:	215e      	movs	r1, #94	; 0x5e
 80051ae:	4620      	mov	r0, r4
 80051b0:	f7fe fd14 	bl	8003bdc <LSM6DSL_ACC_GYRO_ReadReg>
  if(LSM6DSL_X_Read_Reg(handle, LSM6DSL_ACC_GYRO_MD1_CFG, &Md1_Cfg ) == COMPONENT_ERROR )
 80051b4:	2800      	cmp	r0, #0
 80051b6:	d06f      	beq.n	8005298 <LSM6DSL_X_Get_Event_Status+0x164>
  if ( LSM6DSL_ACC_GYRO_ReadReg( (void *)handle, reg, data, 1 ) == MEMS_ERROR )
 80051b8:	2301      	movs	r3, #1
 80051ba:	f10d 0206 	add.w	r2, sp, #6
 80051be:	215f      	movs	r1, #95	; 0x5f
 80051c0:	4620      	mov	r0, r4
 80051c2:	f7fe fd0b 	bl	8003bdc <LSM6DSL_ACC_GYRO_ReadReg>
  if(LSM6DSL_X_Read_Reg(handle, LSM6DSL_ACC_GYRO_MD2_CFG, &Md2_Cfg ) == COMPONENT_ERROR )
 80051c6:	2800      	cmp	r0, #0
 80051c8:	d066      	beq.n	8005298 <LSM6DSL_X_Get_Event_Status+0x164>
  if ( LSM6DSL_ACC_GYRO_ReadReg( (void *)handle, reg, data, 1 ) == MEMS_ERROR )
 80051ca:	4620      	mov	r0, r4
 80051cc:	2301      	movs	r3, #1
 80051ce:	f10d 0207 	add.w	r2, sp, #7
 80051d2:	210d      	movs	r1, #13
 80051d4:	f7fe fd02 	bl	8003bdc <LSM6DSL_ACC_GYRO_ReadReg>
  if(LSM6DSL_X_Read_Reg(handle, LSM6DSL_ACC_GYRO_INT1_CTRL, &Int1_Ctrl ) == COMPONENT_ERROR )
 80051d8:	2800      	cmp	r0, #0
 80051da:	d05d      	beq.n	8005298 <LSM6DSL_X_Get_Event_Status+0x164>
  if((Md1_Cfg & LSM6DSL_ACC_GYRO_INT1_FF_MASK) || (Md2_Cfg & LSM6DSL_ACC_GYRO_INT2_FF_MASK))
 80051dc:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80051e0:	06dc      	lsls	r4, r3, #27
 80051e2:	d403      	bmi.n	80051ec <LSM6DSL_X_Get_Event_Status+0xb8>
 80051e4:	f89d 2006 	ldrb.w	r2, [sp, #6]
 80051e8:	06d0      	lsls	r0, r2, #27
 80051ea:	d507      	bpl.n	80051fc <LSM6DSL_X_Get_Event_Status+0xc8>
    if((Wake_Up_Src & LSM6DSL_ACC_GYRO_FF_EV_STATUS_MASK))
 80051ec:	f89d 2001 	ldrb.w	r2, [sp, #1]
 80051f0:	0691      	lsls	r1, r2, #26
 80051f2:	d503      	bpl.n	80051fc <LSM6DSL_X_Get_Event_Status+0xc8>
      status->FreeFallStatus = 1;  
 80051f4:	782a      	ldrb	r2, [r5, #0]
 80051f6:	f042 0201 	orr.w	r2, r2, #1
 80051fa:	702a      	strb	r2, [r5, #0]
  if((Md1_Cfg & LSM6DSL_ACC_GYRO_INT1_WU_MASK) || (Md2_Cfg & LSM6DSL_ACC_GYRO_INT2_WU_MASK))
 80051fc:	069a      	lsls	r2, r3, #26
 80051fe:	d403      	bmi.n	8005208 <LSM6DSL_X_Get_Event_Status+0xd4>
 8005200:	f89d 2006 	ldrb.w	r2, [sp, #6]
 8005204:	0694      	lsls	r4, r2, #26
 8005206:	d507      	bpl.n	8005218 <LSM6DSL_X_Get_Event_Status+0xe4>
    if((Wake_Up_Src & LSM6DSL_ACC_GYRO_WU_EV_STATUS_MASK))
 8005208:	f89d 2001 	ldrb.w	r2, [sp, #1]
 800520c:	0710      	lsls	r0, r2, #28
 800520e:	d503      	bpl.n	8005218 <LSM6DSL_X_Get_Event_Status+0xe4>
      status->WakeUpStatus = 1;  
 8005210:	782a      	ldrb	r2, [r5, #0]
 8005212:	f042 0208 	orr.w	r2, r2, #8
 8005216:	702a      	strb	r2, [r5, #0]
  if((Md1_Cfg & LSM6DSL_ACC_GYRO_INT1_SINGLE_TAP_MASK) || (Md2_Cfg & LSM6DSL_ACC_GYRO_INT2_SINGLE_TAP_MASK))
 8005218:	0659      	lsls	r1, r3, #25
 800521a:	d403      	bmi.n	8005224 <LSM6DSL_X_Get_Event_Status+0xf0>
 800521c:	f89d 2006 	ldrb.w	r2, [sp, #6]
 8005220:	0652      	lsls	r2, r2, #25
 8005222:	d507      	bpl.n	8005234 <LSM6DSL_X_Get_Event_Status+0x100>
    if((Tap_Src & LSM6DSL_ACC_GYRO_SINGLE_TAP_EV_STATUS_MASK))
 8005224:	f89d 2002 	ldrb.w	r2, [sp, #2]
 8005228:	0694      	lsls	r4, r2, #26
 800522a:	d503      	bpl.n	8005234 <LSM6DSL_X_Get_Event_Status+0x100>
      status->TapStatus = 1;  
 800522c:	782a      	ldrb	r2, [r5, #0]
 800522e:	f042 0202 	orr.w	r2, r2, #2
 8005232:	702a      	strb	r2, [r5, #0]
  if((Md1_Cfg & LSM6DSL_ACC_GYRO_INT1_TAP_MASK) || (Md2_Cfg & LSM6DSL_ACC_GYRO_INT2_TAP_MASK))
 8005234:	0718      	lsls	r0, r3, #28
 8005236:	d403      	bmi.n	8005240 <LSM6DSL_X_Get_Event_Status+0x10c>
 8005238:	f89d 2006 	ldrb.w	r2, [sp, #6]
 800523c:	0711      	lsls	r1, r2, #28
 800523e:	d507      	bpl.n	8005250 <LSM6DSL_X_Get_Event_Status+0x11c>
    if((Tap_Src & LSM6DSL_ACC_GYRO_DOUBLE_TAP_EV_STATUS_MASK))
 8005240:	f89d 2002 	ldrb.w	r2, [sp, #2]
 8005244:	06d2      	lsls	r2, r2, #27
 8005246:	d503      	bpl.n	8005250 <LSM6DSL_X_Get_Event_Status+0x11c>
      status->DoubleTapStatus = 1;  
 8005248:	782a      	ldrb	r2, [r5, #0]
 800524a:	f042 0204 	orr.w	r2, r2, #4
 800524e:	702a      	strb	r2, [r5, #0]
  if((Md1_Cfg & LSM6DSL_ACC_GYRO_INT1_6D_MASK) || (Md2_Cfg & LSM6DSL_ACC_GYRO_INT2_6D_MASK))
 8005250:	075c      	lsls	r4, r3, #29
 8005252:	d403      	bmi.n	800525c <LSM6DSL_X_Get_Event_Status+0x128>
 8005254:	f89d 2006 	ldrb.w	r2, [sp, #6]
 8005258:	0750      	lsls	r0, r2, #29
 800525a:	d507      	bpl.n	800526c <LSM6DSL_X_Get_Event_Status+0x138>
    if((D6D_Src & LSM6DSL_ACC_GYRO_D6D_EV_STATUS_MASK))
 800525c:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8005260:	0651      	lsls	r1, r2, #25
 8005262:	d503      	bpl.n	800526c <LSM6DSL_X_Get_Event_Status+0x138>
      status->D6DOrientationStatus = 1;  
 8005264:	782a      	ldrb	r2, [r5, #0]
 8005266:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800526a:	702a      	strb	r2, [r5, #0]
  if((Int1_Ctrl & LSM6DSL_ACC_GYRO_INT1_PEDO_MASK))
 800526c:	f99d 2007 	ldrsb.w	r2, [sp, #7]
 8005270:	2a00      	cmp	r2, #0
 8005272:	db14      	blt.n	800529e <LSM6DSL_X_Get_Event_Status+0x16a>
  if((Md1_Cfg & LSM6DSL_ACC_GYRO_INT1_TILT_MASK) || (Md2_Cfg & LSM6DSL_ACC_GYRO_INT2_TILT_MASK))
 8005274:	079b      	lsls	r3, r3, #30
 8005276:	d404      	bmi.n	8005282 <LSM6DSL_X_Get_Event_Status+0x14e>
 8005278:	f89d 0006 	ldrb.w	r0, [sp, #6]
 800527c:	f010 0002 	ands.w	r0, r0, #2
 8005280:	d00b      	beq.n	800529a <LSM6DSL_X_Get_Event_Status+0x166>
    if((Func_Src & LSM6DSL_ACC_GYRO_TILT_EV_STATUS_MASK))
 8005282:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8005286:	f010 0020 	ands.w	r0, r0, #32
 800528a:	d006      	beq.n	800529a <LSM6DSL_X_Get_Event_Status+0x166>
      status->TiltStatus = 1;  
 800528c:	782b      	ldrb	r3, [r5, #0]
 800528e:	f043 0320 	orr.w	r3, r3, #32
 8005292:	702b      	strb	r3, [r5, #0]
  return COMPONENT_OK;
 8005294:	2000      	movs	r0, #0
 8005296:	e000      	b.n	800529a <LSM6DSL_X_Get_Event_Status+0x166>
    return COMPONENT_ERROR;
 8005298:	2001      	movs	r0, #1
}
 800529a:	b003      	add	sp, #12
 800529c:	bd30      	pop	{r4, r5, pc}
    if((Func_Src & LSM6DSL_ACC_GYRO_PEDO_EV_STATUS_MASK))
 800529e:	f89d 2004 	ldrb.w	r2, [sp, #4]
 80052a2:	06d2      	lsls	r2, r2, #27
 80052a4:	d5e6      	bpl.n	8005274 <LSM6DSL_X_Get_Event_Status+0x140>
      status->StepStatus = 1;  
 80052a6:	782a      	ldrb	r2, [r5, #0]
 80052a8:	f042 0210 	orr.w	r2, r2, #16
 80052ac:	702a      	strb	r2, [r5, #0]
 80052ae:	e7e1      	b.n	8005274 <LSM6DSL_X_Get_Event_Status+0x140>

080052b0 <LSM6DSL_G_Read_Reg>:
{
 80052b0:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_ReadReg( (void *)handle, reg, data, 1 ) == MEMS_ERROR )
 80052b2:	2301      	movs	r3, #1
 80052b4:	f7fe fc92 	bl	8003bdc <LSM6DSL_ACC_GYRO_ReadReg>
}
 80052b8:	fab0 f080 	clz	r0, r0
 80052bc:	0940      	lsrs	r0, r0, #5
 80052be:	bd08      	pop	{r3, pc}

080052c0 <LSM6DSL_X_Get_6D_Orientation_ZH>:
{
 80052c0:	b510      	push	{r4, lr}
 80052c2:	b082      	sub	sp, #8
 80052c4:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_DSD_ZH( (void *)handle, &zh_raw ) == MEMS_ERROR )
 80052c6:	f10d 0107 	add.w	r1, sp, #7
 80052ca:	f7ff f89f 	bl	800440c <LSM6DSL_ACC_GYRO_R_DSD_ZH>
 80052ce:	b148      	cbz	r0, 80052e4 <LSM6DSL_X_Get_6D_Orientation_ZH+0x24>
  switch( zh_raw )
 80052d0:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80052d4:	b148      	cbz	r0, 80052ea <LSM6DSL_X_Get_6D_Orientation_ZH+0x2a>
 80052d6:	2820      	cmp	r0, #32
 80052d8:	d104      	bne.n	80052e4 <LSM6DSL_X_Get_6D_Orientation_ZH+0x24>
      *zh = 1;
 80052da:	2301      	movs	r3, #1
  return COMPONENT_OK;
 80052dc:	2000      	movs	r0, #0
      *zh = 1;
 80052de:	7023      	strb	r3, [r4, #0]
}
 80052e0:	b002      	add	sp, #8
 80052e2:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 80052e4:	2001      	movs	r0, #1
}
 80052e6:	b002      	add	sp, #8
 80052e8:	bd10      	pop	{r4, pc}
      *zh = 0;
 80052ea:	7020      	strb	r0, [r4, #0]
}
 80052ec:	b002      	add	sp, #8
 80052ee:	bd10      	pop	{r4, pc}

080052f0 <LSM6DSL_X_Get_6D_Orientation_ZL>:
{
 80052f0:	b510      	push	{r4, lr}
 80052f2:	b082      	sub	sp, #8
 80052f4:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_DSD_ZL( (void *)handle, &zl_raw ) == MEMS_ERROR )
 80052f6:	f10d 0107 	add.w	r1, sp, #7
 80052fa:	f7ff f877 	bl	80043ec <LSM6DSL_ACC_GYRO_R_DSD_ZL>
 80052fe:	b148      	cbz	r0, 8005314 <LSM6DSL_X_Get_6D_Orientation_ZL+0x24>
  switch( zl_raw )
 8005300:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8005304:	b148      	cbz	r0, 800531a <LSM6DSL_X_Get_6D_Orientation_ZL+0x2a>
 8005306:	2810      	cmp	r0, #16
 8005308:	d104      	bne.n	8005314 <LSM6DSL_X_Get_6D_Orientation_ZL+0x24>
      *zl = 1;
 800530a:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800530c:	2000      	movs	r0, #0
      *zl = 1;
 800530e:	7023      	strb	r3, [r4, #0]
}
 8005310:	b002      	add	sp, #8
 8005312:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 8005314:	2001      	movs	r0, #1
}
 8005316:	b002      	add	sp, #8
 8005318:	bd10      	pop	{r4, pc}
      *zl = 0;
 800531a:	7020      	strb	r0, [r4, #0]
}
 800531c:	b002      	add	sp, #8
 800531e:	bd10      	pop	{r4, pc}

08005320 <LSM6DSL_X_Get_6D_Orientation_YH>:
{
 8005320:	b510      	push	{r4, lr}
 8005322:	b082      	sub	sp, #8
 8005324:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_DSD_YH( (void *)handle, &yh_raw ) == MEMS_ERROR )
 8005326:	f10d 0107 	add.w	r1, sp, #7
 800532a:	f7ff f84f 	bl	80043cc <LSM6DSL_ACC_GYRO_R_DSD_YH>
 800532e:	b148      	cbz	r0, 8005344 <LSM6DSL_X_Get_6D_Orientation_YH+0x24>
  switch( yh_raw )
 8005330:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8005334:	b148      	cbz	r0, 800534a <LSM6DSL_X_Get_6D_Orientation_YH+0x2a>
 8005336:	2808      	cmp	r0, #8
 8005338:	d104      	bne.n	8005344 <LSM6DSL_X_Get_6D_Orientation_YH+0x24>
      *yh = 1;
 800533a:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800533c:	2000      	movs	r0, #0
      *yh = 1;
 800533e:	7023      	strb	r3, [r4, #0]
}
 8005340:	b002      	add	sp, #8
 8005342:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 8005344:	2001      	movs	r0, #1
}
 8005346:	b002      	add	sp, #8
 8005348:	bd10      	pop	{r4, pc}
      *yh = 0;
 800534a:	7020      	strb	r0, [r4, #0]
}
 800534c:	b002      	add	sp, #8
 800534e:	bd10      	pop	{r4, pc}

08005350 <LSM6DSL_X_Get_6D_Orientation_YL>:
{
 8005350:	b510      	push	{r4, lr}
 8005352:	b082      	sub	sp, #8
 8005354:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_DSD_YL( (void *)handle, &yl_raw ) == MEMS_ERROR )
 8005356:	f10d 0107 	add.w	r1, sp, #7
 800535a:	f7ff f827 	bl	80043ac <LSM6DSL_ACC_GYRO_R_DSD_YL>
 800535e:	b148      	cbz	r0, 8005374 <LSM6DSL_X_Get_6D_Orientation_YL+0x24>
  switch( yl_raw )
 8005360:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8005364:	b148      	cbz	r0, 800537a <LSM6DSL_X_Get_6D_Orientation_YL+0x2a>
 8005366:	2804      	cmp	r0, #4
 8005368:	d104      	bne.n	8005374 <LSM6DSL_X_Get_6D_Orientation_YL+0x24>
      *yl = 1;
 800536a:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800536c:	2000      	movs	r0, #0
      *yl = 1;
 800536e:	7023      	strb	r3, [r4, #0]
}
 8005370:	b002      	add	sp, #8
 8005372:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 8005374:	2001      	movs	r0, #1
}
 8005376:	b002      	add	sp, #8
 8005378:	bd10      	pop	{r4, pc}
      *yl = 0;
 800537a:	7020      	strb	r0, [r4, #0]
}
 800537c:	b002      	add	sp, #8
 800537e:	bd10      	pop	{r4, pc}

08005380 <LSM6DSL_X_Get_6D_Orientation_XH>:
{
 8005380:	b510      	push	{r4, lr}
 8005382:	b082      	sub	sp, #8
 8005384:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_DSD_XH( (void *)handle, &xh_raw ) == MEMS_ERROR )
 8005386:	f10d 0107 	add.w	r1, sp, #7
 800538a:	f7fe ffff 	bl	800438c <LSM6DSL_ACC_GYRO_R_DSD_XH>
 800538e:	b148      	cbz	r0, 80053a4 <LSM6DSL_X_Get_6D_Orientation_XH+0x24>
  switch( xh_raw )
 8005390:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8005394:	b148      	cbz	r0, 80053aa <LSM6DSL_X_Get_6D_Orientation_XH+0x2a>
 8005396:	2802      	cmp	r0, #2
 8005398:	d104      	bne.n	80053a4 <LSM6DSL_X_Get_6D_Orientation_XH+0x24>
      *xh = 1;
 800539a:	2301      	movs	r3, #1
  return COMPONENT_OK;
 800539c:	2000      	movs	r0, #0
      *xh = 1;
 800539e:	7023      	strb	r3, [r4, #0]
}
 80053a0:	b002      	add	sp, #8
 80053a2:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 80053a4:	2001      	movs	r0, #1
}
 80053a6:	b002      	add	sp, #8
 80053a8:	bd10      	pop	{r4, pc}
      *xh = 0;
 80053aa:	7020      	strb	r0, [r4, #0]
}
 80053ac:	b002      	add	sp, #8
 80053ae:	bd10      	pop	{r4, pc}

080053b0 <LSM6DSL_X_Get_6D_Orientation_XL>:
{
 80053b0:	b510      	push	{r4, lr}
 80053b2:	b082      	sub	sp, #8
 80053b4:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_DSD_XL( (void *)handle, &xl_raw ) == MEMS_ERROR )
 80053b6:	f10d 0107 	add.w	r1, sp, #7
 80053ba:	f7fe ffd7 	bl	800436c <LSM6DSL_ACC_GYRO_R_DSD_XL>
 80053be:	b140      	cbz	r0, 80053d2 <LSM6DSL_X_Get_6D_Orientation_XL+0x22>
  switch( xl_raw )
 80053c0:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80053c4:	b140      	cbz	r0, 80053d8 <LSM6DSL_X_Get_6D_Orientation_XL+0x28>
 80053c6:	2801      	cmp	r0, #1
 80053c8:	d103      	bne.n	80053d2 <LSM6DSL_X_Get_6D_Orientation_XL+0x22>
      *xl = 1;
 80053ca:	7020      	strb	r0, [r4, #0]
  return COMPONENT_OK;
 80053cc:	2000      	movs	r0, #0
}
 80053ce:	b002      	add	sp, #8
 80053d0:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 80053d2:	2001      	movs	r0, #1
}
 80053d4:	b002      	add	sp, #8
 80053d6:	bd10      	pop	{r4, pc}
      *xl = 0;
 80053d8:	7020      	strb	r0, [r4, #0]
}
 80053da:	b002      	add	sp, #8
 80053dc:	bd10      	pop	{r4, pc}
 80053de:	bf00      	nop

080053e0 <LSM6DSL_X_Get_6D_Orientation_Status>:
{
 80053e0:	b510      	push	{r4, lr}
 80053e2:	b082      	sub	sp, #8
 80053e4:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_D6D_EV_STATUS( (void *)handle, &status_raw ) == MEMS_ERROR )
 80053e6:	f10d 0107 	add.w	r1, sp, #7
 80053ea:	f7ff f81f 	bl	800442c <LSM6DSL_ACC_GYRO_R_D6D_EV_STATUS>
 80053ee:	b148      	cbz	r0, 8005404 <LSM6DSL_X_Get_6D_Orientation_Status+0x24>
  switch( status_raw )
 80053f0:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80053f4:	b148      	cbz	r0, 800540a <LSM6DSL_X_Get_6D_Orientation_Status+0x2a>
 80053f6:	2840      	cmp	r0, #64	; 0x40
 80053f8:	d104      	bne.n	8005404 <LSM6DSL_X_Get_6D_Orientation_Status+0x24>
      *status = 1;
 80053fa:	2301      	movs	r3, #1
  return COMPONENT_OK;
 80053fc:	2000      	movs	r0, #0
      *status = 1;
 80053fe:	7023      	strb	r3, [r4, #0]
}
 8005400:	b002      	add	sp, #8
 8005402:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 8005404:	2001      	movs	r0, #1
}
 8005406:	b002      	add	sp, #8
 8005408:	bd10      	pop	{r4, pc}
      *status = 0;
 800540a:	7020      	strb	r0, [r4, #0]
}
 800540c:	b002      	add	sp, #8
 800540e:	bd10      	pop	{r4, pc}

08005410 <LSM6DSL_X_Set_FS_Value>:
           : ( fullScale <= 4.0f ) ? LSM6DSL_ACC_GYRO_FS_XL_4g
 8005410:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 8005414:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005418:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 800541c:	b508      	push	{r3, lr}
           : ( fullScale <= 4.0f ) ? LSM6DSL_ACC_GYRO_FS_XL_4g
 800541e:	d90d      	bls.n	800543c <LSM6DSL_X_Set_FS_Value+0x2c>
 8005420:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
 8005424:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005428:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800542c:	d80d      	bhi.n	800544a <LSM6DSL_X_Set_FS_Value+0x3a>
 800542e:	2108      	movs	r1, #8
  if ( LSM6DSL_ACC_GYRO_W_FS_XL( (void *)handle, new_fs ) == MEMS_ERROR )
 8005430:	f7fe fc10 	bl	8003c54 <LSM6DSL_ACC_GYRO_W_FS_XL>
}
 8005434:	fab0 f080 	clz	r0, r0
 8005438:	0940      	lsrs	r0, r0, #5
 800543a:	bd08      	pop	{r3, pc}
           : ( fullScale <= 4.0f ) ? LSM6DSL_ACC_GYRO_FS_XL_4g
 800543c:	2100      	movs	r1, #0
  if ( LSM6DSL_ACC_GYRO_W_FS_XL( (void *)handle, new_fs ) == MEMS_ERROR )
 800543e:	f7fe fc09 	bl	8003c54 <LSM6DSL_ACC_GYRO_W_FS_XL>
}
 8005442:	fab0 f080 	clz	r0, r0
 8005446:	0940      	lsrs	r0, r0, #5
 8005448:	bd08      	pop	{r3, pc}
           : ( fullScale <= 4.0f ) ? LSM6DSL_ACC_GYRO_FS_XL_4g
 800544a:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
 800544e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005452:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005456:	bf94      	ite	ls
 8005458:	210c      	movls	r1, #12
 800545a:	2104      	movhi	r1, #4
  if ( LSM6DSL_ACC_GYRO_W_FS_XL( (void *)handle, new_fs ) == MEMS_ERROR )
 800545c:	f7fe fbfa 	bl	8003c54 <LSM6DSL_ACC_GYRO_W_FS_XL>
}
 8005460:	fab0 f080 	clz	r0, r0
 8005464:	0940      	lsrs	r0, r0, #5
 8005466:	bd08      	pop	{r3, pc}

08005468 <LSM6DSL_X_Set_FS>:
  switch( fullScale )
 8005468:	2902      	cmp	r1, #2
 800546a:	d00c      	beq.n	8005486 <LSM6DSL_X_Set_FS+0x1e>
 800546c:	2904      	cmp	r1, #4
 800546e:	d002      	beq.n	8005476 <LSM6DSL_X_Set_FS+0xe>
 8005470:	b111      	cbz	r1, 8005478 <LSM6DSL_X_Set_FS+0x10>
      return COMPONENT_ERROR;
 8005472:	2001      	movs	r0, #1
 8005474:	4770      	bx	lr
      new_fs = LSM6DSL_ACC_GYRO_FS_XL_8g;
 8005476:	210c      	movs	r1, #12
{
 8005478:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_W_FS_XL( (void *)handle, new_fs ) == MEMS_ERROR )
 800547a:	f7fe fbeb 	bl	8003c54 <LSM6DSL_ACC_GYRO_W_FS_XL>
      return COMPONENT_ERROR;
 800547e:	fab0 f080 	clz	r0, r0
 8005482:	0940      	lsrs	r0, r0, #5
 8005484:	bd08      	pop	{r3, pc}
      new_fs = LSM6DSL_ACC_GYRO_FS_XL_4g;
 8005486:	2108      	movs	r1, #8
 8005488:	e7f6      	b.n	8005478 <LSM6DSL_X_Set_FS+0x10>
 800548a:	bf00      	nop

0800548c <LSM6DSL_X_Set_Tap_Duration_Time>:
{
 800548c:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_W_DUR( (void *)handle, time ) == MEMS_ERROR )
 800548e:	f7ff f9c9 	bl	8004824 <LSM6DSL_ACC_GYRO_W_DUR>
}
 8005492:	fab0 f080 	clz	r0, r0
 8005496:	0940      	lsrs	r0, r0, #5
 8005498:	bd08      	pop	{r3, pc}
 800549a:	bf00      	nop

0800549c <LSM6DSL_X_Set_Tap_Quiet_Time>:
{
 800549c:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_W_QUIET_Duration( (void *)handle, time ) == MEMS_ERROR )
 800549e:	f7ff f99d 	bl	80047dc <LSM6DSL_ACC_GYRO_W_QUIET_Duration>
}
 80054a2:	fab0 f080 	clz	r0, r0
 80054a6:	0940      	lsrs	r0, r0, #5
 80054a8:	bd08      	pop	{r3, pc}
 80054aa:	bf00      	nop

080054ac <LSM6DSL_X_Set_Tap_Shock_Time>:
{
 80054ac:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_W_SHOCK_Duration( (void *)handle, time ) == MEMS_ERROR )
 80054ae:	f7ff f971 	bl	8004794 <LSM6DSL_ACC_GYRO_W_SHOCK_Duration>
}
 80054b2:	fab0 f080 	clz	r0, r0
 80054b6:	0940      	lsrs	r0, r0, #5
 80054b8:	bd08      	pop	{r3, pc}
 80054ba:	bf00      	nop

080054bc <LSM6DSL_X_Set_Tap_Threshold>:
{
 80054bc:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_W_TAP_THS( (void *)handle, thr ) == MEMS_ERROR )
 80054be:	f7ff f923 	bl	8004708 <LSM6DSL_ACC_GYRO_W_TAP_THS>
}
 80054c2:	fab0 f080 	clz	r0, r0
 80054c6:	0940      	lsrs	r0, r0, #5
 80054c8:	bd08      	pop	{r3, pc}
 80054ca:	bf00      	nop

080054cc <LSM6DSL_X_Get_Double_Tap_Detection_Status>:
{
 80054cc:	b510      	push	{r4, lr}
 80054ce:	b082      	sub	sp, #8
 80054d0:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_DOUBLE_TAP_EV_STATUS( (void *)handle, &tap_status ) == MEMS_ERROR )
 80054d2:	f10d 0107 	add.w	r1, sp, #7
 80054d6:	f7fe ff29 	bl	800432c <LSM6DSL_ACC_GYRO_R_DOUBLE_TAP_EV_STATUS>
 80054da:	b148      	cbz	r0, 80054f0 <LSM6DSL_X_Get_Double_Tap_Detection_Status+0x24>
  switch( tap_status )
 80054dc:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80054e0:	b148      	cbz	r0, 80054f6 <LSM6DSL_X_Get_Double_Tap_Detection_Status+0x2a>
 80054e2:	2810      	cmp	r0, #16
 80054e4:	d104      	bne.n	80054f0 <LSM6DSL_X_Get_Double_Tap_Detection_Status+0x24>
      *status = 1;
 80054e6:	2301      	movs	r3, #1
  return COMPONENT_OK;
 80054e8:	2000      	movs	r0, #0
      *status = 1;
 80054ea:	7023      	strb	r3, [r4, #0]
}
 80054ec:	b002      	add	sp, #8
 80054ee:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 80054f0:	2001      	movs	r0, #1
}
 80054f2:	b002      	add	sp, #8
 80054f4:	bd10      	pop	{r4, pc}
      *status = 0;
 80054f6:	7020      	strb	r0, [r4, #0]
}
 80054f8:	b002      	add	sp, #8
 80054fa:	bd10      	pop	{r4, pc}

080054fc <LSM6DSL_X_Get_Single_Tap_Detection_Status>:
{
 80054fc:	b510      	push	{r4, lr}
 80054fe:	b082      	sub	sp, #8
 8005500:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_SINGLE_TAP_EV_STATUS( (void *)handle, &tap_status ) == MEMS_ERROR )
 8005502:	f10d 0107 	add.w	r1, sp, #7
 8005506:	f7fe ff21 	bl	800434c <LSM6DSL_ACC_GYRO_R_SINGLE_TAP_EV_STATUS>
 800550a:	b148      	cbz	r0, 8005520 <LSM6DSL_X_Get_Single_Tap_Detection_Status+0x24>
  switch( tap_status )
 800550c:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8005510:	b148      	cbz	r0, 8005526 <LSM6DSL_X_Get_Single_Tap_Detection_Status+0x2a>
 8005512:	2820      	cmp	r0, #32
 8005514:	d104      	bne.n	8005520 <LSM6DSL_X_Get_Single_Tap_Detection_Status+0x24>
      *status = 1;
 8005516:	2301      	movs	r3, #1
  return COMPONENT_OK;
 8005518:	2000      	movs	r0, #0
      *status = 1;
 800551a:	7023      	strb	r3, [r4, #0]
}
 800551c:	b002      	add	sp, #8
 800551e:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 8005520:	2001      	movs	r0, #1
}
 8005522:	b002      	add	sp, #8
 8005524:	bd10      	pop	{r4, pc}
      *status = 0;
 8005526:	7020      	strb	r0, [r4, #0]
}
 8005528:	b002      	add	sp, #8
 800552a:	bd10      	pop	{r4, pc}

0800552c <LSM6DSL_X_Set_Wake_Up_Threshold>:
{
 800552c:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_W_WK_THS( (void *)handle, thr ) == MEMS_ERROR )
 800552e:	f7ff f99b 	bl	8004868 <LSM6DSL_ACC_GYRO_W_WK_THS>
}
 8005532:	fab0 f080 	clz	r0, r0
 8005536:	0940      	lsrs	r0, r0, #5
 8005538:	bd08      	pop	{r3, pc}
 800553a:	bf00      	nop

0800553c <LSM6DSL_X_Get_Wake_Up_Detection_Status>:
{
 800553c:	b510      	push	{r4, lr}
 800553e:	b082      	sub	sp, #8
 8005540:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_WU_EV_STATUS( (void *)handle, &wake_up_status ) == MEMS_ERROR )
 8005542:	f10d 0107 	add.w	r1, sp, #7
 8005546:	f7fe fed1 	bl	80042ec <LSM6DSL_ACC_GYRO_R_WU_EV_STATUS>
 800554a:	b148      	cbz	r0, 8005560 <LSM6DSL_X_Get_Wake_Up_Detection_Status+0x24>
  switch( wake_up_status )
 800554c:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8005550:	b148      	cbz	r0, 8005566 <LSM6DSL_X_Get_Wake_Up_Detection_Status+0x2a>
 8005552:	2808      	cmp	r0, #8
 8005554:	d104      	bne.n	8005560 <LSM6DSL_X_Get_Wake_Up_Detection_Status+0x24>
      *status = 1;
 8005556:	2301      	movs	r3, #1
  return COMPONENT_OK;
 8005558:	2000      	movs	r0, #0
      *status = 1;
 800555a:	7023      	strb	r3, [r4, #0]
}
 800555c:	b002      	add	sp, #8
 800555e:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 8005560:	2001      	movs	r0, #1
}
 8005562:	b002      	add	sp, #8
 8005564:	bd10      	pop	{r4, pc}
      *status = 0;
 8005566:	7020      	strb	r0, [r4, #0]
}
 8005568:	b002      	add	sp, #8
 800556a:	bd10      	pop	{r4, pc}

0800556c <LSM6DSL_X_Get_Tilt_Detection_Status>:
{
 800556c:	b510      	push	{r4, lr}
 800556e:	b082      	sub	sp, #8
 8005570:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_TILT_EV_STATUS( (void *)handle, &tilt_status ) == MEMS_ERROR )
 8005572:	f10d 0107 	add.w	r1, sp, #7
 8005576:	f7ff f80d 	bl	8004594 <LSM6DSL_ACC_GYRO_R_TILT_EV_STATUS>
 800557a:	b148      	cbz	r0, 8005590 <LSM6DSL_X_Get_Tilt_Detection_Status+0x24>
  switch( tilt_status )
 800557c:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8005580:	b148      	cbz	r0, 8005596 <LSM6DSL_X_Get_Tilt_Detection_Status+0x2a>
 8005582:	2820      	cmp	r0, #32
 8005584:	d104      	bne.n	8005590 <LSM6DSL_X_Get_Tilt_Detection_Status+0x24>
      *status = 1;
 8005586:	2301      	movs	r3, #1
  return COMPONENT_OK;
 8005588:	2000      	movs	r0, #0
      *status = 1;
 800558a:	7023      	strb	r3, [r4, #0]
}
 800558c:	b002      	add	sp, #8
 800558e:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 8005590:	2001      	movs	r0, #1
}
 8005592:	b002      	add	sp, #8
 8005594:	bd10      	pop	{r4, pc}
      *status = 0;
 8005596:	7020      	strb	r0, [r4, #0]
}
 8005598:	b002      	add	sp, #8
 800559a:	bd10      	pop	{r4, pc}

0800559c <LSM6DSL_X_Set_Pedometer_Threshold>:
{
 800559c:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_W_PedoThreshold( (void *)handle, thr ) == MEMS_ERROR )
 800559e:	f7ff fc35 	bl	8004e0c <LSM6DSL_ACC_GYRO_W_PedoThreshold>
}
 80055a2:	fab0 f080 	clz	r0, r0
 80055a6:	0940      	lsrs	r0, r0, #5
 80055a8:	bd08      	pop	{r3, pc}
 80055aa:	bf00      	nop

080055ac <LSM6DSL_X_Disable_Step_Counter_Reset>:
{
 80055ac:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_W_PedoStepReset( (void *)handle, LSM6DSL_ACC_GYRO_PEDO_RST_STEP_DISABLED ) == MEMS_ERROR )
 80055ae:	2100      	movs	r1, #0
 80055b0:	f7fe fe14 	bl	80041dc <LSM6DSL_ACC_GYRO_W_PedoStepReset>
}
 80055b4:	fab0 f080 	clz	r0, r0
 80055b8:	0940      	lsrs	r0, r0, #5
 80055ba:	bd08      	pop	{r3, pc}

080055bc <LSM6DSL_X_Enable_Step_Counter_Reset>:
{
 80055bc:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_W_PedoStepReset( (void *)handle, LSM6DSL_ACC_GYRO_PEDO_RST_STEP_ENABLED ) == MEMS_ERROR )
 80055be:	2102      	movs	r1, #2
 80055c0:	f7fe fe0c 	bl	80041dc <LSM6DSL_ACC_GYRO_W_PedoStepReset>
}
 80055c4:	fab0 f080 	clz	r0, r0
 80055c8:	0940      	lsrs	r0, r0, #5
 80055ca:	bd08      	pop	{r3, pc}

080055cc <LSM6DSL_X_Get_Step_Count>:
{
 80055cc:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_Get_GetStepCounter( (void *)handle, ( uint8_t* )step_count ) == MEMS_ERROR )
 80055ce:	f7ff fc07 	bl	8004de0 <LSM6DSL_ACC_GYRO_Get_GetStepCounter>
}
 80055d2:	fab0 f080 	clz	r0, r0
 80055d6:	0940      	lsrs	r0, r0, #5
 80055d8:	bd08      	pop	{r3, pc}
 80055da:	bf00      	nop

080055dc <LSM6DSL_X_Get_Pedometer_Status>:
{
 80055dc:	b510      	push	{r4, lr}
 80055de:	b082      	sub	sp, #8
 80055e0:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_PEDO_EV_STATUS( (void *)handle, &pedometer_status ) == MEMS_ERROR )
 80055e2:	f10d 0107 	add.w	r1, sp, #7
 80055e6:	f7fe ffc5 	bl	8004574 <LSM6DSL_ACC_GYRO_R_PEDO_EV_STATUS>
 80055ea:	b148      	cbz	r0, 8005600 <LSM6DSL_X_Get_Pedometer_Status+0x24>
  switch( pedometer_status )
 80055ec:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80055f0:	b148      	cbz	r0, 8005606 <LSM6DSL_X_Get_Pedometer_Status+0x2a>
 80055f2:	2810      	cmp	r0, #16
 80055f4:	d104      	bne.n	8005600 <LSM6DSL_X_Get_Pedometer_Status+0x24>
      *status = 1;
 80055f6:	2301      	movs	r3, #1
  return COMPONENT_OK;
 80055f8:	2000      	movs	r0, #0
      *status = 1;
 80055fa:	7023      	strb	r3, [r4, #0]
}
 80055fc:	b002      	add	sp, #8
 80055fe:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 8005600:	2001      	movs	r0, #1
}
 8005602:	b002      	add	sp, #8
 8005604:	bd10      	pop	{r4, pc}
      *status = 0;
 8005606:	7020      	strb	r0, [r4, #0]
}
 8005608:	b002      	add	sp, #8
 800560a:	bd10      	pop	{r4, pc}

0800560c <LSM6DSL_X_Set_Free_Fall_Threshold>:
{
 800560c:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_W_FF_THS( (void *)handle, (LSM6DSL_ACC_GYRO_FF_THS_t)thr ) == MEMS_ERROR )
 800560e:	f7ff f9db 	bl	80049c8 <LSM6DSL_ACC_GYRO_W_FF_THS>
}
 8005612:	fab0 f080 	clz	r0, r0
 8005616:	0940      	lsrs	r0, r0, #5
 8005618:	bd08      	pop	{r3, pc}
 800561a:	bf00      	nop

0800561c <LSM6DSL_X_Get_Free_Fall_Detection_Status>:
{
 800561c:	b510      	push	{r4, lr}
 800561e:	b082      	sub	sp, #8
 8005620:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_FF_EV_STATUS( (void *)handle, &free_fall_status ) == MEMS_ERROR )
 8005622:	f10d 0107 	add.w	r1, sp, #7
 8005626:	f7fe fe71 	bl	800430c <LSM6DSL_ACC_GYRO_R_FF_EV_STATUS>
 800562a:	b148      	cbz	r0, 8005640 <LSM6DSL_X_Get_Free_Fall_Detection_Status+0x24>
  switch( free_fall_status )
 800562c:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8005630:	b148      	cbz	r0, 8005646 <LSM6DSL_X_Get_Free_Fall_Detection_Status+0x2a>
 8005632:	2820      	cmp	r0, #32
 8005634:	d104      	bne.n	8005640 <LSM6DSL_X_Get_Free_Fall_Detection_Status+0x24>
      *status = 1;
 8005636:	2301      	movs	r3, #1
  return COMPONENT_OK;
 8005638:	2000      	movs	r0, #0
      *status = 1;
 800563a:	7023      	strb	r3, [r4, #0]
}
 800563c:	b002      	add	sp, #8
 800563e:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 8005640:	2001      	movs	r0, #1
}
 8005642:	b002      	add	sp, #8
 8005644:	bd10      	pop	{r4, pc}
      *status = 0;
 8005646:	7020      	strb	r0, [r4, #0]
}
 8005648:	b002      	add	sp, #8
 800564a:	bd10      	pop	{r4, pc}

0800564c <LSM6DSL_G_Get_FS>:
{
 800564c:	b530      	push	{r4, r5, lr}
 800564e:	b083      	sub	sp, #12
 8005650:	460d      	mov	r5, r1
  if ( LSM6DSL_ACC_GYRO_R_FS_125( (void *)handle, &fs_125 ) == MEMS_ERROR )
 8005652:	f10d 0107 	add.w	r1, sp, #7
{
 8005656:	4604      	mov	r4, r0
  if ( LSM6DSL_ACC_GYRO_R_FS_125( (void *)handle, &fs_125 ) == MEMS_ERROR )
 8005658:	f7fe fc26 	bl	8003ea8 <LSM6DSL_ACC_GYRO_R_FS_125>
 800565c:	b910      	cbnz	r0, 8005664 <LSM6DSL_G_Get_FS+0x18>
        return COMPONENT_ERROR;
 800565e:	2001      	movs	r0, #1
}
 8005660:	b003      	add	sp, #12
 8005662:	bd30      	pop	{r4, r5, pc}
  if ( LSM6DSL_ACC_GYRO_R_FS_G( (void *)handle, &fs_low_level ) == MEMS_ERROR )
 8005664:	4620      	mov	r0, r4
 8005666:	f10d 0106 	add.w	r1, sp, #6
 800566a:	f7fe fb99 	bl	8003da0 <LSM6DSL_ACC_GYRO_R_FS_G>
 800566e:	2800      	cmp	r0, #0
 8005670:	d0f5      	beq.n	800565e <LSM6DSL_G_Get_FS+0x12>
  if ( fs_125 == LSM6DSL_ACC_GYRO_FS_125_ENABLED )
 8005672:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8005676:	2b02      	cmp	r3, #2
 8005678:	d00c      	beq.n	8005694 <LSM6DSL_G_Get_FS+0x48>
    switch( fs_low_level )
 800567a:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800567e:	2b0c      	cmp	r3, #12
 8005680:	d81c      	bhi.n	80056bc <LSM6DSL_G_Get_FS+0x70>
 8005682:	e8df f003 	tbb	[pc, r3]
 8005686:	1b17      	.short	0x1b17
 8005688:	1b131b1b 	.word	0x1b131b1b
 800568c:	1b0f1b1b 	.word	0x1b0f1b1b
 8005690:	1b1b      	.short	0x1b1b
 8005692:	0b          	.byte	0x0b
 8005693:	00          	.byte	0x00
    *fullScale = 125.0f;
 8005694:	4b0b      	ldr	r3, [pc, #44]	; (80056c4 <LSM6DSL_G_Get_FS+0x78>)
 8005696:	602b      	str	r3, [r5, #0]
  return COMPONENT_OK;
 8005698:	2000      	movs	r0, #0
 800569a:	e7e1      	b.n	8005660 <LSM6DSL_G_Get_FS+0x14>
        *fullScale = 2000.0f;
 800569c:	4b0a      	ldr	r3, [pc, #40]	; (80056c8 <LSM6DSL_G_Get_FS+0x7c>)
 800569e:	602b      	str	r3, [r5, #0]
  return COMPONENT_OK;
 80056a0:	2000      	movs	r0, #0
        break;
 80056a2:	e7dd      	b.n	8005660 <LSM6DSL_G_Get_FS+0x14>
        *fullScale = 1000.0f;
 80056a4:	4b09      	ldr	r3, [pc, #36]	; (80056cc <LSM6DSL_G_Get_FS+0x80>)
 80056a6:	602b      	str	r3, [r5, #0]
  return COMPONENT_OK;
 80056a8:	2000      	movs	r0, #0
        break;
 80056aa:	e7d9      	b.n	8005660 <LSM6DSL_G_Get_FS+0x14>
        *fullScale =  500.0f;
 80056ac:	4b08      	ldr	r3, [pc, #32]	; (80056d0 <LSM6DSL_G_Get_FS+0x84>)
 80056ae:	602b      	str	r3, [r5, #0]
  return COMPONENT_OK;
 80056b0:	2000      	movs	r0, #0
        break;
 80056b2:	e7d5      	b.n	8005660 <LSM6DSL_G_Get_FS+0x14>
        *fullScale =  245.0f;
 80056b4:	4b07      	ldr	r3, [pc, #28]	; (80056d4 <LSM6DSL_G_Get_FS+0x88>)
 80056b6:	602b      	str	r3, [r5, #0]
  return COMPONENT_OK;
 80056b8:	2000      	movs	r0, #0
        break;
 80056ba:	e7d1      	b.n	8005660 <LSM6DSL_G_Get_FS+0x14>
        *fullScale =   -1.0f;
 80056bc:	4b06      	ldr	r3, [pc, #24]	; (80056d8 <LSM6DSL_G_Get_FS+0x8c>)
 80056be:	602b      	str	r3, [r5, #0]
 80056c0:	e7cd      	b.n	800565e <LSM6DSL_G_Get_FS+0x12>
 80056c2:	bf00      	nop
 80056c4:	42fa0000 	.word	0x42fa0000
 80056c8:	44fa0000 	.word	0x44fa0000
 80056cc:	447a0000 	.word	0x447a0000
 80056d0:	43fa0000 	.word	0x43fa0000
 80056d4:	43750000 	.word	0x43750000
 80056d8:	bf800000 	.word	0xbf800000

080056dc <LSM6DSL_X_Get_DRDY_Status>:
{
 80056dc:	b510      	push	{r4, lr}
 80056de:	b082      	sub	sp, #8
 80056e0:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_XLDA( (void *)handle, &status_raw ) == MEMS_ERROR )
 80056e2:	f10d 0107 	add.w	r1, sp, #7
 80056e6:	f7fe feb1 	bl	800444c <LSM6DSL_ACC_GYRO_R_XLDA>
 80056ea:	b140      	cbz	r0, 80056fe <LSM6DSL_X_Get_DRDY_Status+0x22>
  switch( status_raw )
 80056ec:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80056f0:	b140      	cbz	r0, 8005704 <LSM6DSL_X_Get_DRDY_Status+0x28>
 80056f2:	2801      	cmp	r0, #1
 80056f4:	d103      	bne.n	80056fe <LSM6DSL_X_Get_DRDY_Status+0x22>
      *status = 1;
 80056f6:	7020      	strb	r0, [r4, #0]
  return COMPONENT_OK;
 80056f8:	2000      	movs	r0, #0
}
 80056fa:	b002      	add	sp, #8
 80056fc:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 80056fe:	2001      	movs	r0, #1
}
 8005700:	b002      	add	sp, #8
 8005702:	bd10      	pop	{r4, pc}
      *status = 0;
 8005704:	7020      	strb	r0, [r4, #0]
}
 8005706:	b002      	add	sp, #8
 8005708:	bd10      	pop	{r4, pc}
 800570a:	bf00      	nop

0800570c <LSM6DSL_G_Write_Reg>:
{
 800570c:	b510      	push	{r4, lr}
 800570e:	b082      	sub	sp, #8
 8005710:	ac02      	add	r4, sp, #8
  if ( LSM6DSL_ACC_GYRO_WriteReg( (void *)handle, reg, &data, 1 ) == MEMS_ERROR )
 8005712:	2301      	movs	r3, #1
 8005714:	f804 2d01 	strb.w	r2, [r4, #-1]!
 8005718:	4622      	mov	r2, r4
 800571a:	f7fe fa67 	bl	8003bec <LSM6DSL_ACC_GYRO_WriteReg>
}
 800571e:	fab0 f080 	clz	r0, r0
 8005722:	0940      	lsrs	r0, r0, #5
 8005724:	b002      	add	sp, #8
 8005726:	bd10      	pop	{r4, pc}

08005728 <LSM6DSL_X_Get_ODR>:
{
 8005728:	b510      	push	{r4, lr}
 800572a:	b082      	sub	sp, #8
 800572c:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_ODR_XL( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 800572e:	f10d 0107 	add.w	r1, sp, #7
 8005732:	f7fe fb03 	bl	8003d3c <LSM6DSL_ACC_GYRO_R_ODR_XL>
 8005736:	b1d0      	cbz	r0, 800576e <LSM6DSL_X_Get_ODR+0x46>
  switch( odr_low_level )
 8005738:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800573c:	2850      	cmp	r0, #80	; 0x50
 800573e:	d037      	beq.n	80057b0 <LSM6DSL_X_Get_ODR+0x88>
 8005740:	d80a      	bhi.n	8005758 <LSM6DSL_X_Get_ODR+0x30>
 8005742:	2820      	cmp	r0, #32
 8005744:	d025      	beq.n	8005792 <LSM6DSL_X_Get_ODR+0x6a>
 8005746:	d915      	bls.n	8005774 <LSM6DSL_X_Get_ODR+0x4c>
 8005748:	2830      	cmp	r0, #48	; 0x30
 800574a:	d035      	beq.n	80057b8 <LSM6DSL_X_Get_ODR+0x90>
 800574c:	2840      	cmp	r0, #64	; 0x40
 800574e:	d128      	bne.n	80057a2 <LSM6DSL_X_Get_ODR+0x7a>
      *odr =   104.0f;
 8005750:	4b1f      	ldr	r3, [pc, #124]	; (80057d0 <LSM6DSL_X_Get_ODR+0xa8>)
 8005752:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8005754:	2000      	movs	r0, #0
      break;
 8005756:	e00b      	b.n	8005770 <LSM6DSL_X_Get_ODR+0x48>
  switch( odr_low_level )
 8005758:	2880      	cmp	r0, #128	; 0x80
 800575a:	d031      	beq.n	80057c0 <LSM6DSL_X_Get_ODR+0x98>
 800575c:	d911      	bls.n	8005782 <LSM6DSL_X_Get_ODR+0x5a>
 800575e:	2890      	cmp	r0, #144	; 0x90
 8005760:	d01b      	beq.n	800579a <LSM6DSL_X_Get_ODR+0x72>
 8005762:	28a0      	cmp	r0, #160	; 0xa0
 8005764:	d11d      	bne.n	80057a2 <LSM6DSL_X_Get_ODR+0x7a>
      *odr =  6660.0f;
 8005766:	4b1b      	ldr	r3, [pc, #108]	; (80057d4 <LSM6DSL_X_Get_ODR+0xac>)
 8005768:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800576a:	2000      	movs	r0, #0
      break;
 800576c:	e000      	b.n	8005770 <LSM6DSL_X_Get_ODR+0x48>
    return COMPONENT_ERROR;
 800576e:	2001      	movs	r0, #1
}
 8005770:	b002      	add	sp, #8
 8005772:	bd10      	pop	{r4, pc}
  switch( odr_low_level )
 8005774:	b1c8      	cbz	r0, 80057aa <LSM6DSL_X_Get_ODR+0x82>
 8005776:	2810      	cmp	r0, #16
 8005778:	d113      	bne.n	80057a2 <LSM6DSL_X_Get_ODR+0x7a>
      *odr =    13.0f;
 800577a:	4b17      	ldr	r3, [pc, #92]	; (80057d8 <LSM6DSL_X_Get_ODR+0xb0>)
 800577c:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800577e:	2000      	movs	r0, #0
      break;
 8005780:	e7f6      	b.n	8005770 <LSM6DSL_X_Get_ODR+0x48>
  switch( odr_low_level )
 8005782:	2860      	cmp	r0, #96	; 0x60
 8005784:	d020      	beq.n	80057c8 <LSM6DSL_X_Get_ODR+0xa0>
 8005786:	2870      	cmp	r0, #112	; 0x70
 8005788:	d10b      	bne.n	80057a2 <LSM6DSL_X_Get_ODR+0x7a>
      *odr =   833.0f;
 800578a:	4b14      	ldr	r3, [pc, #80]	; (80057dc <LSM6DSL_X_Get_ODR+0xb4>)
 800578c:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800578e:	2000      	movs	r0, #0
      break;
 8005790:	e7ee      	b.n	8005770 <LSM6DSL_X_Get_ODR+0x48>
      *odr =    26.0f;
 8005792:	4b13      	ldr	r3, [pc, #76]	; (80057e0 <LSM6DSL_X_Get_ODR+0xb8>)
 8005794:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8005796:	2000      	movs	r0, #0
      break;
 8005798:	e7ea      	b.n	8005770 <LSM6DSL_X_Get_ODR+0x48>
      *odr =  3330.0f;
 800579a:	4b12      	ldr	r3, [pc, #72]	; (80057e4 <LSM6DSL_X_Get_ODR+0xbc>)
 800579c:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800579e:	2000      	movs	r0, #0
      break;
 80057a0:	e7e6      	b.n	8005770 <LSM6DSL_X_Get_ODR+0x48>
      *odr =    -1.0f;
 80057a2:	4b11      	ldr	r3, [pc, #68]	; (80057e8 <LSM6DSL_X_Get_ODR+0xc0>)
 80057a4:	6023      	str	r3, [r4, #0]
      return COMPONENT_ERROR;
 80057a6:	2001      	movs	r0, #1
 80057a8:	e7e2      	b.n	8005770 <LSM6DSL_X_Get_ODR+0x48>
      *odr =     0.0f;
 80057aa:	2300      	movs	r3, #0
 80057ac:	6023      	str	r3, [r4, #0]
      break;
 80057ae:	e7df      	b.n	8005770 <LSM6DSL_X_Get_ODR+0x48>
      *odr =   208.0f;
 80057b0:	4b0e      	ldr	r3, [pc, #56]	; (80057ec <LSM6DSL_X_Get_ODR+0xc4>)
 80057b2:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80057b4:	2000      	movs	r0, #0
      break;
 80057b6:	e7db      	b.n	8005770 <LSM6DSL_X_Get_ODR+0x48>
      *odr =    52.0f;
 80057b8:	4b0d      	ldr	r3, [pc, #52]	; (80057f0 <LSM6DSL_X_Get_ODR+0xc8>)
 80057ba:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80057bc:	2000      	movs	r0, #0
      break;
 80057be:	e7d7      	b.n	8005770 <LSM6DSL_X_Get_ODR+0x48>
      *odr =  1660.0f;
 80057c0:	4b0c      	ldr	r3, [pc, #48]	; (80057f4 <LSM6DSL_X_Get_ODR+0xcc>)
 80057c2:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80057c4:	2000      	movs	r0, #0
      break;
 80057c6:	e7d3      	b.n	8005770 <LSM6DSL_X_Get_ODR+0x48>
      *odr =   416.0f;
 80057c8:	4b0b      	ldr	r3, [pc, #44]	; (80057f8 <LSM6DSL_X_Get_ODR+0xd0>)
 80057ca:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80057cc:	2000      	movs	r0, #0
      break;
 80057ce:	e7cf      	b.n	8005770 <LSM6DSL_X_Get_ODR+0x48>
 80057d0:	42d00000 	.word	0x42d00000
 80057d4:	45d02000 	.word	0x45d02000
 80057d8:	41500000 	.word	0x41500000
 80057dc:	44504000 	.word	0x44504000
 80057e0:	41d00000 	.word	0x41d00000
 80057e4:	45502000 	.word	0x45502000
 80057e8:	bf800000 	.word	0xbf800000
 80057ec:	43500000 	.word	0x43500000
 80057f0:	42500000 	.word	0x42500000
 80057f4:	44cf8000 	.word	0x44cf8000
 80057f8:	43d00000 	.word	0x43d00000

080057fc <LSM6DSL_G_Get_WhoAmI>:
{
 80057fc:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 80057fe:	f7fe f9fd 	bl	8003bfc <LSM6DSL_ACC_GYRO_R_WHO_AM_I>
}
 8005802:	fab0 f080 	clz	r0, r0
 8005806:	0940      	lsrs	r0, r0, #5
 8005808:	bd08      	pop	{r3, pc}
 800580a:	bf00      	nop

0800580c <LSM6DSL_G_Get_DRDY_Status>:
{
 800580c:	b510      	push	{r4, lr}
 800580e:	b082      	sub	sp, #8
 8005810:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_GDA( (void *)handle, &status_raw ) == MEMS_ERROR )
 8005812:	f10d 0107 	add.w	r1, sp, #7
 8005816:	f7fe fe29 	bl	800446c <LSM6DSL_ACC_GYRO_R_GDA>
 800581a:	b148      	cbz	r0, 8005830 <LSM6DSL_G_Get_DRDY_Status+0x24>
  switch( status_raw )
 800581c:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8005820:	b148      	cbz	r0, 8005836 <LSM6DSL_G_Get_DRDY_Status+0x2a>
 8005822:	2802      	cmp	r0, #2
 8005824:	d104      	bne.n	8005830 <LSM6DSL_G_Get_DRDY_Status+0x24>
      *status = 1;
 8005826:	2301      	movs	r3, #1
  return COMPONENT_OK;
 8005828:	2000      	movs	r0, #0
      *status = 1;
 800582a:	7023      	strb	r3, [r4, #0]
}
 800582c:	b002      	add	sp, #8
 800582e:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 8005830:	2001      	movs	r0, #1
}
 8005832:	b002      	add	sp, #8
 8005834:	bd10      	pop	{r4, pc}
      *status = 0;
 8005836:	7020      	strb	r0, [r4, #0]
}
 8005838:	b002      	add	sp, #8
 800583a:	bd10      	pop	{r4, pc}

0800583c <LSM6DSL_G_Set_FS>:
  switch( fullScale )
 800583c:	2902      	cmp	r1, #2
 800583e:	d00c      	beq.n	800585a <LSM6DSL_G_Set_FS+0x1e>
 8005840:	2904      	cmp	r1, #4
 8005842:	d002      	beq.n	800584a <LSM6DSL_G_Set_FS+0xe>
 8005844:	b111      	cbz	r1, 800584c <LSM6DSL_G_Set_FS+0x10>
      return COMPONENT_ERROR;
 8005846:	2001      	movs	r0, #1
 8005848:	4770      	bx	lr
      new_fs = LSM6DSL_ACC_GYRO_FS_G_2000dps;
 800584a:	210c      	movs	r1, #12
{
 800584c:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_W_FS_G( (void *)handle, new_fs ) == MEMS_ERROR )
 800584e:	f7fe fa85 	bl	8003d5c <LSM6DSL_ACC_GYRO_W_FS_G>
      return COMPONENT_ERROR;
 8005852:	fab0 f080 	clz	r0, r0
 8005856:	0940      	lsrs	r0, r0, #5
 8005858:	bd08      	pop	{r3, pc}
      new_fs = LSM6DSL_ACC_GYRO_FS_G_500dps;
 800585a:	2104      	movs	r1, #4
 800585c:	e7f6      	b.n	800584c <LSM6DSL_G_Set_FS+0x10>
 800585e:	bf00      	nop

08005860 <LSM6DSL_G_Get_ODR>:
{
 8005860:	b510      	push	{r4, lr}
 8005862:	b082      	sub	sp, #8
 8005864:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_ODR_G( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 8005866:	f10d 0107 	add.w	r1, sp, #7
 800586a:	f7fe faeb 	bl	8003e44 <LSM6DSL_ACC_GYRO_R_ODR_G>
 800586e:	b1d0      	cbz	r0, 80058a6 <LSM6DSL_G_Get_ODR+0x46>
  switch( odr_low_level )
 8005870:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8005874:	2850      	cmp	r0, #80	; 0x50
 8005876:	d037      	beq.n	80058e8 <LSM6DSL_G_Get_ODR+0x88>
 8005878:	d80a      	bhi.n	8005890 <LSM6DSL_G_Get_ODR+0x30>
 800587a:	2820      	cmp	r0, #32
 800587c:	d025      	beq.n	80058ca <LSM6DSL_G_Get_ODR+0x6a>
 800587e:	d915      	bls.n	80058ac <LSM6DSL_G_Get_ODR+0x4c>
 8005880:	2830      	cmp	r0, #48	; 0x30
 8005882:	d035      	beq.n	80058f0 <LSM6DSL_G_Get_ODR+0x90>
 8005884:	2840      	cmp	r0, #64	; 0x40
 8005886:	d128      	bne.n	80058da <LSM6DSL_G_Get_ODR+0x7a>
      *odr =  104.0f;
 8005888:	4b1f      	ldr	r3, [pc, #124]	; (8005908 <LSM6DSL_G_Get_ODR+0xa8>)
 800588a:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 800588c:	2000      	movs	r0, #0
      break;
 800588e:	e00b      	b.n	80058a8 <LSM6DSL_G_Get_ODR+0x48>
  switch( odr_low_level )
 8005890:	2880      	cmp	r0, #128	; 0x80
 8005892:	d031      	beq.n	80058f8 <LSM6DSL_G_Get_ODR+0x98>
 8005894:	d911      	bls.n	80058ba <LSM6DSL_G_Get_ODR+0x5a>
 8005896:	2890      	cmp	r0, #144	; 0x90
 8005898:	d01b      	beq.n	80058d2 <LSM6DSL_G_Get_ODR+0x72>
 800589a:	28a0      	cmp	r0, #160	; 0xa0
 800589c:	d11d      	bne.n	80058da <LSM6DSL_G_Get_ODR+0x7a>
      *odr = 6660.0f;
 800589e:	4b1b      	ldr	r3, [pc, #108]	; (800590c <LSM6DSL_G_Get_ODR+0xac>)
 80058a0:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80058a2:	2000      	movs	r0, #0
      break;
 80058a4:	e000      	b.n	80058a8 <LSM6DSL_G_Get_ODR+0x48>
    return COMPONENT_ERROR;
 80058a6:	2001      	movs	r0, #1
}
 80058a8:	b002      	add	sp, #8
 80058aa:	bd10      	pop	{r4, pc}
  switch( odr_low_level )
 80058ac:	b1c8      	cbz	r0, 80058e2 <LSM6DSL_G_Get_ODR+0x82>
 80058ae:	2810      	cmp	r0, #16
 80058b0:	d113      	bne.n	80058da <LSM6DSL_G_Get_ODR+0x7a>
      *odr =   13.0f;
 80058b2:	4b17      	ldr	r3, [pc, #92]	; (8005910 <LSM6DSL_G_Get_ODR+0xb0>)
 80058b4:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80058b6:	2000      	movs	r0, #0
      break;
 80058b8:	e7f6      	b.n	80058a8 <LSM6DSL_G_Get_ODR+0x48>
  switch( odr_low_level )
 80058ba:	2860      	cmp	r0, #96	; 0x60
 80058bc:	d020      	beq.n	8005900 <LSM6DSL_G_Get_ODR+0xa0>
 80058be:	2870      	cmp	r0, #112	; 0x70
 80058c0:	d10b      	bne.n	80058da <LSM6DSL_G_Get_ODR+0x7a>
      *odr =  833.0f;
 80058c2:	4b14      	ldr	r3, [pc, #80]	; (8005914 <LSM6DSL_G_Get_ODR+0xb4>)
 80058c4:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80058c6:	2000      	movs	r0, #0
      break;
 80058c8:	e7ee      	b.n	80058a8 <LSM6DSL_G_Get_ODR+0x48>
      *odr =   26.0f;
 80058ca:	4b13      	ldr	r3, [pc, #76]	; (8005918 <LSM6DSL_G_Get_ODR+0xb8>)
 80058cc:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80058ce:	2000      	movs	r0, #0
      break;
 80058d0:	e7ea      	b.n	80058a8 <LSM6DSL_G_Get_ODR+0x48>
      *odr = 3330.0f;
 80058d2:	4b12      	ldr	r3, [pc, #72]	; (800591c <LSM6DSL_G_Get_ODR+0xbc>)
 80058d4:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80058d6:	2000      	movs	r0, #0
      break;
 80058d8:	e7e6      	b.n	80058a8 <LSM6DSL_G_Get_ODR+0x48>
      *odr =   -1.0f;
 80058da:	4b11      	ldr	r3, [pc, #68]	; (8005920 <LSM6DSL_G_Get_ODR+0xc0>)
 80058dc:	6023      	str	r3, [r4, #0]
      return COMPONENT_ERROR;
 80058de:	2001      	movs	r0, #1
 80058e0:	e7e2      	b.n	80058a8 <LSM6DSL_G_Get_ODR+0x48>
      *odr =    0.0f;
 80058e2:	2300      	movs	r3, #0
 80058e4:	6023      	str	r3, [r4, #0]
      break;
 80058e6:	e7df      	b.n	80058a8 <LSM6DSL_G_Get_ODR+0x48>
      *odr =  208.0f;
 80058e8:	4b0e      	ldr	r3, [pc, #56]	; (8005924 <LSM6DSL_G_Get_ODR+0xc4>)
 80058ea:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80058ec:	2000      	movs	r0, #0
      break;
 80058ee:	e7db      	b.n	80058a8 <LSM6DSL_G_Get_ODR+0x48>
      *odr =   52.0f;
 80058f0:	4b0d      	ldr	r3, [pc, #52]	; (8005928 <LSM6DSL_G_Get_ODR+0xc8>)
 80058f2:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80058f4:	2000      	movs	r0, #0
      break;
 80058f6:	e7d7      	b.n	80058a8 <LSM6DSL_G_Get_ODR+0x48>
      *odr = 1660.0f;
 80058f8:	4b0c      	ldr	r3, [pc, #48]	; (800592c <LSM6DSL_G_Get_ODR+0xcc>)
 80058fa:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 80058fc:	2000      	movs	r0, #0
      break;
 80058fe:	e7d3      	b.n	80058a8 <LSM6DSL_G_Get_ODR+0x48>
      *odr =  416.0f;
 8005900:	4b0b      	ldr	r3, [pc, #44]	; (8005930 <LSM6DSL_G_Get_ODR+0xd0>)
 8005902:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8005904:	2000      	movs	r0, #0
      break;
 8005906:	e7cf      	b.n	80058a8 <LSM6DSL_G_Get_ODR+0x48>
 8005908:	42d00000 	.word	0x42d00000
 800590c:	45d02000 	.word	0x45d02000
 8005910:	41500000 	.word	0x41500000
 8005914:	44504000 	.word	0x44504000
 8005918:	41d00000 	.word	0x41d00000
 800591c:	45502000 	.word	0x45502000
 8005920:	bf800000 	.word	0xbf800000
 8005924:	43500000 	.word	0x43500000
 8005928:	42500000 	.word	0x42500000
 800592c:	44cf8000 	.word	0x44cf8000
 8005930:	43d00000 	.word	0x43d00000

08005934 <LSM6DSL_X_Set_SelfTest>:
*/
static DrvStatusTypeDef LSM6DSL_X_Set_SelfTest( DrvContextTypeDef *handle, uint8_t status )
{

  /* Verify that the passed parameter contains one of the valid values. */
  switch ( ( LSM6DSL_ACC_GYRO_ST_XL_t )status )
 8005934:	2903      	cmp	r1, #3
 8005936:	d901      	bls.n	800593c <LSM6DSL_X_Set_SelfTest+0x8>
    case LSM6DSL_ACC_GYRO_ST_XL_POS_SIGN_TEST:
    case LSM6DSL_ACC_GYRO_ST_XL_NEG_SIGN_TEST:
    case LSM6DSL_ACC_GYRO_ST_XL_NA:
      break;
    default:
      return COMPONENT_ERROR;
 8005938:	2001      	movs	r0, #1
 800593a:	4770      	bx	lr
{
 800593c:	b508      	push	{r3, lr}
  }

  if ( LSM6DSL_ACC_GYRO_W_SelfTest_XL( handle, ( LSM6DSL_ACC_GYRO_ST_XL_t )status ) == MEMS_ERROR )
 800593e:	f7fe fc09 	bl	8004154 <LSM6DSL_ACC_GYRO_W_SelfTest_XL>
      return COMPONENT_ERROR;
 8005942:	fab0 f080 	clz	r0, r0
 8005946:	0940      	lsrs	r0, r0, #5
 8005948:	bd08      	pop	{r3, pc}
 800594a:	bf00      	nop

0800594c <LSM6DSL_G_Set_Interrupt_Latch>:
  switch ( ( LSM6DSL_ACC_GYRO_LIR_t )status )
 800594c:	2901      	cmp	r1, #1
 800594e:	d901      	bls.n	8005954 <LSM6DSL_G_Set_Interrupt_Latch+0x8>
      return COMPONENT_ERROR;
 8005950:	2001      	movs	r0, #1
 8005952:	4770      	bx	lr
 * @param status interrupt latch enable/disable
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LSM6DSL_G_Set_Interrupt_Latch( DrvContextTypeDef *handle, uint8_t status )
{
 8005954:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_W_LIR( handle, ( LSM6DSL_ACC_GYRO_LIR_t )status ) == MEMS_ERROR )
 8005956:	f7fe fe2d 	bl	80045b4 <LSM6DSL_ACC_GYRO_W_LIR>
      return COMPONENT_ERROR;
 800595a:	fab0 f080 	clz	r0, r0
 800595e:	0940      	lsrs	r0, r0, #5
 8005960:	bd08      	pop	{r3, pc}
 8005962:	bf00      	nop

08005964 <LSM6DSL_FIFO_Set_Stop_On_Fth>:
  switch ( ( LSM6DSL_ACC_GYRO_STOP_ON_FTH_t )status )
 8005964:	b119      	cbz	r1, 800596e <LSM6DSL_FIFO_Set_Stop_On_Fth+0xa>
 8005966:	2980      	cmp	r1, #128	; 0x80
 8005968:	d001      	beq.n	800596e <LSM6DSL_FIFO_Set_Stop_On_Fth+0xa>
      return COMPONENT_ERROR;
 800596a:	2001      	movs	r0, #1
 800596c:	4770      	bx	lr
{
 800596e:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_W_STOP_ON_FTH( handle, ( LSM6DSL_ACC_GYRO_STOP_ON_FTH_t )status ) == MEMS_ERROR )
 8005970:	f7fe fb24 	bl	8003fbc <LSM6DSL_ACC_GYRO_W_STOP_ON_FTH>
      return COMPONENT_ERROR;
 8005974:	fab0 f080 	clz	r0, r0
 8005978:	0940      	lsrs	r0, r0, #5
 800597a:	bd08      	pop	{r3, pc}

0800597c <LSM6DSL_FIFO_Set_INT1_FIFO_Full>:
  switch ( ( LSM6DSL_ACC_GYRO_INT1_FULL_FLAG_t )status )
 800597c:	b119      	cbz	r1, 8005986 <LSM6DSL_FIFO_Set_INT1_FIFO_Full+0xa>
 800597e:	2920      	cmp	r1, #32
 8005980:	d001      	beq.n	8005986 <LSM6DSL_FIFO_Set_INT1_FIFO_Full+0xa>
      return COMPONENT_ERROR;
 8005982:	2001      	movs	r0, #1
 8005984:	4770      	bx	lr
{
 8005986:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_W_FULL_FLAG_on_INT1( handle, ( LSM6DSL_ACC_GYRO_INT1_FULL_FLAG_t )status ) == MEMS_ERROR )
 8005988:	f7fe fb7e 	bl	8004088 <LSM6DSL_ACC_GYRO_W_FULL_FLAG_on_INT1>
      return COMPONENT_ERROR;
 800598c:	fab0 f080 	clz	r0, r0
 8005990:	0940      	lsrs	r0, r0, #5
 8005992:	bd08      	pop	{r3, pc}

08005994 <LSM6DSL_FIFO_Set_Mode>:
{
 8005994:	2906      	cmp	r1, #6
 8005996:	d808      	bhi.n	80059aa <LSM6DSL_FIFO_Set_Mode+0x16>
 8005998:	b508      	push	{r3, lr}
 800599a:	2301      	movs	r3, #1
 800599c:	fa03 f201 	lsl.w	r2, r3, r1
 80059a0:	f012 0f5b 	tst.w	r2, #91	; 0x5b
 80059a4:	d103      	bne.n	80059ae <LSM6DSL_FIFO_Set_Mode+0x1a>
      return COMPONENT_ERROR;
 80059a6:	4618      	mov	r0, r3
}
 80059a8:	bd08      	pop	{r3, pc}
      return COMPONENT_ERROR;
 80059aa:	2001      	movs	r0, #1
 80059ac:	4770      	bx	lr
  if ( LSM6DSL_ACC_GYRO_W_FIFO_MODE( handle, ( LSM6DSL_ACC_GYRO_FIFO_MODE_t )mode ) == MEMS_ERROR )
 80059ae:	f7fe fb27 	bl	8004000 <LSM6DSL_ACC_GYRO_W_FIFO_MODE>
      return COMPONENT_ERROR;
 80059b2:	fab0 f080 	clz	r0, r0
 80059b6:	0940      	lsrs	r0, r0, #5
 80059b8:	bd08      	pop	{r3, pc}
 80059ba:	bf00      	nop

080059bc <LSM6DSL_FIFO_X_Set_Decimation>:
  switch ( ( LSM6DSL_ACC_GYRO_DEC_FIFO_XL_t )decimation )
 80059bc:	2907      	cmp	r1, #7
 80059be:	d901      	bls.n	80059c4 <LSM6DSL_FIFO_X_Set_Decimation+0x8>
      return COMPONENT_ERROR;
 80059c0:	2001      	movs	r0, #1
 80059c2:	4770      	bx	lr
{
 80059c4:	b508      	push	{r3, lr}
  if ( LSM6DSL_ACC_GYRO_W_DEC_FIFO_XL( handle, ( LSM6DSL_ACC_GYRO_DEC_FIFO_XL_t )decimation ) == MEMS_ERROR )
 80059c6:	f7fe fab5 	bl	8003f34 <LSM6DSL_ACC_GYRO_W_DEC_FIFO_XL>
      return COMPONENT_ERROR;
 80059ca:	fab0 f080 	clz	r0, r0
 80059ce:	0940      	lsrs	r0, r0, #5
 80059d0:	bd08      	pop	{r3, pc}
 80059d2:	bf00      	nop

080059d4 <LSM6DSL_X_Disable_6D_Orientation>:
{
 80059d4:	b510      	push	{r4, lr}
  if ( LSM6DSL_ACC_GYRO_W_6DEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_6D_DISABLED ) == MEMS_ERROR )
 80059d6:	2100      	movs	r1, #0
{
 80059d8:	4604      	mov	r4, r0
  if ( LSM6DSL_ACC_GYRO_W_6DEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_6D_DISABLED ) == MEMS_ERROR )
 80059da:	f7ff f875 	bl	8004ac8 <LSM6DSL_ACC_GYRO_W_6DEvOnInt1>
 80059de:	b908      	cbnz	r0, 80059e4 <LSM6DSL_X_Disable_6D_Orientation+0x10>
    return COMPONENT_ERROR;
 80059e0:	2001      	movs	r0, #1
 80059e2:	bd10      	pop	{r4, pc}
  if ( LSM6DSL_ACC_GYRO_W_6DEvOnInt2( (void *)handle, LSM6DSL_ACC_GYRO_INT2_6D_DISABLED ) == MEMS_ERROR )
 80059e4:	2100      	movs	r1, #0
 80059e6:	4620      	mov	r0, r4
 80059e8:	f7ff f93a 	bl	8004c60 <LSM6DSL_ACC_GYRO_W_6DEvOnInt2>
 80059ec:	2800      	cmp	r0, #0
 80059ee:	d0f7      	beq.n	80059e0 <LSM6DSL_X_Disable_6D_Orientation+0xc>
  if ( LSM6DSL_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSL_ACC_GYRO_BASIC_INT_DISABLED ) == MEMS_ERROR )
 80059f0:	2100      	movs	r1, #0
 80059f2:	4620      	mov	r0, r4
 80059f4:	f7fe fe66 	bl	80046c4 <LSM6DSL_ACC_GYRO_W_BASIC_INT>
 80059f8:	2800      	cmp	r0, #0
 80059fa:	d0f1      	beq.n	80059e0 <LSM6DSL_X_Disable_6D_Orientation+0xc>
  if ( LSM6DSL_ACC_GYRO_W_SIXD_THS( (void *)handle, LSM6DSL_ACC_GYRO_SIXD_THS_80_degree ) == MEMS_ERROR )
 80059fc:	4620      	mov	r0, r4
 80059fe:	2100      	movs	r1, #0
 8005a00:	f7fe fea6 	bl	8004750 <LSM6DSL_ACC_GYRO_W_SIXD_THS>
    return COMPONENT_ERROR;
 8005a04:	fab0 f080 	clz	r0, r0
 8005a08:	0940      	lsrs	r0, r0, #5
}
 8005a0a:	bd10      	pop	{r4, pc}

08005a0c <LSM6DSL_X_Set_ODR>:
{
 8005a0c:	b508      	push	{r3, lr}
  if(handle->isEnabled == 1)
 8005a0e:	7983      	ldrb	r3, [r0, #6]
 8005a10:	2b01      	cmp	r3, #1
 8005a12:	d018      	beq.n	8005a46 <LSM6DSL_X_Set_ODR+0x3a>
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 8005a14:	6883      	ldr	r3, [r0, #8]
 8005a16:	681b      	ldr	r3, [r3, #0]
  switch( odr )
 8005a18:	2904      	cmp	r1, #4
 8005a1a:	d828      	bhi.n	8005a6e <LSM6DSL_X_Set_ODR+0x62>
 8005a1c:	e8df f001 	tbb	[pc, r1]
 8005a20:	0f0b0303 	.word	0x0f0b0303
 8005a24:	07          	.byte	0x07
 8005a25:	00          	.byte	0x00
      pComponentData->Previous_ODR = 13.0f;
 8005a26:	4a13      	ldr	r2, [pc, #76]	; (8005a74 <LSM6DSL_X_Set_ODR+0x68>)
 8005a28:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 8005a2a:	2000      	movs	r0, #0
 8005a2c:	bd08      	pop	{r3, pc}
      pComponentData->Previous_ODR = 104.0f;
 8005a2e:	4a12      	ldr	r2, [pc, #72]	; (8005a78 <LSM6DSL_X_Set_ODR+0x6c>)
 8005a30:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 8005a32:	2000      	movs	r0, #0
 8005a34:	bd08      	pop	{r3, pc}
      pComponentData->Previous_ODR = 26.0f;
 8005a36:	4a11      	ldr	r2, [pc, #68]	; (8005a7c <LSM6DSL_X_Set_ODR+0x70>)
 8005a38:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 8005a3a:	2000      	movs	r0, #0
 8005a3c:	bd08      	pop	{r3, pc}
      pComponentData->Previous_ODR = 52.0f;
 8005a3e:	4a10      	ldr	r2, [pc, #64]	; (8005a80 <LSM6DSL_X_Set_ODR+0x74>)
 8005a40:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 8005a42:	2000      	movs	r0, #0
 8005a44:	bd08      	pop	{r3, pc}
  switch( odr )
 8005a46:	2904      	cmp	r1, #4
 8005a48:	d811      	bhi.n	8005a6e <LSM6DSL_X_Set_ODR+0x62>
 8005a4a:	e8df f001 	tbb	[pc, r1]
 8005a4e:	0303      	.short	0x0303
 8005a50:	0a0c      	.short	0x0a0c
 8005a52:	0e          	.byte	0x0e
 8005a53:	00          	.byte	0x00
      new_odr = LSM6DSL_ACC_GYRO_ODR_XL_13Hz;
 8005a54:	2110      	movs	r1, #16
  if ( LSM6DSL_ACC_GYRO_W_ODR_XL( (void *)handle, new_odr ) == MEMS_ERROR )
 8005a56:	f7fe f94f 	bl	8003cf8 <LSM6DSL_ACC_GYRO_W_ODR_XL>
  return COMPONENT_OK;
 8005a5a:	fab0 f080 	clz	r0, r0
 8005a5e:	0940      	lsrs	r0, r0, #5
 8005a60:	bd08      	pop	{r3, pc}
      new_odr = LSM6DSL_ACC_GYRO_ODR_XL_52Hz;
 8005a62:	2130      	movs	r1, #48	; 0x30
 8005a64:	e7f7      	b.n	8005a56 <LSM6DSL_X_Set_ODR+0x4a>
      new_odr = LSM6DSL_ACC_GYRO_ODR_XL_26Hz;
 8005a66:	2120      	movs	r1, #32
 8005a68:	e7f5      	b.n	8005a56 <LSM6DSL_X_Set_ODR+0x4a>
      new_odr = LSM6DSL_ACC_GYRO_ODR_XL_104Hz;
 8005a6a:	2140      	movs	r1, #64	; 0x40
 8005a6c:	e7f3      	b.n	8005a56 <LSM6DSL_X_Set_ODR+0x4a>
      return COMPONENT_ERROR;
 8005a6e:	2001      	movs	r0, #1
}
 8005a70:	bd08      	pop	{r3, pc}
 8005a72:	bf00      	nop
 8005a74:	41500000 	.word	0x41500000
 8005a78:	42d00000 	.word	0x42d00000
 8005a7c:	41d00000 	.word	0x41d00000
 8005a80:	42500000 	.word	0x42500000

08005a84 <LSM6DSL_X_Disable_Double_Tap_Detection>:
{
 8005a84:	b510      	push	{r4, lr}
  if ( LSM6DSL_ACC_GYRO_W_TapEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_TAP_DISABLED ) == MEMS_ERROR )
 8005a86:	2100      	movs	r1, #0
{
 8005a88:	4604      	mov	r4, r0
  if ( LSM6DSL_ACC_GYRO_W_TapEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_TAP_DISABLED ) == MEMS_ERROR )
 8005a8a:	f7ff f83f 	bl	8004b0c <LSM6DSL_ACC_GYRO_W_TapEvOnInt1>
 8005a8e:	b908      	cbnz	r0, 8005a94 <LSM6DSL_X_Disable_Double_Tap_Detection+0x10>
    return COMPONENT_ERROR;
 8005a90:	2001      	movs	r0, #1
 8005a92:	bd10      	pop	{r4, pc}
  if ( LSM6DSL_ACC_GYRO_W_TapEvOnInt2( (void *)handle, LSM6DSL_ACC_GYRO_INT2_TAP_DISABLED ) == MEMS_ERROR )
 8005a94:	2100      	movs	r1, #0
 8005a96:	4620      	mov	r0, r4
 8005a98:	f7ff f904 	bl	8004ca4 <LSM6DSL_ACC_GYRO_W_TapEvOnInt2>
 8005a9c:	2800      	cmp	r0, #0
 8005a9e:	d0f7      	beq.n	8005a90 <LSM6DSL_X_Disable_Double_Tap_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSL_ACC_GYRO_BASIC_INT_DISABLED ) == MEMS_ERROR )
 8005aa0:	2100      	movs	r1, #0
 8005aa2:	4620      	mov	r0, r4
 8005aa4:	f7fe fe0e 	bl	80046c4 <LSM6DSL_ACC_GYRO_W_BASIC_INT>
 8005aa8:	2800      	cmp	r0, #0
 8005aaa:	d0f1      	beq.n	8005a90 <LSM6DSL_X_Disable_Double_Tap_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_TAP_THS( (void *)handle, thr ) == MEMS_ERROR )
 8005aac:	2100      	movs	r1, #0
 8005aae:	4620      	mov	r0, r4
 8005ab0:	f7fe fe2a 	bl	8004708 <LSM6DSL_ACC_GYRO_W_TAP_THS>
 8005ab4:	2800      	cmp	r0, #0
 8005ab6:	d0eb      	beq.n	8005a90 <LSM6DSL_X_Disable_Double_Tap_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_SHOCK_Duration( (void *)handle, time ) == MEMS_ERROR )
 8005ab8:	2100      	movs	r1, #0
 8005aba:	4620      	mov	r0, r4
 8005abc:	f7fe fe6a 	bl	8004794 <LSM6DSL_ACC_GYRO_W_SHOCK_Duration>
 8005ac0:	2800      	cmp	r0, #0
 8005ac2:	d0e5      	beq.n	8005a90 <LSM6DSL_X_Disable_Double_Tap_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_QUIET_Duration( (void *)handle, time ) == MEMS_ERROR )
 8005ac4:	2100      	movs	r1, #0
 8005ac6:	4620      	mov	r0, r4
 8005ac8:	f7fe fe88 	bl	80047dc <LSM6DSL_ACC_GYRO_W_QUIET_Duration>
 8005acc:	2800      	cmp	r0, #0
 8005ace:	d0df      	beq.n	8005a90 <LSM6DSL_X_Disable_Double_Tap_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_DUR( (void *)handle, time ) == MEMS_ERROR )
 8005ad0:	2100      	movs	r1, #0
 8005ad2:	4620      	mov	r0, r4
 8005ad4:	f7fe fea6 	bl	8004824 <LSM6DSL_ACC_GYRO_W_DUR>
 8005ad8:	2800      	cmp	r0, #0
 8005ada:	d0d9      	beq.n	8005a90 <LSM6DSL_X_Disable_Double_Tap_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_SINGLE_DOUBLE_TAP_EV( (void *)handle,
 8005adc:	2100      	movs	r1, #0
 8005ade:	4620      	mov	r0, r4
 8005ae0:	f7fe fee6 	bl	80048b0 <LSM6DSL_ACC_GYRO_W_SINGLE_DOUBLE_TAP_EV>
 8005ae4:	2800      	cmp	r0, #0
 8005ae6:	d0d3      	beq.n	8005a90 <LSM6DSL_X_Disable_Double_Tap_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_TAP_Z_EN( (void *)handle, LSM6DSL_ACC_GYRO_TAP_Z_EN_DISABLED ) == MEMS_ERROR )
 8005ae8:	2100      	movs	r1, #0
 8005aea:	4620      	mov	r0, r4
 8005aec:	f7fe fd84 	bl	80045f8 <LSM6DSL_ACC_GYRO_W_TAP_Z_EN>
 8005af0:	2800      	cmp	r0, #0
 8005af2:	d0cd      	beq.n	8005a90 <LSM6DSL_X_Disable_Double_Tap_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_TAP_Y_EN( (void *)handle, LSM6DSL_ACC_GYRO_TAP_Y_EN_DISABLED ) == MEMS_ERROR )
 8005af4:	2100      	movs	r1, #0
 8005af6:	4620      	mov	r0, r4
 8005af8:	f7fe fda0 	bl	800463c <LSM6DSL_ACC_GYRO_W_TAP_Y_EN>
 8005afc:	2800      	cmp	r0, #0
 8005afe:	d0c7      	beq.n	8005a90 <LSM6DSL_X_Disable_Double_Tap_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_TAP_X_EN( (void *)handle, LSM6DSL_ACC_GYRO_TAP_X_EN_DISABLED ) == MEMS_ERROR )
 8005b00:	4620      	mov	r0, r4
 8005b02:	2100      	movs	r1, #0
 8005b04:	f7fe fdbc 	bl	8004680 <LSM6DSL_ACC_GYRO_W_TAP_X_EN>
    return COMPONENT_ERROR;
 8005b08:	fab0 f080 	clz	r0, r0
 8005b0c:	0940      	lsrs	r0, r0, #5
 8005b0e:	bd10      	pop	{r4, pc}

08005b10 <LSM6DSL_X_Disable_Single_Tap_Detection>:
{
 8005b10:	b510      	push	{r4, lr}
  if ( LSM6DSL_ACC_GYRO_W_SingleTapOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_SINGLE_TAP_DISABLED ) == MEMS_ERROR )
 8005b12:	2100      	movs	r1, #0
{
 8005b14:	4604      	mov	r4, r0
  if ( LSM6DSL_ACC_GYRO_W_SingleTapOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_SINGLE_TAP_DISABLED ) == MEMS_ERROR )
 8005b16:	f7ff f85f 	bl	8004bd8 <LSM6DSL_ACC_GYRO_W_SingleTapOnInt1>
 8005b1a:	b908      	cbnz	r0, 8005b20 <LSM6DSL_X_Disable_Single_Tap_Detection+0x10>
    return COMPONENT_ERROR;
 8005b1c:	2001      	movs	r0, #1
 8005b1e:	bd10      	pop	{r4, pc}
  if ( LSM6DSL_ACC_GYRO_W_SingleTapOnInt2( (void *)handle, LSM6DSL_ACC_GYRO_INT2_SINGLE_TAP_DISABLED ) == MEMS_ERROR )
 8005b20:	2100      	movs	r1, #0
 8005b22:	4620      	mov	r0, r4
 8005b24:	f7ff f924 	bl	8004d70 <LSM6DSL_ACC_GYRO_W_SingleTapOnInt2>
 8005b28:	2800      	cmp	r0, #0
 8005b2a:	d0f7      	beq.n	8005b1c <LSM6DSL_X_Disable_Single_Tap_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSL_ACC_GYRO_BASIC_INT_DISABLED ) == MEMS_ERROR )
 8005b2c:	2100      	movs	r1, #0
 8005b2e:	4620      	mov	r0, r4
 8005b30:	f7fe fdc8 	bl	80046c4 <LSM6DSL_ACC_GYRO_W_BASIC_INT>
 8005b34:	2800      	cmp	r0, #0
 8005b36:	d0f1      	beq.n	8005b1c <LSM6DSL_X_Disable_Single_Tap_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_TAP_THS( (void *)handle, thr ) == MEMS_ERROR )
 8005b38:	2100      	movs	r1, #0
 8005b3a:	4620      	mov	r0, r4
 8005b3c:	f7fe fde4 	bl	8004708 <LSM6DSL_ACC_GYRO_W_TAP_THS>
 8005b40:	2800      	cmp	r0, #0
 8005b42:	d0eb      	beq.n	8005b1c <LSM6DSL_X_Disable_Single_Tap_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_SHOCK_Duration( (void *)handle, time ) == MEMS_ERROR )
 8005b44:	2100      	movs	r1, #0
 8005b46:	4620      	mov	r0, r4
 8005b48:	f7fe fe24 	bl	8004794 <LSM6DSL_ACC_GYRO_W_SHOCK_Duration>
 8005b4c:	2800      	cmp	r0, #0
 8005b4e:	d0e5      	beq.n	8005b1c <LSM6DSL_X_Disable_Single_Tap_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_QUIET_Duration( (void *)handle, time ) == MEMS_ERROR )
 8005b50:	2100      	movs	r1, #0
 8005b52:	4620      	mov	r0, r4
 8005b54:	f7fe fe42 	bl	80047dc <LSM6DSL_ACC_GYRO_W_QUIET_Duration>
 8005b58:	2800      	cmp	r0, #0
 8005b5a:	d0df      	beq.n	8005b1c <LSM6DSL_X_Disable_Single_Tap_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_TAP_Z_EN( (void *)handle, LSM6DSL_ACC_GYRO_TAP_Z_EN_DISABLED ) == MEMS_ERROR )
 8005b5c:	2100      	movs	r1, #0
 8005b5e:	4620      	mov	r0, r4
 8005b60:	f7fe fd4a 	bl	80045f8 <LSM6DSL_ACC_GYRO_W_TAP_Z_EN>
 8005b64:	2800      	cmp	r0, #0
 8005b66:	d0d9      	beq.n	8005b1c <LSM6DSL_X_Disable_Single_Tap_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_TAP_Y_EN( (void *)handle, LSM6DSL_ACC_GYRO_TAP_Y_EN_DISABLED ) == MEMS_ERROR )
 8005b68:	2100      	movs	r1, #0
 8005b6a:	4620      	mov	r0, r4
 8005b6c:	f7fe fd66 	bl	800463c <LSM6DSL_ACC_GYRO_W_TAP_Y_EN>
 8005b70:	2800      	cmp	r0, #0
 8005b72:	d0d3      	beq.n	8005b1c <LSM6DSL_X_Disable_Single_Tap_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_TAP_X_EN( (void *)handle, LSM6DSL_ACC_GYRO_TAP_X_EN_DISABLED ) == MEMS_ERROR )
 8005b74:	4620      	mov	r0, r4
 8005b76:	2100      	movs	r1, #0
 8005b78:	f7fe fd82 	bl	8004680 <LSM6DSL_ACC_GYRO_W_TAP_X_EN>
    return COMPONENT_ERROR;
 8005b7c:	fab0 f080 	clz	r0, r0
 8005b80:	0940      	lsrs	r0, r0, #5
 8005b82:	bd10      	pop	{r4, pc}

08005b84 <LSM6DSL_X_Disable_Wake_Up_Detection>:
{
 8005b84:	b510      	push	{r4, lr}
  if ( LSM6DSL_ACC_GYRO_W_WUEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_WU_DISABLED ) == MEMS_ERROR )
 8005b86:	2100      	movs	r1, #0
{
 8005b88:	4604      	mov	r4, r0
  if ( LSM6DSL_ACC_GYRO_W_WUEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_WU_DISABLED ) == MEMS_ERROR )
 8005b8a:	f7ff f803 	bl	8004b94 <LSM6DSL_ACC_GYRO_W_WUEvOnInt1>
 8005b8e:	b908      	cbnz	r0, 8005b94 <LSM6DSL_X_Disable_Wake_Up_Detection+0x10>
    return COMPONENT_ERROR;
 8005b90:	2001      	movs	r0, #1
 8005b92:	bd10      	pop	{r4, pc}
  if ( LSM6DSL_ACC_GYRO_W_WUEvOnInt2( (void *)handle, LSM6DSL_ACC_GYRO_INT2_WU_DISABLED ) == MEMS_ERROR )
 8005b94:	2100      	movs	r1, #0
 8005b96:	4620      	mov	r0, r4
 8005b98:	f7ff f8c8 	bl	8004d2c <LSM6DSL_ACC_GYRO_W_WUEvOnInt2>
 8005b9c:	2800      	cmp	r0, #0
 8005b9e:	d0f7      	beq.n	8005b90 <LSM6DSL_X_Disable_Wake_Up_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSL_ACC_GYRO_BASIC_INT_DISABLED ) == MEMS_ERROR )
 8005ba0:	2100      	movs	r1, #0
 8005ba2:	4620      	mov	r0, r4
 8005ba4:	f7fe fd8e 	bl	80046c4 <LSM6DSL_ACC_GYRO_W_BASIC_INT>
 8005ba8:	2800      	cmp	r0, #0
 8005baa:	d0f1      	beq.n	8005b90 <LSM6DSL_X_Disable_Wake_Up_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_WAKE_DUR( (void *)handle, 0x00 ) == MEMS_ERROR )
 8005bac:	2100      	movs	r1, #0
 8005bae:	4620      	mov	r0, r4
 8005bb0:	f7fe fee6 	bl	8004980 <LSM6DSL_ACC_GYRO_W_WAKE_DUR>
 8005bb4:	2800      	cmp	r0, #0
 8005bb6:	d0eb      	beq.n	8005b90 <LSM6DSL_X_Disable_Wake_Up_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_WK_THS( (void *)handle, 0x00 ) == MEMS_ERROR )
 8005bb8:	4620      	mov	r0, r4
 8005bba:	2100      	movs	r1, #0
 8005bbc:	f7fe fe54 	bl	8004868 <LSM6DSL_ACC_GYRO_W_WK_THS>
    return COMPONENT_ERROR;
 8005bc0:	fab0 f080 	clz	r0, r0
 8005bc4:	0940      	lsrs	r0, r0, #5
}
 8005bc6:	bd10      	pop	{r4, pc}

08005bc8 <LSM6DSL_X_Disable_Tilt_Detection>:
{
 8005bc8:	b510      	push	{r4, lr}
  if ( LSM6DSL_ACC_GYRO_W_TiltEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_TILT_DISABLED ) == MEMS_ERROR )
 8005bca:	2100      	movs	r1, #0
{
 8005bcc:	4604      	mov	r4, r0
  if ( LSM6DSL_ACC_GYRO_W_TiltEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_TILT_DISABLED ) == MEMS_ERROR )
 8005bce:	f7fe ff59 	bl	8004a84 <LSM6DSL_ACC_GYRO_W_TiltEvOnInt1>
 8005bd2:	b908      	cbnz	r0, 8005bd8 <LSM6DSL_X_Disable_Tilt_Detection+0x10>
    return COMPONENT_ERROR;
 8005bd4:	2001      	movs	r0, #1
 8005bd6:	bd10      	pop	{r4, pc}
  if ( LSM6DSL_ACC_GYRO_W_TiltEvOnInt2( (void *)handle, LSM6DSL_ACC_GYRO_INT2_TILT_DISABLED ) == MEMS_ERROR )
 8005bd8:	2100      	movs	r1, #0
 8005bda:	4620      	mov	r0, r4
 8005bdc:	f7ff f81e 	bl	8004c1c <LSM6DSL_ACC_GYRO_W_TiltEvOnInt2>
 8005be0:	2800      	cmp	r0, #0
 8005be2:	d0f7      	beq.n	8005bd4 <LSM6DSL_X_Disable_Tilt_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_TILT( (void *)handle, LSM6DSL_ACC_GYRO_TILT_DISABLED ) == MEMS_ERROR )
 8005be4:	2100      	movs	r1, #0
 8005be6:	4620      	mov	r0, r4
 8005be8:	f7fe fb1a 	bl	8004220 <LSM6DSL_ACC_GYRO_W_TILT>
 8005bec:	2800      	cmp	r0, #0
 8005bee:	d0f1      	beq.n	8005bd4 <LSM6DSL_X_Disable_Tilt_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_FUNC_EN( (void *)handle, LSM6DSL_ACC_GYRO_FUNC_EN_DISABLED ) == MEMS_ERROR )
 8005bf0:	4620      	mov	r0, r4
 8005bf2:	2100      	movs	r1, #0
 8005bf4:	f7fe fb58 	bl	80042a8 <LSM6DSL_ACC_GYRO_W_FUNC_EN>
    return COMPONENT_ERROR;
 8005bf8:	fab0 f080 	clz	r0, r0
 8005bfc:	0940      	lsrs	r0, r0, #5
}
 8005bfe:	bd10      	pop	{r4, pc}

08005c00 <LSM6DSL_X_Disable_Pedometer>:
{
 8005c00:	b510      	push	{r4, lr}
  if ( LSM6DSL_ACC_GYRO_W_STEP_DET_on_INT1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_PEDO_DISABLED ) == MEMS_ERROR )
 8005c02:	2100      	movs	r1, #0
{
 8005c04:	4604      	mov	r4, r0
  if ( LSM6DSL_ACC_GYRO_W_STEP_DET_on_INT1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_PEDO_DISABLED ) == MEMS_ERROR )
 8005c06:	f7fe fa61 	bl	80040cc <LSM6DSL_ACC_GYRO_W_STEP_DET_on_INT1>
 8005c0a:	b908      	cbnz	r0, 8005c10 <LSM6DSL_X_Disable_Pedometer+0x10>
    return COMPONENT_ERROR;
 8005c0c:	2001      	movs	r0, #1
 8005c0e:	bd10      	pop	{r4, pc}
  if ( LSM6DSL_ACC_GYRO_W_PEDO( (void *)handle, LSM6DSL_ACC_GYRO_PEDO_DISABLED ) == MEMS_ERROR )
 8005c10:	2100      	movs	r1, #0
 8005c12:	4620      	mov	r0, r4
 8005c14:	f7fe fb26 	bl	8004264 <LSM6DSL_ACC_GYRO_W_PEDO>
 8005c18:	2800      	cmp	r0, #0
 8005c1a:	d0f7      	beq.n	8005c0c <LSM6DSL_X_Disable_Pedometer+0xc>
  if ( LSM6DSL_ACC_GYRO_W_FUNC_EN( (void *)handle, LSM6DSL_ACC_GYRO_FUNC_EN_DISABLED ) == MEMS_ERROR )
 8005c1c:	2100      	movs	r1, #0
 8005c1e:	4620      	mov	r0, r4
 8005c20:	f7fe fb42 	bl	80042a8 <LSM6DSL_ACC_GYRO_W_FUNC_EN>
 8005c24:	2800      	cmp	r0, #0
 8005c26:	d0f1      	beq.n	8005c0c <LSM6DSL_X_Disable_Pedometer+0xc>
  if ( LSM6DSL_ACC_GYRO_W_PedoThreshold( (void *)handle, thr ) == MEMS_ERROR )
 8005c28:	4620      	mov	r0, r4
 8005c2a:	2100      	movs	r1, #0
 8005c2c:	f7ff f8ee 	bl	8004e0c <LSM6DSL_ACC_GYRO_W_PedoThreshold>
    return COMPONENT_ERROR;
 8005c30:	fab0 f080 	clz	r0, r0
 8005c34:	0940      	lsrs	r0, r0, #5
}
 8005c36:	bd10      	pop	{r4, pc}

08005c38 <LSM6DSL_X_Disable_Free_Fall_Detection>:
{
 8005c38:	b510      	push	{r4, lr}
  if ( LSM6DSL_ACC_GYRO_W_FFEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_FF_DISABLED ) == MEMS_ERROR )
 8005c3a:	2100      	movs	r1, #0
{
 8005c3c:	4604      	mov	r4, r0
  if ( LSM6DSL_ACC_GYRO_W_FFEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_FF_DISABLED ) == MEMS_ERROR )
 8005c3e:	f7fe ff87 	bl	8004b50 <LSM6DSL_ACC_GYRO_W_FFEvOnInt1>
 8005c42:	b908      	cbnz	r0, 8005c48 <LSM6DSL_X_Disable_Free_Fall_Detection+0x10>
    return COMPONENT_ERROR;
 8005c44:	2001      	movs	r0, #1
 8005c46:	bd10      	pop	{r4, pc}
  if ( LSM6DSL_ACC_GYRO_W_FFEvOnInt2( (void *)handle, LSM6DSL_ACC_GYRO_INT2_FF_DISABLED ) == MEMS_ERROR )
 8005c48:	2100      	movs	r1, #0
 8005c4a:	4620      	mov	r0, r4
 8005c4c:	f7ff f84c 	bl	8004ce8 <LSM6DSL_ACC_GYRO_W_FFEvOnInt2>
 8005c50:	2800      	cmp	r0, #0
 8005c52:	d0f7      	beq.n	8005c44 <LSM6DSL_X_Disable_Free_Fall_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSL_ACC_GYRO_BASIC_INT_DISABLED ) == MEMS_ERROR )
 8005c54:	2100      	movs	r1, #0
 8005c56:	4620      	mov	r0, r4
 8005c58:	f7fe fd34 	bl	80046c4 <LSM6DSL_ACC_GYRO_W_BASIC_INT>
 8005c5c:	2800      	cmp	r0, #0
 8005c5e:	d0f1      	beq.n	8005c44 <LSM6DSL_X_Disable_Free_Fall_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_FF_Duration( (void *)handle, 0x00 ) == MEMS_ERROR )
 8005c60:	2100      	movs	r1, #0
 8005c62:	4620      	mov	r0, r4
 8005c64:	f7fe fed2 	bl	8004a0c <LSM6DSL_ACC_GYRO_W_FF_Duration>
 8005c68:	2800      	cmp	r0, #0
 8005c6a:	d0eb      	beq.n	8005c44 <LSM6DSL_X_Disable_Free_Fall_Detection+0xc>
  if ( LSM6DSL_ACC_GYRO_W_FF_THS( (void *)handle, LSM6DSL_ACC_GYRO_FF_THS_156mg ) == MEMS_ERROR )
 8005c6c:	4620      	mov	r0, r4
 8005c6e:	2100      	movs	r1, #0
 8005c70:	f7fe feaa 	bl	80049c8 <LSM6DSL_ACC_GYRO_W_FF_THS>
    return COMPONENT_ERROR;
 8005c74:	fab0 f080 	clz	r0, r0
 8005c78:	0940      	lsrs	r0, r0, #5
}
 8005c7a:	bd10      	pop	{r4, pc}

08005c7c <LSM6DSL_G_Set_SelfTest>:
 * @param status self-test enable/disable
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
*/
static DrvStatusTypeDef LSM6DSL_G_Set_SelfTest( DrvContextTypeDef *handle, uint8_t status )
{
 8005c7c:	290c      	cmp	r1, #12
 8005c7e:	d809      	bhi.n	8005c94 <LSM6DSL_G_Set_SelfTest+0x18>
 8005c80:	2301      	movs	r3, #1
 8005c82:	b510      	push	{r4, lr}
 8005c84:	fa03 f201 	lsl.w	r2, r3, r1
 8005c88:	f241 1411 	movw	r4, #4369	; 0x1111
 8005c8c:	4222      	tst	r2, r4
 8005c8e:	d103      	bne.n	8005c98 <LSM6DSL_G_Set_SelfTest+0x1c>
    case LSM6DSL_ACC_GYRO_ST_G_POS_SIGN_TEST:
    case LSM6DSL_ACC_GYRO_ST_G_NA:
    case LSM6DSL_ACC_GYRO_ST_G_NEG_SIGN_TEST:
      break;
    default:
      return COMPONENT_ERROR;
 8005c90:	4618      	mov	r0, r3
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8005c92:	bd10      	pop	{r4, pc}
      return COMPONENT_ERROR;
 8005c94:	2001      	movs	r0, #1
 8005c96:	4770      	bx	lr
  if ( LSM6DSL_ACC_GYRO_W_SelfTest_G( handle, ( LSM6DSL_ACC_GYRO_ST_G_t )status ) == MEMS_ERROR )
 8005c98:	f7fe fa7e 	bl	8004198 <LSM6DSL_ACC_GYRO_W_SelfTest_G>
      return COMPONENT_ERROR;
 8005c9c:	fab0 f080 	clz	r0, r0
 8005ca0:	0940      	lsrs	r0, r0, #5
 8005ca2:	bd10      	pop	{r4, pc}

08005ca4 <LSM6DSL_G_Get_Sensitivity>:
{
 8005ca4:	b530      	push	{r4, r5, lr}
 8005ca6:	b083      	sub	sp, #12
 8005ca8:	460c      	mov	r4, r1
  if ( LSM6DSL_ACC_GYRO_R_FS_125( (void *)handle, &fullScale125 ) == MEMS_ERROR )
 8005caa:	f10d 0106 	add.w	r1, sp, #6
{
 8005cae:	4605      	mov	r5, r0
  if ( LSM6DSL_ACC_GYRO_R_FS_125( (void *)handle, &fullScale125 ) == MEMS_ERROR )
 8005cb0:	f7fe f8fa 	bl	8003ea8 <LSM6DSL_ACC_GYRO_R_FS_125>
 8005cb4:	b1b0      	cbz	r0, 8005ce4 <LSM6DSL_G_Get_Sensitivity+0x40>
  if ( fullScale125 == LSM6DSL_ACC_GYRO_FS_125_ENABLED )
 8005cb6:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8005cba:	2b02      	cmp	r3, #2
 8005cbc:	d015      	beq.n	8005cea <LSM6DSL_G_Get_Sensitivity+0x46>
    if ( LSM6DSL_ACC_GYRO_R_FS_G( (void *)handle, &fullScale ) == MEMS_ERROR )
 8005cbe:	4628      	mov	r0, r5
 8005cc0:	f10d 0107 	add.w	r1, sp, #7
 8005cc4:	f7fe f86c 	bl	8003da0 <LSM6DSL_ACC_GYRO_R_FS_G>
 8005cc8:	b160      	cbz	r0, 8005ce4 <LSM6DSL_G_Get_Sensitivity+0x40>
    switch( fullScale )
 8005cca:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8005cce:	2b0c      	cmp	r3, #12
 8005cd0:	d820      	bhi.n	8005d14 <LSM6DSL_G_Get_Sensitivity+0x70>
 8005cd2:	e8df f003 	tbb	[pc, r3]
 8005cd6:	1f13      	.short	0x1f13
 8005cd8:	1f171f1f 	.word	0x1f171f1f
 8005cdc:	1f1b1f1f 	.word	0x1f1b1f1f
 8005ce0:	1f1f      	.short	0x1f1f
 8005ce2:	0f          	.byte	0x0f
 8005ce3:	00          	.byte	0x00
    return COMPONENT_ERROR;
 8005ce4:	2001      	movs	r0, #1
}
 8005ce6:	b003      	add	sp, #12
 8005ce8:	bd30      	pop	{r4, r5, pc}
    *sensitivity = ( float )LSM6DSL_GYRO_SENSITIVITY_FOR_FS_125DPS;
 8005cea:	4b0c      	ldr	r3, [pc, #48]	; (8005d1c <LSM6DSL_G_Get_Sensitivity+0x78>)
 8005cec:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8005cee:	2000      	movs	r0, #0
}
 8005cf0:	b003      	add	sp, #12
 8005cf2:	bd30      	pop	{r4, r5, pc}
        *sensitivity = ( float )LSM6DSL_GYRO_SENSITIVITY_FOR_FS_2000DPS;
 8005cf4:	4b0a      	ldr	r3, [pc, #40]	; (8005d20 <LSM6DSL_G_Get_Sensitivity+0x7c>)
 8005cf6:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8005cf8:	2000      	movs	r0, #0
 8005cfa:	e7f4      	b.n	8005ce6 <LSM6DSL_G_Get_Sensitivity+0x42>
        *sensitivity = ( float )LSM6DSL_GYRO_SENSITIVITY_FOR_FS_245DPS;
 8005cfc:	4b09      	ldr	r3, [pc, #36]	; (8005d24 <LSM6DSL_G_Get_Sensitivity+0x80>)
 8005cfe:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8005d00:	2000      	movs	r0, #0
 8005d02:	e7f0      	b.n	8005ce6 <LSM6DSL_G_Get_Sensitivity+0x42>
        *sensitivity = ( float )LSM6DSL_GYRO_SENSITIVITY_FOR_FS_500DPS;
 8005d04:	4b08      	ldr	r3, [pc, #32]	; (8005d28 <LSM6DSL_G_Get_Sensitivity+0x84>)
 8005d06:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8005d08:	2000      	movs	r0, #0
 8005d0a:	e7ec      	b.n	8005ce6 <LSM6DSL_G_Get_Sensitivity+0x42>
        *sensitivity = ( float )LSM6DSL_GYRO_SENSITIVITY_FOR_FS_1000DPS;
 8005d0c:	4b07      	ldr	r3, [pc, #28]	; (8005d2c <LSM6DSL_G_Get_Sensitivity+0x88>)
 8005d0e:	6023      	str	r3, [r4, #0]
  return COMPONENT_OK;
 8005d10:	2000      	movs	r0, #0
 8005d12:	e7e8      	b.n	8005ce6 <LSM6DSL_G_Get_Sensitivity+0x42>
        *sensitivity = -1.0f;
 8005d14:	4b06      	ldr	r3, [pc, #24]	; (8005d30 <LSM6DSL_G_Get_Sensitivity+0x8c>)
 8005d16:	6023      	str	r3, [r4, #0]
        return COMPONENT_ERROR;
 8005d18:	2001      	movs	r0, #1
 8005d1a:	e7e4      	b.n	8005ce6 <LSM6DSL_G_Get_Sensitivity+0x42>
 8005d1c:	408c0000 	.word	0x408c0000
 8005d20:	428c0000 	.word	0x428c0000
 8005d24:	410c0000 	.word	0x410c0000
 8005d28:	418c0000 	.word	0x418c0000
 8005d2c:	420c0000 	.word	0x420c0000
 8005d30:	bf800000 	.word	0xbf800000

08005d34 <LSM6DSL_FIFO_G_Set_Decimation>:
{
 8005d34:	b508      	push	{r3, lr}
  switch ( ( LSM6DSL_ACC_GYRO_DEC_FIFO_G_t )decimation )
 8005d36:	2938      	cmp	r1, #56	; 0x38
 8005d38:	d81e      	bhi.n	8005d78 <LSM6DSL_FIFO_G_Set_Decimation+0x44>
 8005d3a:	e8df f001 	tbb	[pc, r1]
 8005d3e:	1d1f      	.short	0x1d1f
 8005d40:	1d1d1d1d 	.word	0x1d1d1d1d
 8005d44:	1d1f1d1d 	.word	0x1d1f1d1d
 8005d48:	1d1d1d1d 	.word	0x1d1d1d1d
 8005d4c:	1d1f1d1d 	.word	0x1d1f1d1d
 8005d50:	1d1d1d1d 	.word	0x1d1d1d1d
 8005d54:	1d1f1d1d 	.word	0x1d1f1d1d
 8005d58:	1d1d1d1d 	.word	0x1d1d1d1d
 8005d5c:	1d1f1d1d 	.word	0x1d1f1d1d
 8005d60:	1d1d1d1d 	.word	0x1d1d1d1d
 8005d64:	1d1f1d1d 	.word	0x1d1f1d1d
 8005d68:	1d1d1d1d 	.word	0x1d1d1d1d
 8005d6c:	1d1f1d1d 	.word	0x1d1f1d1d
 8005d70:	1d1d1d1d 	.word	0x1d1d1d1d
 8005d74:	1d1d      	.short	0x1d1d
 8005d76:	1f          	.byte	0x1f
 8005d77:	00          	.byte	0x00
      return COMPONENT_ERROR;
 8005d78:	2001      	movs	r0, #1
}
 8005d7a:	bd08      	pop	{r3, pc}
  if ( LSM6DSL_ACC_GYRO_W_DEC_FIFO_G( handle, ( LSM6DSL_ACC_GYRO_DEC_FIFO_G_t )decimation ) == MEMS_ERROR )
 8005d7c:	f7fe f8fc 	bl	8003f78 <LSM6DSL_ACC_GYRO_W_DEC_FIFO_G>
      return COMPONENT_ERROR;
 8005d80:	fab0 f080 	clz	r0, r0
 8005d84:	0940      	lsrs	r0, r0, #5
 8005d86:	bd08      	pop	{r3, pc}

08005d88 <LSM6DSL_G_Set_FS_Value>:
  if ( fullScale <= 125.0f )
 8005d88:	eddf 7a1f 	vldr	s15, [pc, #124]	; 8005e08 <LSM6DSL_G_Set_FS_Value+0x80>
 8005d8c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005d90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 8005d94:	b538      	push	{r3, r4, r5, lr}
  if ( fullScale <= 125.0f )
 8005d96:	d925      	bls.n	8005de4 <LSM6DSL_G_Set_FS_Value+0x5c>
             : ( fullScale <=  500.0f ) ? LSM6DSL_ACC_GYRO_FS_G_500dps
 8005d98:	eddf 7a1c 	vldr	s15, [pc, #112]	; 8005e0c <LSM6DSL_G_Set_FS_Value+0x84>
 8005d9c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005da0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005da4:	4604      	mov	r4, r0
 8005da6:	d807      	bhi.n	8005db8 <LSM6DSL_G_Set_FS_Value+0x30>
 8005da8:	2500      	movs	r5, #0
    if ( LSM6DSL_ACC_GYRO_W_FS_125( (void *)handle, LSM6DSL_ACC_GYRO_FS_125_DISABLED ) == MEMS_ERROR )
 8005daa:	2100      	movs	r1, #0
 8005dac:	4620      	mov	r0, r4
 8005dae:	f7fe f859 	bl	8003e64 <LSM6DSL_ACC_GYRO_W_FS_125>
 8005db2:	b978      	cbnz	r0, 8005dd4 <LSM6DSL_G_Set_FS_Value+0x4c>
      return COMPONENT_ERROR;
 8005db4:	2001      	movs	r0, #1
}
 8005db6:	bd38      	pop	{r3, r4, r5, pc}
             : ( fullScale <=  500.0f ) ? LSM6DSL_ACC_GYRO_FS_G_500dps
 8005db8:	eddf 7a15 	vldr	s15, [pc, #84]	; 8005e10 <LSM6DSL_G_Set_FS_Value+0x88>
 8005dbc:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005dc0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005dc4:	d815      	bhi.n	8005df2 <LSM6DSL_G_Set_FS_Value+0x6a>
    if ( LSM6DSL_ACC_GYRO_W_FS_125( (void *)handle, LSM6DSL_ACC_GYRO_FS_125_DISABLED ) == MEMS_ERROR )
 8005dc6:	2100      	movs	r1, #0
 8005dc8:	4620      	mov	r0, r4
             : ( fullScale <=  500.0f ) ? LSM6DSL_ACC_GYRO_FS_G_500dps
 8005dca:	2504      	movs	r5, #4
    if ( LSM6DSL_ACC_GYRO_W_FS_125( (void *)handle, LSM6DSL_ACC_GYRO_FS_125_DISABLED ) == MEMS_ERROR )
 8005dcc:	f7fe f84a 	bl	8003e64 <LSM6DSL_ACC_GYRO_W_FS_125>
 8005dd0:	2800      	cmp	r0, #0
 8005dd2:	d0ef      	beq.n	8005db4 <LSM6DSL_G_Set_FS_Value+0x2c>
    if ( LSM6DSL_ACC_GYRO_W_FS_G( (void *)handle, new_fs ) == MEMS_ERROR )
 8005dd4:	4629      	mov	r1, r5
 8005dd6:	4620      	mov	r0, r4
 8005dd8:	f7fd ffc0 	bl	8003d5c <LSM6DSL_ACC_GYRO_W_FS_G>
  return COMPONENT_OK;
 8005ddc:	fab0 f080 	clz	r0, r0
 8005de0:	0940      	lsrs	r0, r0, #5
 8005de2:	bd38      	pop	{r3, r4, r5, pc}
    if ( LSM6DSL_ACC_GYRO_W_FS_125( (void *)handle, LSM6DSL_ACC_GYRO_FS_125_ENABLED ) == MEMS_ERROR )
 8005de4:	2102      	movs	r1, #2
 8005de6:	f7fe f83d 	bl	8003e64 <LSM6DSL_ACC_GYRO_W_FS_125>
  return COMPONENT_OK;
 8005dea:	fab0 f080 	clz	r0, r0
 8005dee:	0940      	lsrs	r0, r0, #5
 8005df0:	bd38      	pop	{r3, r4, r5, pc}
             : ( fullScale <=  500.0f ) ? LSM6DSL_ACC_GYRO_FS_G_500dps
 8005df2:	eddf 7a08 	vldr	s15, [pc, #32]	; 8005e14 <LSM6DSL_G_Set_FS_Value+0x8c>
 8005df6:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005dfa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005dfe:	bf94      	ite	ls
 8005e00:	2508      	movls	r5, #8
 8005e02:	250c      	movhi	r5, #12
 8005e04:	e7d1      	b.n	8005daa <LSM6DSL_G_Set_FS_Value+0x22>
 8005e06:	bf00      	nop
 8005e08:	42fa0000 	.word	0x42fa0000
 8005e0c:	43750000 	.word	0x43750000
 8005e10:	43fa0000 	.word	0x43fa0000
 8005e14:	447a0000 	.word	0x447a0000

08005e18 <LSM6DSL_G_Set_ODR_Value>:
{
 8005e18:	b508      	push	{r3, lr}
  if(handle->isEnabled == 1)
 8005e1a:	7983      	ldrb	r3, [r0, #6]
 8005e1c:	2b01      	cmp	r3, #1
 8005e1e:	d048      	beq.n	8005eb2 <LSM6DSL_G_Set_ODR_Value+0x9a>
                                 : ( odr <=  26.0f )  ? 26.0f
 8005e20:	eef2 7a0a 	vmov.f32	s15, #42	; 0x41500000  13.0
  LSM6DSL_G_Data_t *pComponentData = ( LSM6DSL_G_Data_t * )pData->pComponentData;
 8005e24:	6883      	ldr	r3, [r0, #8]
                                 : ( odr <=  26.0f )  ? 26.0f
 8005e26:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005e2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  LSM6DSL_G_Data_t *pComponentData = ( LSM6DSL_G_Data_t * )pData->pComponentData;
 8005e2e:	681b      	ldr	r3, [r3, #0]
                                 : ( odr <=  26.0f )  ? 26.0f
 8005e30:	d93b      	bls.n	8005eaa <LSM6DSL_G_Set_ODR_Value+0x92>
                                 : ( odr <=  52.0f )  ? 52.0f
 8005e32:	eef3 7a0a 	vmov.f32	s15, #58	; 0x41d00000  26.0
 8005e36:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005e3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005e3e:	d934      	bls.n	8005eaa <LSM6DSL_G_Set_ODR_Value+0x92>
                                 : ( odr <= 104.0f )  ? 104.0f
 8005e40:	eddf 7a47 	vldr	s15, [pc, #284]	; 8005f60 <LSM6DSL_G_Set_ODR_Value+0x148>
 8005e44:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005e48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005e4c:	d92d      	bls.n	8005eaa <LSM6DSL_G_Set_ODR_Value+0x92>
                                 : ( odr <= 208.0f )  ? 208.0f
 8005e4e:	eddf 7a45 	vldr	s15, [pc, #276]	; 8005f64 <LSM6DSL_G_Set_ODR_Value+0x14c>
 8005e52:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005e56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005e5a:	d926      	bls.n	8005eaa <LSM6DSL_G_Set_ODR_Value+0x92>
                                 : ( odr <= 416.0f )  ? 416.0f
 8005e5c:	eddf 7a42 	vldr	s15, [pc, #264]	; 8005f68 <LSM6DSL_G_Set_ODR_Value+0x150>
 8005e60:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005e64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005e68:	d91f      	bls.n	8005eaa <LSM6DSL_G_Set_ODR_Value+0x92>
                                 : ( odr <= 833.0f )  ? 833.0f
 8005e6a:	eddf 7a40 	vldr	s15, [pc, #256]	; 8005f6c <LSM6DSL_G_Set_ODR_Value+0x154>
 8005e6e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005e72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005e76:	d918      	bls.n	8005eaa <LSM6DSL_G_Set_ODR_Value+0x92>
                                 : ( odr <= 1660.0f ) ? 1660.0f
 8005e78:	eddf 7a3d 	vldr	s15, [pc, #244]	; 8005f70 <LSM6DSL_G_Set_ODR_Value+0x158>
 8005e7c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005e80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005e84:	d911      	bls.n	8005eaa <LSM6DSL_G_Set_ODR_Value+0x92>
                                 : ( odr <= 3330.0f ) ? 3330.0f
 8005e86:	eddf 7a3b 	vldr	s15, [pc, #236]	; 8005f74 <LSM6DSL_G_Set_ODR_Value+0x15c>
 8005e8a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005e8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005e92:	d90a      	bls.n	8005eaa <LSM6DSL_G_Set_ODR_Value+0x92>
                                 :                      6660.0f;
 8005e94:	eddf 7a38 	vldr	s15, [pc, #224]	; 8005f78 <LSM6DSL_G_Set_ODR_Value+0x160>
 8005e98:	ed9f 7a38 	vldr	s14, [pc, #224]	; 8005f7c <LSM6DSL_G_Set_ODR_Value+0x164>
 8005e9c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005ea0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005ea4:	bf88      	it	hi
 8005ea6:	eef0 7a47 	vmovhi.f32	s15, s14
  pComponentData->Previous_ODR = ( odr <=  13.0f )  ? 13.0f
 8005eaa:	edc3 7a01 	vstr	s15, [r3, #4]
  return COMPONENT_OK;
 8005eae:	2000      	movs	r0, #0
}
 8005eb0:	bd08      	pop	{r3, pc}
            : ( odr <=  26.0f )  ? LSM6DSL_ACC_GYRO_ODR_G_26Hz
 8005eb2:	eef2 7a0a 	vmov.f32	s15, #42	; 0x41500000  13.0
 8005eb6:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005eba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005ebe:	d806      	bhi.n	8005ece <LSM6DSL_G_Set_ODR_Value+0xb6>
 8005ec0:	2110      	movs	r1, #16
  if ( LSM6DSL_ACC_GYRO_W_ODR_G( (void *)handle, new_odr ) == MEMS_ERROR )
 8005ec2:	f7fd ff9d 	bl	8003e00 <LSM6DSL_ACC_GYRO_W_ODR_G>
      return COMPONENT_ERROR;
 8005ec6:	fab0 f080 	clz	r0, r0
 8005eca:	0940      	lsrs	r0, r0, #5
 8005ecc:	bd08      	pop	{r3, pc}
            : ( odr <=  26.0f )  ? LSM6DSL_ACC_GYRO_ODR_G_26Hz
 8005ece:	eef3 7a0a 	vmov.f32	s15, #58	; 0x41d00000  26.0
 8005ed2:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005ed6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005eda:	d933      	bls.n	8005f44 <LSM6DSL_G_Set_ODR_Value+0x12c>
 8005edc:	eddf 7a20 	vldr	s15, [pc, #128]	; 8005f60 <LSM6DSL_G_Set_ODR_Value+0x148>
 8005ee0:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005ee4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005ee8:	d92e      	bls.n	8005f48 <LSM6DSL_G_Set_ODR_Value+0x130>
 8005eea:	eddf 7a1e 	vldr	s15, [pc, #120]	; 8005f64 <LSM6DSL_G_Set_ODR_Value+0x14c>
 8005eee:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005ef2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005ef6:	d929      	bls.n	8005f4c <LSM6DSL_G_Set_ODR_Value+0x134>
 8005ef8:	eddf 7a1b 	vldr	s15, [pc, #108]	; 8005f68 <LSM6DSL_G_Set_ODR_Value+0x150>
 8005efc:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005f00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005f04:	d924      	bls.n	8005f50 <LSM6DSL_G_Set_ODR_Value+0x138>
 8005f06:	eddf 7a19 	vldr	s15, [pc, #100]	; 8005f6c <LSM6DSL_G_Set_ODR_Value+0x154>
 8005f0a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005f0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005f12:	d91f      	bls.n	8005f54 <LSM6DSL_G_Set_ODR_Value+0x13c>
 8005f14:	eddf 7a16 	vldr	s15, [pc, #88]	; 8005f70 <LSM6DSL_G_Set_ODR_Value+0x158>
 8005f18:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005f1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005f20:	d91a      	bls.n	8005f58 <LSM6DSL_G_Set_ODR_Value+0x140>
 8005f22:	eddf 7a14 	vldr	s15, [pc, #80]	; 8005f74 <LSM6DSL_G_Set_ODR_Value+0x15c>
 8005f26:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005f2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005f2e:	d915      	bls.n	8005f5c <LSM6DSL_G_Set_ODR_Value+0x144>
 8005f30:	eddf 7a11 	vldr	s15, [pc, #68]	; 8005f78 <LSM6DSL_G_Set_ODR_Value+0x160>
 8005f34:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005f38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005f3c:	bf94      	ite	ls
 8005f3e:	2190      	movls	r1, #144	; 0x90
 8005f40:	21a0      	movhi	r1, #160	; 0xa0
 8005f42:	e7be      	b.n	8005ec2 <LSM6DSL_G_Set_ODR_Value+0xaa>
 8005f44:	2120      	movs	r1, #32
 8005f46:	e7bc      	b.n	8005ec2 <LSM6DSL_G_Set_ODR_Value+0xaa>
 8005f48:	2130      	movs	r1, #48	; 0x30
 8005f4a:	e7ba      	b.n	8005ec2 <LSM6DSL_G_Set_ODR_Value+0xaa>
 8005f4c:	2140      	movs	r1, #64	; 0x40
 8005f4e:	e7b8      	b.n	8005ec2 <LSM6DSL_G_Set_ODR_Value+0xaa>
 8005f50:	2150      	movs	r1, #80	; 0x50
 8005f52:	e7b6      	b.n	8005ec2 <LSM6DSL_G_Set_ODR_Value+0xaa>
 8005f54:	2160      	movs	r1, #96	; 0x60
 8005f56:	e7b4      	b.n	8005ec2 <LSM6DSL_G_Set_ODR_Value+0xaa>
 8005f58:	2170      	movs	r1, #112	; 0x70
 8005f5a:	e7b2      	b.n	8005ec2 <LSM6DSL_G_Set_ODR_Value+0xaa>
 8005f5c:	2180      	movs	r1, #128	; 0x80
 8005f5e:	e7b0      	b.n	8005ec2 <LSM6DSL_G_Set_ODR_Value+0xaa>
 8005f60:	42500000 	.word	0x42500000
 8005f64:	42d00000 	.word	0x42d00000
 8005f68:	43500000 	.word	0x43500000
 8005f6c:	43d00000 	.word	0x43d00000
 8005f70:	44504000 	.word	0x44504000
 8005f74:	44cf8000 	.word	0x44cf8000
 8005f78:	45502000 	.word	0x45502000
 8005f7c:	45d02000 	.word	0x45d02000

08005f80 <LSM6DSL_G_Set_ODR>:
{
 8005f80:	b508      	push	{r3, lr}
  if(handle->isEnabled == 1)
 8005f82:	7983      	ldrb	r3, [r0, #6]
 8005f84:	2b01      	cmp	r3, #1
 8005f86:	d018      	beq.n	8005fba <LSM6DSL_G_Set_ODR+0x3a>
  LSM6DSL_G_Data_t *pComponentData = ( LSM6DSL_G_Data_t * )pData->pComponentData;
 8005f88:	6883      	ldr	r3, [r0, #8]
 8005f8a:	681b      	ldr	r3, [r3, #0]
  switch( odr )
 8005f8c:	2904      	cmp	r1, #4
 8005f8e:	d828      	bhi.n	8005fe2 <LSM6DSL_G_Set_ODR+0x62>
 8005f90:	e8df f001 	tbb	[pc, r1]
 8005f94:	0f0b0303 	.word	0x0f0b0303
 8005f98:	07          	.byte	0x07
 8005f99:	00          	.byte	0x00
      pComponentData->Previous_ODR = 13.0f;
 8005f9a:	4a13      	ldr	r2, [pc, #76]	; (8005fe8 <LSM6DSL_G_Set_ODR+0x68>)
 8005f9c:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 8005f9e:	2000      	movs	r0, #0
 8005fa0:	bd08      	pop	{r3, pc}
      pComponentData->Previous_ODR = 104.0f;
 8005fa2:	4a12      	ldr	r2, [pc, #72]	; (8005fec <LSM6DSL_G_Set_ODR+0x6c>)
 8005fa4:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 8005fa6:	2000      	movs	r0, #0
 8005fa8:	bd08      	pop	{r3, pc}
      pComponentData->Previous_ODR = 26.0f;
 8005faa:	4a11      	ldr	r2, [pc, #68]	; (8005ff0 <LSM6DSL_G_Set_ODR+0x70>)
 8005fac:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 8005fae:	2000      	movs	r0, #0
 8005fb0:	bd08      	pop	{r3, pc}
      pComponentData->Previous_ODR = 52.0f;
 8005fb2:	4a10      	ldr	r2, [pc, #64]	; (8005ff4 <LSM6DSL_G_Set_ODR+0x74>)
 8005fb4:	605a      	str	r2, [r3, #4]
  return COMPONENT_OK;
 8005fb6:	2000      	movs	r0, #0
 8005fb8:	bd08      	pop	{r3, pc}
  switch( odr )
 8005fba:	2904      	cmp	r1, #4
 8005fbc:	d811      	bhi.n	8005fe2 <LSM6DSL_G_Set_ODR+0x62>
 8005fbe:	e8df f001 	tbb	[pc, r1]
 8005fc2:	0303      	.short	0x0303
 8005fc4:	0a0c      	.short	0x0a0c
 8005fc6:	0e          	.byte	0x0e
 8005fc7:	00          	.byte	0x00
      new_odr = LSM6DSL_ACC_GYRO_ODR_G_13Hz;
 8005fc8:	2110      	movs	r1, #16
  if ( LSM6DSL_ACC_GYRO_W_ODR_G( (void *)handle, new_odr ) == MEMS_ERROR )
 8005fca:	f7fd ff19 	bl	8003e00 <LSM6DSL_ACC_GYRO_W_ODR_G>
  return COMPONENT_OK;
 8005fce:	fab0 f080 	clz	r0, r0
 8005fd2:	0940      	lsrs	r0, r0, #5
 8005fd4:	bd08      	pop	{r3, pc}
      new_odr = LSM6DSL_ACC_GYRO_ODR_G_52Hz;
 8005fd6:	2130      	movs	r1, #48	; 0x30
 8005fd8:	e7f7      	b.n	8005fca <LSM6DSL_G_Set_ODR+0x4a>
      new_odr = LSM6DSL_ACC_GYRO_ODR_G_26Hz;
 8005fda:	2120      	movs	r1, #32
 8005fdc:	e7f5      	b.n	8005fca <LSM6DSL_G_Set_ODR+0x4a>
      new_odr = LSM6DSL_ACC_GYRO_ODR_G_104Hz;
 8005fde:	2140      	movs	r1, #64	; 0x40
 8005fe0:	e7f3      	b.n	8005fca <LSM6DSL_G_Set_ODR+0x4a>
      return COMPONENT_ERROR;
 8005fe2:	2001      	movs	r0, #1
}
 8005fe4:	bd08      	pop	{r3, pc}
 8005fe6:	bf00      	nop
 8005fe8:	41500000 	.word	0x41500000
 8005fec:	42d00000 	.word	0x42d00000
 8005ff0:	41d00000 	.word	0x41d00000
 8005ff4:	42500000 	.word	0x42500000

08005ff8 <LSM6DSL_X_Get_WhoAmI>:
 8005ff8:	b508      	push	{r3, lr}
 8005ffa:	f7fd fdff 	bl	8003bfc <LSM6DSL_ACC_GYRO_R_WHO_AM_I>
 8005ffe:	fab0 f080 	clz	r0, r0
 8006002:	0940      	lsrs	r0, r0, #5
 8006004:	bd08      	pop	{r3, pc}
 8006006:	bf00      	nop

08006008 <LSM6DSL_X_Set_ODR_Value>:
{
 8006008:	b508      	push	{r3, lr}
  if(handle->isEnabled == 1)
 800600a:	7983      	ldrb	r3, [r0, #6]
 800600c:	2b01      	cmp	r3, #1
 800600e:	d048      	beq.n	80060a2 <LSM6DSL_X_Set_ODR_Value+0x9a>
                                 : ( odr <=   26.0f ) ? 26.0f
 8006010:	eef2 7a0a 	vmov.f32	s15, #42	; 0x41500000  13.0
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 8006014:	6883      	ldr	r3, [r0, #8]
                                 : ( odr <=   26.0f ) ? 26.0f
 8006016:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800601a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 800601e:	681b      	ldr	r3, [r3, #0]
                                 : ( odr <=   26.0f ) ? 26.0f
 8006020:	d93b      	bls.n	800609a <LSM6DSL_X_Set_ODR_Value+0x92>
                                 : ( odr <=   52.0f ) ? 52.0f
 8006022:	eef3 7a0a 	vmov.f32	s15, #58	; 0x41d00000  26.0
 8006026:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800602a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800602e:	d934      	bls.n	800609a <LSM6DSL_X_Set_ODR_Value+0x92>
                                 : ( odr <=  104.0f ) ? 104.0f
 8006030:	eddf 7a47 	vldr	s15, [pc, #284]	; 8006150 <LSM6DSL_X_Set_ODR_Value+0x148>
 8006034:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8006038:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800603c:	d92d      	bls.n	800609a <LSM6DSL_X_Set_ODR_Value+0x92>
                                 : ( odr <=  208.0f ) ? 208.0f
 800603e:	eddf 7a45 	vldr	s15, [pc, #276]	; 8006154 <LSM6DSL_X_Set_ODR_Value+0x14c>
 8006042:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8006046:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800604a:	d926      	bls.n	800609a <LSM6DSL_X_Set_ODR_Value+0x92>
                                 : ( odr <=  416.0f ) ? 416.0f
 800604c:	eddf 7a42 	vldr	s15, [pc, #264]	; 8006158 <LSM6DSL_X_Set_ODR_Value+0x150>
 8006050:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8006054:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006058:	d91f      	bls.n	800609a <LSM6DSL_X_Set_ODR_Value+0x92>
                                 : ( odr <=  833.0f ) ? 833.0f
 800605a:	eddf 7a40 	vldr	s15, [pc, #256]	; 800615c <LSM6DSL_X_Set_ODR_Value+0x154>
 800605e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8006062:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006066:	d918      	bls.n	800609a <LSM6DSL_X_Set_ODR_Value+0x92>
                                 : ( odr <= 1660.0f ) ? 1660.0f
 8006068:	eddf 7a3d 	vldr	s15, [pc, #244]	; 8006160 <LSM6DSL_X_Set_ODR_Value+0x158>
 800606c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8006070:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006074:	d911      	bls.n	800609a <LSM6DSL_X_Set_ODR_Value+0x92>
                                 : ( odr <= 3330.0f ) ? 3330.0f
 8006076:	eddf 7a3b 	vldr	s15, [pc, #236]	; 8006164 <LSM6DSL_X_Set_ODR_Value+0x15c>
 800607a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800607e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006082:	d90a      	bls.n	800609a <LSM6DSL_X_Set_ODR_Value+0x92>
                                 :                      6660.0f;
 8006084:	eddf 7a38 	vldr	s15, [pc, #224]	; 8006168 <LSM6DSL_X_Set_ODR_Value+0x160>
 8006088:	ed9f 7a38 	vldr	s14, [pc, #224]	; 800616c <LSM6DSL_X_Set_ODR_Value+0x164>
 800608c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8006090:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006094:	bf88      	it	hi
 8006096:	eef0 7a47 	vmovhi.f32	s15, s14
  pComponentData->Previous_ODR = ( odr <=   13.0f ) ? 13.0f
 800609a:	edc3 7a01 	vstr	s15, [r3, #4]
  return COMPONENT_OK;
 800609e:	2000      	movs	r0, #0
}
 80060a0:	bd08      	pop	{r3, pc}
            : ( odr <=   26.0f ) ? LSM6DSL_ACC_GYRO_ODR_XL_26Hz
 80060a2:	eef2 7a0a 	vmov.f32	s15, #42	; 0x41500000  13.0
 80060a6:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80060aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80060ae:	d806      	bhi.n	80060be <LSM6DSL_X_Set_ODR_Value+0xb6>
 80060b0:	2110      	movs	r1, #16
  if ( LSM6DSL_ACC_GYRO_W_ODR_XL( (void *)handle, new_odr ) == MEMS_ERROR )
 80060b2:	f7fd fe21 	bl	8003cf8 <LSM6DSL_ACC_GYRO_W_ODR_XL>
      return COMPONENT_ERROR;
 80060b6:	fab0 f080 	clz	r0, r0
 80060ba:	0940      	lsrs	r0, r0, #5
 80060bc:	bd08      	pop	{r3, pc}
            : ( odr <=   26.0f ) ? LSM6DSL_ACC_GYRO_ODR_XL_26Hz
 80060be:	eef3 7a0a 	vmov.f32	s15, #58	; 0x41d00000  26.0
 80060c2:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80060c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80060ca:	d933      	bls.n	8006134 <LSM6DSL_X_Set_ODR_Value+0x12c>
 80060cc:	eddf 7a20 	vldr	s15, [pc, #128]	; 8006150 <LSM6DSL_X_Set_ODR_Value+0x148>
 80060d0:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80060d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80060d8:	d92e      	bls.n	8006138 <LSM6DSL_X_Set_ODR_Value+0x130>
 80060da:	eddf 7a1e 	vldr	s15, [pc, #120]	; 8006154 <LSM6DSL_X_Set_ODR_Value+0x14c>
 80060de:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80060e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80060e6:	d929      	bls.n	800613c <LSM6DSL_X_Set_ODR_Value+0x134>
 80060e8:	eddf 7a1b 	vldr	s15, [pc, #108]	; 8006158 <LSM6DSL_X_Set_ODR_Value+0x150>
 80060ec:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80060f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80060f4:	d924      	bls.n	8006140 <LSM6DSL_X_Set_ODR_Value+0x138>
 80060f6:	eddf 7a19 	vldr	s15, [pc, #100]	; 800615c <LSM6DSL_X_Set_ODR_Value+0x154>
 80060fa:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80060fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006102:	d91f      	bls.n	8006144 <LSM6DSL_X_Set_ODR_Value+0x13c>
 8006104:	eddf 7a16 	vldr	s15, [pc, #88]	; 8006160 <LSM6DSL_X_Set_ODR_Value+0x158>
 8006108:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800610c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006110:	d91a      	bls.n	8006148 <LSM6DSL_X_Set_ODR_Value+0x140>
 8006112:	eddf 7a14 	vldr	s15, [pc, #80]	; 8006164 <LSM6DSL_X_Set_ODR_Value+0x15c>
 8006116:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800611a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800611e:	d915      	bls.n	800614c <LSM6DSL_X_Set_ODR_Value+0x144>
 8006120:	eddf 7a11 	vldr	s15, [pc, #68]	; 8006168 <LSM6DSL_X_Set_ODR_Value+0x160>
 8006124:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8006128:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800612c:	bf94      	ite	ls
 800612e:	2190      	movls	r1, #144	; 0x90
 8006130:	21a0      	movhi	r1, #160	; 0xa0
 8006132:	e7be      	b.n	80060b2 <LSM6DSL_X_Set_ODR_Value+0xaa>
 8006134:	2120      	movs	r1, #32
 8006136:	e7bc      	b.n	80060b2 <LSM6DSL_X_Set_ODR_Value+0xaa>
 8006138:	2130      	movs	r1, #48	; 0x30
 800613a:	e7ba      	b.n	80060b2 <LSM6DSL_X_Set_ODR_Value+0xaa>
 800613c:	2140      	movs	r1, #64	; 0x40
 800613e:	e7b8      	b.n	80060b2 <LSM6DSL_X_Set_ODR_Value+0xaa>
 8006140:	2150      	movs	r1, #80	; 0x50
 8006142:	e7b6      	b.n	80060b2 <LSM6DSL_X_Set_ODR_Value+0xaa>
 8006144:	2160      	movs	r1, #96	; 0x60
 8006146:	e7b4      	b.n	80060b2 <LSM6DSL_X_Set_ODR_Value+0xaa>
 8006148:	2170      	movs	r1, #112	; 0x70
 800614a:	e7b2      	b.n	80060b2 <LSM6DSL_X_Set_ODR_Value+0xaa>
 800614c:	2180      	movs	r1, #128	; 0x80
 800614e:	e7b0      	b.n	80060b2 <LSM6DSL_X_Set_ODR_Value+0xaa>
 8006150:	42500000 	.word	0x42500000
 8006154:	42d00000 	.word	0x42d00000
 8006158:	43500000 	.word	0x43500000
 800615c:	43d00000 	.word	0x43d00000
 8006160:	44504000 	.word	0x44504000
 8006164:	44cf8000 	.word	0x44cf8000
 8006168:	45502000 	.word	0x45502000
 800616c:	45d02000 	.word	0x45d02000

08006170 <LSM6DSL_X_Set_Interrupt_Latch>:
 8006170:	2901      	cmp	r1, #1
 8006172:	d901      	bls.n	8006178 <LSM6DSL_X_Set_Interrupt_Latch+0x8>
 8006174:	2001      	movs	r0, #1
 8006176:	4770      	bx	lr
 8006178:	b508      	push	{r3, lr}
 800617a:	f7fe fa1b 	bl	80045b4 <LSM6DSL_ACC_GYRO_W_LIR>
 800617e:	fab0 f080 	clz	r0, r0
 8006182:	0940      	lsrs	r0, r0, #5
 8006184:	bd08      	pop	{r3, pc}
 8006186:	bf00      	nop

08006188 <LSM6DSL_X_Read_Reg>:
 8006188:	b508      	push	{r3, lr}
 800618a:	2301      	movs	r3, #1
 800618c:	f7fd fd26 	bl	8003bdc <LSM6DSL_ACC_GYRO_ReadReg>
 8006190:	fab0 f080 	clz	r0, r0
 8006194:	0940      	lsrs	r0, r0, #5
 8006196:	bd08      	pop	{r3, pc}

08006198 <LSM6DSL_X_Write_Reg>:
 8006198:	b510      	push	{r4, lr}
 800619a:	b082      	sub	sp, #8
 800619c:	ac02      	add	r4, sp, #8
 800619e:	2301      	movs	r3, #1
 80061a0:	f804 2d01 	strb.w	r2, [r4, #-1]!
 80061a4:	4622      	mov	r2, r4
 80061a6:	f7fd fd21 	bl	8003bec <LSM6DSL_ACC_GYRO_WriteReg>
 80061aa:	fab0 f080 	clz	r0, r0
 80061ae:	0940      	lsrs	r0, r0, #5
 80061b0:	b002      	add	sp, #8
 80061b2:	bd10      	pop	{r4, pc}

080061b4 <LSM6DSL_X_Enable_Free_Fall_Detection>:
{
 80061b4:	b538      	push	{r3, r4, r5, lr}
  if(handle->isEnabled == 1)
 80061b6:	7983      	ldrb	r3, [r0, #6]
 80061b8:	2b01      	cmp	r3, #1
{
 80061ba:	4604      	mov	r4, r0
 80061bc:	460d      	mov	r5, r1
  if(handle->isEnabled == 1)
 80061be:	d039      	beq.n	8006234 <LSM6DSL_X_Enable_Free_Fall_Detection+0x80>
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 80061c0:	6883      	ldr	r3, [r0, #8]
  pComponentData->Previous_ODR = ( odr <=   13.0f ) ? 13.0f
 80061c2:	4a24      	ldr	r2, [pc, #144]	; (8006254 <LSM6DSL_X_Enable_Free_Fall_Detection+0xa0>)
 80061c4:	681b      	ldr	r3, [r3, #0]
 80061c6:	605a      	str	r2, [r3, #4]
  if ( LSM6DSL_ACC_GYRO_W_FS_XL( (void *)handle, LSM6DSL_ACC_GYRO_FS_XL_2g ) == MEMS_ERROR )
 80061c8:	2100      	movs	r1, #0
 80061ca:	4620      	mov	r0, r4
 80061cc:	f7fd fd42 	bl	8003c54 <LSM6DSL_ACC_GYRO_W_FS_XL>
 80061d0:	b908      	cbnz	r0, 80061d6 <LSM6DSL_X_Enable_Free_Fall_Detection+0x22>
    return COMPONENT_ERROR;
 80061d2:	2001      	movs	r0, #1
}
 80061d4:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSL_ACC_GYRO_W_FF_Duration( (void *)handle, 0x06 ) == MEMS_ERROR )
 80061d6:	2106      	movs	r1, #6
 80061d8:	4620      	mov	r0, r4
 80061da:	f7fe fc17 	bl	8004a0c <LSM6DSL_ACC_GYRO_W_FF_Duration>
 80061de:	2800      	cmp	r0, #0
 80061e0:	d0f7      	beq.n	80061d2 <LSM6DSL_X_Enable_Free_Fall_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_WAKE_DUR( (void *)handle, 0x00 ) == MEMS_ERROR )
 80061e2:	2100      	movs	r1, #0
 80061e4:	4620      	mov	r0, r4
 80061e6:	f7fe fbcb 	bl	8004980 <LSM6DSL_ACC_GYRO_W_WAKE_DUR>
 80061ea:	2800      	cmp	r0, #0
 80061ec:	d0f1      	beq.n	80061d2 <LSM6DSL_X_Enable_Free_Fall_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_TIMER_HR( (void *)handle, LSM6DSL_ACC_GYRO_TIMER_HR_6_4ms ) == MEMS_ERROR )
 80061ee:	2100      	movs	r1, #0
 80061f0:	4620      	mov	r0, r4
 80061f2:	f7fe fba3 	bl	800493c <LSM6DSL_ACC_GYRO_W_TIMER_HR>
 80061f6:	2800      	cmp	r0, #0
 80061f8:	d0eb      	beq.n	80061d2 <LSM6DSL_X_Enable_Free_Fall_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_SLEEP_DUR( (void *)handle, 0x00 ) == MEMS_ERROR )
 80061fa:	2100      	movs	r1, #0
 80061fc:	4620      	mov	r0, r4
 80061fe:	f7fe fb79 	bl	80048f4 <LSM6DSL_ACC_GYRO_W_SLEEP_DUR>
 8006202:	2800      	cmp	r0, #0
 8006204:	d0e5      	beq.n	80061d2 <LSM6DSL_X_Enable_Free_Fall_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_FF_THS( (void *) handle, LSM6DSL_ACC_GYRO_FF_THS_312mg ) == MEMS_ERROR )
 8006206:	2103      	movs	r1, #3
 8006208:	4620      	mov	r0, r4
 800620a:	f7fe fbdd 	bl	80049c8 <LSM6DSL_ACC_GYRO_W_FF_THS>
 800620e:	2800      	cmp	r0, #0
 8006210:	d0df      	beq.n	80061d2 <LSM6DSL_X_Enable_Free_Fall_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSL_ACC_GYRO_BASIC_INT_ENABLED ) == MEMS_ERROR )
 8006212:	2180      	movs	r1, #128	; 0x80
 8006214:	4620      	mov	r0, r4
 8006216:	f7fe fa55 	bl	80046c4 <LSM6DSL_ACC_GYRO_W_BASIC_INT>
 800621a:	2800      	cmp	r0, #0
 800621c:	d0d9      	beq.n	80061d2 <LSM6DSL_X_Enable_Free_Fall_Detection+0x1e>
  switch (int_pin)
 800621e:	b185      	cbz	r5, 8006242 <LSM6DSL_X_Enable_Free_Fall_Detection+0x8e>
 8006220:	2d01      	cmp	r5, #1
 8006222:	d1d6      	bne.n	80061d2 <LSM6DSL_X_Enable_Free_Fall_Detection+0x1e>
    if ( LSM6DSL_ACC_GYRO_W_FFEvOnInt2( (void *)handle, LSM6DSL_ACC_GYRO_INT2_FF_ENABLED ) == MEMS_ERROR )
 8006224:	4620      	mov	r0, r4
 8006226:	2110      	movs	r1, #16
 8006228:	f7fe fd5e 	bl	8004ce8 <LSM6DSL_ACC_GYRO_W_FFEvOnInt2>
    return COMPONENT_ERROR;
 800622c:	fab0 f080 	clz	r0, r0
 8006230:	0940      	lsrs	r0, r0, #5
 8006232:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSL_ACC_GYRO_W_ODR_XL( (void *)handle, new_odr ) == MEMS_ERROR )
 8006234:	2160      	movs	r1, #96	; 0x60
 8006236:	f7fd fd5f 	bl	8003cf8 <LSM6DSL_ACC_GYRO_W_ODR_XL>
  if(LSM6DSL_X_Set_ODR_Value(handle, 416.0f) == COMPONENT_ERROR)
 800623a:	2800      	cmp	r0, #0
 800623c:	d1c4      	bne.n	80061c8 <LSM6DSL_X_Enable_Free_Fall_Detection+0x14>
    return COMPONENT_ERROR;
 800623e:	2001      	movs	r0, #1
}
 8006240:	bd38      	pop	{r3, r4, r5, pc}
    if ( LSM6DSL_ACC_GYRO_W_FFEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_FF_ENABLED ) == MEMS_ERROR )
 8006242:	4620      	mov	r0, r4
 8006244:	2110      	movs	r1, #16
 8006246:	f7fe fc83 	bl	8004b50 <LSM6DSL_ACC_GYRO_W_FFEvOnInt1>
    return COMPONENT_ERROR;
 800624a:	fab0 f080 	clz	r0, r0
 800624e:	0940      	lsrs	r0, r0, #5
 8006250:	bd38      	pop	{r3, r4, r5, pc}
 8006252:	bf00      	nop
 8006254:	43d00000 	.word	0x43d00000

08006258 <LSM6DSL_X_Enable_Tilt_Detection>:
{
 8006258:	b538      	push	{r3, r4, r5, lr}
  if(handle->isEnabled == 1)
 800625a:	7983      	ldrb	r3, [r0, #6]
 800625c:	2b01      	cmp	r3, #1
{
 800625e:	4604      	mov	r4, r0
 8006260:	460d      	mov	r5, r1
  if(handle->isEnabled == 1)
 8006262:	d021      	beq.n	80062a8 <LSM6DSL_X_Enable_Tilt_Detection+0x50>
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 8006264:	6883      	ldr	r3, [r0, #8]
  pComponentData->Previous_ODR = ( odr <=   13.0f ) ? 13.0f
 8006266:	4a18      	ldr	r2, [pc, #96]	; (80062c8 <LSM6DSL_X_Enable_Tilt_Detection+0x70>)
 8006268:	681b      	ldr	r3, [r3, #0]
 800626a:	605a      	str	r2, [r3, #4]
  if ( LSM6DSL_ACC_GYRO_W_FS_XL( (void *)handle, LSM6DSL_ACC_GYRO_FS_XL_2g ) == MEMS_ERROR )
 800626c:	2100      	movs	r1, #0
 800626e:	4620      	mov	r0, r4
 8006270:	f7fd fcf0 	bl	8003c54 <LSM6DSL_ACC_GYRO_W_FS_XL>
 8006274:	b908      	cbnz	r0, 800627a <LSM6DSL_X_Enable_Tilt_Detection+0x22>
    return COMPONENT_ERROR;
 8006276:	2001      	movs	r0, #1
}
 8006278:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSL_ACC_GYRO_W_FUNC_EN( (void *)handle, LSM6DSL_ACC_GYRO_FUNC_EN_ENABLED ) == MEMS_ERROR )
 800627a:	2104      	movs	r1, #4
 800627c:	4620      	mov	r0, r4
 800627e:	f7fe f813 	bl	80042a8 <LSM6DSL_ACC_GYRO_W_FUNC_EN>
 8006282:	2800      	cmp	r0, #0
 8006284:	d0f7      	beq.n	8006276 <LSM6DSL_X_Enable_Tilt_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_TILT( (void *)handle, LSM6DSL_ACC_GYRO_TILT_ENABLED ) == MEMS_ERROR )
 8006286:	2108      	movs	r1, #8
 8006288:	4620      	mov	r0, r4
 800628a:	f7fd ffc9 	bl	8004220 <LSM6DSL_ACC_GYRO_W_TILT>
 800628e:	2800      	cmp	r0, #0
 8006290:	d0f1      	beq.n	8006276 <LSM6DSL_X_Enable_Tilt_Detection+0x1e>
  switch (int_pin)
 8006292:	b185      	cbz	r5, 80062b6 <LSM6DSL_X_Enable_Tilt_Detection+0x5e>
 8006294:	2d01      	cmp	r5, #1
 8006296:	d1ee      	bne.n	8006276 <LSM6DSL_X_Enable_Tilt_Detection+0x1e>
    if ( LSM6DSL_ACC_GYRO_W_TiltEvOnInt2( (void *)handle, LSM6DSL_ACC_GYRO_INT2_TILT_ENABLED ) == MEMS_ERROR )
 8006298:	4620      	mov	r0, r4
 800629a:	2102      	movs	r1, #2
 800629c:	f7fe fcbe 	bl	8004c1c <LSM6DSL_ACC_GYRO_W_TiltEvOnInt2>
    return COMPONENT_ERROR;
 80062a0:	fab0 f080 	clz	r0, r0
 80062a4:	0940      	lsrs	r0, r0, #5
 80062a6:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSL_ACC_GYRO_W_ODR_XL( (void *)handle, new_odr ) == MEMS_ERROR )
 80062a8:	2120      	movs	r1, #32
 80062aa:	f7fd fd25 	bl	8003cf8 <LSM6DSL_ACC_GYRO_W_ODR_XL>
  if(LSM6DSL_X_Set_ODR_Value(handle, 26.0f) == COMPONENT_ERROR)
 80062ae:	2800      	cmp	r0, #0
 80062b0:	d1dc      	bne.n	800626c <LSM6DSL_X_Enable_Tilt_Detection+0x14>
    return COMPONENT_ERROR;
 80062b2:	2001      	movs	r0, #1
}
 80062b4:	bd38      	pop	{r3, r4, r5, pc}
    if ( LSM6DSL_ACC_GYRO_W_TiltEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_TILT_ENABLED ) == MEMS_ERROR )
 80062b6:	4620      	mov	r0, r4
 80062b8:	2102      	movs	r1, #2
 80062ba:	f7fe fbe3 	bl	8004a84 <LSM6DSL_ACC_GYRO_W_TiltEvOnInt1>
    return COMPONENT_ERROR;
 80062be:	fab0 f080 	clz	r0, r0
 80062c2:	0940      	lsrs	r0, r0, #5
 80062c4:	bd38      	pop	{r3, r4, r5, pc}
 80062c6:	bf00      	nop
 80062c8:	41d00000 	.word	0x41d00000

080062cc <LSM6DSL_X_Enable_Pedometer>:
{
 80062cc:	b510      	push	{r4, lr}
  if(handle->isEnabled == 1)
 80062ce:	7983      	ldrb	r3, [r0, #6]
 80062d0:	2b01      	cmp	r3, #1
{
 80062d2:	4604      	mov	r4, r0
  if(handle->isEnabled == 1)
 80062d4:	d024      	beq.n	8006320 <LSM6DSL_X_Enable_Pedometer+0x54>
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 80062d6:	6883      	ldr	r3, [r0, #8]
  pComponentData->Previous_ODR = ( odr <=   13.0f ) ? 13.0f
 80062d8:	4a15      	ldr	r2, [pc, #84]	; (8006330 <LSM6DSL_X_Enable_Pedometer+0x64>)
 80062da:	681b      	ldr	r3, [r3, #0]
 80062dc:	605a      	str	r2, [r3, #4]
  if ( LSM6DSL_ACC_GYRO_W_FS_XL( (void *)handle, LSM6DSL_ACC_GYRO_FS_XL_2g ) == MEMS_ERROR )
 80062de:	2100      	movs	r1, #0
 80062e0:	4620      	mov	r0, r4
 80062e2:	f7fd fcb7 	bl	8003c54 <LSM6DSL_ACC_GYRO_W_FS_XL>
 80062e6:	b908      	cbnz	r0, 80062ec <LSM6DSL_X_Enable_Pedometer+0x20>
    return COMPONENT_ERROR;
 80062e8:	2001      	movs	r0, #1
 80062ea:	bd10      	pop	{r4, pc}
  if ( LSM6DSL_ACC_GYRO_W_PedoThreshold( (void *)handle, thr ) == MEMS_ERROR )
 80062ec:	2117      	movs	r1, #23
 80062ee:	4620      	mov	r0, r4
 80062f0:	f7fe fd8c 	bl	8004e0c <LSM6DSL_ACC_GYRO_W_PedoThreshold>
 80062f4:	2800      	cmp	r0, #0
 80062f6:	d0f7      	beq.n	80062e8 <LSM6DSL_X_Enable_Pedometer+0x1c>
  if ( LSM6DSL_ACC_GYRO_W_FUNC_EN( (void *)handle, LSM6DSL_ACC_GYRO_FUNC_EN_ENABLED ) == MEMS_ERROR )
 80062f8:	2104      	movs	r1, #4
 80062fa:	4620      	mov	r0, r4
 80062fc:	f7fd ffd4 	bl	80042a8 <LSM6DSL_ACC_GYRO_W_FUNC_EN>
 8006300:	2800      	cmp	r0, #0
 8006302:	d0f1      	beq.n	80062e8 <LSM6DSL_X_Enable_Pedometer+0x1c>
  if ( LSM6DSL_ACC_GYRO_W_PEDO( (void *)handle, LSM6DSL_ACC_GYRO_PEDO_ENABLED ) == MEMS_ERROR )
 8006304:	2110      	movs	r1, #16
 8006306:	4620      	mov	r0, r4
 8006308:	f7fd ffac 	bl	8004264 <LSM6DSL_ACC_GYRO_W_PEDO>
 800630c:	2800      	cmp	r0, #0
 800630e:	d0eb      	beq.n	80062e8 <LSM6DSL_X_Enable_Pedometer+0x1c>
  if ( LSM6DSL_ACC_GYRO_W_STEP_DET_on_INT1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_PEDO_ENABLED ) == MEMS_ERROR )
 8006310:	4620      	mov	r0, r4
 8006312:	2180      	movs	r1, #128	; 0x80
 8006314:	f7fd feda 	bl	80040cc <LSM6DSL_ACC_GYRO_W_STEP_DET_on_INT1>
    return COMPONENT_ERROR;
 8006318:	fab0 f080 	clz	r0, r0
 800631c:	0940      	lsrs	r0, r0, #5
 800631e:	bd10      	pop	{r4, pc}
  if ( LSM6DSL_ACC_GYRO_W_ODR_XL( (void *)handle, new_odr ) == MEMS_ERROR )
 8006320:	2120      	movs	r1, #32
 8006322:	f7fd fce9 	bl	8003cf8 <LSM6DSL_ACC_GYRO_W_ODR_XL>
  if(LSM6DSL_X_Set_ODR_Value(handle, 26.0f) == COMPONENT_ERROR)
 8006326:	2800      	cmp	r0, #0
 8006328:	d1d9      	bne.n	80062de <LSM6DSL_X_Enable_Pedometer+0x12>
    return COMPONENT_ERROR;
 800632a:	2001      	movs	r0, #1
 800632c:	bd10      	pop	{r4, pc}
 800632e:	bf00      	nop
 8006330:	41d00000 	.word	0x41d00000

08006334 <LSM6DSL_X_Get_AxesRaw>:
{
 8006334:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006336:	b083      	sub	sp, #12
  uint8_t regValue[6] = {0, 0, 0, 0, 0, 0};
 8006338:	2400      	movs	r4, #0
{
 800633a:	460d      	mov	r5, r1
  if ( LSM6DSL_ACC_GYRO_GetRawAccData( (void *)handle, ( uint8_t* )regValue ) == MEMS_ERROR )
 800633c:	4669      	mov	r1, sp
  uint8_t regValue[6] = {0, 0, 0, 0, 0, 0};
 800633e:	f8ad 4004 	strh.w	r4, [sp, #4]
 8006342:	9400      	str	r4, [sp, #0]
  if ( LSM6DSL_ACC_GYRO_GetRawAccData( (void *)handle, ( uint8_t* )regValue ) == MEMS_ERROR )
 8006344:	f7fd fcb8 	bl	8003cb8 <LSM6DSL_ACC_GYRO_GetRawAccData>
 8006348:	b1b8      	cbz	r0, 800637a <LSM6DSL_X_Get_AxesRaw+0x46>
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 800634a:	f89d 0005 	ldrb.w	r0, [sp, #5]
  pData[0] = ( ( ( ( int16_t )regValue[1] ) << 8 ) + ( int16_t )regValue[0] );
 800634e:	f89d 7001 	ldrb.w	r7, [sp, #1]
 8006352:	f89d 1000 	ldrb.w	r1, [sp]
  pData[1] = ( ( ( ( int16_t )regValue[3] ) << 8 ) + ( int16_t )regValue[2] );
 8006356:	f89d 6003 	ldrb.w	r6, [sp, #3]
 800635a:	f89d 2002 	ldrb.w	r2, [sp, #2]
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 800635e:	f89d 3004 	ldrb.w	r3, [sp, #4]
  pData[0] = ( ( ( ( int16_t )regValue[1] ) << 8 ) + ( int16_t )regValue[0] );
 8006362:	eb01 2107 	add.w	r1, r1, r7, lsl #8
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 8006366:	eb03 2300 	add.w	r3, r3, r0, lsl #8
  pData[1] = ( ( ( ( int16_t )regValue[3] ) << 8 ) + ( int16_t )regValue[2] );
 800636a:	eb02 2206 	add.w	r2, r2, r6, lsl #8
  return COMPONENT_OK;
 800636e:	4620      	mov	r0, r4
  value->AXIS_X = dataRaw[0];
 8006370:	8029      	strh	r1, [r5, #0]
  value->AXIS_Y = dataRaw[1];
 8006372:	806a      	strh	r2, [r5, #2]
  value->AXIS_Z = dataRaw[2];
 8006374:	80ab      	strh	r3, [r5, #4]
}
 8006376:	b003      	add	sp, #12
 8006378:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return COMPONENT_ERROR;
 800637a:	2001      	movs	r0, #1
}
 800637c:	b003      	add	sp, #12
 800637e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08006380 <LSM6DSL_G_Get_AxesRaw>:
{
 8006380:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006382:	b083      	sub	sp, #12
  uint8_t regValue[6] = {0, 0, 0, 0, 0, 0};
 8006384:	2400      	movs	r4, #0
{
 8006386:	460d      	mov	r5, r1
  if ( LSM6DSL_ACC_GYRO_GetRawGyroData( (void *)handle, ( uint8_t* )regValue ) == MEMS_ERROR )
 8006388:	4669      	mov	r1, sp
  uint8_t regValue[6] = {0, 0, 0, 0, 0, 0};
 800638a:	f8ad 4004 	strh.w	r4, [sp, #4]
 800638e:	9400      	str	r4, [sp, #0]
  if ( LSM6DSL_ACC_GYRO_GetRawGyroData( (void *)handle, ( uint8_t* )regValue ) == MEMS_ERROR )
 8006390:	f7fd fd16 	bl	8003dc0 <LSM6DSL_ACC_GYRO_GetRawGyroData>
 8006394:	b1b8      	cbz	r0, 80063c6 <LSM6DSL_G_Get_AxesRaw+0x46>
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 8006396:	f89d 0005 	ldrb.w	r0, [sp, #5]
  pData[0] = ( ( ( ( int16_t )regValue[1] ) << 8 ) + ( int16_t )regValue[0] );
 800639a:	f89d 7001 	ldrb.w	r7, [sp, #1]
 800639e:	f89d 1000 	ldrb.w	r1, [sp]
  pData[1] = ( ( ( ( int16_t )regValue[3] ) << 8 ) + ( int16_t )regValue[2] );
 80063a2:	f89d 6003 	ldrb.w	r6, [sp, #3]
 80063a6:	f89d 2002 	ldrb.w	r2, [sp, #2]
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 80063aa:	f89d 3004 	ldrb.w	r3, [sp, #4]
  pData[0] = ( ( ( ( int16_t )regValue[1] ) << 8 ) + ( int16_t )regValue[0] );
 80063ae:	eb01 2107 	add.w	r1, r1, r7, lsl #8
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 80063b2:	eb03 2300 	add.w	r3, r3, r0, lsl #8
  pData[1] = ( ( ( ( int16_t )regValue[3] ) << 8 ) + ( int16_t )regValue[2] );
 80063b6:	eb02 2206 	add.w	r2, r2, r6, lsl #8
  return COMPONENT_OK;
 80063ba:	4620      	mov	r0, r4
  value->AXIS_X = dataRaw[0];
 80063bc:	8029      	strh	r1, [r5, #0]
  value->AXIS_Y = dataRaw[1];
 80063be:	806a      	strh	r2, [r5, #2]
  value->AXIS_Z = dataRaw[2];
 80063c0:	80ab      	strh	r3, [r5, #4]
}
 80063c2:	b003      	add	sp, #12
 80063c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return COMPONENT_ERROR;
 80063c6:	2001      	movs	r0, #1
}
 80063c8:	b003      	add	sp, #12
 80063ca:	bdf0      	pop	{r4, r5, r6, r7, pc}

080063cc <LSM6DSL_X_Sensor_Enable>:
  if ( handle->isEnabled == 1 )
 80063cc:	7983      	ldrb	r3, [r0, #6]
 80063ce:	2b01      	cmp	r3, #1
 80063d0:	d050      	beq.n	8006474 <LSM6DSL_X_Sensor_Enable+0xa8>
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 80063d2:	6883      	ldr	r3, [r0, #8]
  if ( LSM6DSL_X_Set_ODR_Value_When_Enabled( handle, pComponentData->Previous_ODR ) == COMPONENT_ERROR )
 80063d4:	681b      	ldr	r3, [r3, #0]
 80063d6:	edd3 7a01 	vldr	s15, [r3, #4]
            : ( odr <=   26.0f ) ? LSM6DSL_ACC_GYRO_ODR_XL_26Hz
 80063da:	eeb2 7a0a 	vmov.f32	s14, #42	; 0x41500000  13.0
 80063de:	eef4 7ac7 	vcmpe.f32	s15, s14
 80063e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 80063e6:	b510      	push	{r4, lr}
            : ( odr <=   26.0f ) ? LSM6DSL_ACC_GYRO_ODR_XL_26Hz
 80063e8:	d809      	bhi.n	80063fe <LSM6DSL_X_Sensor_Enable+0x32>
 80063ea:	2110      	movs	r1, #16
 80063ec:	4604      	mov	r4, r0
  if ( LSM6DSL_ACC_GYRO_W_ODR_XL( (void *)handle, new_odr ) == MEMS_ERROR )
 80063ee:	f7fd fc83 	bl	8003cf8 <LSM6DSL_ACC_GYRO_W_ODR_XL>
 80063f2:	2800      	cmp	r0, #0
 80063f4:	d040      	beq.n	8006478 <LSM6DSL_X_Sensor_Enable+0xac>
  handle->isEnabled = 1;
 80063f6:	2301      	movs	r3, #1
 80063f8:	71a3      	strb	r3, [r4, #6]
  return COMPONENT_OK;
 80063fa:	2000      	movs	r0, #0
}
 80063fc:	bd10      	pop	{r4, pc}
            : ( odr <=   26.0f ) ? LSM6DSL_ACC_GYRO_ODR_XL_26Hz
 80063fe:	eeb3 7a0a 	vmov.f32	s14, #58	; 0x41d00000  26.0
 8006402:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006406:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800640a:	d937      	bls.n	800647c <LSM6DSL_X_Sensor_Enable+0xb0>
 800640c:	ed9f 7a22 	vldr	s14, [pc, #136]	; 8006498 <LSM6DSL_X_Sensor_Enable+0xcc>
 8006410:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006414:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006418:	d932      	bls.n	8006480 <LSM6DSL_X_Sensor_Enable+0xb4>
 800641a:	ed9f 7a20 	vldr	s14, [pc, #128]	; 800649c <LSM6DSL_X_Sensor_Enable+0xd0>
 800641e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006422:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006426:	d92d      	bls.n	8006484 <LSM6DSL_X_Sensor_Enable+0xb8>
 8006428:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 80064a0 <LSM6DSL_X_Sensor_Enable+0xd4>
 800642c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006430:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006434:	d928      	bls.n	8006488 <LSM6DSL_X_Sensor_Enable+0xbc>
 8006436:	ed9f 7a1b 	vldr	s14, [pc, #108]	; 80064a4 <LSM6DSL_X_Sensor_Enable+0xd8>
 800643a:	eef4 7ac7 	vcmpe.f32	s15, s14
 800643e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006442:	d923      	bls.n	800648c <LSM6DSL_X_Sensor_Enable+0xc0>
 8006444:	ed9f 7a18 	vldr	s14, [pc, #96]	; 80064a8 <LSM6DSL_X_Sensor_Enable+0xdc>
 8006448:	eef4 7ac7 	vcmpe.f32	s15, s14
 800644c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006450:	d91e      	bls.n	8006490 <LSM6DSL_X_Sensor_Enable+0xc4>
 8006452:	ed9f 7a16 	vldr	s14, [pc, #88]	; 80064ac <LSM6DSL_X_Sensor_Enable+0xe0>
 8006456:	eef4 7ac7 	vcmpe.f32	s15, s14
 800645a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800645e:	d919      	bls.n	8006494 <LSM6DSL_X_Sensor_Enable+0xc8>
 8006460:	ed9f 7a13 	vldr	s14, [pc, #76]	; 80064b0 <LSM6DSL_X_Sensor_Enable+0xe4>
 8006464:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006468:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800646c:	bf94      	ite	ls
 800646e:	2190      	movls	r1, #144	; 0x90
 8006470:	21a0      	movhi	r1, #160	; 0xa0
 8006472:	e7bb      	b.n	80063ec <LSM6DSL_X_Sensor_Enable+0x20>
    return COMPONENT_OK;
 8006474:	2000      	movs	r0, #0
 8006476:	4770      	bx	lr
    return COMPONENT_ERROR;
 8006478:	2001      	movs	r0, #1
 800647a:	bd10      	pop	{r4, pc}
            : ( odr <=   26.0f ) ? LSM6DSL_ACC_GYRO_ODR_XL_26Hz
 800647c:	2120      	movs	r1, #32
 800647e:	e7b5      	b.n	80063ec <LSM6DSL_X_Sensor_Enable+0x20>
 8006480:	2130      	movs	r1, #48	; 0x30
 8006482:	e7b3      	b.n	80063ec <LSM6DSL_X_Sensor_Enable+0x20>
 8006484:	2140      	movs	r1, #64	; 0x40
 8006486:	e7b1      	b.n	80063ec <LSM6DSL_X_Sensor_Enable+0x20>
 8006488:	2150      	movs	r1, #80	; 0x50
 800648a:	e7af      	b.n	80063ec <LSM6DSL_X_Sensor_Enable+0x20>
 800648c:	2160      	movs	r1, #96	; 0x60
 800648e:	e7ad      	b.n	80063ec <LSM6DSL_X_Sensor_Enable+0x20>
 8006490:	2170      	movs	r1, #112	; 0x70
 8006492:	e7ab      	b.n	80063ec <LSM6DSL_X_Sensor_Enable+0x20>
 8006494:	2180      	movs	r1, #128	; 0x80
 8006496:	e7a9      	b.n	80063ec <LSM6DSL_X_Sensor_Enable+0x20>
 8006498:	42500000 	.word	0x42500000
 800649c:	42d00000 	.word	0x42d00000
 80064a0:	43500000 	.word	0x43500000
 80064a4:	43d00000 	.word	0x43d00000
 80064a8:	44504000 	.word	0x44504000
 80064ac:	44cf8000 	.word	0x44cf8000
 80064b0:	45502000 	.word	0x45502000

080064b4 <LSM6DSL_G_Sensor_Enable>:
  if ( handle->isEnabled == 1 )
 80064b4:	7983      	ldrb	r3, [r0, #6]
 80064b6:	2b01      	cmp	r3, #1
 80064b8:	d050      	beq.n	800655c <LSM6DSL_G_Sensor_Enable+0xa8>
  LSM6DSL_G_Data_t *pComponentData = ( LSM6DSL_G_Data_t * )pData->pComponentData;
 80064ba:	6883      	ldr	r3, [r0, #8]
  if ( LSM6DSL_G_Set_ODR_Value_When_Enabled( handle, pComponentData->Previous_ODR ) == COMPONENT_ERROR )
 80064bc:	681b      	ldr	r3, [r3, #0]
 80064be:	edd3 7a01 	vldr	s15, [r3, #4]
            : ( odr <=  26.0f )  ? LSM6DSL_ACC_GYRO_ODR_G_26Hz
 80064c2:	eeb2 7a0a 	vmov.f32	s14, #42	; 0x41500000  13.0
 80064c6:	eef4 7ac7 	vcmpe.f32	s15, s14
 80064ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 80064ce:	b510      	push	{r4, lr}
            : ( odr <=  26.0f )  ? LSM6DSL_ACC_GYRO_ODR_G_26Hz
 80064d0:	d809      	bhi.n	80064e6 <LSM6DSL_G_Sensor_Enable+0x32>
 80064d2:	2110      	movs	r1, #16
 80064d4:	4604      	mov	r4, r0
  if ( LSM6DSL_ACC_GYRO_W_ODR_G( (void *)handle, new_odr ) == MEMS_ERROR )
 80064d6:	f7fd fc93 	bl	8003e00 <LSM6DSL_ACC_GYRO_W_ODR_G>
 80064da:	2800      	cmp	r0, #0
 80064dc:	d040      	beq.n	8006560 <LSM6DSL_G_Sensor_Enable+0xac>
  handle->isEnabled = 1;
 80064de:	2301      	movs	r3, #1
 80064e0:	71a3      	strb	r3, [r4, #6]
  return COMPONENT_OK;
 80064e2:	2000      	movs	r0, #0
}
 80064e4:	bd10      	pop	{r4, pc}
            : ( odr <=  26.0f )  ? LSM6DSL_ACC_GYRO_ODR_G_26Hz
 80064e6:	eeb3 7a0a 	vmov.f32	s14, #58	; 0x41d00000  26.0
 80064ea:	eef4 7ac7 	vcmpe.f32	s15, s14
 80064ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80064f2:	d937      	bls.n	8006564 <LSM6DSL_G_Sensor_Enable+0xb0>
 80064f4:	ed9f 7a22 	vldr	s14, [pc, #136]	; 8006580 <LSM6DSL_G_Sensor_Enable+0xcc>
 80064f8:	eef4 7ac7 	vcmpe.f32	s15, s14
 80064fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006500:	d932      	bls.n	8006568 <LSM6DSL_G_Sensor_Enable+0xb4>
 8006502:	ed9f 7a20 	vldr	s14, [pc, #128]	; 8006584 <LSM6DSL_G_Sensor_Enable+0xd0>
 8006506:	eef4 7ac7 	vcmpe.f32	s15, s14
 800650a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800650e:	d92d      	bls.n	800656c <LSM6DSL_G_Sensor_Enable+0xb8>
 8006510:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 8006588 <LSM6DSL_G_Sensor_Enable+0xd4>
 8006514:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006518:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800651c:	d928      	bls.n	8006570 <LSM6DSL_G_Sensor_Enable+0xbc>
 800651e:	ed9f 7a1b 	vldr	s14, [pc, #108]	; 800658c <LSM6DSL_G_Sensor_Enable+0xd8>
 8006522:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006526:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800652a:	d923      	bls.n	8006574 <LSM6DSL_G_Sensor_Enable+0xc0>
 800652c:	ed9f 7a18 	vldr	s14, [pc, #96]	; 8006590 <LSM6DSL_G_Sensor_Enable+0xdc>
 8006530:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006534:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006538:	d91e      	bls.n	8006578 <LSM6DSL_G_Sensor_Enable+0xc4>
 800653a:	ed9f 7a16 	vldr	s14, [pc, #88]	; 8006594 <LSM6DSL_G_Sensor_Enable+0xe0>
 800653e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006542:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006546:	d919      	bls.n	800657c <LSM6DSL_G_Sensor_Enable+0xc8>
 8006548:	ed9f 7a13 	vldr	s14, [pc, #76]	; 8006598 <LSM6DSL_G_Sensor_Enable+0xe4>
 800654c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006550:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006554:	bf94      	ite	ls
 8006556:	2190      	movls	r1, #144	; 0x90
 8006558:	21a0      	movhi	r1, #160	; 0xa0
 800655a:	e7bb      	b.n	80064d4 <LSM6DSL_G_Sensor_Enable+0x20>
    return COMPONENT_OK;
 800655c:	2000      	movs	r0, #0
 800655e:	4770      	bx	lr
    return COMPONENT_ERROR;
 8006560:	2001      	movs	r0, #1
 8006562:	bd10      	pop	{r4, pc}
            : ( odr <=  26.0f )  ? LSM6DSL_ACC_GYRO_ODR_G_26Hz
 8006564:	2120      	movs	r1, #32
 8006566:	e7b5      	b.n	80064d4 <LSM6DSL_G_Sensor_Enable+0x20>
 8006568:	2130      	movs	r1, #48	; 0x30
 800656a:	e7b3      	b.n	80064d4 <LSM6DSL_G_Sensor_Enable+0x20>
 800656c:	2140      	movs	r1, #64	; 0x40
 800656e:	e7b1      	b.n	80064d4 <LSM6DSL_G_Sensor_Enable+0x20>
 8006570:	2150      	movs	r1, #80	; 0x50
 8006572:	e7af      	b.n	80064d4 <LSM6DSL_G_Sensor_Enable+0x20>
 8006574:	2160      	movs	r1, #96	; 0x60
 8006576:	e7ad      	b.n	80064d4 <LSM6DSL_G_Sensor_Enable+0x20>
 8006578:	2170      	movs	r1, #112	; 0x70
 800657a:	e7ab      	b.n	80064d4 <LSM6DSL_G_Sensor_Enable+0x20>
 800657c:	2180      	movs	r1, #128	; 0x80
 800657e:	e7a9      	b.n	80064d4 <LSM6DSL_G_Sensor_Enable+0x20>
 8006580:	42500000 	.word	0x42500000
 8006584:	42d00000 	.word	0x42d00000
 8006588:	43500000 	.word	0x43500000
 800658c:	43d00000 	.word	0x43d00000
 8006590:	44504000 	.word	0x44504000
 8006594:	44cf8000 	.word	0x44cf8000
 8006598:	45502000 	.word	0x45502000

0800659c <LSM6DSL_X_Check_WhoAmI>:
 800659c:	b510      	push	{r4, lr}
 800659e:	b082      	sub	sp, #8
 80065a0:	a902      	add	r1, sp, #8
 80065a2:	2300      	movs	r3, #0
 80065a4:	f801 3d01 	strb.w	r3, [r1, #-1]!
 80065a8:	4604      	mov	r4, r0
 80065aa:	f7fd fb27 	bl	8003bfc <LSM6DSL_ACC_GYRO_R_WHO_AM_I>
 80065ae:	b910      	cbnz	r0, 80065b6 <LSM6DSL_X_Check_WhoAmI+0x1a>
 80065b0:	2001      	movs	r0, #1
 80065b2:	b002      	add	sp, #8
 80065b4:	bd10      	pop	{r4, pc}
 80065b6:	7820      	ldrb	r0, [r4, #0]
 80065b8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80065bc:	1ac0      	subs	r0, r0, r3
 80065be:	bf18      	it	ne
 80065c0:	2001      	movne	r0, #1
 80065c2:	b002      	add	sp, #8
 80065c4:	bd10      	pop	{r4, pc}
 80065c6:	bf00      	nop

080065c8 <LSM6DSL_G_Check_WhoAmI>:
{
 80065c8:	b510      	push	{r4, lr}
 80065ca:	b082      	sub	sp, #8
  uint8_t who_am_i = 0x00;
 80065cc:	a902      	add	r1, sp, #8
 80065ce:	2300      	movs	r3, #0
 80065d0:	f801 3d01 	strb.w	r3, [r1, #-1]!
{
 80065d4:	4604      	mov	r4, r0
  if ( LSM6DSL_ACC_GYRO_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 80065d6:	f7fd fb11 	bl	8003bfc <LSM6DSL_ACC_GYRO_R_WHO_AM_I>
 80065da:	b910      	cbnz	r0, 80065e2 <LSM6DSL_G_Check_WhoAmI+0x1a>
 80065dc:	2001      	movs	r0, #1
}
 80065de:	b002      	add	sp, #8
 80065e0:	bd10      	pop	{r4, pc}
  if ( who_am_i != handle->who_am_i )
 80065e2:	7820      	ldrb	r0, [r4, #0]
 80065e4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80065e8:	1ac0      	subs	r0, r0, r3
 80065ea:	bf18      	it	ne
 80065ec:	2001      	movne	r0, #1
}
 80065ee:	b002      	add	sp, #8
 80065f0:	bd10      	pop	{r4, pc}
 80065f2:	bf00      	nop

080065f4 <LSM6DSL_X_Enable_6D_Orientation>:
{
 80065f4:	b538      	push	{r3, r4, r5, lr}
  if(handle->isEnabled == 1)
 80065f6:	7983      	ldrb	r3, [r0, #6]
 80065f8:	2b01      	cmp	r3, #1
{
 80065fa:	4604      	mov	r4, r0
 80065fc:	460d      	mov	r5, r1
  if(handle->isEnabled == 1)
 80065fe:	d021      	beq.n	8006644 <LSM6DSL_X_Enable_6D_Orientation+0x50>
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 8006600:	6883      	ldr	r3, [r0, #8]
  pComponentData->Previous_ODR = ( odr <=   13.0f ) ? 13.0f
 8006602:	4a18      	ldr	r2, [pc, #96]	; (8006664 <LSM6DSL_X_Enable_6D_Orientation+0x70>)
 8006604:	681b      	ldr	r3, [r3, #0]
 8006606:	605a      	str	r2, [r3, #4]
  if ( LSM6DSL_ACC_GYRO_W_FS_XL( (void *)handle, LSM6DSL_ACC_GYRO_FS_XL_2g ) == MEMS_ERROR )
 8006608:	2100      	movs	r1, #0
 800660a:	4620      	mov	r0, r4
 800660c:	f7fd fb22 	bl	8003c54 <LSM6DSL_ACC_GYRO_W_FS_XL>
 8006610:	b908      	cbnz	r0, 8006616 <LSM6DSL_X_Enable_6D_Orientation+0x22>
    return COMPONENT_ERROR;
 8006612:	2001      	movs	r0, #1
}
 8006614:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSL_ACC_GYRO_W_SIXD_THS( (void *)handle, LSM6DSL_ACC_GYRO_SIXD_THS_60_degree ) == MEMS_ERROR )
 8006616:	2140      	movs	r1, #64	; 0x40
 8006618:	4620      	mov	r0, r4
 800661a:	f7fe f899 	bl	8004750 <LSM6DSL_ACC_GYRO_W_SIXD_THS>
 800661e:	2800      	cmp	r0, #0
 8006620:	d0f7      	beq.n	8006612 <LSM6DSL_X_Enable_6D_Orientation+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSL_ACC_GYRO_BASIC_INT_ENABLED ) == MEMS_ERROR )
 8006622:	2180      	movs	r1, #128	; 0x80
 8006624:	4620      	mov	r0, r4
 8006626:	f7fe f84d 	bl	80046c4 <LSM6DSL_ACC_GYRO_W_BASIC_INT>
 800662a:	2800      	cmp	r0, #0
 800662c:	d0f1      	beq.n	8006612 <LSM6DSL_X_Enable_6D_Orientation+0x1e>
  switch (int_pin)
 800662e:	b185      	cbz	r5, 8006652 <LSM6DSL_X_Enable_6D_Orientation+0x5e>
 8006630:	2d01      	cmp	r5, #1
 8006632:	d1ee      	bne.n	8006612 <LSM6DSL_X_Enable_6D_Orientation+0x1e>
    if ( LSM6DSL_ACC_GYRO_W_6DEvOnInt2( (void *)handle, LSM6DSL_ACC_GYRO_INT2_6D_ENABLED ) == MEMS_ERROR )
 8006634:	4620      	mov	r0, r4
 8006636:	2104      	movs	r1, #4
 8006638:	f7fe fb12 	bl	8004c60 <LSM6DSL_ACC_GYRO_W_6DEvOnInt2>
    return COMPONENT_ERROR;
 800663c:	fab0 f080 	clz	r0, r0
 8006640:	0940      	lsrs	r0, r0, #5
 8006642:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSL_ACC_GYRO_W_ODR_XL( (void *)handle, new_odr ) == MEMS_ERROR )
 8006644:	2160      	movs	r1, #96	; 0x60
 8006646:	f7fd fb57 	bl	8003cf8 <LSM6DSL_ACC_GYRO_W_ODR_XL>
  if(LSM6DSL_X_Set_ODR_Value(handle, 416.0f) == COMPONENT_ERROR)
 800664a:	2800      	cmp	r0, #0
 800664c:	d1dc      	bne.n	8006608 <LSM6DSL_X_Enable_6D_Orientation+0x14>
    return COMPONENT_ERROR;
 800664e:	2001      	movs	r0, #1
}
 8006650:	bd38      	pop	{r3, r4, r5, pc}
    if ( LSM6DSL_ACC_GYRO_W_6DEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_6D_ENABLED ) == MEMS_ERROR )
 8006652:	4620      	mov	r0, r4
 8006654:	2104      	movs	r1, #4
 8006656:	f7fe fa37 	bl	8004ac8 <LSM6DSL_ACC_GYRO_W_6DEvOnInt1>
    return COMPONENT_ERROR;
 800665a:	fab0 f080 	clz	r0, r0
 800665e:	0940      	lsrs	r0, r0, #5
 8006660:	bd38      	pop	{r3, r4, r5, pc}
 8006662:	bf00      	nop
 8006664:	43d00000 	.word	0x43d00000

08006668 <LSM6DSL_X_Enable_Double_Tap_Detection>:
{
 8006668:	b538      	push	{r3, r4, r5, lr}
  if(handle->isEnabled == 1)
 800666a:	7983      	ldrb	r3, [r0, #6]
 800666c:	2b01      	cmp	r3, #1
{
 800666e:	4604      	mov	r4, r0
 8006670:	460d      	mov	r5, r1
  if(handle->isEnabled == 1)
 8006672:	d04b      	beq.n	800670c <LSM6DSL_X_Enable_Double_Tap_Detection+0xa4>
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 8006674:	6883      	ldr	r3, [r0, #8]
  pComponentData->Previous_ODR = ( odr <=   13.0f ) ? 13.0f
 8006676:	4a2d      	ldr	r2, [pc, #180]	; (800672c <LSM6DSL_X_Enable_Double_Tap_Detection+0xc4>)
 8006678:	681b      	ldr	r3, [r3, #0]
 800667a:	605a      	str	r2, [r3, #4]
  if ( LSM6DSL_ACC_GYRO_W_FS_XL( (void *)handle, LSM6DSL_ACC_GYRO_FS_XL_2g ) == MEMS_ERROR )
 800667c:	2100      	movs	r1, #0
 800667e:	4620      	mov	r0, r4
 8006680:	f7fd fae8 	bl	8003c54 <LSM6DSL_ACC_GYRO_W_FS_XL>
 8006684:	b908      	cbnz	r0, 800668a <LSM6DSL_X_Enable_Double_Tap_Detection+0x22>
    return COMPONENT_ERROR;
 8006686:	2001      	movs	r0, #1
 8006688:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSL_ACC_GYRO_W_TAP_X_EN( (void *)handle, LSM6DSL_ACC_GYRO_TAP_X_EN_ENABLED ) == MEMS_ERROR )
 800668a:	2108      	movs	r1, #8
 800668c:	4620      	mov	r0, r4
 800668e:	f7fd fff7 	bl	8004680 <LSM6DSL_ACC_GYRO_W_TAP_X_EN>
 8006692:	2800      	cmp	r0, #0
 8006694:	d0f7      	beq.n	8006686 <LSM6DSL_X_Enable_Double_Tap_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_TAP_Y_EN( (void *)handle, LSM6DSL_ACC_GYRO_TAP_Y_EN_ENABLED ) == MEMS_ERROR )
 8006696:	2104      	movs	r1, #4
 8006698:	4620      	mov	r0, r4
 800669a:	f7fd ffcf 	bl	800463c <LSM6DSL_ACC_GYRO_W_TAP_Y_EN>
 800669e:	2800      	cmp	r0, #0
 80066a0:	d0f1      	beq.n	8006686 <LSM6DSL_X_Enable_Double_Tap_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_TAP_Z_EN( (void *)handle, LSM6DSL_ACC_GYRO_TAP_Z_EN_ENABLED ) == MEMS_ERROR )
 80066a2:	2102      	movs	r1, #2
 80066a4:	4620      	mov	r0, r4
 80066a6:	f7fd ffa7 	bl	80045f8 <LSM6DSL_ACC_GYRO_W_TAP_Z_EN>
 80066aa:	2800      	cmp	r0, #0
 80066ac:	d0eb      	beq.n	8006686 <LSM6DSL_X_Enable_Double_Tap_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_TAP_THS( (void *)handle, thr ) == MEMS_ERROR )
 80066ae:	2108      	movs	r1, #8
 80066b0:	4620      	mov	r0, r4
 80066b2:	f7fe f829 	bl	8004708 <LSM6DSL_ACC_GYRO_W_TAP_THS>
 80066b6:	2800      	cmp	r0, #0
 80066b8:	d0e5      	beq.n	8006686 <LSM6DSL_X_Enable_Double_Tap_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_SHOCK_Duration( (void *)handle, time ) == MEMS_ERROR )
 80066ba:	2103      	movs	r1, #3
 80066bc:	4620      	mov	r0, r4
 80066be:	f7fe f869 	bl	8004794 <LSM6DSL_ACC_GYRO_W_SHOCK_Duration>
 80066c2:	2800      	cmp	r0, #0
 80066c4:	d0df      	beq.n	8006686 <LSM6DSL_X_Enable_Double_Tap_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_QUIET_Duration( (void *)handle, time ) == MEMS_ERROR )
 80066c6:	2103      	movs	r1, #3
 80066c8:	4620      	mov	r0, r4
 80066ca:	f7fe f887 	bl	80047dc <LSM6DSL_ACC_GYRO_W_QUIET_Duration>
 80066ce:	2800      	cmp	r0, #0
 80066d0:	d0d9      	beq.n	8006686 <LSM6DSL_X_Enable_Double_Tap_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_DUR( (void *)handle, time ) == MEMS_ERROR )
 80066d2:	2108      	movs	r1, #8
 80066d4:	4620      	mov	r0, r4
 80066d6:	f7fe f8a5 	bl	8004824 <LSM6DSL_ACC_GYRO_W_DUR>
 80066da:	2800      	cmp	r0, #0
 80066dc:	d0d3      	beq.n	8006686 <LSM6DSL_X_Enable_Double_Tap_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_SINGLE_DOUBLE_TAP_EV( (void *)handle,
 80066de:	2180      	movs	r1, #128	; 0x80
 80066e0:	4620      	mov	r0, r4
 80066e2:	f7fe f8e5 	bl	80048b0 <LSM6DSL_ACC_GYRO_W_SINGLE_DOUBLE_TAP_EV>
 80066e6:	2800      	cmp	r0, #0
 80066e8:	d0cd      	beq.n	8006686 <LSM6DSL_X_Enable_Double_Tap_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSL_ACC_GYRO_BASIC_INT_ENABLED ) == MEMS_ERROR )
 80066ea:	2180      	movs	r1, #128	; 0x80
 80066ec:	4620      	mov	r0, r4
 80066ee:	f7fd ffe9 	bl	80046c4 <LSM6DSL_ACC_GYRO_W_BASIC_INT>
 80066f2:	2800      	cmp	r0, #0
 80066f4:	d0c7      	beq.n	8006686 <LSM6DSL_X_Enable_Double_Tap_Detection+0x1e>
  switch (int_pin)
 80066f6:	b185      	cbz	r5, 800671a <LSM6DSL_X_Enable_Double_Tap_Detection+0xb2>
 80066f8:	2d01      	cmp	r5, #1
 80066fa:	d1c4      	bne.n	8006686 <LSM6DSL_X_Enable_Double_Tap_Detection+0x1e>
    if ( LSM6DSL_ACC_GYRO_W_TapEvOnInt2( (void *)handle, LSM6DSL_ACC_GYRO_INT2_TAP_ENABLED ) == MEMS_ERROR )
 80066fc:	4620      	mov	r0, r4
 80066fe:	2108      	movs	r1, #8
 8006700:	f7fe fad0 	bl	8004ca4 <LSM6DSL_ACC_GYRO_W_TapEvOnInt2>
    return COMPONENT_ERROR;
 8006704:	fab0 f080 	clz	r0, r0
 8006708:	0940      	lsrs	r0, r0, #5
 800670a:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSL_ACC_GYRO_W_ODR_XL( (void *)handle, new_odr ) == MEMS_ERROR )
 800670c:	2160      	movs	r1, #96	; 0x60
 800670e:	f7fd faf3 	bl	8003cf8 <LSM6DSL_ACC_GYRO_W_ODR_XL>
  if(LSM6DSL_X_Set_ODR_Value(handle, 416.0f) == COMPONENT_ERROR)
 8006712:	2800      	cmp	r0, #0
 8006714:	d1b2      	bne.n	800667c <LSM6DSL_X_Enable_Double_Tap_Detection+0x14>
    return COMPONENT_ERROR;
 8006716:	2001      	movs	r0, #1
 8006718:	bd38      	pop	{r3, r4, r5, pc}
    if ( LSM6DSL_ACC_GYRO_W_TapEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_TAP_ENABLED ) == MEMS_ERROR )
 800671a:	4620      	mov	r0, r4
 800671c:	2108      	movs	r1, #8
 800671e:	f7fe f9f5 	bl	8004b0c <LSM6DSL_ACC_GYRO_W_TapEvOnInt1>
    return COMPONENT_ERROR;
 8006722:	fab0 f080 	clz	r0, r0
 8006726:	0940      	lsrs	r0, r0, #5
 8006728:	bd38      	pop	{r3, r4, r5, pc}
 800672a:	bf00      	nop
 800672c:	43d00000 	.word	0x43d00000

08006730 <LSM6DSL_X_Enable_Wake_Up_Detection>:
{
 8006730:	b538      	push	{r3, r4, r5, lr}
  if(handle->isEnabled == 1)
 8006732:	7983      	ldrb	r3, [r0, #6]
 8006734:	2b01      	cmp	r3, #1
{
 8006736:	4604      	mov	r4, r0
 8006738:	460d      	mov	r5, r1
  if(handle->isEnabled == 1)
 800673a:	d027      	beq.n	800678c <LSM6DSL_X_Enable_Wake_Up_Detection+0x5c>
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 800673c:	6883      	ldr	r3, [r0, #8]
  pComponentData->Previous_ODR = ( odr <=   13.0f ) ? 13.0f
 800673e:	4a1b      	ldr	r2, [pc, #108]	; (80067ac <LSM6DSL_X_Enable_Wake_Up_Detection+0x7c>)
 8006740:	681b      	ldr	r3, [r3, #0]
 8006742:	605a      	str	r2, [r3, #4]
  if ( LSM6DSL_ACC_GYRO_W_FS_XL( (void *)handle, LSM6DSL_ACC_GYRO_FS_XL_2g ) == MEMS_ERROR )
 8006744:	2100      	movs	r1, #0
 8006746:	4620      	mov	r0, r4
 8006748:	f7fd fa84 	bl	8003c54 <LSM6DSL_ACC_GYRO_W_FS_XL>
 800674c:	b908      	cbnz	r0, 8006752 <LSM6DSL_X_Enable_Wake_Up_Detection+0x22>
    return COMPONENT_ERROR;
 800674e:	2001      	movs	r0, #1
}
 8006750:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSL_ACC_GYRO_W_WAKE_DUR( (void *)handle, 0x00 ) == MEMS_ERROR )
 8006752:	2100      	movs	r1, #0
 8006754:	4620      	mov	r0, r4
 8006756:	f7fe f913 	bl	8004980 <LSM6DSL_ACC_GYRO_W_WAKE_DUR>
 800675a:	2800      	cmp	r0, #0
 800675c:	d0f7      	beq.n	800674e <LSM6DSL_X_Enable_Wake_Up_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_WK_THS( (void *)handle, 0x02 ) == MEMS_ERROR )
 800675e:	2102      	movs	r1, #2
 8006760:	4620      	mov	r0, r4
 8006762:	f7fe f881 	bl	8004868 <LSM6DSL_ACC_GYRO_W_WK_THS>
 8006766:	2800      	cmp	r0, #0
 8006768:	d0f1      	beq.n	800674e <LSM6DSL_X_Enable_Wake_Up_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSL_ACC_GYRO_BASIC_INT_ENABLED ) == MEMS_ERROR )
 800676a:	2180      	movs	r1, #128	; 0x80
 800676c:	4620      	mov	r0, r4
 800676e:	f7fd ffa9 	bl	80046c4 <LSM6DSL_ACC_GYRO_W_BASIC_INT>
 8006772:	2800      	cmp	r0, #0
 8006774:	d0eb      	beq.n	800674e <LSM6DSL_X_Enable_Wake_Up_Detection+0x1e>
  switch (int_pin)
 8006776:	b185      	cbz	r5, 800679a <LSM6DSL_X_Enable_Wake_Up_Detection+0x6a>
 8006778:	2d01      	cmp	r5, #1
 800677a:	d1e8      	bne.n	800674e <LSM6DSL_X_Enable_Wake_Up_Detection+0x1e>
    if ( LSM6DSL_ACC_GYRO_W_WUEvOnInt2( (void *)handle, LSM6DSL_ACC_GYRO_INT2_WU_ENABLED ) == MEMS_ERROR )
 800677c:	4620      	mov	r0, r4
 800677e:	2120      	movs	r1, #32
 8006780:	f7fe fad4 	bl	8004d2c <LSM6DSL_ACC_GYRO_W_WUEvOnInt2>
    return COMPONENT_ERROR;
 8006784:	fab0 f080 	clz	r0, r0
 8006788:	0940      	lsrs	r0, r0, #5
 800678a:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSL_ACC_GYRO_W_ODR_XL( (void *)handle, new_odr ) == MEMS_ERROR )
 800678c:	2160      	movs	r1, #96	; 0x60
 800678e:	f7fd fab3 	bl	8003cf8 <LSM6DSL_ACC_GYRO_W_ODR_XL>
  if(LSM6DSL_X_Set_ODR_Value(handle, 416.0f) == COMPONENT_ERROR)
 8006792:	2800      	cmp	r0, #0
 8006794:	d1d6      	bne.n	8006744 <LSM6DSL_X_Enable_Wake_Up_Detection+0x14>
    return COMPONENT_ERROR;
 8006796:	2001      	movs	r0, #1
}
 8006798:	bd38      	pop	{r3, r4, r5, pc}
    if ( LSM6DSL_ACC_GYRO_W_WUEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_WU_ENABLED ) == MEMS_ERROR )
 800679a:	4620      	mov	r0, r4
 800679c:	2120      	movs	r1, #32
 800679e:	f7fe f9f9 	bl	8004b94 <LSM6DSL_ACC_GYRO_W_WUEvOnInt1>
    return COMPONENT_ERROR;
 80067a2:	fab0 f080 	clz	r0, r0
 80067a6:	0940      	lsrs	r0, r0, #5
 80067a8:	bd38      	pop	{r3, r4, r5, pc}
 80067aa:	bf00      	nop
 80067ac:	43d00000 	.word	0x43d00000

080067b0 <LSM6DSL_X_Enable_Single_Tap_Detection>:
{
 80067b0:	b538      	push	{r3, r4, r5, lr}
  if(handle->isEnabled == 1)
 80067b2:	7983      	ldrb	r3, [r0, #6]
 80067b4:	2b01      	cmp	r3, #1
{
 80067b6:	4604      	mov	r4, r0
 80067b8:	460d      	mov	r5, r1
  if(handle->isEnabled == 1)
 80067ba:	d03f      	beq.n	800683c <LSM6DSL_X_Enable_Single_Tap_Detection+0x8c>
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 80067bc:	6883      	ldr	r3, [r0, #8]
  pComponentData->Previous_ODR = ( odr <=   13.0f ) ? 13.0f
 80067be:	4a27      	ldr	r2, [pc, #156]	; (800685c <LSM6DSL_X_Enable_Single_Tap_Detection+0xac>)
 80067c0:	681b      	ldr	r3, [r3, #0]
 80067c2:	605a      	str	r2, [r3, #4]
  if ( LSM6DSL_ACC_GYRO_W_FS_XL( (void *)handle, LSM6DSL_ACC_GYRO_FS_XL_2g ) == MEMS_ERROR )
 80067c4:	2100      	movs	r1, #0
 80067c6:	4620      	mov	r0, r4
 80067c8:	f7fd fa44 	bl	8003c54 <LSM6DSL_ACC_GYRO_W_FS_XL>
 80067cc:	b908      	cbnz	r0, 80067d2 <LSM6DSL_X_Enable_Single_Tap_Detection+0x22>
    return COMPONENT_ERROR;
 80067ce:	2001      	movs	r0, #1
 80067d0:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSL_ACC_GYRO_W_TAP_X_EN( (void *)handle, LSM6DSL_ACC_GYRO_TAP_X_EN_ENABLED ) == MEMS_ERROR )
 80067d2:	2108      	movs	r1, #8
 80067d4:	4620      	mov	r0, r4
 80067d6:	f7fd ff53 	bl	8004680 <LSM6DSL_ACC_GYRO_W_TAP_X_EN>
 80067da:	2800      	cmp	r0, #0
 80067dc:	d0f7      	beq.n	80067ce <LSM6DSL_X_Enable_Single_Tap_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_TAP_Y_EN( (void *)handle, LSM6DSL_ACC_GYRO_TAP_Y_EN_ENABLED ) == MEMS_ERROR )
 80067de:	2104      	movs	r1, #4
 80067e0:	4620      	mov	r0, r4
 80067e2:	f7fd ff2b 	bl	800463c <LSM6DSL_ACC_GYRO_W_TAP_Y_EN>
 80067e6:	2800      	cmp	r0, #0
 80067e8:	d0f1      	beq.n	80067ce <LSM6DSL_X_Enable_Single_Tap_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_TAP_Z_EN( (void *)handle, LSM6DSL_ACC_GYRO_TAP_Z_EN_ENABLED ) == MEMS_ERROR )
 80067ea:	2102      	movs	r1, #2
 80067ec:	4620      	mov	r0, r4
 80067ee:	f7fd ff03 	bl	80045f8 <LSM6DSL_ACC_GYRO_W_TAP_Z_EN>
 80067f2:	2800      	cmp	r0, #0
 80067f4:	d0eb      	beq.n	80067ce <LSM6DSL_X_Enable_Single_Tap_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_TAP_THS( (void *)handle, thr ) == MEMS_ERROR )
 80067f6:	2108      	movs	r1, #8
 80067f8:	4620      	mov	r0, r4
 80067fa:	f7fd ff85 	bl	8004708 <LSM6DSL_ACC_GYRO_W_TAP_THS>
 80067fe:	2800      	cmp	r0, #0
 8006800:	d0e5      	beq.n	80067ce <LSM6DSL_X_Enable_Single_Tap_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_SHOCK_Duration( (void *)handle, time ) == MEMS_ERROR )
 8006802:	2102      	movs	r1, #2
 8006804:	4620      	mov	r0, r4
 8006806:	f7fd ffc5 	bl	8004794 <LSM6DSL_ACC_GYRO_W_SHOCK_Duration>
 800680a:	2800      	cmp	r0, #0
 800680c:	d0df      	beq.n	80067ce <LSM6DSL_X_Enable_Single_Tap_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_QUIET_Duration( (void *)handle, time ) == MEMS_ERROR )
 800680e:	2101      	movs	r1, #1
 8006810:	4620      	mov	r0, r4
 8006812:	f7fd ffe3 	bl	80047dc <LSM6DSL_ACC_GYRO_W_QUIET_Duration>
 8006816:	2800      	cmp	r0, #0
 8006818:	d0d9      	beq.n	80067ce <LSM6DSL_X_Enable_Single_Tap_Detection+0x1e>
  if ( LSM6DSL_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSL_ACC_GYRO_BASIC_INT_ENABLED ) == MEMS_ERROR )
 800681a:	2180      	movs	r1, #128	; 0x80
 800681c:	4620      	mov	r0, r4
 800681e:	f7fd ff51 	bl	80046c4 <LSM6DSL_ACC_GYRO_W_BASIC_INT>
 8006822:	2800      	cmp	r0, #0
 8006824:	d0d3      	beq.n	80067ce <LSM6DSL_X_Enable_Single_Tap_Detection+0x1e>
  switch (int_pin)
 8006826:	b185      	cbz	r5, 800684a <LSM6DSL_X_Enable_Single_Tap_Detection+0x9a>
 8006828:	2d01      	cmp	r5, #1
 800682a:	d1d0      	bne.n	80067ce <LSM6DSL_X_Enable_Single_Tap_Detection+0x1e>
    if ( LSM6DSL_ACC_GYRO_W_SingleTapOnInt2( (void *)handle, LSM6DSL_ACC_GYRO_INT2_SINGLE_TAP_ENABLED ) == MEMS_ERROR )
 800682c:	4620      	mov	r0, r4
 800682e:	2140      	movs	r1, #64	; 0x40
 8006830:	f7fe fa9e 	bl	8004d70 <LSM6DSL_ACC_GYRO_W_SingleTapOnInt2>
    return COMPONENT_ERROR;
 8006834:	fab0 f080 	clz	r0, r0
 8006838:	0940      	lsrs	r0, r0, #5
 800683a:	bd38      	pop	{r3, r4, r5, pc}
  if ( LSM6DSL_ACC_GYRO_W_ODR_XL( (void *)handle, new_odr ) == MEMS_ERROR )
 800683c:	2160      	movs	r1, #96	; 0x60
 800683e:	f7fd fa5b 	bl	8003cf8 <LSM6DSL_ACC_GYRO_W_ODR_XL>
  if(LSM6DSL_X_Set_ODR_Value(handle, 416.0f) == COMPONENT_ERROR)
 8006842:	2800      	cmp	r0, #0
 8006844:	d1be      	bne.n	80067c4 <LSM6DSL_X_Enable_Single_Tap_Detection+0x14>
    return COMPONENT_ERROR;
 8006846:	2001      	movs	r0, #1
 8006848:	bd38      	pop	{r3, r4, r5, pc}
    if ( LSM6DSL_ACC_GYRO_W_SingleTapOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_SINGLE_TAP_ENABLED ) == MEMS_ERROR )
 800684a:	4620      	mov	r0, r4
 800684c:	2140      	movs	r1, #64	; 0x40
 800684e:	f7fe f9c3 	bl	8004bd8 <LSM6DSL_ACC_GYRO_W_SingleTapOnInt1>
    return COMPONENT_ERROR;
 8006852:	fab0 f080 	clz	r0, r0
 8006856:	0940      	lsrs	r0, r0, #5
 8006858:	bd38      	pop	{r3, r4, r5, pc}
 800685a:	bf00      	nop
 800685c:	43d00000 	.word	0x43d00000

08006860 <LSM6DSL_G_Init>:
{
 8006860:	b5f0      	push	{r4, r5, r6, r7, lr}
  LSM6DSL_G_Data_t *pComponentData = ( LSM6DSL_G_Data_t * )pData->pComponentData;
 8006862:	6883      	ldr	r3, [r0, #8]
{
 8006864:	b083      	sub	sp, #12
  LSM6DSL_G_Data_t *pComponentData = ( LSM6DSL_G_Data_t * )pData->pComponentData;
 8006866:	681e      	ldr	r6, [r3, #0]
  uint8_t who_am_i = 0x00;
 8006868:	a902      	add	r1, sp, #8
 800686a:	2400      	movs	r4, #0
  LSM6DSL_Combo_Data_t *comboData = pComponentData->comboData;
 800686c:	6837      	ldr	r7, [r6, #0]
  uint8_t who_am_i = 0x00;
 800686e:	f801 4d01 	strb.w	r4, [r1, #-1]!
{
 8006872:	4605      	mov	r5, r0
  if ( LSM6DSL_ACC_GYRO_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 8006874:	f7fd f9c2 	bl	8003bfc <LSM6DSL_ACC_GYRO_R_WHO_AM_I>
 8006878:	b120      	cbz	r0, 8006884 <LSM6DSL_G_Init+0x24>
  if ( who_am_i != handle->who_am_i )
 800687a:	782a      	ldrb	r2, [r5, #0]
 800687c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8006880:	429a      	cmp	r2, r3
 8006882:	d002      	beq.n	800688a <LSM6DSL_G_Init+0x2a>
    return COMPONENT_ERROR;
 8006884:	2001      	movs	r0, #1
}
 8006886:	b003      	add	sp, #12
 8006888:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ( LSM6DSL_ACC_GYRO_W_IF_Addr_Incr( (void *)handle, LSM6DSL_ACC_GYRO_IF_INC_ENABLED ) == MEMS_ERROR )
 800688a:	2104      	movs	r1, #4
 800688c:	4628      	mov	r0, r5
 800688e:	f7fd fc3f 	bl	8004110 <LSM6DSL_ACC_GYRO_W_IF_Addr_Incr>
 8006892:	2800      	cmp	r0, #0
 8006894:	d0f6      	beq.n	8006884 <LSM6DSL_G_Init+0x24>
  if ( LSM6DSL_ACC_GYRO_W_BDU( (void *)handle, LSM6DSL_ACC_GYRO_BDU_BLOCK_UPDATE ) == MEMS_ERROR )
 8006896:	2140      	movs	r1, #64	; 0x40
 8006898:	4628      	mov	r0, r5
 800689a:	f7fd f9b9 	bl	8003c10 <LSM6DSL_ACC_GYRO_W_BDU>
 800689e:	2800      	cmp	r0, #0
 80068a0:	d0f0      	beq.n	8006884 <LSM6DSL_G_Init+0x24>
  if ( LSM6DSL_ACC_GYRO_W_FIFO_MODE( (void *)handle, LSM6DSL_ACC_GYRO_FIFO_MODE_BYPASS ) == MEMS_ERROR )
 80068a2:	4621      	mov	r1, r4
 80068a4:	4628      	mov	r0, r5
 80068a6:	f7fd fbab 	bl	8004000 <LSM6DSL_ACC_GYRO_W_FIFO_MODE>
 80068aa:	2800      	cmp	r0, #0
 80068ac:	d0ea      	beq.n	8006884 <LSM6DSL_G_Init+0x24>
  pComponentData->Previous_ODR = 104.0f;
 80068ae:	4b09      	ldr	r3, [pc, #36]	; (80068d4 <LSM6DSL_G_Init+0x74>)
 80068b0:	6073      	str	r3, [r6, #4]
  if ( LSM6DSL_ACC_GYRO_W_ODR_G( (void *)handle, LSM6DSL_ACC_GYRO_ODR_G_POWER_DOWN ) == MEMS_ERROR )
 80068b2:	4621      	mov	r1, r4
 80068b4:	4628      	mov	r0, r5
 80068b6:	f7fd faa3 	bl	8003e00 <LSM6DSL_ACC_GYRO_W_ODR_G>
 80068ba:	2800      	cmp	r0, #0
 80068bc:	d0e2      	beq.n	8006884 <LSM6DSL_G_Init+0x24>
  if ( LSM6DSL_ACC_GYRO_W_FS_G( (void *)handle, new_fs ) == MEMS_ERROR )
 80068be:	210c      	movs	r1, #12
 80068c0:	4628      	mov	r0, r5
 80068c2:	f7fd fa4b 	bl	8003d5c <LSM6DSL_ACC_GYRO_W_FS_G>
 80068c6:	2800      	cmp	r0, #0
 80068c8:	d0dc      	beq.n	8006884 <LSM6DSL_G_Init+0x24>
  comboData->isGyroInitialized = 1;
 80068ca:	2301      	movs	r3, #1
 80068cc:	707b      	strb	r3, [r7, #1]
  return COMPONENT_OK;
 80068ce:	4620      	mov	r0, r4
  handle->isInitialized = 1;
 80068d0:	716b      	strb	r3, [r5, #5]
  return COMPONENT_OK;
 80068d2:	e7d8      	b.n	8006886 <LSM6DSL_G_Init+0x26>
 80068d4:	42d00000 	.word	0x42d00000

080068d8 <LSM6DSL_X_Init>:
{
 80068d8:	b5f0      	push	{r4, r5, r6, r7, lr}
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 80068da:	6883      	ldr	r3, [r0, #8]
{
 80068dc:	b083      	sub	sp, #12
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 80068de:	681e      	ldr	r6, [r3, #0]
  uint8_t who_am_i = 0x00;
 80068e0:	a902      	add	r1, sp, #8
 80068e2:	2400      	movs	r4, #0
  LSM6DSL_Combo_Data_t *comboData = pComponentData->comboData;
 80068e4:	6837      	ldr	r7, [r6, #0]
  uint8_t who_am_i = 0x00;
 80068e6:	f801 4d01 	strb.w	r4, [r1, #-1]!
{
 80068ea:	4605      	mov	r5, r0
  if ( LSM6DSL_ACC_GYRO_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 80068ec:	f7fd f986 	bl	8003bfc <LSM6DSL_ACC_GYRO_R_WHO_AM_I>
 80068f0:	b120      	cbz	r0, 80068fc <LSM6DSL_X_Init+0x24>
  if ( who_am_i != handle->who_am_i )
 80068f2:	782a      	ldrb	r2, [r5, #0]
 80068f4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80068f8:	429a      	cmp	r2, r3
 80068fa:	d002      	beq.n	8006902 <LSM6DSL_X_Init+0x2a>
    return COMPONENT_ERROR;
 80068fc:	2001      	movs	r0, #1
}
 80068fe:	b003      	add	sp, #12
 8006900:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ( LSM6DSL_ACC_GYRO_W_IF_Addr_Incr( (void *)handle, LSM6DSL_ACC_GYRO_IF_INC_ENABLED ) == MEMS_ERROR )
 8006902:	2104      	movs	r1, #4
 8006904:	4628      	mov	r0, r5
 8006906:	f7fd fc03 	bl	8004110 <LSM6DSL_ACC_GYRO_W_IF_Addr_Incr>
 800690a:	2800      	cmp	r0, #0
 800690c:	d0f6      	beq.n	80068fc <LSM6DSL_X_Init+0x24>
  if ( LSM6DSL_ACC_GYRO_W_BDU( (void *)handle, LSM6DSL_ACC_GYRO_BDU_BLOCK_UPDATE ) == MEMS_ERROR )
 800690e:	2140      	movs	r1, #64	; 0x40
 8006910:	4628      	mov	r0, r5
 8006912:	f7fd f97d 	bl	8003c10 <LSM6DSL_ACC_GYRO_W_BDU>
 8006916:	2800      	cmp	r0, #0
 8006918:	d0f0      	beq.n	80068fc <LSM6DSL_X_Init+0x24>
  if ( LSM6DSL_ACC_GYRO_W_FIFO_MODE( (void *)handle, LSM6DSL_ACC_GYRO_FIFO_MODE_BYPASS ) == MEMS_ERROR )
 800691a:	4621      	mov	r1, r4
 800691c:	4628      	mov	r0, r5
 800691e:	f7fd fb6f 	bl	8004000 <LSM6DSL_ACC_GYRO_W_FIFO_MODE>
 8006922:	2800      	cmp	r0, #0
 8006924:	d0ea      	beq.n	80068fc <LSM6DSL_X_Init+0x24>
  pComponentData->Previous_ODR = 104.0f;
 8006926:	4b09      	ldr	r3, [pc, #36]	; (800694c <LSM6DSL_X_Init+0x74>)
 8006928:	6073      	str	r3, [r6, #4]
  if ( LSM6DSL_ACC_GYRO_W_ODR_XL( (void *)handle, LSM6DSL_ACC_GYRO_ODR_XL_POWER_DOWN ) == MEMS_ERROR )
 800692a:	4621      	mov	r1, r4
 800692c:	4628      	mov	r0, r5
 800692e:	f7fd f9e3 	bl	8003cf8 <LSM6DSL_ACC_GYRO_W_ODR_XL>
 8006932:	2800      	cmp	r0, #0
 8006934:	d0e2      	beq.n	80068fc <LSM6DSL_X_Init+0x24>
  if ( LSM6DSL_ACC_GYRO_W_FS_XL( (void *)handle, new_fs ) == MEMS_ERROR )
 8006936:	4621      	mov	r1, r4
 8006938:	4628      	mov	r0, r5
 800693a:	f7fd f98b 	bl	8003c54 <LSM6DSL_ACC_GYRO_W_FS_XL>
 800693e:	2800      	cmp	r0, #0
 8006940:	d0dc      	beq.n	80068fc <LSM6DSL_X_Init+0x24>
  comboData->isAccInitialized = 1;
 8006942:	2301      	movs	r3, #1
 8006944:	703b      	strb	r3, [r7, #0]
  return COMPONENT_OK;
 8006946:	4620      	mov	r0, r4
  handle->isInitialized = 1;
 8006948:	716b      	strb	r3, [r5, #5]
  return COMPONENT_OK;
 800694a:	e7d8      	b.n	80068fe <LSM6DSL_X_Init+0x26>
 800694c:	42d00000 	.word	0x42d00000

08006950 <LSM6DSL_FIFO_G_Get_Axis>:
{
 8006950:	b570      	push	{r4, r5, r6, lr}
 8006952:	b082      	sub	sp, #8
 8006954:	460e      	mov	r6, r1
  if ( LSM6DSL_ACC_GYRO_Get_GetFIFOData( handle, aData ) == MEMS_ERROR )
 8006956:	a901      	add	r1, sp, #4
{
 8006958:	4605      	mov	r5, r0
  if ( LSM6DSL_ACC_GYRO_Get_GetFIFOData( handle, aData ) == MEMS_ERROR )
 800695a:	f7fe fa2b 	bl	8004db4 <LSM6DSL_ACC_GYRO_Get_GetFIFOData>
 800695e:	b318      	cbz	r0, 80069a8 <LSM6DSL_FIFO_G_Get_Axis+0x58>
  rawData = ( aData[1] << 8 ) | aData[0];
 8006960:	f89d 2005 	ldrb.w	r2, [sp, #5]
 8006964:	f89d 3004 	ldrb.w	r3, [sp, #4]
  if ( LSM6DSL_ACC_GYRO_R_FS_125( (void *)handle, &fullScale125 ) == MEMS_ERROR )
 8006968:	f10d 0102 	add.w	r1, sp, #2
  rawData = ( aData[1] << 8 ) | aData[0];
 800696c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  if ( LSM6DSL_ACC_GYRO_R_FS_125( (void *)handle, &fullScale125 ) == MEMS_ERROR )
 8006970:	4628      	mov	r0, r5
  rawData = ( aData[1] << 8 ) | aData[0];
 8006972:	b21c      	sxth	r4, r3
  if ( LSM6DSL_ACC_GYRO_R_FS_125( (void *)handle, &fullScale125 ) == MEMS_ERROR )
 8006974:	f7fd fa98 	bl	8003ea8 <LSM6DSL_ACC_GYRO_R_FS_125>
 8006978:	b1b0      	cbz	r0, 80069a8 <LSM6DSL_FIFO_G_Get_Axis+0x58>
  if ( fullScale125 == LSM6DSL_ACC_GYRO_FS_125_ENABLED )
 800697a:	f89d 3002 	ldrb.w	r3, [sp, #2]
 800697e:	2b02      	cmp	r3, #2
 8006980:	d015      	beq.n	80069ae <LSM6DSL_FIFO_G_Get_Axis+0x5e>
    if ( LSM6DSL_ACC_GYRO_R_FS_G( (void *)handle, &fullScale ) == MEMS_ERROR )
 8006982:	4628      	mov	r0, r5
 8006984:	f10d 0103 	add.w	r1, sp, #3
 8006988:	f7fd fa0a 	bl	8003da0 <LSM6DSL_ACC_GYRO_R_FS_G>
 800698c:	b160      	cbz	r0, 80069a8 <LSM6DSL_FIFO_G_Get_Axis+0x58>
    switch( fullScale )
 800698e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006992:	2b0c      	cmp	r3, #12
 8006994:	d808      	bhi.n	80069a8 <LSM6DSL_FIFO_G_Get_Axis+0x58>
 8006996:	e8df f003 	tbb	[pc, r3]
 800699a:	0722      	.short	0x0722
 800699c:	071f0707 	.word	0x071f0707
 80069a0:	071c0707 	.word	0x071c0707
 80069a4:	0707      	.short	0x0707
 80069a6:	19          	.byte	0x19
 80069a7:	00          	.byte	0x00
    return COMPONENT_ERROR;
 80069a8:	2001      	movs	r0, #1
}
 80069aa:	b002      	add	sp, #8
 80069ac:	bd70      	pop	{r4, r5, r6, pc}
    *sensitivity = ( float )LSM6DSL_GYRO_SENSITIVITY_FOR_FS_125DPS;
 80069ae:	ed9f 7a0d 	vldr	s14, [pc, #52]	; 80069e4 <LSM6DSL_FIFO_G_Get_Axis+0x94>
  *angular_velocity = ( int32_t )( rawData * sensitivity );
 80069b2:	ee07 4a90 	vmov	s15, r4
 80069b6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  return COMPONENT_OK;
 80069ba:	2000      	movs	r0, #0
  *angular_velocity = ( int32_t )( rawData * sensitivity );
 80069bc:	ee67 7a87 	vmul.f32	s15, s15, s14
 80069c0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80069c4:	edc6 7a00 	vstr	s15, [r6]
}
 80069c8:	b002      	add	sp, #8
 80069ca:	bd70      	pop	{r4, r5, r6, pc}
        *sensitivity = ( float )LSM6DSL_GYRO_SENSITIVITY_FOR_FS_2000DPS;
 80069cc:	ed9f 7a06 	vldr	s14, [pc, #24]	; 80069e8 <LSM6DSL_FIFO_G_Get_Axis+0x98>
 80069d0:	e7ef      	b.n	80069b2 <LSM6DSL_FIFO_G_Get_Axis+0x62>
        *sensitivity = ( float )LSM6DSL_GYRO_SENSITIVITY_FOR_FS_1000DPS;
 80069d2:	ed9f 7a06 	vldr	s14, [pc, #24]	; 80069ec <LSM6DSL_FIFO_G_Get_Axis+0x9c>
 80069d6:	e7ec      	b.n	80069b2 <LSM6DSL_FIFO_G_Get_Axis+0x62>
        *sensitivity = ( float )LSM6DSL_GYRO_SENSITIVITY_FOR_FS_500DPS;
 80069d8:	ed9f 7a05 	vldr	s14, [pc, #20]	; 80069f0 <LSM6DSL_FIFO_G_Get_Axis+0xa0>
 80069dc:	e7e9      	b.n	80069b2 <LSM6DSL_FIFO_G_Get_Axis+0x62>
        *sensitivity = ( float )LSM6DSL_GYRO_SENSITIVITY_FOR_FS_245DPS;
 80069de:	ed9f 7a05 	vldr	s14, [pc, #20]	; 80069f4 <LSM6DSL_FIFO_G_Get_Axis+0xa4>
 80069e2:	e7e6      	b.n	80069b2 <LSM6DSL_FIFO_G_Get_Axis+0x62>
 80069e4:	408c0000 	.word	0x408c0000
 80069e8:	428c0000 	.word	0x428c0000
 80069ec:	420c0000 	.word	0x420c0000
 80069f0:	418c0000 	.word	0x418c0000
 80069f4:	410c0000 	.word	0x410c0000

080069f8 <LSM6DSL_G_Get_Axes>:
{
 80069f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80069fc:	b084      	sub	sp, #16
  uint8_t regValue[6] = {0, 0, 0, 0, 0, 0};
 80069fe:	2300      	movs	r3, #0
{
 8006a00:	460e      	mov	r6, r1
  if ( LSM6DSL_ACC_GYRO_GetRawGyroData( (void *)handle, ( uint8_t* )regValue ) == MEMS_ERROR )
 8006a02:	a902      	add	r1, sp, #8
  uint8_t regValue[6] = {0, 0, 0, 0, 0, 0};
 8006a04:	f8ad 300c 	strh.w	r3, [sp, #12]
 8006a08:	9302      	str	r3, [sp, #8]
{
 8006a0a:	4607      	mov	r7, r0
  if ( LSM6DSL_ACC_GYRO_GetRawGyroData( (void *)handle, ( uint8_t* )regValue ) == MEMS_ERROR )
 8006a0c:	f7fd f9d8 	bl	8003dc0 <LSM6DSL_ACC_GYRO_GetRawGyroData>
 8006a10:	b388      	cbz	r0, 8006a76 <LSM6DSL_G_Get_Axes+0x7e>
  pData[0] = ( ( ( ( int16_t )regValue[1] ) << 8 ) + ( int16_t )regValue[0] );
 8006a12:	f89d 5009 	ldrb.w	r5, [sp, #9]
  pData[1] = ( ( ( ( int16_t )regValue[3] ) << 8 ) + ( int16_t )regValue[2] );
 8006a16:	f89d 000b 	ldrb.w	r0, [sp, #11]
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 8006a1a:	f89d 100d 	ldrb.w	r1, [sp, #13]
  pData[0] = ( ( ( ( int16_t )regValue[1] ) << 8 ) + ( int16_t )regValue[0] );
 8006a1e:	f89d 4008 	ldrb.w	r4, [sp, #8]
  pData[1] = ( ( ( ( int16_t )regValue[3] ) << 8 ) + ( int16_t )regValue[2] );
 8006a22:	f89d 200a 	ldrb.w	r2, [sp, #10]
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 8006a26:	f89d 300c 	ldrb.w	r3, [sp, #12]
  pData[0] = ( ( ( ( int16_t )regValue[1] ) << 8 ) + ( int16_t )regValue[0] );
 8006a2a:	eb04 2405 	add.w	r4, r4, r5, lsl #8
  pData[1] = ( ( ( ( int16_t )regValue[3] ) << 8 ) + ( int16_t )regValue[2] );
 8006a2e:	eb02 2200 	add.w	r2, r2, r0, lsl #8
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 8006a32:	eb03 2301 	add.w	r3, r3, r1, lsl #8
  if ( LSM6DSL_ACC_GYRO_R_FS_125( (void *)handle, &fullScale125 ) == MEMS_ERROR )
 8006a36:	4638      	mov	r0, r7
 8006a38:	f10d 0107 	add.w	r1, sp, #7
  pData[0] = ( ( ( ( int16_t )regValue[1] ) << 8 ) + ( int16_t )regValue[0] );
 8006a3c:	fa0f f884 	sxth.w	r8, r4
  pData[1] = ( ( ( ( int16_t )regValue[3] ) << 8 ) + ( int16_t )regValue[2] );
 8006a40:	b215      	sxth	r5, r2
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 8006a42:	b21c      	sxth	r4, r3
  if ( LSM6DSL_ACC_GYRO_R_FS_125( (void *)handle, &fullScale125 ) == MEMS_ERROR )
 8006a44:	f7fd fa30 	bl	8003ea8 <LSM6DSL_ACC_GYRO_R_FS_125>
 8006a48:	b1a8      	cbz	r0, 8006a76 <LSM6DSL_G_Get_Axes+0x7e>
  if ( fullScale125 == LSM6DSL_ACC_GYRO_FS_125_ENABLED )
 8006a4a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8006a4e:	2b02      	cmp	r3, #2
 8006a50:	d015      	beq.n	8006a7e <LSM6DSL_G_Get_Axes+0x86>
    if ( LSM6DSL_ACC_GYRO_R_FS_G( (void *)handle, &fullScale ) == MEMS_ERROR )
 8006a52:	a902      	add	r1, sp, #8
 8006a54:	4638      	mov	r0, r7
 8006a56:	f7fd f9a3 	bl	8003da0 <LSM6DSL_ACC_GYRO_R_FS_G>
 8006a5a:	b160      	cbz	r0, 8006a76 <LSM6DSL_G_Get_Axes+0x7e>
    switch( fullScale )
 8006a5c:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8006a60:	2b0c      	cmp	r3, #12
 8006a62:	d808      	bhi.n	8006a76 <LSM6DSL_G_Get_Axes+0x7e>
 8006a64:	e8df f003 	tbb	[pc, r3]
 8006a68:	07070738 	.word	0x07070738
 8006a6c:	07070735 	.word	0x07070735
 8006a70:	07070732 	.word	0x07070732
 8006a74:	2f          	.byte	0x2f
 8006a75:	00          	.byte	0x00
    return COMPONENT_ERROR;
 8006a76:	2001      	movs	r0, #1
}
 8006a78:	b004      	add	sp, #16
 8006a7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    *sensitivity = ( float )LSM6DSL_GYRO_SENSITIVITY_FOR_FS_125DPS;
 8006a7e:	ed9f 6a18 	vldr	s12, [pc, #96]	; 8006ae0 <LSM6DSL_G_Get_Axes+0xe8>
  angular_velocity->AXIS_X = ( int32_t )( dataRaw[0] * sensitivity );
 8006a82:	ee07 8a90 	vmov	s15, r8
 8006a86:	eef8 6ae7 	vcvt.f32.s32	s13, s15
  angular_velocity->AXIS_Y = ( int32_t )( dataRaw[1] * sensitivity );
 8006a8a:	ee07 5a90 	vmov	s15, r5
 8006a8e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  angular_velocity->AXIS_Z = ( int32_t )( dataRaw[2] * sensitivity );
 8006a92:	ee07 4a90 	vmov	s15, r4
 8006a96:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  angular_velocity->AXIS_X = ( int32_t )( dataRaw[0] * sensitivity );
 8006a9a:	ee66 6a86 	vmul.f32	s13, s13, s12
  angular_velocity->AXIS_Y = ( int32_t )( dataRaw[1] * sensitivity );
 8006a9e:	ee27 7a06 	vmul.f32	s14, s14, s12
  angular_velocity->AXIS_Z = ( int32_t )( dataRaw[2] * sensitivity );
 8006aa2:	ee67 7a86 	vmul.f32	s15, s15, s12
  angular_velocity->AXIS_X = ( int32_t )( dataRaw[0] * sensitivity );
 8006aa6:	eefd 6ae6 	vcvt.s32.f32	s13, s13
  angular_velocity->AXIS_Y = ( int32_t )( dataRaw[1] * sensitivity );
 8006aaa:	eebd 7ac7 	vcvt.s32.f32	s14, s14
  angular_velocity->AXIS_Z = ( int32_t )( dataRaw[2] * sensitivity );
 8006aae:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  return COMPONENT_OK;
 8006ab2:	2000      	movs	r0, #0
  angular_velocity->AXIS_X = ( int32_t )( dataRaw[0] * sensitivity );
 8006ab4:	edc6 6a00 	vstr	s13, [r6]
  angular_velocity->AXIS_Y = ( int32_t )( dataRaw[1] * sensitivity );
 8006ab8:	ed86 7a01 	vstr	s14, [r6, #4]
  angular_velocity->AXIS_Z = ( int32_t )( dataRaw[2] * sensitivity );
 8006abc:	edc6 7a02 	vstr	s15, [r6, #8]
}
 8006ac0:	b004      	add	sp, #16
 8006ac2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        *sensitivity = ( float )LSM6DSL_GYRO_SENSITIVITY_FOR_FS_2000DPS;
 8006ac6:	ed9f 6a07 	vldr	s12, [pc, #28]	; 8006ae4 <LSM6DSL_G_Get_Axes+0xec>
 8006aca:	e7da      	b.n	8006a82 <LSM6DSL_G_Get_Axes+0x8a>
        *sensitivity = ( float )LSM6DSL_GYRO_SENSITIVITY_FOR_FS_1000DPS;
 8006acc:	ed9f 6a06 	vldr	s12, [pc, #24]	; 8006ae8 <LSM6DSL_G_Get_Axes+0xf0>
 8006ad0:	e7d7      	b.n	8006a82 <LSM6DSL_G_Get_Axes+0x8a>
        *sensitivity = ( float )LSM6DSL_GYRO_SENSITIVITY_FOR_FS_500DPS;
 8006ad2:	ed9f 6a06 	vldr	s12, [pc, #24]	; 8006aec <LSM6DSL_G_Get_Axes+0xf4>
 8006ad6:	e7d4      	b.n	8006a82 <LSM6DSL_G_Get_Axes+0x8a>
        *sensitivity = ( float )LSM6DSL_GYRO_SENSITIVITY_FOR_FS_245DPS;
 8006ad8:	ed9f 6a05 	vldr	s12, [pc, #20]	; 8006af0 <LSM6DSL_G_Get_Axes+0xf8>
 8006adc:	e7d1      	b.n	8006a82 <LSM6DSL_G_Get_Axes+0x8a>
 8006ade:	bf00      	nop
 8006ae0:	408c0000 	.word	0x408c0000
 8006ae4:	428c0000 	.word	0x428c0000
 8006ae8:	420c0000 	.word	0x420c0000
 8006aec:	418c0000 	.word	0x418c0000
 8006af0:	410c0000 	.word	0x410c0000

08006af4 <LSM6DSL_FIFO_X_Get_Axis>:
{
 8006af4:	b530      	push	{r4, r5, lr}
 8006af6:	b083      	sub	sp, #12
 8006af8:	460d      	mov	r5, r1
  if ( LSM6DSL_ACC_GYRO_Get_GetFIFOData( handle, aData ) == MEMS_ERROR )
 8006afa:	a901      	add	r1, sp, #4
{
 8006afc:	4604      	mov	r4, r0
  if ( LSM6DSL_ACC_GYRO_Get_GetFIFOData( handle, aData ) == MEMS_ERROR )
 8006afe:	f7fe f959 	bl	8004db4 <LSM6DSL_ACC_GYRO_Get_GetFIFOData>
 8006b02:	b1c8      	cbz	r0, 8006b38 <LSM6DSL_FIFO_X_Get_Axis+0x44>
  rawData = ( aData[1] << 8 ) | aData[0];
 8006b04:	f89d 2005 	ldrb.w	r2, [sp, #5]
 8006b08:	f89d 3004 	ldrb.w	r3, [sp, #4]
  if ( LSM6DSL_ACC_GYRO_R_FS_XL( (void *)handle, &fullScale ) == MEMS_ERROR )
 8006b0c:	4620      	mov	r0, r4
  rawData = ( aData[1] << 8 ) | aData[0];
 8006b0e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  if ( LSM6DSL_ACC_GYRO_R_FS_XL( (void *)handle, &fullScale ) == MEMS_ERROR )
 8006b12:	f10d 0103 	add.w	r1, sp, #3
  rawData = ( aData[1] << 8 ) | aData[0];
 8006b16:	b21c      	sxth	r4, r3
  if ( LSM6DSL_ACC_GYRO_R_FS_XL( (void *)handle, &fullScale ) == MEMS_ERROR )
 8006b18:	f7fd f8be 	bl	8003c98 <LSM6DSL_ACC_GYRO_R_FS_XL>
 8006b1c:	b160      	cbz	r0, 8006b38 <LSM6DSL_FIFO_X_Get_Axis+0x44>
  switch( fullScale )
 8006b1e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006b22:	2b0c      	cmp	r3, #12
 8006b24:	d808      	bhi.n	8006b38 <LSM6DSL_FIFO_X_Get_Axis+0x44>
 8006b26:	e8df f003 	tbb	[pc, r3]
 8006b2a:	071f      	.short	0x071f
 8006b2c:	071c0707 	.word	0x071c0707
 8006b30:	07190707 	.word	0x07190707
 8006b34:	0707      	.short	0x0707
 8006b36:	0a          	.byte	0x0a
 8006b37:	00          	.byte	0x00
    return COMPONENT_ERROR;
 8006b38:	2001      	movs	r0, #1
}
 8006b3a:	b003      	add	sp, #12
 8006b3c:	bd30      	pop	{r4, r5, pc}
      *sensitivity = ( float )LSM6DSL_ACC_SENSITIVITY_FOR_FS_8G;
 8006b3e:	ed9f 7a0c 	vldr	s14, [pc, #48]	; 8006b70 <LSM6DSL_FIFO_X_Get_Axis+0x7c>
  *acceleration = ( int32_t )( rawData * sensitivity );
 8006b42:	ee07 4a90 	vmov	s15, r4
 8006b46:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  return COMPONENT_OK;
 8006b4a:	2000      	movs	r0, #0
  *acceleration = ( int32_t )( rawData * sensitivity );
 8006b4c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8006b50:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8006b54:	edc5 7a00 	vstr	s15, [r5]
}
 8006b58:	b003      	add	sp, #12
 8006b5a:	bd30      	pop	{r4, r5, pc}
      *sensitivity = ( float )LSM6DSL_ACC_SENSITIVITY_FOR_FS_4G;
 8006b5c:	ed9f 7a05 	vldr	s14, [pc, #20]	; 8006b74 <LSM6DSL_FIFO_X_Get_Axis+0x80>
 8006b60:	e7ef      	b.n	8006b42 <LSM6DSL_FIFO_X_Get_Axis+0x4e>
      *sensitivity = ( float )LSM6DSL_ACC_SENSITIVITY_FOR_FS_16G;
 8006b62:	ed9f 7a05 	vldr	s14, [pc, #20]	; 8006b78 <LSM6DSL_FIFO_X_Get_Axis+0x84>
 8006b66:	e7ec      	b.n	8006b42 <LSM6DSL_FIFO_X_Get_Axis+0x4e>
      *sensitivity = ( float )LSM6DSL_ACC_SENSITIVITY_FOR_FS_2G;
 8006b68:	ed9f 7a04 	vldr	s14, [pc, #16]	; 8006b7c <LSM6DSL_FIFO_X_Get_Axis+0x88>
 8006b6c:	e7e9      	b.n	8006b42 <LSM6DSL_FIFO_X_Get_Axis+0x4e>
 8006b6e:	bf00      	nop
 8006b70:	3e79db23 	.word	0x3e79db23
 8006b74:	3df9db23 	.word	0x3df9db23
 8006b78:	3ef9db23 	.word	0x3ef9db23
 8006b7c:	3d79db23 	.word	0x3d79db23

08006b80 <LSM6DSL_X_Get_Axes>:
{
 8006b80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006b82:	b083      	sub	sp, #12
  uint8_t regValue[6] = {0, 0, 0, 0, 0, 0};
 8006b84:	2300      	movs	r3, #0
{
 8006b86:	460e      	mov	r6, r1
  if ( LSM6DSL_ACC_GYRO_GetRawAccData( (void *)handle, ( uint8_t* )regValue ) == MEMS_ERROR )
 8006b88:	4669      	mov	r1, sp
  uint8_t regValue[6] = {0, 0, 0, 0, 0, 0};
 8006b8a:	f8ad 3004 	strh.w	r3, [sp, #4]
 8006b8e:	9300      	str	r3, [sp, #0]
{
 8006b90:	4605      	mov	r5, r0
  if ( LSM6DSL_ACC_GYRO_GetRawAccData( (void *)handle, ( uint8_t* )regValue ) == MEMS_ERROR )
 8006b92:	f7fd f891 	bl	8003cb8 <LSM6DSL_ACC_GYRO_GetRawAccData>
 8006b96:	b330      	cbz	r0, 8006be6 <LSM6DSL_X_Get_Axes+0x66>
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 8006b98:	f89d 7005 	ldrb.w	r7, [sp, #5]
  pData[0] = ( ( ( ( int16_t )regValue[1] ) << 8 ) + ( int16_t )regValue[0] );
 8006b9c:	f89d c001 	ldrb.w	ip, [sp, #1]
 8006ba0:	f89d 4000 	ldrb.w	r4, [sp]
  pData[1] = ( ( ( ( int16_t )regValue[3] ) << 8 ) + ( int16_t )regValue[2] );
 8006ba4:	f89d e003 	ldrb.w	lr, [sp, #3]
 8006ba8:	f89d 2002 	ldrb.w	r2, [sp, #2]
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 8006bac:	f89d 3004 	ldrb.w	r3, [sp, #4]
  pData[0] = ( ( ( ( int16_t )regValue[1] ) << 8 ) + ( int16_t )regValue[0] );
 8006bb0:	eb04 240c 	add.w	r4, r4, ip, lsl #8
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 8006bb4:	eb03 2307 	add.w	r3, r3, r7, lsl #8
  if ( LSM6DSL_ACC_GYRO_R_FS_XL( (void *)handle, &fullScale ) == MEMS_ERROR )
 8006bb8:	4628      	mov	r0, r5
  pData[1] = ( ( ( ( int16_t )regValue[3] ) << 8 ) + ( int16_t )regValue[2] );
 8006bba:	eb02 220e 	add.w	r2, r2, lr, lsl #8
  if ( LSM6DSL_ACC_GYRO_R_FS_XL( (void *)handle, &fullScale ) == MEMS_ERROR )
 8006bbe:	4669      	mov	r1, sp
  pData[0] = ( ( ( ( int16_t )regValue[1] ) << 8 ) + ( int16_t )regValue[0] );
 8006bc0:	b227      	sxth	r7, r4
  pData[1] = ( ( ( ( int16_t )regValue[3] ) << 8 ) + ( int16_t )regValue[2] );
 8006bc2:	b215      	sxth	r5, r2
  pData[2] = ( ( ( ( int16_t )regValue[5] ) << 8 ) + ( int16_t )regValue[4] );
 8006bc4:	b21c      	sxth	r4, r3
  if ( LSM6DSL_ACC_GYRO_R_FS_XL( (void *)handle, &fullScale ) == MEMS_ERROR )
 8006bc6:	f7fd f867 	bl	8003c98 <LSM6DSL_ACC_GYRO_R_FS_XL>
 8006bca:	b160      	cbz	r0, 8006be6 <LSM6DSL_X_Get_Axes+0x66>
  switch( fullScale )
 8006bcc:	f89d 3000 	ldrb.w	r3, [sp]
 8006bd0:	2b0c      	cmp	r3, #12
 8006bd2:	d808      	bhi.n	8006be6 <LSM6DSL_X_Get_Axes+0x66>
 8006bd4:	e8df f003 	tbb	[pc, r3]
 8006bd8:	07070733 	.word	0x07070733
 8006bdc:	07070730 	.word	0x07070730
 8006be0:	0707072d 	.word	0x0707072d
 8006be4:	0a          	.byte	0x0a
 8006be5:	00          	.byte	0x00
    return COMPONENT_ERROR;
 8006be6:	2001      	movs	r0, #1
}
 8006be8:	b003      	add	sp, #12
 8006bea:	bdf0      	pop	{r4, r5, r6, r7, pc}
      *sensitivity = ( float )LSM6DSL_ACC_SENSITIVITY_FOR_FS_8G;
 8006bec:	ed9f 6a15 	vldr	s12, [pc, #84]	; 8006c44 <LSM6DSL_X_Get_Axes+0xc4>
  acceleration->AXIS_X = ( int32_t )( dataRaw[0] * sensitivity );
 8006bf0:	ee07 7a90 	vmov	s15, r7
 8006bf4:	eef8 6ae7 	vcvt.f32.s32	s13, s15
  acceleration->AXIS_Y = ( int32_t )( dataRaw[1] * sensitivity );
 8006bf8:	ee07 5a90 	vmov	s15, r5
 8006bfc:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  acceleration->AXIS_Z = ( int32_t )( dataRaw[2] * sensitivity );
 8006c00:	ee07 4a90 	vmov	s15, r4
 8006c04:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  acceleration->AXIS_X = ( int32_t )( dataRaw[0] * sensitivity );
 8006c08:	ee66 6a86 	vmul.f32	s13, s13, s12
  acceleration->AXIS_Y = ( int32_t )( dataRaw[1] * sensitivity );
 8006c0c:	ee27 7a06 	vmul.f32	s14, s14, s12
  acceleration->AXIS_Z = ( int32_t )( dataRaw[2] * sensitivity );
 8006c10:	ee67 7a86 	vmul.f32	s15, s15, s12
  acceleration->AXIS_X = ( int32_t )( dataRaw[0] * sensitivity );
 8006c14:	eefd 6ae6 	vcvt.s32.f32	s13, s13
  acceleration->AXIS_Y = ( int32_t )( dataRaw[1] * sensitivity );
 8006c18:	eebd 7ac7 	vcvt.s32.f32	s14, s14
  acceleration->AXIS_Z = ( int32_t )( dataRaw[2] * sensitivity );
 8006c1c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  return COMPONENT_OK;
 8006c20:	2000      	movs	r0, #0
  acceleration->AXIS_X = ( int32_t )( dataRaw[0] * sensitivity );
 8006c22:	edc6 6a00 	vstr	s13, [r6]
  acceleration->AXIS_Y = ( int32_t )( dataRaw[1] * sensitivity );
 8006c26:	ed86 7a01 	vstr	s14, [r6, #4]
  acceleration->AXIS_Z = ( int32_t )( dataRaw[2] * sensitivity );
 8006c2a:	edc6 7a02 	vstr	s15, [r6, #8]
}
 8006c2e:	b003      	add	sp, #12
 8006c30:	bdf0      	pop	{r4, r5, r6, r7, pc}
      *sensitivity = ( float )LSM6DSL_ACC_SENSITIVITY_FOR_FS_4G;
 8006c32:	ed9f 6a05 	vldr	s12, [pc, #20]	; 8006c48 <LSM6DSL_X_Get_Axes+0xc8>
 8006c36:	e7db      	b.n	8006bf0 <LSM6DSL_X_Get_Axes+0x70>
      *sensitivity = ( float )LSM6DSL_ACC_SENSITIVITY_FOR_FS_16G;
 8006c38:	ed9f 6a04 	vldr	s12, [pc, #16]	; 8006c4c <LSM6DSL_X_Get_Axes+0xcc>
 8006c3c:	e7d8      	b.n	8006bf0 <LSM6DSL_X_Get_Axes+0x70>
      *sensitivity = ( float )LSM6DSL_ACC_SENSITIVITY_FOR_FS_2G;
 8006c3e:	ed9f 6a04 	vldr	s12, [pc, #16]	; 8006c50 <LSM6DSL_X_Get_Axes+0xd0>
 8006c42:	e7d5      	b.n	8006bf0 <LSM6DSL_X_Get_Axes+0x70>
 8006c44:	3e79db23 	.word	0x3e79db23
 8006c48:	3df9db23 	.word	0x3df9db23
 8006c4c:	3ef9db23 	.word	0x3ef9db23
 8006c50:	3d79db23 	.word	0x3d79db23

08006c54 <LSM6DSL_X_Sensor_Disable>:
  if ( handle->isEnabled == 0 )
 8006c54:	7983      	ldrb	r3, [r0, #6]
 8006c56:	b90b      	cbnz	r3, 8006c5c <LSM6DSL_X_Sensor_Disable+0x8>
    return COMPONENT_OK;
 8006c58:	4618      	mov	r0, r3
 8006c5a:	4770      	bx	lr
{
 8006c5c:	b530      	push	{r4, r5, lr}
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 8006c5e:	6883      	ldr	r3, [r0, #8]
{
 8006c60:	b083      	sub	sp, #12
  if ( LSM6DSL_ACC_GYRO_R_ODR_XL( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 8006c62:	f10d 0107 	add.w	r1, sp, #7
 8006c66:	4604      	mov	r4, r0
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 8006c68:	681d      	ldr	r5, [r3, #0]
  if ( LSM6DSL_ACC_GYRO_R_ODR_XL( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 8006c6a:	f7fd f867 	bl	8003d3c <LSM6DSL_ACC_GYRO_R_ODR_XL>
 8006c6e:	b180      	cbz	r0, 8006c92 <LSM6DSL_X_Sensor_Disable+0x3e>
  switch( odr_low_level )
 8006c70:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8006c74:	2b50      	cmp	r3, #80	; 0x50
 8006c76:	d03c      	beq.n	8006cf2 <LSM6DSL_X_Sensor_Disable+0x9e>
 8006c78:	d80e      	bhi.n	8006c98 <LSM6DSL_X_Sensor_Disable+0x44>
 8006c7a:	2b20      	cmp	r3, #32
 8006c7c:	d036      	beq.n	8006cec <LSM6DSL_X_Sensor_Disable+0x98>
 8006c7e:	d926      	bls.n	8006cce <LSM6DSL_X_Sensor_Disable+0x7a>
 8006c80:	2b30      	cmp	r3, #48	; 0x30
 8006c82:	d02d      	beq.n	8006ce0 <LSM6DSL_X_Sensor_Disable+0x8c>
 8006c84:	2b40      	cmp	r3, #64	; 0x40
 8006c86:	d102      	bne.n	8006c8e <LSM6DSL_X_Sensor_Disable+0x3a>
      *odr =   104.0f;
 8006c88:	4b1e      	ldr	r3, [pc, #120]	; (8006d04 <LSM6DSL_X_Sensor_Disable+0xb0>)
 8006c8a:	606b      	str	r3, [r5, #4]
 8006c8c:	e00d      	b.n	8006caa <LSM6DSL_X_Sensor_Disable+0x56>
      *odr =    -1.0f;
 8006c8e:	4b1e      	ldr	r3, [pc, #120]	; (8006d08 <LSM6DSL_X_Sensor_Disable+0xb4>)
 8006c90:	606b      	str	r3, [r5, #4]
    return COMPONENT_ERROR;
 8006c92:	2001      	movs	r0, #1
}
 8006c94:	b003      	add	sp, #12
 8006c96:	bd30      	pop	{r4, r5, pc}
  switch( odr_low_level )
 8006c98:	2b80      	cmp	r3, #128	; 0x80
 8006c9a:	d01e      	beq.n	8006cda <LSM6DSL_X_Sensor_Disable+0x86>
 8006c9c:	d810      	bhi.n	8006cc0 <LSM6DSL_X_Sensor_Disable+0x6c>
 8006c9e:	2b60      	cmp	r3, #96	; 0x60
 8006ca0:	d021      	beq.n	8006ce6 <LSM6DSL_X_Sensor_Disable+0x92>
 8006ca2:	2b70      	cmp	r3, #112	; 0x70
 8006ca4:	d1f3      	bne.n	8006c8e <LSM6DSL_X_Sensor_Disable+0x3a>
      *odr =   833.0f;
 8006ca6:	4b19      	ldr	r3, [pc, #100]	; (8006d0c <LSM6DSL_X_Sensor_Disable+0xb8>)
 8006ca8:	606b      	str	r3, [r5, #4]
  if ( LSM6DSL_ACC_GYRO_W_ODR_XL( (void *)handle, LSM6DSL_ACC_GYRO_ODR_XL_POWER_DOWN ) == MEMS_ERROR )
 8006caa:	2100      	movs	r1, #0
 8006cac:	4620      	mov	r0, r4
 8006cae:	f7fd f823 	bl	8003cf8 <LSM6DSL_ACC_GYRO_W_ODR_XL>
 8006cb2:	2800      	cmp	r0, #0
 8006cb4:	d0ed      	beq.n	8006c92 <LSM6DSL_X_Sensor_Disable+0x3e>
  handle->isEnabled = 0;
 8006cb6:	2300      	movs	r3, #0
  return COMPONENT_OK;
 8006cb8:	4618      	mov	r0, r3
  handle->isEnabled = 0;
 8006cba:	71a3      	strb	r3, [r4, #6]
}
 8006cbc:	b003      	add	sp, #12
 8006cbe:	bd30      	pop	{r4, r5, pc}
  switch( odr_low_level )
 8006cc0:	2b90      	cmp	r3, #144	; 0x90
 8006cc2:	d019      	beq.n	8006cf8 <LSM6DSL_X_Sensor_Disable+0xa4>
 8006cc4:	2ba0      	cmp	r3, #160	; 0xa0
 8006cc6:	d1e2      	bne.n	8006c8e <LSM6DSL_X_Sensor_Disable+0x3a>
      *odr =  6660.0f;
 8006cc8:	4b11      	ldr	r3, [pc, #68]	; (8006d10 <LSM6DSL_X_Sensor_Disable+0xbc>)
 8006cca:	606b      	str	r3, [r5, #4]
 8006ccc:	e7ed      	b.n	8006caa <LSM6DSL_X_Sensor_Disable+0x56>
  switch( odr_low_level )
 8006cce:	b1b3      	cbz	r3, 8006cfe <LSM6DSL_X_Sensor_Disable+0xaa>
 8006cd0:	2b10      	cmp	r3, #16
 8006cd2:	d1dc      	bne.n	8006c8e <LSM6DSL_X_Sensor_Disable+0x3a>
      *odr =    13.0f;
 8006cd4:	4b0f      	ldr	r3, [pc, #60]	; (8006d14 <LSM6DSL_X_Sensor_Disable+0xc0>)
 8006cd6:	606b      	str	r3, [r5, #4]
 8006cd8:	e7e7      	b.n	8006caa <LSM6DSL_X_Sensor_Disable+0x56>
      *odr =  1660.0f;
 8006cda:	4b0f      	ldr	r3, [pc, #60]	; (8006d18 <LSM6DSL_X_Sensor_Disable+0xc4>)
 8006cdc:	606b      	str	r3, [r5, #4]
 8006cde:	e7e4      	b.n	8006caa <LSM6DSL_X_Sensor_Disable+0x56>
      *odr =    52.0f;
 8006ce0:	4b0e      	ldr	r3, [pc, #56]	; (8006d1c <LSM6DSL_X_Sensor_Disable+0xc8>)
 8006ce2:	606b      	str	r3, [r5, #4]
 8006ce4:	e7e1      	b.n	8006caa <LSM6DSL_X_Sensor_Disable+0x56>
      *odr =   416.0f;
 8006ce6:	4b0e      	ldr	r3, [pc, #56]	; (8006d20 <LSM6DSL_X_Sensor_Disable+0xcc>)
 8006ce8:	606b      	str	r3, [r5, #4]
 8006cea:	e7de      	b.n	8006caa <LSM6DSL_X_Sensor_Disable+0x56>
      *odr =    26.0f;
 8006cec:	4b0d      	ldr	r3, [pc, #52]	; (8006d24 <LSM6DSL_X_Sensor_Disable+0xd0>)
 8006cee:	606b      	str	r3, [r5, #4]
 8006cf0:	e7db      	b.n	8006caa <LSM6DSL_X_Sensor_Disable+0x56>
      *odr =   208.0f;
 8006cf2:	4b0d      	ldr	r3, [pc, #52]	; (8006d28 <LSM6DSL_X_Sensor_Disable+0xd4>)
 8006cf4:	606b      	str	r3, [r5, #4]
 8006cf6:	e7d8      	b.n	8006caa <LSM6DSL_X_Sensor_Disable+0x56>
      *odr =  3330.0f;
 8006cf8:	4b0c      	ldr	r3, [pc, #48]	; (8006d2c <LSM6DSL_X_Sensor_Disable+0xd8>)
 8006cfa:	606b      	str	r3, [r5, #4]
 8006cfc:	e7d5      	b.n	8006caa <LSM6DSL_X_Sensor_Disable+0x56>
      *odr =     0.0f;
 8006cfe:	2300      	movs	r3, #0
 8006d00:	606b      	str	r3, [r5, #4]
 8006d02:	e7d2      	b.n	8006caa <LSM6DSL_X_Sensor_Disable+0x56>
 8006d04:	42d00000 	.word	0x42d00000
 8006d08:	bf800000 	.word	0xbf800000
 8006d0c:	44504000 	.word	0x44504000
 8006d10:	45d02000 	.word	0x45d02000
 8006d14:	41500000 	.word	0x41500000
 8006d18:	44cf8000 	.word	0x44cf8000
 8006d1c:	42500000 	.word	0x42500000
 8006d20:	43d00000 	.word	0x43d00000
 8006d24:	41d00000 	.word	0x41d00000
 8006d28:	43500000 	.word	0x43500000
 8006d2c:	45502000 	.word	0x45502000

08006d30 <LSM6DSL_G_Sensor_Disable>:
  if ( handle->isEnabled == 0 )
 8006d30:	7983      	ldrb	r3, [r0, #6]
 8006d32:	b90b      	cbnz	r3, 8006d38 <LSM6DSL_G_Sensor_Disable+0x8>
    return COMPONENT_OK;
 8006d34:	4618      	mov	r0, r3
 8006d36:	4770      	bx	lr
{
 8006d38:	b530      	push	{r4, r5, lr}
  LSM6DSL_G_Data_t *pComponentData = ( LSM6DSL_G_Data_t * )pData->pComponentData;
 8006d3a:	6883      	ldr	r3, [r0, #8]
{
 8006d3c:	b083      	sub	sp, #12
  if ( LSM6DSL_ACC_GYRO_R_ODR_G( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 8006d3e:	f10d 0107 	add.w	r1, sp, #7
 8006d42:	4604      	mov	r4, r0
  LSM6DSL_G_Data_t *pComponentData = ( LSM6DSL_G_Data_t * )pData->pComponentData;
 8006d44:	681d      	ldr	r5, [r3, #0]
  if ( LSM6DSL_ACC_GYRO_R_ODR_G( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 8006d46:	f7fd f87d 	bl	8003e44 <LSM6DSL_ACC_GYRO_R_ODR_G>
 8006d4a:	b180      	cbz	r0, 8006d6e <LSM6DSL_G_Sensor_Disable+0x3e>
  switch( odr_low_level )
 8006d4c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8006d50:	2b50      	cmp	r3, #80	; 0x50
 8006d52:	d03c      	beq.n	8006dce <LSM6DSL_G_Sensor_Disable+0x9e>
 8006d54:	d80e      	bhi.n	8006d74 <LSM6DSL_G_Sensor_Disable+0x44>
 8006d56:	2b20      	cmp	r3, #32
 8006d58:	d036      	beq.n	8006dc8 <LSM6DSL_G_Sensor_Disable+0x98>
 8006d5a:	d926      	bls.n	8006daa <LSM6DSL_G_Sensor_Disable+0x7a>
 8006d5c:	2b30      	cmp	r3, #48	; 0x30
 8006d5e:	d02d      	beq.n	8006dbc <LSM6DSL_G_Sensor_Disable+0x8c>
 8006d60:	2b40      	cmp	r3, #64	; 0x40
 8006d62:	d102      	bne.n	8006d6a <LSM6DSL_G_Sensor_Disable+0x3a>
      *odr =  104.0f;
 8006d64:	4b1e      	ldr	r3, [pc, #120]	; (8006de0 <LSM6DSL_G_Sensor_Disable+0xb0>)
 8006d66:	606b      	str	r3, [r5, #4]
 8006d68:	e00d      	b.n	8006d86 <LSM6DSL_G_Sensor_Disable+0x56>
      *odr =   -1.0f;
 8006d6a:	4b1e      	ldr	r3, [pc, #120]	; (8006de4 <LSM6DSL_G_Sensor_Disable+0xb4>)
 8006d6c:	606b      	str	r3, [r5, #4]
    return COMPONENT_ERROR;
 8006d6e:	2001      	movs	r0, #1
}
 8006d70:	b003      	add	sp, #12
 8006d72:	bd30      	pop	{r4, r5, pc}
  switch( odr_low_level )
 8006d74:	2b80      	cmp	r3, #128	; 0x80
 8006d76:	d01e      	beq.n	8006db6 <LSM6DSL_G_Sensor_Disable+0x86>
 8006d78:	d810      	bhi.n	8006d9c <LSM6DSL_G_Sensor_Disable+0x6c>
 8006d7a:	2b60      	cmp	r3, #96	; 0x60
 8006d7c:	d021      	beq.n	8006dc2 <LSM6DSL_G_Sensor_Disable+0x92>
 8006d7e:	2b70      	cmp	r3, #112	; 0x70
 8006d80:	d1f3      	bne.n	8006d6a <LSM6DSL_G_Sensor_Disable+0x3a>
      *odr =  833.0f;
 8006d82:	4b19      	ldr	r3, [pc, #100]	; (8006de8 <LSM6DSL_G_Sensor_Disable+0xb8>)
 8006d84:	606b      	str	r3, [r5, #4]
  if ( LSM6DSL_ACC_GYRO_W_ODR_G( (void *)handle, LSM6DSL_ACC_GYRO_ODR_G_POWER_DOWN ) == MEMS_ERROR )
 8006d86:	2100      	movs	r1, #0
 8006d88:	4620      	mov	r0, r4
 8006d8a:	f7fd f839 	bl	8003e00 <LSM6DSL_ACC_GYRO_W_ODR_G>
 8006d8e:	2800      	cmp	r0, #0
 8006d90:	d0ed      	beq.n	8006d6e <LSM6DSL_G_Sensor_Disable+0x3e>
  handle->isEnabled = 0;
 8006d92:	2300      	movs	r3, #0
  return COMPONENT_OK;
 8006d94:	4618      	mov	r0, r3
  handle->isEnabled = 0;
 8006d96:	71a3      	strb	r3, [r4, #6]
}
 8006d98:	b003      	add	sp, #12
 8006d9a:	bd30      	pop	{r4, r5, pc}
  switch( odr_low_level )
 8006d9c:	2b90      	cmp	r3, #144	; 0x90
 8006d9e:	d019      	beq.n	8006dd4 <LSM6DSL_G_Sensor_Disable+0xa4>
 8006da0:	2ba0      	cmp	r3, #160	; 0xa0
 8006da2:	d1e2      	bne.n	8006d6a <LSM6DSL_G_Sensor_Disable+0x3a>
      *odr = 6660.0f;
 8006da4:	4b11      	ldr	r3, [pc, #68]	; (8006dec <LSM6DSL_G_Sensor_Disable+0xbc>)
 8006da6:	606b      	str	r3, [r5, #4]
 8006da8:	e7ed      	b.n	8006d86 <LSM6DSL_G_Sensor_Disable+0x56>
  switch( odr_low_level )
 8006daa:	b1b3      	cbz	r3, 8006dda <LSM6DSL_G_Sensor_Disable+0xaa>
 8006dac:	2b10      	cmp	r3, #16
 8006dae:	d1dc      	bne.n	8006d6a <LSM6DSL_G_Sensor_Disable+0x3a>
      *odr =   13.0f;
 8006db0:	4b0f      	ldr	r3, [pc, #60]	; (8006df0 <LSM6DSL_G_Sensor_Disable+0xc0>)
 8006db2:	606b      	str	r3, [r5, #4]
 8006db4:	e7e7      	b.n	8006d86 <LSM6DSL_G_Sensor_Disable+0x56>
      *odr = 1660.0f;
 8006db6:	4b0f      	ldr	r3, [pc, #60]	; (8006df4 <LSM6DSL_G_Sensor_Disable+0xc4>)
 8006db8:	606b      	str	r3, [r5, #4]
 8006dba:	e7e4      	b.n	8006d86 <LSM6DSL_G_Sensor_Disable+0x56>
      *odr =   52.0f;
 8006dbc:	4b0e      	ldr	r3, [pc, #56]	; (8006df8 <LSM6DSL_G_Sensor_Disable+0xc8>)
 8006dbe:	606b      	str	r3, [r5, #4]
 8006dc0:	e7e1      	b.n	8006d86 <LSM6DSL_G_Sensor_Disable+0x56>
      *odr =  416.0f;
 8006dc2:	4b0e      	ldr	r3, [pc, #56]	; (8006dfc <LSM6DSL_G_Sensor_Disable+0xcc>)
 8006dc4:	606b      	str	r3, [r5, #4]
 8006dc6:	e7de      	b.n	8006d86 <LSM6DSL_G_Sensor_Disable+0x56>
      *odr =   26.0f;
 8006dc8:	4b0d      	ldr	r3, [pc, #52]	; (8006e00 <LSM6DSL_G_Sensor_Disable+0xd0>)
 8006dca:	606b      	str	r3, [r5, #4]
 8006dcc:	e7db      	b.n	8006d86 <LSM6DSL_G_Sensor_Disable+0x56>
      *odr =  208.0f;
 8006dce:	4b0d      	ldr	r3, [pc, #52]	; (8006e04 <LSM6DSL_G_Sensor_Disable+0xd4>)
 8006dd0:	606b      	str	r3, [r5, #4]
 8006dd2:	e7d8      	b.n	8006d86 <LSM6DSL_G_Sensor_Disable+0x56>
      *odr = 3330.0f;
 8006dd4:	4b0c      	ldr	r3, [pc, #48]	; (8006e08 <LSM6DSL_G_Sensor_Disable+0xd8>)
 8006dd6:	606b      	str	r3, [r5, #4]
 8006dd8:	e7d5      	b.n	8006d86 <LSM6DSL_G_Sensor_Disable+0x56>
      *odr =    0.0f;
 8006dda:	2300      	movs	r3, #0
 8006ddc:	606b      	str	r3, [r5, #4]
 8006dde:	e7d2      	b.n	8006d86 <LSM6DSL_G_Sensor_Disable+0x56>
 8006de0:	42d00000 	.word	0x42d00000
 8006de4:	bf800000 	.word	0xbf800000
 8006de8:	44504000 	.word	0x44504000
 8006dec:	45d02000 	.word	0x45d02000
 8006df0:	41500000 	.word	0x41500000
 8006df4:	44cf8000 	.word	0x44cf8000
 8006df8:	42500000 	.word	0x42500000
 8006dfc:	43d00000 	.word	0x43d00000
 8006e00:	41d00000 	.word	0x41d00000
 8006e04:	43500000 	.word	0x43500000
 8006e08:	45502000 	.word	0x45502000

08006e0c <LSM6DSL_G_DeInit>:
{
 8006e0c:	b5f0      	push	{r4, r5, r6, r7, lr}
  LSM6DSL_G_Data_t *pComponentData = ( LSM6DSL_G_Data_t * )pData->pComponentData;
 8006e0e:	6883      	ldr	r3, [r0, #8]
{
 8006e10:	b083      	sub	sp, #12
  LSM6DSL_G_Data_t *pComponentData = ( LSM6DSL_G_Data_t * )pData->pComponentData;
 8006e12:	681e      	ldr	r6, [r3, #0]
  uint8_t who_am_i = 0x00;
 8006e14:	ad02      	add	r5, sp, #8
 8006e16:	2300      	movs	r3, #0
  LSM6DSL_Combo_Data_t *comboData = pComponentData->comboData;
 8006e18:	6837      	ldr	r7, [r6, #0]
  uint8_t who_am_i = 0x00;
 8006e1a:	f805 3d01 	strb.w	r3, [r5, #-1]!
  if ( LSM6DSL_ACC_GYRO_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 8006e1e:	4629      	mov	r1, r5
{
 8006e20:	4604      	mov	r4, r0
  if ( LSM6DSL_ACC_GYRO_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 8006e22:	f7fc feeb 	bl	8003bfc <LSM6DSL_ACC_GYRO_R_WHO_AM_I>
 8006e26:	b910      	cbnz	r0, 8006e2e <LSM6DSL_G_DeInit+0x22>
    return COMPONENT_ERROR;
 8006e28:	2001      	movs	r0, #1
}
 8006e2a:	b003      	add	sp, #12
 8006e2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ( who_am_i != handle->who_am_i )
 8006e2e:	7822      	ldrb	r2, [r4, #0]
 8006e30:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8006e34:	429a      	cmp	r2, r3
 8006e36:	d1f7      	bne.n	8006e28 <LSM6DSL_G_DeInit+0x1c>
  if ( handle->isEnabled == 0 )
 8006e38:	79a3      	ldrb	r3, [r4, #6]
 8006e3a:	b93b      	cbnz	r3, 8006e4c <LSM6DSL_G_DeInit+0x40>
  comboData->isGyroInitialized = 0;
 8006e3c:	2300      	movs	r3, #0
  pComponentData->Previous_ODR = 0.0f;
 8006e3e:	2200      	movs	r2, #0
  return COMPONENT_OK;
 8006e40:	4618      	mov	r0, r3
  pComponentData->Previous_ODR = 0.0f;
 8006e42:	6072      	str	r2, [r6, #4]
  comboData->isGyroInitialized = 0;
 8006e44:	707b      	strb	r3, [r7, #1]
  handle->isInitialized = 0;
 8006e46:	7163      	strb	r3, [r4, #5]
}
 8006e48:	b003      	add	sp, #12
 8006e4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  LSM6DSL_G_Data_t *pComponentData = ( LSM6DSL_G_Data_t * )pData->pComponentData;
 8006e4c:	68a3      	ldr	r3, [r4, #8]
  if ( LSM6DSL_ACC_GYRO_R_ODR_G( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 8006e4e:	4629      	mov	r1, r5
 8006e50:	4620      	mov	r0, r4
  LSM6DSL_G_Data_t *pComponentData = ( LSM6DSL_G_Data_t * )pData->pComponentData;
 8006e52:	681d      	ldr	r5, [r3, #0]
  if ( LSM6DSL_ACC_GYRO_R_ODR_G( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 8006e54:	f7fc fff6 	bl	8003e44 <LSM6DSL_ACC_GYRO_R_ODR_G>
 8006e58:	2800      	cmp	r0, #0
 8006e5a:	d0e5      	beq.n	8006e28 <LSM6DSL_G_DeInit+0x1c>
  switch( odr_low_level )
 8006e5c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8006e60:	2b50      	cmp	r3, #80	; 0x50
 8006e62:	d035      	beq.n	8006ed0 <LSM6DSL_G_DeInit+0xc4>
 8006e64:	d810      	bhi.n	8006e88 <LSM6DSL_G_DeInit+0x7c>
 8006e66:	2b20      	cmp	r3, #32
 8006e68:	d026      	beq.n	8006eb8 <LSM6DSL_G_DeInit+0xac>
 8006e6a:	d817      	bhi.n	8006e9c <LSM6DSL_G_DeInit+0x90>
 8006e6c:	b36b      	cbz	r3, 8006eca <LSM6DSL_G_DeInit+0xbe>
 8006e6e:	2b10      	cmp	r3, #16
 8006e70:	d128      	bne.n	8006ec4 <LSM6DSL_G_DeInit+0xb8>
      *odr =   13.0f;
 8006e72:	4b1d      	ldr	r3, [pc, #116]	; (8006ee8 <LSM6DSL_G_DeInit+0xdc>)
 8006e74:	606b      	str	r3, [r5, #4]
  if ( LSM6DSL_ACC_GYRO_W_ODR_G( (void *)handle, LSM6DSL_ACC_GYRO_ODR_G_POWER_DOWN ) == MEMS_ERROR )
 8006e76:	2100      	movs	r1, #0
 8006e78:	4620      	mov	r0, r4
 8006e7a:	f7fc ffc1 	bl	8003e00 <LSM6DSL_ACC_GYRO_W_ODR_G>
 8006e7e:	2800      	cmp	r0, #0
 8006e80:	d0d2      	beq.n	8006e28 <LSM6DSL_G_DeInit+0x1c>
  handle->isEnabled = 0;
 8006e82:	2300      	movs	r3, #0
 8006e84:	71a3      	strb	r3, [r4, #6]
 8006e86:	e7d9      	b.n	8006e3c <LSM6DSL_G_DeInit+0x30>
  switch( odr_low_level )
 8006e88:	2b80      	cmp	r3, #128	; 0x80
 8006e8a:	d027      	beq.n	8006edc <LSM6DSL_G_DeInit+0xd0>
 8006e8c:	d90d      	bls.n	8006eaa <LSM6DSL_G_DeInit+0x9e>
 8006e8e:	2b90      	cmp	r3, #144	; 0x90
 8006e90:	d015      	beq.n	8006ebe <LSM6DSL_G_DeInit+0xb2>
 8006e92:	2ba0      	cmp	r3, #160	; 0xa0
 8006e94:	d116      	bne.n	8006ec4 <LSM6DSL_G_DeInit+0xb8>
      *odr = 6660.0f;
 8006e96:	4b15      	ldr	r3, [pc, #84]	; (8006eec <LSM6DSL_G_DeInit+0xe0>)
 8006e98:	606b      	str	r3, [r5, #4]
 8006e9a:	e7ec      	b.n	8006e76 <LSM6DSL_G_DeInit+0x6a>
  switch( odr_low_level )
 8006e9c:	2b30      	cmp	r3, #48	; 0x30
 8006e9e:	d01a      	beq.n	8006ed6 <LSM6DSL_G_DeInit+0xca>
 8006ea0:	2b40      	cmp	r3, #64	; 0x40
 8006ea2:	d10f      	bne.n	8006ec4 <LSM6DSL_G_DeInit+0xb8>
      *odr =  104.0f;
 8006ea4:	4b12      	ldr	r3, [pc, #72]	; (8006ef0 <LSM6DSL_G_DeInit+0xe4>)
 8006ea6:	606b      	str	r3, [r5, #4]
 8006ea8:	e7e5      	b.n	8006e76 <LSM6DSL_G_DeInit+0x6a>
  switch( odr_low_level )
 8006eaa:	2b60      	cmp	r3, #96	; 0x60
 8006eac:	d019      	beq.n	8006ee2 <LSM6DSL_G_DeInit+0xd6>
 8006eae:	2b70      	cmp	r3, #112	; 0x70
 8006eb0:	d108      	bne.n	8006ec4 <LSM6DSL_G_DeInit+0xb8>
      *odr =  833.0f;
 8006eb2:	4b10      	ldr	r3, [pc, #64]	; (8006ef4 <LSM6DSL_G_DeInit+0xe8>)
 8006eb4:	606b      	str	r3, [r5, #4]
 8006eb6:	e7de      	b.n	8006e76 <LSM6DSL_G_DeInit+0x6a>
      *odr =   26.0f;
 8006eb8:	4b0f      	ldr	r3, [pc, #60]	; (8006ef8 <LSM6DSL_G_DeInit+0xec>)
 8006eba:	606b      	str	r3, [r5, #4]
 8006ebc:	e7db      	b.n	8006e76 <LSM6DSL_G_DeInit+0x6a>
      *odr = 3330.0f;
 8006ebe:	4b0f      	ldr	r3, [pc, #60]	; (8006efc <LSM6DSL_G_DeInit+0xf0>)
 8006ec0:	606b      	str	r3, [r5, #4]
 8006ec2:	e7d8      	b.n	8006e76 <LSM6DSL_G_DeInit+0x6a>
      *odr =   -1.0f;
 8006ec4:	4b0e      	ldr	r3, [pc, #56]	; (8006f00 <LSM6DSL_G_DeInit+0xf4>)
 8006ec6:	606b      	str	r3, [r5, #4]
 8006ec8:	e7ae      	b.n	8006e28 <LSM6DSL_G_DeInit+0x1c>
      *odr =    0.0f;
 8006eca:	2300      	movs	r3, #0
 8006ecc:	606b      	str	r3, [r5, #4]
 8006ece:	e7d2      	b.n	8006e76 <LSM6DSL_G_DeInit+0x6a>
      *odr =  208.0f;
 8006ed0:	4b0c      	ldr	r3, [pc, #48]	; (8006f04 <LSM6DSL_G_DeInit+0xf8>)
 8006ed2:	606b      	str	r3, [r5, #4]
 8006ed4:	e7cf      	b.n	8006e76 <LSM6DSL_G_DeInit+0x6a>
      *odr =   52.0f;
 8006ed6:	4b0c      	ldr	r3, [pc, #48]	; (8006f08 <LSM6DSL_G_DeInit+0xfc>)
 8006ed8:	606b      	str	r3, [r5, #4]
 8006eda:	e7cc      	b.n	8006e76 <LSM6DSL_G_DeInit+0x6a>
      *odr = 1660.0f;
 8006edc:	4b0b      	ldr	r3, [pc, #44]	; (8006f0c <LSM6DSL_G_DeInit+0x100>)
 8006ede:	606b      	str	r3, [r5, #4]
 8006ee0:	e7c9      	b.n	8006e76 <LSM6DSL_G_DeInit+0x6a>
      *odr =  416.0f;
 8006ee2:	4b0b      	ldr	r3, [pc, #44]	; (8006f10 <LSM6DSL_G_DeInit+0x104>)
 8006ee4:	606b      	str	r3, [r5, #4]
 8006ee6:	e7c6      	b.n	8006e76 <LSM6DSL_G_DeInit+0x6a>
 8006ee8:	41500000 	.word	0x41500000
 8006eec:	45d02000 	.word	0x45d02000
 8006ef0:	42d00000 	.word	0x42d00000
 8006ef4:	44504000 	.word	0x44504000
 8006ef8:	41d00000 	.word	0x41d00000
 8006efc:	45502000 	.word	0x45502000
 8006f00:	bf800000 	.word	0xbf800000
 8006f04:	43500000 	.word	0x43500000
 8006f08:	42500000 	.word	0x42500000
 8006f0c:	44cf8000 	.word	0x44cf8000
 8006f10:	43d00000 	.word	0x43d00000

08006f14 <LSM6DSL_X_DeInit>:
{
 8006f14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 8006f18:	6883      	ldr	r3, [r0, #8]
{
 8006f1a:	b082      	sub	sp, #8
  uint8_t who_am_i = 0x00;
 8006f1c:	ad02      	add	r5, sp, #8
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 8006f1e:	681f      	ldr	r7, [r3, #0]
  uint8_t who_am_i = 0x00;
 8006f20:	2600      	movs	r6, #0
  LSM6DSL_Combo_Data_t *comboData = pComponentData->comboData;
 8006f22:	f8d7 8000 	ldr.w	r8, [r7]
  uint8_t who_am_i = 0x00;
 8006f26:	f805 6d01 	strb.w	r6, [r5, #-1]!
  if ( LSM6DSL_ACC_GYRO_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 8006f2a:	4629      	mov	r1, r5
{
 8006f2c:	4604      	mov	r4, r0
  if ( LSM6DSL_ACC_GYRO_R_WHO_AM_I( (void *)handle, ( uint8_t* )who_am_i ) == MEMS_ERROR )
 8006f2e:	f7fc fe65 	bl	8003bfc <LSM6DSL_ACC_GYRO_R_WHO_AM_I>
 8006f32:	b120      	cbz	r0, 8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( who_am_i != handle->who_am_i )
 8006f34:	7822      	ldrb	r2, [r4, #0]
 8006f36:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8006f3a:	429a      	cmp	r2, r3
 8006f3c:	d003      	beq.n	8006f46 <LSM6DSL_X_DeInit+0x32>
    return COMPONENT_ERROR;
 8006f3e:	2001      	movs	r0, #1
}
 8006f40:	b002      	add	sp, #8
 8006f42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ( LSM6DSL_ACC_GYRO_W_FFEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_FF_DISABLED ) == MEMS_ERROR )
 8006f46:	4631      	mov	r1, r6
 8006f48:	4620      	mov	r0, r4
 8006f4a:	f7fd fe01 	bl	8004b50 <LSM6DSL_ACC_GYRO_W_FFEvOnInt1>
 8006f4e:	2800      	cmp	r0, #0
 8006f50:	d0f5      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_FFEvOnInt2( (void *)handle, LSM6DSL_ACC_GYRO_INT2_FF_DISABLED ) == MEMS_ERROR )
 8006f52:	4631      	mov	r1, r6
 8006f54:	4620      	mov	r0, r4
 8006f56:	f7fd fec7 	bl	8004ce8 <LSM6DSL_ACC_GYRO_W_FFEvOnInt2>
 8006f5a:	2800      	cmp	r0, #0
 8006f5c:	d0ef      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSL_ACC_GYRO_BASIC_INT_DISABLED ) == MEMS_ERROR )
 8006f5e:	4631      	mov	r1, r6
 8006f60:	4620      	mov	r0, r4
 8006f62:	f7fd fbaf 	bl	80046c4 <LSM6DSL_ACC_GYRO_W_BASIC_INT>
 8006f66:	2800      	cmp	r0, #0
 8006f68:	d0e9      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_FF_Duration( (void *)handle, 0x00 ) == MEMS_ERROR )
 8006f6a:	4631      	mov	r1, r6
 8006f6c:	4620      	mov	r0, r4
 8006f6e:	f7fd fd4d 	bl	8004a0c <LSM6DSL_ACC_GYRO_W_FF_Duration>
 8006f72:	2800      	cmp	r0, #0
 8006f74:	d0e3      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_FF_THS( (void *)handle, LSM6DSL_ACC_GYRO_FF_THS_156mg ) == MEMS_ERROR )
 8006f76:	4631      	mov	r1, r6
 8006f78:	4620      	mov	r0, r4
 8006f7a:	f7fd fd25 	bl	80049c8 <LSM6DSL_ACC_GYRO_W_FF_THS>
 8006f7e:	2800      	cmp	r0, #0
 8006f80:	d0dd      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_6DEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_6D_DISABLED ) == MEMS_ERROR )
 8006f82:	4631      	mov	r1, r6
 8006f84:	4620      	mov	r0, r4
 8006f86:	f7fd fd9f 	bl	8004ac8 <LSM6DSL_ACC_GYRO_W_6DEvOnInt1>
 8006f8a:	2800      	cmp	r0, #0
 8006f8c:	d0d7      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_6DEvOnInt2( (void *)handle, LSM6DSL_ACC_GYRO_INT2_6D_DISABLED ) == MEMS_ERROR )
 8006f8e:	4631      	mov	r1, r6
 8006f90:	4620      	mov	r0, r4
 8006f92:	f7fd fe65 	bl	8004c60 <LSM6DSL_ACC_GYRO_W_6DEvOnInt2>
 8006f96:	2800      	cmp	r0, #0
 8006f98:	d0d1      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSL_ACC_GYRO_BASIC_INT_DISABLED ) == MEMS_ERROR )
 8006f9a:	4631      	mov	r1, r6
 8006f9c:	4620      	mov	r0, r4
 8006f9e:	f7fd fb91 	bl	80046c4 <LSM6DSL_ACC_GYRO_W_BASIC_INT>
 8006fa2:	2800      	cmp	r0, #0
 8006fa4:	d0cb      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_SIXD_THS( (void *)handle, LSM6DSL_ACC_GYRO_SIXD_THS_80_degree ) == MEMS_ERROR )
 8006fa6:	2100      	movs	r1, #0
 8006fa8:	4620      	mov	r0, r4
 8006faa:	f7fd fbd1 	bl	8004750 <LSM6DSL_ACC_GYRO_W_SIXD_THS>
 8006fae:	2800      	cmp	r0, #0
 8006fb0:	d0c5      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_STEP_DET_on_INT1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_PEDO_DISABLED ) == MEMS_ERROR )
 8006fb2:	2100      	movs	r1, #0
 8006fb4:	4620      	mov	r0, r4
 8006fb6:	f7fd f889 	bl	80040cc <LSM6DSL_ACC_GYRO_W_STEP_DET_on_INT1>
 8006fba:	2800      	cmp	r0, #0
 8006fbc:	d0bf      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_PEDO( (void *)handle, LSM6DSL_ACC_GYRO_PEDO_DISABLED ) == MEMS_ERROR )
 8006fbe:	2100      	movs	r1, #0
 8006fc0:	4620      	mov	r0, r4
 8006fc2:	f7fd f94f 	bl	8004264 <LSM6DSL_ACC_GYRO_W_PEDO>
 8006fc6:	2800      	cmp	r0, #0
 8006fc8:	d0b9      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_FUNC_EN( (void *)handle, LSM6DSL_ACC_GYRO_FUNC_EN_DISABLED ) == MEMS_ERROR )
 8006fca:	2100      	movs	r1, #0
 8006fcc:	4620      	mov	r0, r4
 8006fce:	f7fd f96b 	bl	80042a8 <LSM6DSL_ACC_GYRO_W_FUNC_EN>
 8006fd2:	2800      	cmp	r0, #0
 8006fd4:	d0b3      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_PedoThreshold( (void *)handle, thr ) == MEMS_ERROR )
 8006fd6:	2100      	movs	r1, #0
 8006fd8:	4620      	mov	r0, r4
 8006fda:	f7fd ff17 	bl	8004e0c <LSM6DSL_ACC_GYRO_W_PedoThreshold>
  if( LSM6DSL_X_Disable_Pedometer( handle ) == COMPONENT_ERROR )
 8006fde:	2800      	cmp	r0, #0
 8006fe0:	d0ad      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if( LSM6DSL_X_Disable_Single_Tap_Detection( handle ) == COMPONENT_ERROR )
 8006fe2:	4620      	mov	r0, r4
 8006fe4:	f7fe fd94 	bl	8005b10 <LSM6DSL_X_Disable_Single_Tap_Detection>
 8006fe8:	2801      	cmp	r0, #1
 8006fea:	d0a8      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if( LSM6DSL_X_Disable_Double_Tap_Detection( handle ) == COMPONENT_ERROR )
 8006fec:	4620      	mov	r0, r4
 8006fee:	f7fe fd49 	bl	8005a84 <LSM6DSL_X_Disable_Double_Tap_Detection>
 8006ff2:	2801      	cmp	r0, #1
 8006ff4:	d0a3      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_TiltEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_TILT_DISABLED ) == MEMS_ERROR )
 8006ff6:	2100      	movs	r1, #0
 8006ff8:	4620      	mov	r0, r4
 8006ffa:	f7fd fd43 	bl	8004a84 <LSM6DSL_ACC_GYRO_W_TiltEvOnInt1>
 8006ffe:	2800      	cmp	r0, #0
 8007000:	d09d      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_TiltEvOnInt2( (void *)handle, LSM6DSL_ACC_GYRO_INT2_TILT_DISABLED ) == MEMS_ERROR )
 8007002:	2100      	movs	r1, #0
 8007004:	4620      	mov	r0, r4
 8007006:	f7fd fe09 	bl	8004c1c <LSM6DSL_ACC_GYRO_W_TiltEvOnInt2>
 800700a:	2800      	cmp	r0, #0
 800700c:	d097      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_TILT( (void *)handle, LSM6DSL_ACC_GYRO_TILT_DISABLED ) == MEMS_ERROR )
 800700e:	2100      	movs	r1, #0
 8007010:	4620      	mov	r0, r4
 8007012:	f7fd f905 	bl	8004220 <LSM6DSL_ACC_GYRO_W_TILT>
 8007016:	2800      	cmp	r0, #0
 8007018:	d091      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_FUNC_EN( (void *)handle, LSM6DSL_ACC_GYRO_FUNC_EN_DISABLED ) == MEMS_ERROR )
 800701a:	2100      	movs	r1, #0
 800701c:	4620      	mov	r0, r4
 800701e:	f7fd f943 	bl	80042a8 <LSM6DSL_ACC_GYRO_W_FUNC_EN>
 8007022:	2800      	cmp	r0, #0
 8007024:	d08b      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_WUEvOnInt1( (void *)handle, LSM6DSL_ACC_GYRO_INT1_WU_DISABLED ) == MEMS_ERROR )
 8007026:	2100      	movs	r1, #0
 8007028:	4620      	mov	r0, r4
 800702a:	f7fd fdb3 	bl	8004b94 <LSM6DSL_ACC_GYRO_W_WUEvOnInt1>
 800702e:	2800      	cmp	r0, #0
 8007030:	d085      	beq.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_WUEvOnInt2( (void *)handle, LSM6DSL_ACC_GYRO_INT2_WU_DISABLED ) == MEMS_ERROR )
 8007032:	2100      	movs	r1, #0
 8007034:	4620      	mov	r0, r4
 8007036:	f7fd fe79 	bl	8004d2c <LSM6DSL_ACC_GYRO_W_WUEvOnInt2>
 800703a:	2800      	cmp	r0, #0
 800703c:	f43f af7f 	beq.w	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_BASIC_INT( (void *)handle, LSM6DSL_ACC_GYRO_BASIC_INT_DISABLED ) == MEMS_ERROR )
 8007040:	2100      	movs	r1, #0
 8007042:	4620      	mov	r0, r4
 8007044:	f7fd fb3e 	bl	80046c4 <LSM6DSL_ACC_GYRO_W_BASIC_INT>
 8007048:	2800      	cmp	r0, #0
 800704a:	f43f af78 	beq.w	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_WAKE_DUR( (void *)handle, 0x00 ) == MEMS_ERROR )
 800704e:	2100      	movs	r1, #0
 8007050:	4620      	mov	r0, r4
 8007052:	f7fd fc95 	bl	8004980 <LSM6DSL_ACC_GYRO_W_WAKE_DUR>
 8007056:	2800      	cmp	r0, #0
 8007058:	f43f af71 	beq.w	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( LSM6DSL_ACC_GYRO_W_WK_THS( (void *)handle, 0x00 ) == MEMS_ERROR )
 800705c:	2100      	movs	r1, #0
 800705e:	4620      	mov	r0, r4
 8007060:	f7fd fc02 	bl	8004868 <LSM6DSL_ACC_GYRO_W_WK_THS>
 8007064:	2800      	cmp	r0, #0
 8007066:	f43f af6a 	beq.w	8006f3e <LSM6DSL_X_DeInit+0x2a>
  if ( handle->isEnabled == 0 )
 800706a:	79a3      	ldrb	r3, [r4, #6]
 800706c:	b93b      	cbnz	r3, 800707e <LSM6DSL_X_DeInit+0x16a>
  comboData->isAccInitialized = 0;
 800706e:	2300      	movs	r3, #0
  pComponentData->Previous_ODR = 0.0f;
 8007070:	2200      	movs	r2, #0
 8007072:	607a      	str	r2, [r7, #4]
  return COMPONENT_OK;
 8007074:	4618      	mov	r0, r3
  comboData->isAccInitialized = 0;
 8007076:	f888 3000 	strb.w	r3, [r8]
  handle->isInitialized = 0;
 800707a:	7163      	strb	r3, [r4, #5]
  return COMPONENT_OK;
 800707c:	e760      	b.n	8006f40 <LSM6DSL_X_DeInit+0x2c>
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 800707e:	68a3      	ldr	r3, [r4, #8]
  if ( LSM6DSL_ACC_GYRO_R_ODR_XL( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 8007080:	4629      	mov	r1, r5
 8007082:	4620      	mov	r0, r4
  LSM6DSL_X_Data_t *pComponentData = ( LSM6DSL_X_Data_t * )pData->pComponentData;
 8007084:	681d      	ldr	r5, [r3, #0]
  if ( LSM6DSL_ACC_GYRO_R_ODR_XL( (void *)handle, &odr_low_level ) == MEMS_ERROR )
 8007086:	f7fc fe59 	bl	8003d3c <LSM6DSL_ACC_GYRO_R_ODR_XL>
 800708a:	2800      	cmp	r0, #0
 800708c:	f43f af57 	beq.w	8006f3e <LSM6DSL_X_DeInit+0x2a>
  switch( odr_low_level )
 8007090:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8007094:	2b50      	cmp	r3, #80	; 0x50
 8007096:	d02a      	beq.n	80070ee <LSM6DSL_X_DeInit+0x1da>
 8007098:	d811      	bhi.n	80070be <LSM6DSL_X_DeInit+0x1aa>
 800709a:	2b20      	cmp	r3, #32
 800709c:	d033      	beq.n	8007106 <LSM6DSL_X_DeInit+0x1f2>
 800709e:	d818      	bhi.n	80070d2 <LSM6DSL_X_DeInit+0x1be>
 80070a0:	b373      	cbz	r3, 8007100 <LSM6DSL_X_DeInit+0x1ec>
 80070a2:	2b10      	cmp	r3, #16
 80070a4:	d129      	bne.n	80070fa <LSM6DSL_X_DeInit+0x1e6>
      *odr =    13.0f;
 80070a6:	4b1e      	ldr	r3, [pc, #120]	; (8007120 <LSM6DSL_X_DeInit+0x20c>)
 80070a8:	606b      	str	r3, [r5, #4]
  if ( LSM6DSL_ACC_GYRO_W_ODR_XL( (void *)handle, LSM6DSL_ACC_GYRO_ODR_XL_POWER_DOWN ) == MEMS_ERROR )
 80070aa:	2100      	movs	r1, #0
 80070ac:	4620      	mov	r0, r4
 80070ae:	f7fc fe23 	bl	8003cf8 <LSM6DSL_ACC_GYRO_W_ODR_XL>
 80070b2:	2800      	cmp	r0, #0
 80070b4:	f43f af43 	beq.w	8006f3e <LSM6DSL_X_DeInit+0x2a>
  handle->isEnabled = 0;
 80070b8:	2300      	movs	r3, #0
 80070ba:	71a3      	strb	r3, [r4, #6]
 80070bc:	e7d7      	b.n	800706e <LSM6DSL_X_DeInit+0x15a>
  switch( odr_low_level )
 80070be:	2b80      	cmp	r3, #128	; 0x80
 80070c0:	d027      	beq.n	8007112 <LSM6DSL_X_DeInit+0x1fe>
 80070c2:	d80d      	bhi.n	80070e0 <LSM6DSL_X_DeInit+0x1cc>
 80070c4:	2b60      	cmp	r3, #96	; 0x60
 80070c6:	d021      	beq.n	800710c <LSM6DSL_X_DeInit+0x1f8>
 80070c8:	2b70      	cmp	r3, #112	; 0x70
 80070ca:	d116      	bne.n	80070fa <LSM6DSL_X_DeInit+0x1e6>
      *odr =   833.0f;
 80070cc:	4b15      	ldr	r3, [pc, #84]	; (8007124 <LSM6DSL_X_DeInit+0x210>)
 80070ce:	606b      	str	r3, [r5, #4]
 80070d0:	e7eb      	b.n	80070aa <LSM6DSL_X_DeInit+0x196>
  switch( odr_low_level )
 80070d2:	2b30      	cmp	r3, #48	; 0x30
 80070d4:	d020      	beq.n	8007118 <LSM6DSL_X_DeInit+0x204>
 80070d6:	2b40      	cmp	r3, #64	; 0x40
 80070d8:	d10f      	bne.n	80070fa <LSM6DSL_X_DeInit+0x1e6>
      *odr =   104.0f;
 80070da:	4b13      	ldr	r3, [pc, #76]	; (8007128 <LSM6DSL_X_DeInit+0x214>)
 80070dc:	606b      	str	r3, [r5, #4]
 80070de:	e7e4      	b.n	80070aa <LSM6DSL_X_DeInit+0x196>
  switch( odr_low_level )
 80070e0:	2b90      	cmp	r3, #144	; 0x90
 80070e2:	d007      	beq.n	80070f4 <LSM6DSL_X_DeInit+0x1e0>
 80070e4:	2ba0      	cmp	r3, #160	; 0xa0
 80070e6:	d108      	bne.n	80070fa <LSM6DSL_X_DeInit+0x1e6>
      *odr =  6660.0f;
 80070e8:	4b10      	ldr	r3, [pc, #64]	; (800712c <LSM6DSL_X_DeInit+0x218>)
 80070ea:	606b      	str	r3, [r5, #4]
 80070ec:	e7dd      	b.n	80070aa <LSM6DSL_X_DeInit+0x196>
      *odr =   208.0f;
 80070ee:	4b10      	ldr	r3, [pc, #64]	; (8007130 <LSM6DSL_X_DeInit+0x21c>)
 80070f0:	606b      	str	r3, [r5, #4]
 80070f2:	e7da      	b.n	80070aa <LSM6DSL_X_DeInit+0x196>
      *odr =  3330.0f;
 80070f4:	4b0f      	ldr	r3, [pc, #60]	; (8007134 <LSM6DSL_X_DeInit+0x220>)
 80070f6:	606b      	str	r3, [r5, #4]
 80070f8:	e7d7      	b.n	80070aa <LSM6DSL_X_DeInit+0x196>
      *odr =    -1.0f;
 80070fa:	4b0f      	ldr	r3, [pc, #60]	; (8007138 <LSM6DSL_X_DeInit+0x224>)
 80070fc:	606b      	str	r3, [r5, #4]
 80070fe:	e71e      	b.n	8006f3e <LSM6DSL_X_DeInit+0x2a>
      *odr =     0.0f;
 8007100:	2300      	movs	r3, #0
 8007102:	606b      	str	r3, [r5, #4]
 8007104:	e7d1      	b.n	80070aa <LSM6DSL_X_DeInit+0x196>
      *odr =    26.0f;
 8007106:	4b0d      	ldr	r3, [pc, #52]	; (800713c <LSM6DSL_X_DeInit+0x228>)
 8007108:	606b      	str	r3, [r5, #4]
 800710a:	e7ce      	b.n	80070aa <LSM6DSL_X_DeInit+0x196>
      *odr =   416.0f;
 800710c:	4b0c      	ldr	r3, [pc, #48]	; (8007140 <LSM6DSL_X_DeInit+0x22c>)
 800710e:	606b      	str	r3, [r5, #4]
 8007110:	e7cb      	b.n	80070aa <LSM6DSL_X_DeInit+0x196>
      *odr =  1660.0f;
 8007112:	4b0c      	ldr	r3, [pc, #48]	; (8007144 <LSM6DSL_X_DeInit+0x230>)
 8007114:	606b      	str	r3, [r5, #4]
 8007116:	e7c8      	b.n	80070aa <LSM6DSL_X_DeInit+0x196>
      *odr =    52.0f;
 8007118:	4b0b      	ldr	r3, [pc, #44]	; (8007148 <LSM6DSL_X_DeInit+0x234>)
 800711a:	606b      	str	r3, [r5, #4]
 800711c:	e7c5      	b.n	80070aa <LSM6DSL_X_DeInit+0x196>
 800711e:	bf00      	nop
 8007120:	41500000 	.word	0x41500000
 8007124:	44504000 	.word	0x44504000
 8007128:	42d00000 	.word	0x42d00000
 800712c:	45d02000 	.word	0x45d02000
 8007130:	43500000 	.word	0x43500000
 8007134:	45502000 	.word	0x45502000
 8007138:	bf800000 	.word	0xbf800000
 800713c:	41d00000 	.word	0x41d00000
 8007140:	43d00000 	.word	0x43d00000
 8007144:	44cf8000 	.word	0x44cf8000
 8007148:	42500000 	.word	0x42500000

0800714c <BSP_LED_Init>:
  * @param  Led: Specifies the Led to be configured. 
  *   This parameter can be one of following parameters:
  *     @arg LED2
  */
void BSP_LED_Init(Led_TypeDef Led)
{
 800714c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800714e:	b087      	sub	sp, #28
  GPIO_InitTypeDef  GPIO_InitStruct;
  
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);
 8007150:	2400      	movs	r4, #0
 8007152:	4b10      	ldr	r3, [pc, #64]	; (8007194 <BSP_LED_Init+0x48>)
 8007154:	9400      	str	r4, [sp, #0]
 8007156:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  GPIO_InitStruct.Pin = GPIO_PIN[Led];
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
  
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 8007158:	4d0f      	ldr	r5, [pc, #60]	; (8007198 <BSP_LED_Init+0x4c>)
  LEDx_GPIO_CLK_ENABLE(Led);
 800715a:	f042 0201 	orr.w	r2, r2, #1
 800715e:	631a      	str	r2, [r3, #48]	; 0x30
 8007160:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8007162:	9403      	str	r4, [sp, #12]
  LEDx_GPIO_CLK_ENABLE(Led);
 8007164:	f003 0301 	and.w	r3, r3, #1
{
 8007168:	4606      	mov	r6, r0
  LEDx_GPIO_CLK_ENABLE(Led);
 800716a:	9300      	str	r3, [sp, #0]
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 800716c:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
  LEDx_GPIO_CLK_ENABLE(Led);
 8007170:	9b00      	ldr	r3, [sp, #0]
  GPIO_InitStruct.Pin = GPIO_PIN[Led];
 8007172:	2720      	movs	r7, #32
  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
 8007174:	2302      	movs	r3, #2
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8007176:	2201      	movs	r2, #1
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 8007178:	a901      	add	r1, sp, #4
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800717a:	9202      	str	r2, [sp, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
 800717c:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Pin = GPIO_PIN[Led];
 800717e:	9701      	str	r7, [sp, #4]
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 8007180:	f001 faf2 	bl	8008768 <HAL_GPIO_Init>
  
  HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET); 
 8007184:	4622      	mov	r2, r4
 8007186:	4639      	mov	r1, r7
 8007188:	f855 0026 	ldr.w	r0, [r5, r6, lsl #2]
 800718c:	f001 fbda 	bl	8008944 <HAL_GPIO_WritePin>
}
 8007190:	b007      	add	sp, #28
 8007192:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007194:	40023800 	.word	0x40023800
 8007198:	20000390 	.word	0x20000390

0800719c <BSP_LED_Off>:
  *   This parameter can be one of following parameters:
  *     @arg LED2
  */
void BSP_LED_Off(Led_TypeDef Led)
{
  HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET); 
 800719c:	4b03      	ldr	r3, [pc, #12]	; (80071ac <BSP_LED_Off+0x10>)
 800719e:	2200      	movs	r2, #0
 80071a0:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 80071a4:	2120      	movs	r1, #32
 80071a6:	f001 bbcd 	b.w	8008944 <HAL_GPIO_WritePin>
 80071aa:	bf00      	nop
 80071ac:	20000390 	.word	0x20000390

080071b0 <BSP_LED_Toggle>:
  *   This parameter can be one of following parameters:
  *     @arg LED2  
  */
void BSP_LED_Toggle(Led_TypeDef Led)
{
  HAL_GPIO_TogglePin(GPIO_PORT[Led], GPIO_PIN[Led]);
 80071b0:	4b02      	ldr	r3, [pc, #8]	; (80071bc <BSP_LED_Toggle+0xc>)
 80071b2:	2120      	movs	r1, #32
 80071b4:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 80071b8:	f001 bbc8 	b.w	800894c <HAL_GPIO_TogglePin>
 80071bc:	20000390 	.word	0x20000390

080071c0 <BSP_PB_Init>:
  *     @arg BUTTON_MODE_GPIO: Button will be used as simple IO 
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                            generation capability  
  */
void BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
 80071c0:	b530      	push	{r4, r5, lr}
 80071c2:	b087      	sub	sp, #28
  GPIO_InitTypeDef GPIO_InitStruct;
  
  /* Enable the BUTTON Clock */
  BUTTONx_GPIO_CLK_ENABLE(Button);
 80071c4:	4b1b      	ldr	r3, [pc, #108]	; (8007234 <BSP_PB_Init+0x74>)
 80071c6:	2500      	movs	r5, #0
 80071c8:	9500      	str	r5, [sp, #0]
 80071ca:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 80071cc:	f044 0404 	orr.w	r4, r4, #4
 80071d0:	631c      	str	r4, [r3, #48]	; 0x30
 80071d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80071d4:	f003 0304 	and.w	r3, r3, #4
 80071d8:	9300      	str	r3, [sp, #0]
 80071da:	9b00      	ldr	r3, [sp, #0]
  
  if(ButtonMode == BUTTON_MODE_GPIO)
 80071dc:	b119      	cbz	r1, 80071e6 <BSP_PB_Init+0x26>
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
  }
  
  if(ButtonMode == BUTTON_MODE_EXTI)
 80071de:	2901      	cmp	r1, #1
 80071e0:	d011      	beq.n	8007206 <BSP_PB_Init+0x46>
    
    /* Enable and set Button EXTI Interrupt to the lowest priority */
    HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0x00);
    HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
  }
}
 80071e2:	b007      	add	sp, #28
 80071e4:	bd30      	pop	{r4, r5, pc}
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 80071e6:	4b14      	ldr	r3, [pc, #80]	; (8007238 <BSP_PB_Init+0x78>)
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80071e8:	9102      	str	r1, [sp, #8]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 80071ea:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 80071ee:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80071f2:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 80071f4:	6840      	ldr	r0, [r0, #4]
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 80071f6:	2302      	movs	r3, #2
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 80071f8:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 80071fa:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
 80071fc:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 80071fe:	f001 fab3 	bl	8008768 <HAL_GPIO_Init>
}
 8007202:	b007      	add	sp, #28
 8007204:	bd30      	pop	{r4, r5, pc}
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 8007206:	4b0c      	ldr	r3, [pc, #48]	; (8007238 <BSP_PB_Init+0x78>)
    GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING; 
 8007208:	4a0c      	ldr	r2, [pc, #48]	; (800723c <BSP_PB_Init+0x7c>)
 800720a:	9202      	str	r2, [sp, #8]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 800720c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8007210:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 8007212:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 8007216:	6840      	ldr	r0, [r0, #4]
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 8007218:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800721a:	9503      	str	r5, [sp, #12]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 800721c:	f001 faa4 	bl	8008768 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0x00);
 8007220:	462a      	mov	r2, r5
 8007222:	210f      	movs	r1, #15
 8007224:	2028      	movs	r0, #40	; 0x28
 8007226:	f001 f967 	bl	80084f8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
 800722a:	2028      	movs	r0, #40	; 0x28
 800722c:	f001 f99a 	bl	8008564 <HAL_NVIC_EnableIRQ>
}
 8007230:	b007      	add	sp, #28
 8007232:	bd30      	pop	{r4, r5, pc}
 8007234:	40023800 	.word	0x40023800
 8007238:	20000390 	.word	0x20000390
 800723c:	10210000 	.word	0x10210000

08007240 <I2C_EXPBD_Init>:
 * @param  None
 * @retval COMPONENT_OK    in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
static DrvStatusTypeDef I2C_EXPBD_Init( void )
{
 8007240:	b5f0      	push	{r4, r5, r6, r7, lr}
  if( HAL_I2C_GetState( &I2C_EXPBD_Handle) == HAL_I2C_STATE_RESET )
 8007242:	4c2c      	ldr	r4, [pc, #176]	; (80072f4 <I2C_EXPBD_Init+0xb4>)
{
 8007244:	b089      	sub	sp, #36	; 0x24
  if( HAL_I2C_GetState( &I2C_EXPBD_Handle) == HAL_I2C_STATE_RESET )
 8007246:	4620      	mov	r0, r4
 8007248:	f002 f884 	bl	8009354 <HAL_I2C_GetState>
 800724c:	b138      	cbz	r0, 800725e <I2C_EXPBD_Init+0x1e>

    /* Setup Fast Mode */
    BOARD_I2C_EXPBD_SET_FAST_MODE();
  }

  if( HAL_I2C_GetState( &I2C_EXPBD_Handle) == HAL_I2C_STATE_READY )
 800724e:	4829      	ldr	r0, [pc, #164]	; (80072f4 <I2C_EXPBD_Init+0xb4>)
 8007250:	f002 f880 	bl	8009354 <HAL_I2C_GetState>
  }
  else
  {
    return COMPONENT_ERROR;
  }
}
 8007254:	3820      	subs	r0, #32
 8007256:	bf18      	it	ne
 8007258:	2001      	movne	r0, #1
 800725a:	b009      	add	sp, #36	; 0x24
 800725c:	bdf0      	pop	{r4, r5, r6, r7, pc}

  /* Setup the I2C clock source */
  BOARD_I2C_EXPBD_SET_CLK_SOURCE();

  /* Enable I2C GPIO clocks */
  BOARD_I2C_EXPBD_SCL_SDA_GPIO_CLK_ENABLE();
 800725e:	4e26      	ldr	r6, [pc, #152]	; (80072f8 <I2C_EXPBD_Init+0xb8>)
 8007260:	9001      	str	r0, [sp, #4]
    I2C_EXPBD_Handle.Instance            = BOARD_I2C_EXPBD;
 8007262:	4b26      	ldr	r3, [pc, #152]	; (80072fc <I2C_EXPBD_Init+0xbc>)
 8007264:	6023      	str	r3, [r4, #0]
  BOARD_I2C_EXPBD_SCL_SDA_GPIO_CLK_ENABLE();
 8007266:	6b33      	ldr	r3, [r6, #48]	; 0x30
    BOARD_I2C_EXPBD_SET_CLK_SPEED(&I2C_EXPBD_Handle.Init);
 8007268:	4a25      	ldr	r2, [pc, #148]	; (8007300 <I2C_EXPBD_Init+0xc0>)
 800726a:	4605      	mov	r5, r0
  BOARD_I2C_EXPBD_SCL_SDA_GPIO_CLK_ENABLE();
 800726c:	f043 0302 	orr.w	r3, r3, #2
    BOARD_I2C_EXPBD_SET_CLK_SPEED(&I2C_EXPBD_Handle.Init);
 8007270:	60a5      	str	r5, [r4, #8]
  BOARD_I2C_EXPBD_SCL_SDA_GPIO_CLK_ENABLE();
 8007272:	6333      	str	r3, [r6, #48]	; 0x30
 8007274:	6b33      	ldr	r3, [r6, #48]	; 0x30
    BOARD_I2C_EXPBD_SET_CLK_SPEED(&I2C_EXPBD_Handle.Init);
 8007276:	6062      	str	r2, [r4, #4]
  BOARD_I2C_EXPBD_SCL_SDA_GPIO_CLK_ENABLE();
 8007278:	f003 0302 	and.w	r3, r3, #2
 800727c:	9301      	str	r3, [sp, #4]
    I2C_EXPBD_Handle.Init.OwnAddress1    = 0x33;
 800727e:	2233      	movs	r2, #51	; 0x33
    I2C_EXPBD_Handle.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8007280:	f44f 4380 	mov.w	r3, #16384	; 0x4000

  /* I2C_EXPBD SCL and SDA pins configuration -------------------------------------*/
  GPIO_InitStruct.Pin        = BOARD_I2C_EXPBD_SCL_PIN | BOARD_I2C_EXPBD_SDA_PIN;
 8007284:	f44f 7140 	mov.w	r1, #768	; 0x300
    I2C_EXPBD_Handle.Init.OwnAddress1    = 0x33;
 8007288:	60e2      	str	r2, [r4, #12]
    I2C_EXPBD_Handle.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800728a:	6123      	str	r3, [r4, #16]
  GPIO_InitStruct.Mode       = GPIO_MODE_AF_OD;
  GPIO_InitStruct.Speed      = BOARD_I2C_EXPBD_GPIO_SPEED;
 800728c:	2202      	movs	r2, #2
  GPIO_InitStruct.Pull       = GPIO_NOPULL;
  GPIO_InitStruct.Alternate  = BOARD_I2C_EXPBD_SCL_SDA_AF;
 800728e:	2304      	movs	r3, #4
  GPIO_InitStruct.Pin        = BOARD_I2C_EXPBD_SCL_PIN | BOARD_I2C_EXPBD_SDA_PIN;
 8007290:	9103      	str	r1, [sp, #12]

  HAL_GPIO_Init( BOARD_I2C_EXPBD_SCL_SDA_GPIO_PORT, &GPIO_InitStruct );
 8007292:	481c      	ldr	r0, [pc, #112]	; (8007304 <I2C_EXPBD_Init+0xc4>)
  BOARD_I2C_EXPBD_SCL_SDA_GPIO_CLK_ENABLE();
 8007294:	f8dd e004 	ldr.w	lr, [sp, #4]
  GPIO_InitStruct.Speed      = BOARD_I2C_EXPBD_GPIO_SPEED;
 8007298:	9206      	str	r2, [sp, #24]
  HAL_GPIO_Init( BOARD_I2C_EXPBD_SCL_SDA_GPIO_PORT, &GPIO_InitStruct );
 800729a:	a903      	add	r1, sp, #12
  GPIO_InitStruct.Mode       = GPIO_MODE_AF_OD;
 800729c:	2712      	movs	r7, #18
  GPIO_InitStruct.Alternate  = BOARD_I2C_EXPBD_SCL_SDA_AF;
 800729e:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Pull       = GPIO_NOPULL;
 80072a0:	9505      	str	r5, [sp, #20]
  GPIO_InitStruct.Mode       = GPIO_MODE_AF_OD;
 80072a2:	9704      	str	r7, [sp, #16]
  HAL_GPIO_Init( BOARD_I2C_EXPBD_SCL_SDA_GPIO_PORT, &GPIO_InitStruct );
 80072a4:	f001 fa60 	bl	8008768 <HAL_GPIO_Init>

  /* Enable the I2C_EXPBD peripheral clock */
  BOARD_I2C_EXPBD_CLK_ENABLE();
 80072a8:	9502      	str	r5, [sp, #8]
 80072aa:	6c33      	ldr	r3, [r6, #64]	; 0x40
 80072ac:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80072b0:	6433      	str	r3, [r6, #64]	; 0x40
 80072b2:	6c33      	ldr	r3, [r6, #64]	; 0x40
 80072b4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80072b8:	9302      	str	r3, [sp, #8]
 80072ba:	9b02      	ldr	r3, [sp, #8]

  /* Force the I2C peripheral clock reset */
  BOARD_I2C_EXPBD_FORCE_RESET();
 80072bc:	6a33      	ldr	r3, [r6, #32]
 80072be:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80072c2:	6233      	str	r3, [r6, #32]

  /* Release the I2C peripheral clock reset */
  BOARD_I2C_EXPBD_RELEASE_RESET();
 80072c4:	6a33      	ldr	r3, [r6, #32]
 80072c6:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80072ca:	6233      	str	r3, [r6, #32]

  /* Enable and set I2C_EXPBD Interrupt priority */
  HAL_NVIC_SetPriority(BOARD_I2C_EXPBD_EV_IRQn, BOARD_I2C_EXPBD_IRQ_PRI_LEVEL, 0x01);
 80072cc:	4629      	mov	r1, r5
 80072ce:	2201      	movs	r2, #1
 80072d0:	201f      	movs	r0, #31
 80072d2:	f001 f911 	bl	80084f8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(BOARD_I2C_EXPBD_EV_IRQn);
 80072d6:	201f      	movs	r0, #31
 80072d8:	f001 f944 	bl	8008564 <HAL_NVIC_EnableIRQ>

#if (defined (BOARD_I2C_EXPBD_ER_IRQn))
  HAL_NVIC_SetPriority(BOARD_I2C_EXPBD_ER_IRQn, BOARD_I2C_EXPBD_IRQ_PRI_LEVEL, 0x00);
 80072dc:	462a      	mov	r2, r5
 80072de:	4629      	mov	r1, r5
 80072e0:	2020      	movs	r0, #32
 80072e2:	f001 f909 	bl	80084f8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(BOARD_I2C_EXPBD_ER_IRQn);
 80072e6:	2020      	movs	r0, #32
 80072e8:	f001 f93c 	bl	8008564 <HAL_NVIC_EnableIRQ>
    HAL_I2C_Init( &I2C_EXPBD_Handle );
 80072ec:	4620      	mov	r0, r4
 80072ee:	f001 fd3d 	bl	8008d6c <HAL_I2C_Init>
 80072f2:	e7ac      	b.n	800724e <I2C_EXPBD_Init+0xe>
 80072f4:	2000059c 	.word	0x2000059c
 80072f8:	40023800 	.word	0x40023800
 80072fc:	40005400 	.word	0x40005400
 8007300:	00061a80 	.word	0x00061a80
 8007304:	40020400 	.word	0x40020400

08007308 <Sensor_IO_Init>:
{
 8007308:	b5f0      	push	{r4, r5, r6, r7, lr}
  if( HAL_I2C_GetState( &I2C_EXPBD_Handle) == HAL_I2C_STATE_RESET )
 800730a:	4c2c      	ldr	r4, [pc, #176]	; (80073bc <Sensor_IO_Init+0xb4>)
{
 800730c:	b089      	sub	sp, #36	; 0x24
  if( HAL_I2C_GetState( &I2C_EXPBD_Handle) == HAL_I2C_STATE_RESET )
 800730e:	4620      	mov	r0, r4
 8007310:	f002 f820 	bl	8009354 <HAL_I2C_GetState>
 8007314:	b138      	cbz	r0, 8007326 <Sensor_IO_Init+0x1e>
  if( HAL_I2C_GetState( &I2C_EXPBD_Handle) == HAL_I2C_STATE_READY )
 8007316:	4829      	ldr	r0, [pc, #164]	; (80073bc <Sensor_IO_Init+0xb4>)
 8007318:	f002 f81c 	bl	8009354 <HAL_I2C_GetState>
}
 800731c:	3820      	subs	r0, #32
 800731e:	bf18      	it	ne
 8007320:	2001      	movne	r0, #1
 8007322:	b009      	add	sp, #36	; 0x24
 8007324:	bdf0      	pop	{r4, r5, r6, r7, pc}
  BOARD_I2C_EXPBD_SCL_SDA_GPIO_CLK_ENABLE();
 8007326:	4e26      	ldr	r6, [pc, #152]	; (80073c0 <Sensor_IO_Init+0xb8>)
 8007328:	9001      	str	r0, [sp, #4]
    I2C_EXPBD_Handle.Instance            = BOARD_I2C_EXPBD;
 800732a:	4b26      	ldr	r3, [pc, #152]	; (80073c4 <Sensor_IO_Init+0xbc>)
 800732c:	6023      	str	r3, [r4, #0]
  BOARD_I2C_EXPBD_SCL_SDA_GPIO_CLK_ENABLE();
 800732e:	6b33      	ldr	r3, [r6, #48]	; 0x30
    BOARD_I2C_EXPBD_SET_CLK_SPEED(&I2C_EXPBD_Handle.Init);
 8007330:	4a25      	ldr	r2, [pc, #148]	; (80073c8 <Sensor_IO_Init+0xc0>)
 8007332:	4605      	mov	r5, r0
  BOARD_I2C_EXPBD_SCL_SDA_GPIO_CLK_ENABLE();
 8007334:	f043 0302 	orr.w	r3, r3, #2
    BOARD_I2C_EXPBD_SET_CLK_SPEED(&I2C_EXPBD_Handle.Init);
 8007338:	60a5      	str	r5, [r4, #8]
  BOARD_I2C_EXPBD_SCL_SDA_GPIO_CLK_ENABLE();
 800733a:	6333      	str	r3, [r6, #48]	; 0x30
 800733c:	6b33      	ldr	r3, [r6, #48]	; 0x30
    BOARD_I2C_EXPBD_SET_CLK_SPEED(&I2C_EXPBD_Handle.Init);
 800733e:	6062      	str	r2, [r4, #4]
  BOARD_I2C_EXPBD_SCL_SDA_GPIO_CLK_ENABLE();
 8007340:	f003 0302 	and.w	r3, r3, #2
 8007344:	9301      	str	r3, [sp, #4]
    I2C_EXPBD_Handle.Init.OwnAddress1    = 0x33;
 8007346:	2233      	movs	r2, #51	; 0x33
    I2C_EXPBD_Handle.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8007348:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  GPIO_InitStruct.Pin        = BOARD_I2C_EXPBD_SCL_PIN | BOARD_I2C_EXPBD_SDA_PIN;
 800734c:	f44f 7140 	mov.w	r1, #768	; 0x300
    I2C_EXPBD_Handle.Init.OwnAddress1    = 0x33;
 8007350:	60e2      	str	r2, [r4, #12]
    I2C_EXPBD_Handle.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8007352:	6123      	str	r3, [r4, #16]
  GPIO_InitStruct.Speed      = BOARD_I2C_EXPBD_GPIO_SPEED;
 8007354:	2202      	movs	r2, #2
  GPIO_InitStruct.Alternate  = BOARD_I2C_EXPBD_SCL_SDA_AF;
 8007356:	2304      	movs	r3, #4
  GPIO_InitStruct.Pin        = BOARD_I2C_EXPBD_SCL_PIN | BOARD_I2C_EXPBD_SDA_PIN;
 8007358:	9103      	str	r1, [sp, #12]
  HAL_GPIO_Init( BOARD_I2C_EXPBD_SCL_SDA_GPIO_PORT, &GPIO_InitStruct );
 800735a:	481c      	ldr	r0, [pc, #112]	; (80073cc <Sensor_IO_Init+0xc4>)
  BOARD_I2C_EXPBD_SCL_SDA_GPIO_CLK_ENABLE();
 800735c:	f8dd e004 	ldr.w	lr, [sp, #4]
  GPIO_InitStruct.Speed      = BOARD_I2C_EXPBD_GPIO_SPEED;
 8007360:	9206      	str	r2, [sp, #24]
  HAL_GPIO_Init( BOARD_I2C_EXPBD_SCL_SDA_GPIO_PORT, &GPIO_InitStruct );
 8007362:	a903      	add	r1, sp, #12
  GPIO_InitStruct.Mode       = GPIO_MODE_AF_OD;
 8007364:	2712      	movs	r7, #18
  GPIO_InitStruct.Alternate  = BOARD_I2C_EXPBD_SCL_SDA_AF;
 8007366:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Pull       = GPIO_NOPULL;
 8007368:	9505      	str	r5, [sp, #20]
  GPIO_InitStruct.Mode       = GPIO_MODE_AF_OD;
 800736a:	9704      	str	r7, [sp, #16]
  HAL_GPIO_Init( BOARD_I2C_EXPBD_SCL_SDA_GPIO_PORT, &GPIO_InitStruct );
 800736c:	f001 f9fc 	bl	8008768 <HAL_GPIO_Init>
  BOARD_I2C_EXPBD_CLK_ENABLE();
 8007370:	9502      	str	r5, [sp, #8]
 8007372:	6c33      	ldr	r3, [r6, #64]	; 0x40
 8007374:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8007378:	6433      	str	r3, [r6, #64]	; 0x40
 800737a:	6c33      	ldr	r3, [r6, #64]	; 0x40
 800737c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8007380:	9302      	str	r3, [sp, #8]
 8007382:	9b02      	ldr	r3, [sp, #8]
  BOARD_I2C_EXPBD_FORCE_RESET();
 8007384:	6a33      	ldr	r3, [r6, #32]
 8007386:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800738a:	6233      	str	r3, [r6, #32]
  BOARD_I2C_EXPBD_RELEASE_RESET();
 800738c:	6a33      	ldr	r3, [r6, #32]
 800738e:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8007392:	6233      	str	r3, [r6, #32]
  HAL_NVIC_SetPriority(BOARD_I2C_EXPBD_EV_IRQn, BOARD_I2C_EXPBD_IRQ_PRI_LEVEL, 0x01);
 8007394:	4629      	mov	r1, r5
 8007396:	2201      	movs	r2, #1
 8007398:	201f      	movs	r0, #31
 800739a:	f001 f8ad 	bl	80084f8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(BOARD_I2C_EXPBD_EV_IRQn);
 800739e:	201f      	movs	r0, #31
 80073a0:	f001 f8e0 	bl	8008564 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(BOARD_I2C_EXPBD_ER_IRQn, BOARD_I2C_EXPBD_IRQ_PRI_LEVEL, 0x00);
 80073a4:	462a      	mov	r2, r5
 80073a6:	4629      	mov	r1, r5
 80073a8:	2020      	movs	r0, #32
 80073aa:	f001 f8a5 	bl	80084f8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(BOARD_I2C_EXPBD_ER_IRQn);
 80073ae:	2020      	movs	r0, #32
 80073b0:	f001 f8d8 	bl	8008564 <HAL_NVIC_EnableIRQ>
    HAL_I2C_Init( &I2C_EXPBD_Handle );
 80073b4:	4620      	mov	r0, r4
 80073b6:	f001 fcd9 	bl	8008d6c <HAL_I2C_Init>
 80073ba:	e7ac      	b.n	8007316 <Sensor_IO_Init+0xe>
 80073bc:	2000059c 	.word	0x2000059c
 80073c0:	40023800 	.word	0x40023800
 80073c4:	40005400 	.word	0x40005400
 80073c8:	00061a80 	.word	0x00061a80
 80073cc:	40020400 	.word	0x40020400

080073d0 <LSM6DSL_Sensor_IO_ITConfig>:
{
 80073d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80073d4:	b088      	sub	sp, #32
    GPIO_InitTypeDef GPIO_InitStructureInt = {0};
 80073d6:	2400      	movs	r4, #0
    LSM6DSL_INT1_O_GPIO_CLK_ENABLE();
 80073d8:	4d24      	ldr	r5, [pc, #144]	; (800746c <LSM6DSL_Sensor_IO_ITConfig+0x9c>)
 80073da:	9401      	str	r4, [sp, #4]
    GPIO_InitTypeDef GPIO_InitStructureInt = {0};
 80073dc:	9404      	str	r4, [sp, #16]
 80073de:	9403      	str	r4, [sp, #12]
 80073e0:	9406      	str	r4, [sp, #24]
 80073e2:	9405      	str	r4, [sp, #20]
 80073e4:	9407      	str	r4, [sp, #28]
    LSM6DSL_INT1_O_GPIO_CLK_ENABLE();
 80073e6:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    HAL_GPIO_Init(LSM6DSL_INT1_O_GPIO_PORT, &GPIO_InitStructureInt);
 80073e8:	4e21      	ldr	r6, [pc, #132]	; (8007470 <LSM6DSL_Sensor_IO_ITConfig+0xa0>)
    GPIO_InitStructureInt.Mode  = GPIO_MODE_IT_RISING;
 80073ea:	4f22      	ldr	r7, [pc, #136]	; (8007474 <LSM6DSL_Sensor_IO_ITConfig+0xa4>)
    LSM6DSL_INT1_O_GPIO_CLK_ENABLE();
 80073ec:	f043 0302 	orr.w	r3, r3, #2
 80073f0:	632b      	str	r3, [r5, #48]	; 0x30
 80073f2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    GPIO_InitStructureInt.Mode  = GPIO_MODE_IT_RISING;
 80073f4:	9704      	str	r7, [sp, #16]
    LSM6DSL_INT1_O_GPIO_CLK_ENABLE();
 80073f6:	f003 0302 	and.w	r3, r3, #2
    GPIO_InitStructureInt.Speed = BOARD_I2C_EXPBD_GPIO_SPEED;
 80073fa:	f04f 0802 	mov.w	r8, #2
    LSM6DSL_INT1_O_GPIO_CLK_ENABLE();
 80073fe:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(LSM6DSL_INT1_O_GPIO_PORT, &GPIO_InitStructureInt);
 8007400:	a903      	add	r1, sp, #12
    GPIO_InitStructureInt.Pin   = LSM6DSL_INT1_O_PIN;
 8007402:	2320      	movs	r3, #32
    HAL_GPIO_Init(LSM6DSL_INT1_O_GPIO_PORT, &GPIO_InitStructureInt);
 8007404:	4630      	mov	r0, r6
    GPIO_InitStructureInt.Pin   = LSM6DSL_INT1_O_PIN;
 8007406:	9303      	str	r3, [sp, #12]
    LSM6DSL_INT1_O_GPIO_CLK_ENABLE();
 8007408:	9a01      	ldr	r2, [sp, #4]
    GPIO_InitStructureInt.Speed = BOARD_I2C_EXPBD_GPIO_SPEED;
 800740a:	f8cd 8018 	str.w	r8, [sp, #24]
    HAL_GPIO_Init(LSM6DSL_INT1_O_GPIO_PORT, &GPIO_InitStructureInt);
 800740e:	f001 f9ab 	bl	8008768 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(LSM6DSL_INT1_O_EXTI_IRQn, BOARD_I2C_EXPBD_IRQ_PRI_LEVEL, 0x00);
 8007412:	4622      	mov	r2, r4
 8007414:	4621      	mov	r1, r4
 8007416:	2017      	movs	r0, #23
 8007418:	f001 f86e 	bl	80084f8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(LSM6DSL_INT1_O_EXTI_IRQn);
 800741c:	2017      	movs	r0, #23
 800741e:	f001 f8a1 	bl	8008564 <HAL_NVIC_EnableIRQ>
    LSM6DSL_INT2_O_GPIO_CLK_ENABLE();
 8007422:	9402      	str	r4, [sp, #8]
    GPIO_InitTypeDef GPIO_InitStructureInt = {0};
 8007424:	9403      	str	r4, [sp, #12]
 8007426:	9404      	str	r4, [sp, #16]
 8007428:	9406      	str	r4, [sp, #24]
 800742a:	9405      	str	r4, [sp, #20]
 800742c:	9407      	str	r4, [sp, #28]
    LSM6DSL_INT2_O_GPIO_CLK_ENABLE();
 800742e:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8007430:	ea43 0308 	orr.w	r3, r3, r8
 8007434:	632b      	str	r3, [r5, #48]	; 0x30
 8007436:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    GPIO_InitStructureInt.Mode  = GPIO_MODE_IT_RISING;
 8007438:	9704      	str	r7, [sp, #16]
    LSM6DSL_INT2_O_GPIO_CLK_ENABLE();
 800743a:	ea03 0308 	and.w	r3, r3, r8
 800743e:	9302      	str	r3, [sp, #8]
    HAL_GPIO_Init(LSM6DSL_INT2_O_GPIO_PORT, &GPIO_InitStructureInt);
 8007440:	a903      	add	r1, sp, #12
    GPIO_InitStructureInt.Pin   = LSM6DSL_INT2_O_PIN;
 8007442:	2310      	movs	r3, #16
    HAL_GPIO_Init(LSM6DSL_INT2_O_GPIO_PORT, &GPIO_InitStructureInt);
 8007444:	4630      	mov	r0, r6
    GPIO_InitStructureInt.Pin   = LSM6DSL_INT2_O_PIN;
 8007446:	9303      	str	r3, [sp, #12]
    LSM6DSL_INT2_O_GPIO_CLK_ENABLE();
 8007448:	9a02      	ldr	r2, [sp, #8]
    GPIO_InitStructureInt.Speed = BOARD_I2C_EXPBD_GPIO_SPEED;
 800744a:	f8cd 8018 	str.w	r8, [sp, #24]
    HAL_GPIO_Init(LSM6DSL_INT2_O_GPIO_PORT, &GPIO_InitStructureInt);
 800744e:	f001 f98b 	bl	8008768 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(LSM6DSL_INT2_O_EXTI_IRQn, BOARD_I2C_EXPBD_IRQ_PRI_LEVEL, 0x00);
 8007452:	4622      	mov	r2, r4
 8007454:	4621      	mov	r1, r4
 8007456:	200a      	movs	r0, #10
 8007458:	f001 f84e 	bl	80084f8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(LSM6DSL_INT2_O_EXTI_IRQn);
 800745c:	200a      	movs	r0, #10
 800745e:	f001 f881 	bl	8008564 <HAL_NVIC_EnableIRQ>
}
 8007462:	4620      	mov	r0, r4
 8007464:	b008      	add	sp, #32
 8007466:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800746a:	bf00      	nop
 800746c:	40023800 	.word	0x40023800
 8007470:	40020400 	.word	0x40020400
 8007474:	10110000 	.word	0x10110000

08007478 <LPS22HB_Sensor_IO_ITConfig>:
{
 8007478:	b570      	push	{r4, r5, r6, lr}
 800747a:	b086      	sub	sp, #24
  LPS22H_INT1_O_GPIO_CLK_ENABLE();
 800747c:	2400      	movs	r4, #0
 800747e:	4b11      	ldr	r3, [pc, #68]	; (80074c4 <LPS22HB_Sensor_IO_ITConfig+0x4c>)
 8007480:	9400      	str	r4, [sp, #0]
 8007482:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  GPIO_InitStructureInt1.Mode  = GPIO_MODE_IT_RISING;
 8007484:	4d10      	ldr	r5, [pc, #64]	; (80074c8 <LPS22HB_Sensor_IO_ITConfig+0x50>)
  HAL_GPIO_Init(LPS22H_INT1_O_GPIO_PORT, &GPIO_InitStructureInt1);
 8007486:	4811      	ldr	r0, [pc, #68]	; (80074cc <LPS22HB_Sensor_IO_ITConfig+0x54>)
  LPS22H_INT1_O_GPIO_CLK_ENABLE();
 8007488:	f042 0202 	orr.w	r2, r2, #2
 800748c:	631a      	str	r2, [r3, #48]	; 0x30
 800748e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  GPIO_InitStructureInt1.Pull  = GPIO_NOPULL;
 8007490:	9403      	str	r4, [sp, #12]
  LPS22H_INT1_O_GPIO_CLK_ENABLE();
 8007492:	f003 0302 	and.w	r3, r3, #2
 8007496:	9300      	str	r3, [sp, #0]
  GPIO_InitStructureInt1.Pin   = LPS22H_INT1_O_PIN;
 8007498:	f44f 6280 	mov.w	r2, #1024	; 0x400
  GPIO_InitStructureInt1.Speed = BOARD_I2C_EXPBD_GPIO_SPEED;
 800749c:	2302      	movs	r3, #2
  HAL_GPIO_Init(LPS22H_INT1_O_GPIO_PORT, &GPIO_InitStructureInt1);
 800749e:	a901      	add	r1, sp, #4
  GPIO_InitStructureInt1.Speed = BOARD_I2C_EXPBD_GPIO_SPEED;
 80074a0:	9304      	str	r3, [sp, #16]
  GPIO_InitStructureInt1.Pin   = LPS22H_INT1_O_PIN;
 80074a2:	9201      	str	r2, [sp, #4]
  LPS22H_INT1_O_GPIO_CLK_ENABLE();
 80074a4:	9e00      	ldr	r6, [sp, #0]
  GPIO_InitStructureInt1.Mode  = GPIO_MODE_IT_RISING;
 80074a6:	9502      	str	r5, [sp, #8]
  HAL_GPIO_Init(LPS22H_INT1_O_GPIO_PORT, &GPIO_InitStructureInt1);
 80074a8:	f001 f95e 	bl	8008768 <HAL_GPIO_Init>
  HAL_NVIC_SetPriority(LPS22H_INT1_O_EXTI_IRQn, BOARD_I2C_EXPBD_IRQ_PRI_LEVEL, 0x00);
 80074ac:	4622      	mov	r2, r4
 80074ae:	4621      	mov	r1, r4
 80074b0:	2028      	movs	r0, #40	; 0x28
 80074b2:	f001 f821 	bl	80084f8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(LPS22H_INT1_O_EXTI_IRQn);
 80074b6:	2028      	movs	r0, #40	; 0x28
 80074b8:	f001 f854 	bl	8008564 <HAL_NVIC_EnableIRQ>
}
 80074bc:	4620      	mov	r0, r4
 80074be:	b006      	add	sp, #24
 80074c0:	bd70      	pop	{r4, r5, r6, pc}
 80074c2:	bf00      	nop
 80074c4:	40023800 	.word	0x40023800
 80074c8:	10110000 	.word	0x10110000
 80074cc:	40020400 	.word	0x40020400

080074d0 <Sensor_IO_Write>:
{
 80074d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80074d4:	460e      	mov	r6, r1
  switch(ctx->who_am_i)
 80074d6:	7801      	ldrb	r1, [r0, #0]
 80074d8:	2940      	cmp	r1, #64	; 0x40
{
 80074da:	b085      	sub	sp, #20
 80074dc:	4605      	mov	r5, r0
 80074de:	4617      	mov	r7, r2
 80074e0:	4698      	mov	r8, r3
  switch(ctx->who_am_i)
 80074e2:	d031      	beq.n	8007548 <Sensor_IO_Write+0x78>
 80074e4:	d92e      	bls.n	8007544 <Sensor_IO_Write+0x74>
 80074e6:	29b1      	cmp	r1, #177	; 0xb1
 80074e8:	d119      	bne.n	800751e <Sensor_IO_Write+0x4e>
      for (i = 0; ((i < nBytesToWrite) && (ret == COMPONENT_OK)); i++ )
 80074ea:	b33b      	cbz	r3, 800753c <Sensor_IO_Write+0x6c>
  status = HAL_I2C_Mem_Write( &I2C_EXPBD_Handle, Addr, ( uint16_t )Reg, I2C_MEMADD_SIZE_8BIT, pBuffer, Size,
 80074ec:	f8df b078 	ldr.w	fp, [pc, #120]	; 8007568 <Sensor_IO_Write+0x98>
 80074f0:	2400      	movs	r4, #0
 80074f2:	f44f 5a80 	mov.w	sl, #4096	; 0x1000
 80074f6:	f04f 0901 	mov.w	r9, #1
 80074fa:	193b      	adds	r3, r7, r4
 80074fc:	1932      	adds	r2, r6, r4
 80074fe:	78a9      	ldrb	r1, [r5, #2]
 8007500:	9300      	str	r3, [sp, #0]
 8007502:	f8cd a008 	str.w	sl, [sp, #8]
 8007506:	f8cd 9004 	str.w	r9, [sp, #4]
 800750a:	b2d2      	uxtb	r2, r2
 800750c:	2301      	movs	r3, #1
 800750e:	4658      	mov	r0, fp
 8007510:	f001 fcc0 	bl	8008e94 <HAL_I2C_Mem_Write>
      for (i = 0; ((i < nBytesToWrite) && (ret == COMPONENT_OK)); i++ )
 8007514:	3401      	adds	r4, #1
  if( status != HAL_OK )
 8007516:	b9e8      	cbnz	r0, 8007554 <Sensor_IO_Write+0x84>
      for (i = 0; ((i < nBytesToWrite) && (ret == COMPONENT_OK)); i++ )
 8007518:	45a0      	cmp	r8, r4
 800751a:	d1ee      	bne.n	80074fa <Sensor_IO_Write+0x2a>
 800751c:	e00e      	b.n	800753c <Sensor_IO_Write+0x6c>
  switch(ctx->who_am_i)
 800751e:	29bc      	cmp	r1, #188	; 0xbc
 8007520:	d012      	beq.n	8007548 <Sensor_IO_Write+0x78>
  status = HAL_I2C_Mem_Write( &I2C_EXPBD_Handle, Addr, ( uint16_t )Reg, I2C_MEMADD_SIZE_8BIT, pBuffer, Size,
 8007522:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8007526:	78a9      	ldrb	r1, [r5, #2]
 8007528:	480f      	ldr	r0, [pc, #60]	; (8007568 <Sensor_IO_Write+0x98>)
 800752a:	9302      	str	r3, [sp, #8]
 800752c:	f8cd 8004 	str.w	r8, [sp, #4]
 8007530:	9700      	str	r7, [sp, #0]
 8007532:	4632      	mov	r2, r6
 8007534:	2301      	movs	r3, #1
 8007536:	f001 fcad 	bl	8008e94 <HAL_I2C_Mem_Write>
  if( status != HAL_OK )
 800753a:	b958      	cbnz	r0, 8007554 <Sensor_IO_Write+0x84>
    return COMPONENT_OK;
 800753c:	2000      	movs	r0, #0
}
 800753e:	b005      	add	sp, #20
 8007540:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  switch(ctx->who_am_i)
 8007544:	2933      	cmp	r1, #51	; 0x33
 8007546:	d1ec      	bne.n	8007522 <Sensor_IO_Write+0x52>
      if ( nBytesToWrite > 1 ) WriteAddr |= 0x80;  /* Enable I2C multi-bytes Write */
 8007548:	f1b8 0f01 	cmp.w	r8, #1
 800754c:	d9e9      	bls.n	8007522 <Sensor_IO_Write+0x52>
 800754e:	f046 0680 	orr.w	r6, r6, #128	; 0x80
 8007552:	e7e6      	b.n	8007522 <Sensor_IO_Write+0x52>
  if(HAL_I2C_DeInit(&I2C_EXPBD_Handle) == HAL_OK)
 8007554:	4804      	ldr	r0, [pc, #16]	; (8007568 <Sensor_IO_Write+0x98>)
 8007556:	f001 fc83 	bl	8008e60 <HAL_I2C_DeInit>
 800755a:	b908      	cbnz	r0, 8007560 <Sensor_IO_Write+0x90>
    I2C_EXPBD_Init();
 800755c:	f7ff fe70 	bl	8007240 <I2C_EXPBD_Init>
    return COMPONENT_ERROR;
 8007560:	2001      	movs	r0, #1
}
 8007562:	b005      	add	sp, #20
 8007564:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007568:	2000059c 	.word	0x2000059c

0800756c <Sensor_IO_Read>:
{
 800756c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007570:	460e      	mov	r6, r1
  switch(ctx->who_am_i)
 8007572:	7801      	ldrb	r1, [r0, #0]
 8007574:	2940      	cmp	r1, #64	; 0x40
{
 8007576:	b085      	sub	sp, #20
 8007578:	4605      	mov	r5, r0
 800757a:	4617      	mov	r7, r2
 800757c:	4698      	mov	r8, r3
  switch(ctx->who_am_i)
 800757e:	d031      	beq.n	80075e4 <Sensor_IO_Read+0x78>
 8007580:	d92e      	bls.n	80075e0 <Sensor_IO_Read+0x74>
 8007582:	29b1      	cmp	r1, #177	; 0xb1
 8007584:	d119      	bne.n	80075ba <Sensor_IO_Read+0x4e>
      for (i = 0; ((i < nBytesToRead) && (ret == COMPONENT_OK)); i++ )
 8007586:	b33b      	cbz	r3, 80075d8 <Sensor_IO_Read+0x6c>
  status = HAL_I2C_Mem_Read( &I2C_EXPBD_Handle, Addr, ( uint16_t )Reg, I2C_MEMADD_SIZE_8BIT, pBuffer, Size,
 8007588:	f8df b078 	ldr.w	fp, [pc, #120]	; 8007604 <Sensor_IO_Read+0x98>
 800758c:	2400      	movs	r4, #0
 800758e:	f44f 5a80 	mov.w	sl, #4096	; 0x1000
 8007592:	f04f 0901 	mov.w	r9, #1
 8007596:	193b      	adds	r3, r7, r4
 8007598:	1932      	adds	r2, r6, r4
 800759a:	78a9      	ldrb	r1, [r5, #2]
 800759c:	9300      	str	r3, [sp, #0]
 800759e:	f8cd a008 	str.w	sl, [sp, #8]
 80075a2:	f8cd 9004 	str.w	r9, [sp, #4]
 80075a6:	b2d2      	uxtb	r2, r2
 80075a8:	2301      	movs	r3, #1
 80075aa:	4658      	mov	r0, fp
 80075ac:	f001 fd5c 	bl	8009068 <HAL_I2C_Mem_Read>
      for (i = 0; ((i < nBytesToRead) && (ret == COMPONENT_OK)); i++ )
 80075b0:	3401      	adds	r4, #1
  if( status != HAL_OK )
 80075b2:	b9e8      	cbnz	r0, 80075f0 <Sensor_IO_Read+0x84>
      for (i = 0; ((i < nBytesToRead) && (ret == COMPONENT_OK)); i++ )
 80075b4:	45a0      	cmp	r8, r4
 80075b6:	d1ee      	bne.n	8007596 <Sensor_IO_Read+0x2a>
 80075b8:	e00e      	b.n	80075d8 <Sensor_IO_Read+0x6c>
  switch(ctx->who_am_i)
 80075ba:	29bc      	cmp	r1, #188	; 0xbc
 80075bc:	d012      	beq.n	80075e4 <Sensor_IO_Read+0x78>
  status = HAL_I2C_Mem_Read( &I2C_EXPBD_Handle, Addr, ( uint16_t )Reg, I2C_MEMADD_SIZE_8BIT, pBuffer, Size,
 80075be:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80075c2:	78a9      	ldrb	r1, [r5, #2]
 80075c4:	480f      	ldr	r0, [pc, #60]	; (8007604 <Sensor_IO_Read+0x98>)
 80075c6:	9302      	str	r3, [sp, #8]
 80075c8:	f8cd 8004 	str.w	r8, [sp, #4]
 80075cc:	9700      	str	r7, [sp, #0]
 80075ce:	4632      	mov	r2, r6
 80075d0:	2301      	movs	r3, #1
 80075d2:	f001 fd49 	bl	8009068 <HAL_I2C_Mem_Read>
  if( status != HAL_OK )
 80075d6:	b958      	cbnz	r0, 80075f0 <Sensor_IO_Read+0x84>
    return COMPONENT_OK;
 80075d8:	2000      	movs	r0, #0
}
 80075da:	b005      	add	sp, #20
 80075dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  switch(ctx->who_am_i)
 80075e0:	2933      	cmp	r1, #51	; 0x33
 80075e2:	d1ec      	bne.n	80075be <Sensor_IO_Read+0x52>
      if ( nBytesToRead > 1 ) ReadAddr |= 0x80; /* Enable I2C multi-bytes Read */
 80075e4:	f1b8 0f01 	cmp.w	r8, #1
 80075e8:	d9e9      	bls.n	80075be <Sensor_IO_Read+0x52>
 80075ea:	f046 0680 	orr.w	r6, r6, #128	; 0x80
 80075ee:	e7e6      	b.n	80075be <Sensor_IO_Read+0x52>
  if(HAL_I2C_DeInit(&I2C_EXPBD_Handle) == HAL_OK)
 80075f0:	4804      	ldr	r0, [pc, #16]	; (8007604 <Sensor_IO_Read+0x98>)
 80075f2:	f001 fc35 	bl	8008e60 <HAL_I2C_DeInit>
 80075f6:	b908      	cbnz	r0, 80075fc <Sensor_IO_Read+0x90>
    I2C_EXPBD_Init();
 80075f8:	f7ff fe22 	bl	8007240 <I2C_EXPBD_Init>
    return COMPONENT_ERROR;
 80075fc:	2001      	movs	r0, #1
}
 80075fe:	b005      	add	sp, #20
 8007600:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007604:	2000059c 	.word	0x2000059c

08007608 <BSP_ACCELERO_Init>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
DrvStatusTypeDef BSP_ACCELERO_Init( ACCELERO_ID_t id, void **handle )
{
 8007608:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  *handle = NULL;
 800760a:	2500      	movs	r5, #0
{
 800760c:	460e      	mov	r6, r1
  *handle = NULL;
 800760e:	600d      	str	r5, [r1, #0]

  switch(id)
 8007610:	4604      	mov	r4, r0
 8007612:	2800      	cmp	r0, #0
 8007614:	f000 8086 	beq.w	8007724 <BSP_ACCELERO_Init+0x11c>
 8007618:	2801      	cmp	r0, #1

static DrvStatusTypeDef BSP_LSM303AGR_ACCELERO_Init( void **handle )
{
  ACCELERO_Drv_t *driver = NULL;

  if(ACCELERO_SensorHandle[ LSM303AGR_X_0 ].isInitialized == 1)
 800761a:	4c68      	ldr	r4, [pc, #416]	; (80077bc <BSP_ACCELERO_Init+0x1b4>)
  switch(id)
 800761c:	d12b      	bne.n	8007676 <BSP_ACCELERO_Init+0x6e>
  if(ACCELERO_SensorHandle[ LSM303AGR_X_0 ].isInitialized == 1)
 800761e:	7e63      	ldrb	r3, [r4, #25]
 8007620:	2b01      	cmp	r3, #1
 8007622:	f000 8087 	beq.w	8007734 <BSP_ACCELERO_Init+0x12c>
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
  }

  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 8007626:	f7ff fe6f 	bl	8007308 <Sensor_IO_Init>
 800762a:	2801      	cmp	r0, #1
 800762c:	f000 8082 	beq.w	8007734 <BSP_ACCELERO_Init+0x12c>
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].isCombo       = 1;
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pData         = ( void * )&ACCELERO_Data[ LSM303AGR_X_0 ];
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pVTable       = ( void * )&LSM303AGR_X_Drv;
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pExtVTable    = 0;

  LSM303AGR_X_0_Data.comboData = &LSM303AGR_Combo_Data[0];
 8007630:	4623      	mov	r3, r4
 8007632:	4a63      	ldr	r2, [pc, #396]	; (80077c0 <BSP_ACCELERO_Init+0x1b8>)
 8007634:	f843 2f40 	str.w	r2, [r3, #64]!
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].who_am_i      = LSM303AGR_ACC_WHO_AM_I;
 8007638:	f04f 0e33 	mov.w	lr, #51	; 0x33
  ACCELERO_Data[ LSM303AGR_X_0 ].pComponentData = ( void * )&LSM303AGR_X_0_Data;
 800763c:	6323      	str	r3, [r4, #48]	; 0x30
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pVTable       = ( void * )&LSM303AGR_X_Drv;
 800763e:	4a61      	ldr	r2, [pc, #388]	; (80077c4 <BSP_ACCELERO_Init+0x1bc>)
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].instance      = LSM303AGR_X_0;
 8007640:	4861      	ldr	r0, [pc, #388]	; (80077c8 <BSP_ACCELERO_Init+0x1c0>)
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pVTable       = ( void * )&LSM303AGR_X_Drv;
 8007642:	6222      	str	r2, [r4, #32]
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].address       = LSM303AGR_ACC_I2C_ADDRESS;
 8007644:	2732      	movs	r7, #50	; 0x32
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pData         = ( void * )&ACCELERO_Data[ LSM303AGR_X_0 ];
 8007646:	f104 0130 	add.w	r1, r4, #48	; 0x30
  ACCELERO_Data[ LSM303AGR_X_0 ].pExtData       = 0;

  *handle = (void *)&ACCELERO_SensorHandle[ LSM303AGR_X_0 ];
 800764a:	f104 0314 	add.w	r3, r4, #20
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].ifType        = 0; /* I2C interface */
 800764e:	7565      	strb	r5, [r4, #21]
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pExtVTable    = 0;
 8007650:	6265      	str	r5, [r4, #36]	; 0x24
  ACCELERO_Data[ LSM303AGR_X_0 ].pExtData       = 0;
 8007652:	6365      	str	r5, [r4, #52]	; 0x34
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].who_am_i      = LSM303AGR_ACC_WHO_AM_I;
 8007654:	f884 e014 	strb.w	lr, [r4, #20]
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].address       = LSM303AGR_ACC_I2C_ADDRESS;
 8007658:	75a7      	strb	r7, [r4, #22]
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].instance      = LSM303AGR_X_0;
 800765a:	61a0      	str	r0, [r4, #24]
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pData         = ( void * )&ACCELERO_Data[ LSM303AGR_X_0 ];
 800765c:	61e1      	str	r1, [r4, #28]
  *handle = (void *)&ACCELERO_SensorHandle[ LSM303AGR_X_0 ];
 800765e:	6033      	str	r3, [r6, #0]

  driver = ( ACCELERO_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;

  if ( driver->Init == NULL )
 8007660:	6a22      	ldr	r2, [r4, #32]
 8007662:	6812      	ldr	r2, [r2, #0]
 8007664:	2a00      	cmp	r2, #0
 8007666:	d054      	beq.n	8007712 <BSP_ACCELERO_Init+0x10a>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }

  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 8007668:	4618      	mov	r0, r3
 800766a:	4790      	blx	r2
 800766c:	2801      	cmp	r0, #1
 800766e:	f000 8086 	beq.w	800777e <BSP_ACCELERO_Init+0x176>
  return COMPONENT_OK;
 8007672:	2000      	movs	r0, #0
 8007674:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if(ACCELERO_SensorHandle[ LSM6DSL_X_0 ].isInitialized == 1)
 8007676:	7963      	ldrb	r3, [r4, #5]
 8007678:	2b01      	cmp	r3, #1
 800767a:	d02a      	beq.n	80076d2 <BSP_ACCELERO_Init+0xca>
  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 800767c:	f7ff fe44 	bl	8007308 <Sensor_IO_Init>
 8007680:	2801      	cmp	r0, #1
 8007682:	d026      	beq.n	80076d2 <BSP_ACCELERO_Init+0xca>
  LSM6DSL_X_0_Data.comboData = &LSM6DSL_Combo_Data[0];
 8007684:	4623      	mov	r3, r4
 8007686:	4a51      	ldr	r2, [pc, #324]	; (80077cc <BSP_ACCELERO_Init+0x1c4>)
 8007688:	f843 2f38 	str.w	r2, [r3, #56]!
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].who_am_i      = LSM6DSL_ACC_GYRO_WHO_AM_I;
 800768c:	f04f 0e6a 	mov.w	lr, #106	; 0x6a
  ACCELERO_Data[ LSM6DSL_X_0 ].pComponentData = ( void * )&LSM6DSL_X_0_Data;
 8007690:	62a3      	str	r3, [r4, #40]	; 0x28
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].address       = LSM6DSL_ACC_GYRO_I2C_ADDRESS_HIGH;
 8007692:	27d6      	movs	r7, #214	; 0xd6
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].pExtVTable    = ( void * )&LSM6DSL_X_ExtDrv;
 8007694:	4b4e      	ldr	r3, [pc, #312]	; (80077d0 <BSP_ACCELERO_Init+0x1c8>)
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].pVTable       = ( void * )&LSM6DSL_X_Drv;
 8007696:	4a4f      	ldr	r2, [pc, #316]	; (80077d4 <BSP_ACCELERO_Init+0x1cc>)
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].ifType        = 0; /* I2C interface */
 8007698:	7065      	strb	r5, [r4, #1]
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].instance      = LSM6DSL_X_0;
 800769a:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].pData         = ( void * )&ACCELERO_Data[ LSM6DSL_X_0 ];
 800769e:	f104 0128 	add.w	r1, r4, #40	; 0x28
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].who_am_i      = LSM6DSL_ACC_GYRO_WHO_AM_I;
 80076a2:	f884 e000 	strb.w	lr, [r4]
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].address       = LSM6DSL_ACC_GYRO_I2C_ADDRESS_HIGH;
 80076a6:	70a7      	strb	r7, [r4, #2]
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].instance      = LSM6DSL_X_0;
 80076a8:	6060      	str	r0, [r4, #4]
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].pVTable       = ( void * )&LSM6DSL_X_Drv;
 80076aa:	60e2      	str	r2, [r4, #12]
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].pExtVTable    = ( void * )&LSM6DSL_X_ExtDrv;
 80076ac:	6123      	str	r3, [r4, #16]
  ACCELERO_Data[ LSM6DSL_X_0 ].pExtData       = 0;
 80076ae:	62e5      	str	r5, [r4, #44]	; 0x2c
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].pData         = ( void * )&ACCELERO_Data[ LSM6DSL_X_0 ];
 80076b0:	60a1      	str	r1, [r4, #8]
  *handle = (void *)&ACCELERO_SensorHandle[ LSM6DSL_X_0 ];
 80076b2:	6034      	str	r4, [r6, #0]
  if ( driver->Init == NULL )
 80076b4:	68e3      	ldr	r3, [r4, #12]
 80076b6:	681b      	ldr	r3, [r3, #0]
 80076b8:	2b00      	cmp	r3, #0
 80076ba:	d070      	beq.n	800779e <BSP_ACCELERO_Init+0x196>
  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 80076bc:	4620      	mov	r0, r4
 80076be:	4798      	blx	r3
 80076c0:	2801      	cmp	r0, #1
 80076c2:	d158      	bne.n	8007776 <BSP_ACCELERO_Init+0x16e>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 80076c4:	6833      	ldr	r3, [r6, #0]
 80076c6:	601d      	str	r5, [r3, #0]
 80076c8:	605d      	str	r5, [r3, #4]
 80076ca:	609d      	str	r5, [r3, #8]
 80076cc:	60dd      	str	r5, [r3, #12]
 80076ce:	611d      	str	r5, [r3, #16]
    *handle = NULL;
 80076d0:	6035      	str	r5, [r6, #0]
  if(ACCELERO_SensorHandle[ LSM303AGR_X_0 ].isInitialized == 1)
 80076d2:	7e63      	ldrb	r3, [r4, #25]
 80076d4:	2b01      	cmp	r3, #1
 80076d6:	d02d      	beq.n	8007734 <BSP_ACCELERO_Init+0x12c>
  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 80076d8:	f7ff fe16 	bl	8007308 <Sensor_IO_Init>
 80076dc:	2801      	cmp	r0, #1
 80076de:	d029      	beq.n	8007734 <BSP_ACCELERO_Init+0x12c>
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pData         = ( void * )&ACCELERO_Data[ LSM303AGR_X_0 ];
 80076e0:	4b3d      	ldr	r3, [pc, #244]	; (80077d8 <BSP_ACCELERO_Init+0x1d0>)
 80076e2:	61e3      	str	r3, [r4, #28]
  ACCELERO_Data[ LSM303AGR_X_0 ].pComponentData = ( void * )&LSM303AGR_X_0_Data;
 80076e4:	f103 0510 	add.w	r5, r3, #16
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].who_am_i      = LSM303AGR_ACC_WHO_AM_I;
 80076e8:	2733      	movs	r7, #51	; 0x33
  ACCELERO_Data[ LSM303AGR_X_0 ].pComponentData = ( void * )&LSM303AGR_X_0_Data;
 80076ea:	6325      	str	r5, [r4, #48]	; 0x30
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].who_am_i      = LSM303AGR_ACC_WHO_AM_I;
 80076ec:	7527      	strb	r7, [r4, #20]
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].ifType        = 0; /* I2C interface */
 80076ee:	2500      	movs	r5, #0
  LSM303AGR_X_0_Data.comboData = &LSM303AGR_Combo_Data[0];
 80076f0:	4a33      	ldr	r2, [pc, #204]	; (80077c0 <BSP_ACCELERO_Init+0x1b8>)
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].instance      = LSM303AGR_X_0;
 80076f2:	4835      	ldr	r0, [pc, #212]	; (80077c8 <BSP_ACCELERO_Init+0x1c0>)
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pVTable       = ( void * )&LSM303AGR_X_Drv;
 80076f4:	4933      	ldr	r1, [pc, #204]	; (80077c4 <BSP_ACCELERO_Init+0x1bc>)
 80076f6:	6221      	str	r1, [r4, #32]
  *handle = (void *)&ACCELERO_SensorHandle[ LSM303AGR_X_0 ];
 80076f8:	3b1c      	subs	r3, #28
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].address       = LSM303AGR_ACC_I2C_ADDRESS;
 80076fa:	2732      	movs	r7, #50	; 0x32
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].ifType        = 0; /* I2C interface */
 80076fc:	7565      	strb	r5, [r4, #21]
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].pExtVTable    = 0;
 80076fe:	6265      	str	r5, [r4, #36]	; 0x24
  ACCELERO_Data[ LSM303AGR_X_0 ].pExtData       = 0;
 8007700:	6365      	str	r5, [r4, #52]	; 0x34
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].address       = LSM303AGR_ACC_I2C_ADDRESS;
 8007702:	75a7      	strb	r7, [r4, #22]
  ACCELERO_SensorHandle[ LSM303AGR_X_0 ].instance      = LSM303AGR_X_0;
 8007704:	61a0      	str	r0, [r4, #24]
  LSM303AGR_X_0_Data.comboData = &LSM303AGR_Combo_Data[0];
 8007706:	6422      	str	r2, [r4, #64]	; 0x40
  *handle = (void *)&ACCELERO_SensorHandle[ LSM303AGR_X_0 ];
 8007708:	6033      	str	r3, [r6, #0]
  if ( driver->Init == NULL )
 800770a:	6a22      	ldr	r2, [r4, #32]
 800770c:	6812      	ldr	r2, [r2, #0]
 800770e:	2a00      	cmp	r2, #0
 8007710:	d1aa      	bne.n	8007668 <BSP_ACCELERO_Init+0x60>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8007712:	2200      	movs	r2, #0
 8007714:	6162      	str	r2, [r4, #20]
 8007716:	605a      	str	r2, [r3, #4]
 8007718:	609a      	str	r2, [r3, #8]
 800771a:	60da      	str	r2, [r3, #12]
 800771c:	611a      	str	r2, [r3, #16]
          return COMPONENT_ERROR;
 800771e:	2001      	movs	r0, #1
    *handle = NULL;
 8007720:	6032      	str	r2, [r6, #0]
 8007722:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if(ACCELERO_SensorHandle[ LSM6DSL_X_0 ].isInitialized == 1)
 8007724:	4d25      	ldr	r5, [pc, #148]	; (80077bc <BSP_ACCELERO_Init+0x1b4>)
 8007726:	796b      	ldrb	r3, [r5, #5]
 8007728:	2b01      	cmp	r3, #1
 800772a:	d003      	beq.n	8007734 <BSP_ACCELERO_Init+0x12c>
  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 800772c:	f7ff fdec 	bl	8007308 <Sensor_IO_Init>
 8007730:	2801      	cmp	r0, #1
 8007732:	d101      	bne.n	8007738 <BSP_ACCELERO_Init+0x130>
          return COMPONENT_ERROR;
 8007734:	2001      	movs	r0, #1
 8007736:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  LSM6DSL_X_0_Data.comboData = &LSM6DSL_Combo_Data[0];
 8007738:	462b      	mov	r3, r5
 800773a:	4a24      	ldr	r2, [pc, #144]	; (80077cc <BSP_ACCELERO_Init+0x1c4>)
 800773c:	f843 2f38 	str.w	r2, [r3, #56]!
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].who_am_i      = LSM6DSL_ACC_GYRO_WHO_AM_I;
 8007740:	f04f 0e6a 	mov.w	lr, #106	; 0x6a
  ACCELERO_Data[ LSM6DSL_X_0 ].pComponentData = ( void * )&LSM6DSL_X_0_Data;
 8007744:	62ab      	str	r3, [r5, #40]	; 0x28
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].address       = LSM6DSL_ACC_GYRO_I2C_ADDRESS_HIGH;
 8007746:	27d6      	movs	r7, #214	; 0xd6
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].pExtVTable    = ( void * )&LSM6DSL_X_ExtDrv;
 8007748:	4b21      	ldr	r3, [pc, #132]	; (80077d0 <BSP_ACCELERO_Init+0x1c8>)
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].pVTable       = ( void * )&LSM6DSL_X_Drv;
 800774a:	4a22      	ldr	r2, [pc, #136]	; (80077d4 <BSP_ACCELERO_Init+0x1cc>)
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].ifType        = 0; /* I2C interface */
 800774c:	706c      	strb	r4, [r5, #1]
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].instance      = LSM6DSL_X_0;
 800774e:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].pData         = ( void * )&ACCELERO_Data[ LSM6DSL_X_0 ];
 8007752:	f105 0128 	add.w	r1, r5, #40	; 0x28
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].who_am_i      = LSM6DSL_ACC_GYRO_WHO_AM_I;
 8007756:	f885 e000 	strb.w	lr, [r5]
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].address       = LSM6DSL_ACC_GYRO_I2C_ADDRESS_HIGH;
 800775a:	70af      	strb	r7, [r5, #2]
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].instance      = LSM6DSL_X_0;
 800775c:	6068      	str	r0, [r5, #4]
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].pVTable       = ( void * )&LSM6DSL_X_Drv;
 800775e:	60ea      	str	r2, [r5, #12]
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].pExtVTable    = ( void * )&LSM6DSL_X_ExtDrv;
 8007760:	612b      	str	r3, [r5, #16]
  ACCELERO_Data[ LSM6DSL_X_0 ].pExtData       = 0;
 8007762:	62ec      	str	r4, [r5, #44]	; 0x2c
  ACCELERO_SensorHandle[ LSM6DSL_X_0 ].pData         = ( void * )&ACCELERO_Data[ LSM6DSL_X_0 ];
 8007764:	60a9      	str	r1, [r5, #8]
  *handle = (void *)&ACCELERO_SensorHandle[ LSM6DSL_X_0 ];
 8007766:	6035      	str	r5, [r6, #0]
  if ( driver->Init == NULL )
 8007768:	68eb      	ldr	r3, [r5, #12]
 800776a:	681b      	ldr	r3, [r3, #0]
 800776c:	b1f3      	cbz	r3, 80077ac <BSP_ACCELERO_Init+0x1a4>
  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 800776e:	4628      	mov	r0, r5
 8007770:	4798      	blx	r3
 8007772:	2801      	cmp	r0, #1
 8007774:	d00b      	beq.n	800778e <BSP_ACCELERO_Init+0x186>
  LSM6DSL_Sensor_IO_ITConfig();
 8007776:	f7ff fe2b 	bl	80073d0 <LSM6DSL_Sensor_IO_ITConfig>
  return COMPONENT_OK;
 800777a:	2000      	movs	r0, #0
 800777c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  {
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 800777e:	6833      	ldr	r3, [r6, #0]
 8007780:	601d      	str	r5, [r3, #0]
 8007782:	605d      	str	r5, [r3, #4]
 8007784:	609d      	str	r5, [r3, #8]
 8007786:	60dd      	str	r5, [r3, #12]
 8007788:	611d      	str	r5, [r3, #16]
    *handle = NULL;
 800778a:	6035      	str	r5, [r6, #0]
 800778c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 800778e:	6833      	ldr	r3, [r6, #0]
 8007790:	601c      	str	r4, [r3, #0]
 8007792:	605c      	str	r4, [r3, #4]
 8007794:	609c      	str	r4, [r3, #8]
 8007796:	60dc      	str	r4, [r3, #12]
 8007798:	611c      	str	r4, [r3, #16]
    *handle = NULL;
 800779a:	6034      	str	r4, [r6, #0]
 800779c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 800779e:	6023      	str	r3, [r4, #0]
 80077a0:	6063      	str	r3, [r4, #4]
 80077a2:	60a3      	str	r3, [r4, #8]
 80077a4:	60e3      	str	r3, [r4, #12]
 80077a6:	6123      	str	r3, [r4, #16]
    *handle = NULL;
 80077a8:	6033      	str	r3, [r6, #0]
 80077aa:	e792      	b.n	80076d2 <BSP_ACCELERO_Init+0xca>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 80077ac:	602b      	str	r3, [r5, #0]
 80077ae:	606b      	str	r3, [r5, #4]
 80077b0:	60ab      	str	r3, [r5, #8]
 80077b2:	60eb      	str	r3, [r5, #12]
 80077b4:	612b      	str	r3, [r5, #16]
        return COMPONENT_ERROR;
 80077b6:	2001      	movs	r0, #1
    *handle = NULL;
 80077b8:	6033      	str	r3, [r6, #0]
 80077ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80077bc:	200005f0 	.word	0x200005f0
 80077c0:	20000760 	.word	0x20000760
 80077c4:	20000148 	.word	0x20000148
 80077c8:	01000001 	.word	0x01000001
 80077cc:	20000764 	.word	0x20000764
 80077d0:	200002bc 	.word	0x200002bc
 80077d4:	20000230 	.word	0x20000230
 80077d8:	20000620 	.word	0x20000620

080077dc <BSP_ACCELERO_Sensor_Enable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  ACCELERO_Drv_t *driver = NULL;

  if(ctx == NULL)
 80077dc:	b160      	cbz	r0, 80077f8 <BSP_ACCELERO_Sensor_Enable+0x1c>
{
 80077de:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( ACCELERO_Drv_t * )ctx->pVTable;

  if ( driver->Sensor_Enable == NULL )
 80077e0:	68c3      	ldr	r3, [r0, #12]
 80077e2:	689b      	ldr	r3, [r3, #8]
 80077e4:	b133      	cbz	r3, 80077f4 <BSP_ACCELERO_Sensor_Enable+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Sensor_Enable( ctx ) == COMPONENT_ERROR )
 80077e6:	4798      	blx	r3
    return COMPONENT_ERROR;
 80077e8:	f1a0 0001 	sub.w	r0, r0, #1
 80077ec:	fab0 f080 	clz	r0, r0
 80077f0:	0940      	lsrs	r0, r0, #5
 80077f2:	bd08      	pop	{r3, pc}
 80077f4:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 80077f6:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 80077f8:	2001      	movs	r0, #1
 80077fa:	4770      	bx	lr

080077fc <BSP_ACCELERO_Sensor_Disable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  ACCELERO_Drv_t *driver = NULL;

  if(ctx == NULL)
 80077fc:	b160      	cbz	r0, 8007818 <BSP_ACCELERO_Sensor_Disable+0x1c>
{
 80077fe:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( ACCELERO_Drv_t * )ctx->pVTable;

  if ( driver->Sensor_Disable == NULL )
 8007800:	68c3      	ldr	r3, [r0, #12]
 8007802:	68db      	ldr	r3, [r3, #12]
 8007804:	b133      	cbz	r3, 8007814 <BSP_ACCELERO_Sensor_Disable+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Sensor_Disable( ctx ) == COMPONENT_ERROR )
 8007806:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007808:	f1a0 0001 	sub.w	r0, r0, #1
 800780c:	fab0 f080 	clz	r0, r0
 8007810:	0940      	lsrs	r0, r0, #5
 8007812:	bd08      	pop	{r3, pc}
 8007814:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007816:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007818:	2001      	movs	r0, #1
 800781a:	4770      	bx	lr

0800781c <BSP_ACCELERO_IsInitialized>:
 */
DrvStatusTypeDef BSP_ACCELERO_IsInitialized( void *handle, uint8_t *status )
{
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;

  if(ctx == NULL)
 800781c:	b120      	cbz	r0, 8007828 <BSP_ACCELERO_IsInitialized+0xc>
  {
    return COMPONENT_ERROR;
  }

  if ( status == NULL )
 800781e:	b119      	cbz	r1, 8007828 <BSP_ACCELERO_IsInitialized+0xc>
  {
    return COMPONENT_ERROR;
  }

  *status = ctx->isInitialized;
 8007820:	7943      	ldrb	r3, [r0, #5]
 8007822:	700b      	strb	r3, [r1, #0]

  return COMPONENT_OK;
 8007824:	2000      	movs	r0, #0
 8007826:	4770      	bx	lr
    return COMPONENT_ERROR;
 8007828:	2001      	movs	r0, #1
}
 800782a:	4770      	bx	lr

0800782c <BSP_ACCELERO_Get_Instance>:
 */
DrvStatusTypeDef BSP_ACCELERO_Get_Instance( void *handle, uint8_t *instance )
{
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;

  if(ctx == NULL)
 800782c:	b120      	cbz	r0, 8007838 <BSP_ACCELERO_Get_Instance+0xc>
  {
    return COMPONENT_ERROR;
  }

  if ( instance == NULL )
 800782e:	b119      	cbz	r1, 8007838 <BSP_ACCELERO_Get_Instance+0xc>
  {
    return COMPONENT_ERROR;
  }

  *instance = ctx->instance;
 8007830:	7903      	ldrb	r3, [r0, #4]
 8007832:	700b      	strb	r3, [r1, #0]

  return COMPONENT_OK;
 8007834:	2000      	movs	r0, #0
 8007836:	4770      	bx	lr
    return COMPONENT_ERROR;
 8007838:	2001      	movs	r0, #1
}
 800783a:	4770      	bx	lr

0800783c <BSP_ACCELERO_Get_Axes>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  ACCELERO_Drv_t *driver = NULL;

  if(ctx == NULL)
 800783c:	b168      	cbz	r0, 800785a <BSP_ACCELERO_Get_Axes+0x1e>
{
 800783e:	b508      	push	{r3, lr}
  {
    return COMPONENT_ERROR;
  }

  driver = ( ACCELERO_Drv_t * )ctx->pVTable;
 8007840:	68c2      	ldr	r2, [r0, #12]

  if(acceleration == NULL)
 8007842:	b141      	cbz	r1, 8007856 <BSP_ACCELERO_Get_Axes+0x1a>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Get_Axes == NULL )
 8007844:	6993      	ldr	r3, [r2, #24]
 8007846:	b133      	cbz	r3, 8007856 <BSP_ACCELERO_Get_Axes+0x1a>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Get_Axes( ctx, acceleration ) == COMPONENT_ERROR )
 8007848:	4798      	blx	r3
    return COMPONENT_ERROR;
 800784a:	f1a0 0001 	sub.w	r0, r0, #1
 800784e:	fab0 f080 	clz	r0, r0
 8007852:	0940      	lsrs	r0, r0, #5
 8007854:	bd08      	pop	{r3, pc}
 8007856:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007858:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800785a:	2001      	movs	r0, #1
 800785c:	4770      	bx	lr
 800785e:	bf00      	nop

08007860 <BSP_ACCELERO_Set_ODR_Value>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  ACCELERO_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007860:	b160      	cbz	r0, 800787c <BSP_ACCELERO_Set_ODR_Value+0x1c>
{
 8007862:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( ACCELERO_Drv_t * )ctx->pVTable;

  if ( driver->Set_ODR_Value == NULL )
 8007864:	68c3      	ldr	r3, [r0, #12]
 8007866:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007868:	b133      	cbz	r3, 8007878 <BSP_ACCELERO_Set_ODR_Value+0x18>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Set_ODR_Value( ctx, odr ) == COMPONENT_ERROR )
 800786a:	4798      	blx	r3
    return COMPONENT_ERROR;
 800786c:	f1a0 0001 	sub.w	r0, r0, #1
 8007870:	fab0 f080 	clz	r0, r0
 8007874:	0940      	lsrs	r0, r0, #5
 8007876:	bd08      	pop	{r3, pc}
 8007878:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 800787a:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800787c:	2001      	movs	r0, #1
 800787e:	4770      	bx	lr

08007880 <BSP_ACCELERO_Set_FS_Value>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  ACCELERO_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007880:	b160      	cbz	r0, 800789c <BSP_ACCELERO_Set_FS_Value+0x1c>
{
 8007882:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( ACCELERO_Drv_t * )ctx->pVTable;

  if ( driver->Set_FS_Value == NULL )
 8007884:	68c3      	ldr	r3, [r0, #12]
 8007886:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007888:	b133      	cbz	r3, 8007898 <BSP_ACCELERO_Set_FS_Value+0x18>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Set_FS_Value( ctx, fullScale ) == COMPONENT_ERROR )
 800788a:	4798      	blx	r3
    return COMPONENT_ERROR;
 800788c:	f1a0 0001 	sub.w	r0, r0, #1
 8007890:	fab0 f080 	clz	r0, r0
 8007894:	0940      	lsrs	r0, r0, #5
 8007896:	bd08      	pop	{r3, pc}
 8007898:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 800789a:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800789c:	2001      	movs	r0, #1
 800789e:	4770      	bx	lr

080078a0 <BSP_ACCELERO_Read_Reg>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  ACCELERO_Drv_t *driver = NULL;

  if(ctx == NULL)
 80078a0:	b168      	cbz	r0, 80078be <BSP_ACCELERO_Read_Reg+0x1e>
{
 80078a2:	b510      	push	{r4, lr}
  {
    return COMPONENT_ERROR;
  }

  driver = ( ACCELERO_Drv_t * )ctx->pVTable;
 80078a4:	68c4      	ldr	r4, [r0, #12]

  if(data == NULL)
 80078a6:	b142      	cbz	r2, 80078ba <BSP_ACCELERO_Read_Reg+0x1a>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Read_Reg == NULL )
 80078a8:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80078aa:	b133      	cbz	r3, 80078ba <BSP_ACCELERO_Read_Reg+0x1a>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Read_Reg( ctx, reg, data ) == COMPONENT_ERROR )
 80078ac:	4798      	blx	r3
    return COMPONENT_ERROR;
 80078ae:	f1a0 0001 	sub.w	r0, r0, #1
 80078b2:	fab0 f080 	clz	r0, r0
 80078b6:	0940      	lsrs	r0, r0, #5
 80078b8:	bd10      	pop	{r4, pc}
 80078ba:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 80078bc:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 80078be:	2001      	movs	r0, #1
 80078c0:	4770      	bx	lr
 80078c2:	bf00      	nop

080078c4 <BSP_ACCELERO_Write_Reg>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  ACCELERO_Drv_t *driver = NULL;

  if(ctx == NULL)
 80078c4:	b160      	cbz	r0, 80078e0 <BSP_ACCELERO_Write_Reg+0x1c>
{
 80078c6:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( ACCELERO_Drv_t * )ctx->pVTable;

  if ( driver->Write_Reg == NULL )
 80078c8:	68c3      	ldr	r3, [r0, #12]
 80078ca:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80078cc:	b133      	cbz	r3, 80078dc <BSP_ACCELERO_Write_Reg+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Write_Reg( ctx, reg, data ) == COMPONENT_ERROR )
 80078ce:	4798      	blx	r3
    return COMPONENT_ERROR;
 80078d0:	f1a0 0001 	sub.w	r0, r0, #1
 80078d4:	fab0 f080 	clz	r0, r0
 80078d8:	0940      	lsrs	r0, r0, #5
 80078da:	bd08      	pop	{r3, pc}
 80078dc:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 80078de:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 80078e0:	2001      	movs	r0, #1
 80078e2:	4770      	bx	lr

080078e4 <BSP_ACCELERO_Get_DRDY_Status>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  ACCELERO_Drv_t *driver = NULL;

  if(ctx == NULL)
 80078e4:	b160      	cbz	r0, 8007900 <BSP_ACCELERO_Get_DRDY_Status+0x1c>
{
 80078e6:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( ACCELERO_Drv_t * )ctx->pVTable;

  if ( driver->Get_DRDY_Status == NULL )
 80078e8:	68c3      	ldr	r3, [r0, #12]
 80078ea:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80078ec:	b133      	cbz	r3, 80078fc <BSP_ACCELERO_Get_DRDY_Status+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Get_DRDY_Status( ctx, status ) == COMPONENT_ERROR )
 80078ee:	4798      	blx	r3
    return COMPONENT_ERROR;
 80078f0:	f1a0 0001 	sub.w	r0, r0, #1
 80078f4:	fab0 f080 	clz	r0, r0
 80078f8:	0940      	lsrs	r0, r0, #5
 80078fa:	bd08      	pop	{r3, pc}
 80078fc:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 80078fe:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007900:	2001      	movs	r0, #1
 8007902:	4770      	bx	lr

08007904 <BSP_GYRO_Init>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
DrvStatusTypeDef BSP_GYRO_Init( GYRO_ID_t id, void **handle )
{
 8007904:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  *handle = NULL;
 8007906:	2600      	movs	r6, #0

static DrvStatusTypeDef BSP_LSM6DSL_GYRO_Init( void **handle )
{
  GYRO_Drv_t *driver = NULL;

  if(GYRO_SensorHandle[ LSM6DSL_G_0 ].isInitialized == 1)
 8007908:	4c37      	ldr	r4, [pc, #220]	; (80079e8 <BSP_GYRO_Init+0xe4>)
  *handle = NULL;
 800790a:	600e      	str	r6, [r1, #0]
{
 800790c:	460f      	mov	r7, r1
  if(GYRO_SensorHandle[ LSM6DSL_G_0 ].isInitialized == 1)
 800790e:	7963      	ldrb	r3, [r4, #5]
  switch(id)
 8007910:	b348      	cbz	r0, 8007966 <BSP_GYRO_Init+0x62>
  if(GYRO_SensorHandle[ LSM6DSL_G_0 ].isInitialized == 1)
 8007912:	2b01      	cmp	r3, #1
 8007914:	d029      	beq.n	800796a <BSP_GYRO_Init+0x66>
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
  }

  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 8007916:	f7ff fcf7 	bl	8007308 <Sensor_IO_Init>
 800791a:	2801      	cmp	r0, #1
 800791c:	d025      	beq.n	800796a <BSP_GYRO_Init+0x66>
  GYRO_SensorHandle[ LSM6DSL_G_0 ].isCombo       = 1;
  GYRO_SensorHandle[ LSM6DSL_G_0 ].pData         = ( void * )&GYRO_Data[ LSM6DSL_G_0 ];
  GYRO_SensorHandle[ LSM6DSL_G_0 ].pVTable       = ( void * )&LSM6DSL_G_Drv;
  GYRO_SensorHandle[ LSM6DSL_G_0 ].pExtVTable    = ( void * )&LSM6DSL_G_ExtDrv;

  LSM6DSL_G_0_Data.comboData = &LSM6DSL_Combo_Data[0];
 800791e:	4623      	mov	r3, r4
 8007920:	4a32      	ldr	r2, [pc, #200]	; (80079ec <BSP_GYRO_Init+0xe8>)
 8007922:	f843 2f1c 	str.w	r2, [r3, #28]!
  GYRO_SensorHandle[ LSM6DSL_G_0 ].who_am_i      = LSM6DSL_ACC_GYRO_WHO_AM_I;
 8007926:	f04f 0e6a 	mov.w	lr, #106	; 0x6a
  GYRO_Data[ LSM6DSL_G_0 ].pComponentData = ( void * )&LSM6DSL_G_0_Data;
 800792a:	6163      	str	r3, [r4, #20]
  GYRO_SensorHandle[ LSM6DSL_G_0 ].address       = LSM6DSL_ACC_GYRO_I2C_ADDRESS_HIGH;
 800792c:	25d6      	movs	r5, #214	; 0xd6
  GYRO_SensorHandle[ LSM6DSL_G_0 ].pExtVTable    = ( void * )&LSM6DSL_G_ExtDrv;
 800792e:	4b30      	ldr	r3, [pc, #192]	; (80079f0 <BSP_GYRO_Init+0xec>)
  GYRO_SensorHandle[ LSM6DSL_G_0 ].pVTable       = ( void * )&LSM6DSL_G_Drv;
 8007930:	4a30      	ldr	r2, [pc, #192]	; (80079f4 <BSP_GYRO_Init+0xf0>)
  GYRO_SensorHandle[ LSM6DSL_G_0 ].ifType        = 0; /* I2C interface */
 8007932:	7066      	strb	r6, [r4, #1]
  GYRO_SensorHandle[ LSM6DSL_G_0 ].instance      = LSM6DSL_G_0;
 8007934:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
  GYRO_SensorHandle[ LSM6DSL_G_0 ].pData         = ( void * )&GYRO_Data[ LSM6DSL_G_0 ];
 8007938:	f104 0114 	add.w	r1, r4, #20
  GYRO_SensorHandle[ LSM6DSL_G_0 ].who_am_i      = LSM6DSL_ACC_GYRO_WHO_AM_I;
 800793c:	f884 e000 	strb.w	lr, [r4]
  GYRO_SensorHandle[ LSM6DSL_G_0 ].address       = LSM6DSL_ACC_GYRO_I2C_ADDRESS_HIGH;
 8007940:	70a5      	strb	r5, [r4, #2]
  GYRO_SensorHandle[ LSM6DSL_G_0 ].instance      = LSM6DSL_G_0;
 8007942:	6060      	str	r0, [r4, #4]
  GYRO_SensorHandle[ LSM6DSL_G_0 ].pVTable       = ( void * )&LSM6DSL_G_Drv;
 8007944:	60e2      	str	r2, [r4, #12]
  GYRO_SensorHandle[ LSM6DSL_G_0 ].pExtVTable    = ( void * )&LSM6DSL_G_ExtDrv;
 8007946:	6123      	str	r3, [r4, #16]
  GYRO_Data[ LSM6DSL_G_0 ].pExtData       = 0;
 8007948:	61a6      	str	r6, [r4, #24]
  GYRO_SensorHandle[ LSM6DSL_G_0 ].pData         = ( void * )&GYRO_Data[ LSM6DSL_G_0 ];
 800794a:	60a1      	str	r1, [r4, #8]

  *handle = (void *)&GYRO_SensorHandle[ LSM6DSL_G_0 ];
 800794c:	603c      	str	r4, [r7, #0]

  driver = ( GYRO_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;

  if ( driver->Init == NULL )
 800794e:	68e3      	ldr	r3, [r4, #12]
 8007950:	681b      	ldr	r3, [r3, #0]
 8007952:	2b00      	cmp	r3, #0
 8007954:	d037      	beq.n	80079c6 <BSP_GYRO_Init+0xc2>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }

  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 8007956:	4620      	mov	r0, r4
 8007958:	4798      	blx	r3
 800795a:	2801      	cmp	r0, #1
 800795c:	d03c      	beq.n	80079d8 <BSP_GYRO_Init+0xd4>
    *handle = NULL;
    return COMPONENT_ERROR;
  }

  /* Configure interrupt lines for LSM6DSL */
  LSM6DSL_Sensor_IO_ITConfig();
 800795e:	f7ff fd37 	bl	80073d0 <LSM6DSL_Sensor_IO_ITConfig>
  return COMPONENT_OK;
 8007962:	2000      	movs	r0, #0
 8007964:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if(GYRO_SensorHandle[ LSM6DSL_G_0 ].isInitialized == 1)
 8007966:	2b01      	cmp	r3, #1
 8007968:	d101      	bne.n	800796e <BSP_GYRO_Init+0x6a>
        return COMPONENT_ERROR;
 800796a:	2001      	movs	r0, #1
 800796c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800796e:	4605      	mov	r5, r0
  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 8007970:	f7ff fcca 	bl	8007308 <Sensor_IO_Init>
 8007974:	2801      	cmp	r0, #1
 8007976:	d0f8      	beq.n	800796a <BSP_GYRO_Init+0x66>
  LSM6DSL_G_0_Data.comboData = &LSM6DSL_Combo_Data[0];
 8007978:	4623      	mov	r3, r4
 800797a:	4a1c      	ldr	r2, [pc, #112]	; (80079ec <BSP_GYRO_Init+0xe8>)
 800797c:	f843 2f1c 	str.w	r2, [r3, #28]!
  GYRO_SensorHandle[ LSM6DSL_G_0 ].who_am_i      = LSM6DSL_ACC_GYRO_WHO_AM_I;
 8007980:	f04f 0e6a 	mov.w	lr, #106	; 0x6a
  GYRO_Data[ LSM6DSL_G_0 ].pComponentData = ( void * )&LSM6DSL_G_0_Data;
 8007984:	6163      	str	r3, [r4, #20]
  GYRO_SensorHandle[ LSM6DSL_G_0 ].address       = LSM6DSL_ACC_GYRO_I2C_ADDRESS_HIGH;
 8007986:	26d6      	movs	r6, #214	; 0xd6
  GYRO_SensorHandle[ LSM6DSL_G_0 ].pExtVTable    = ( void * )&LSM6DSL_G_ExtDrv;
 8007988:	4b19      	ldr	r3, [pc, #100]	; (80079f0 <BSP_GYRO_Init+0xec>)
  GYRO_SensorHandle[ LSM6DSL_G_0 ].pVTable       = ( void * )&LSM6DSL_G_Drv;
 800798a:	4a1a      	ldr	r2, [pc, #104]	; (80079f4 <BSP_GYRO_Init+0xf0>)
  GYRO_SensorHandle[ LSM6DSL_G_0 ].ifType        = 0; /* I2C interface */
 800798c:	7065      	strb	r5, [r4, #1]
  GYRO_SensorHandle[ LSM6DSL_G_0 ].instance      = LSM6DSL_G_0;
 800798e:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
  GYRO_SensorHandle[ LSM6DSL_G_0 ].pData         = ( void * )&GYRO_Data[ LSM6DSL_G_0 ];
 8007992:	f104 0114 	add.w	r1, r4, #20
  GYRO_SensorHandle[ LSM6DSL_G_0 ].who_am_i      = LSM6DSL_ACC_GYRO_WHO_AM_I;
 8007996:	f884 e000 	strb.w	lr, [r4]
  GYRO_SensorHandle[ LSM6DSL_G_0 ].address       = LSM6DSL_ACC_GYRO_I2C_ADDRESS_HIGH;
 800799a:	70a6      	strb	r6, [r4, #2]
  GYRO_SensorHandle[ LSM6DSL_G_0 ].instance      = LSM6DSL_G_0;
 800799c:	6060      	str	r0, [r4, #4]
  GYRO_SensorHandle[ LSM6DSL_G_0 ].pVTable       = ( void * )&LSM6DSL_G_Drv;
 800799e:	60e2      	str	r2, [r4, #12]
  GYRO_SensorHandle[ LSM6DSL_G_0 ].pExtVTable    = ( void * )&LSM6DSL_G_ExtDrv;
 80079a0:	6123      	str	r3, [r4, #16]
  GYRO_Data[ LSM6DSL_G_0 ].pExtData       = 0;
 80079a2:	61a5      	str	r5, [r4, #24]
  GYRO_SensorHandle[ LSM6DSL_G_0 ].pData         = ( void * )&GYRO_Data[ LSM6DSL_G_0 ];
 80079a4:	60a1      	str	r1, [r4, #8]
  *handle = (void *)&GYRO_SensorHandle[ LSM6DSL_G_0 ];
 80079a6:	603c      	str	r4, [r7, #0]
  if ( driver->Init == NULL )
 80079a8:	68e3      	ldr	r3, [r4, #12]
 80079aa:	681b      	ldr	r3, [r3, #0]
 80079ac:	b15b      	cbz	r3, 80079c6 <BSP_GYRO_Init+0xc2>
  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 80079ae:	4620      	mov	r0, r4
 80079b0:	4798      	blx	r3
 80079b2:	2801      	cmp	r0, #1
 80079b4:	d1d3      	bne.n	800795e <BSP_GYRO_Init+0x5a>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 80079b6:	683b      	ldr	r3, [r7, #0]
 80079b8:	601d      	str	r5, [r3, #0]
 80079ba:	605d      	str	r5, [r3, #4]
 80079bc:	609d      	str	r5, [r3, #8]
 80079be:	60dd      	str	r5, [r3, #12]
 80079c0:	611d      	str	r5, [r3, #16]
    *handle = NULL;
 80079c2:	603d      	str	r5, [r7, #0]
}
 80079c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 80079c6:	2300      	movs	r3, #0
 80079c8:	6023      	str	r3, [r4, #0]
 80079ca:	6063      	str	r3, [r4, #4]
 80079cc:	60a3      	str	r3, [r4, #8]
 80079ce:	60e3      	str	r3, [r4, #12]
 80079d0:	6123      	str	r3, [r4, #16]
        return COMPONENT_ERROR;
 80079d2:	2001      	movs	r0, #1
    *handle = NULL;
 80079d4:	603b      	str	r3, [r7, #0]
 80079d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 80079d8:	683b      	ldr	r3, [r7, #0]
 80079da:	601e      	str	r6, [r3, #0]
 80079dc:	605e      	str	r6, [r3, #4]
 80079de:	609e      	str	r6, [r3, #8]
 80079e0:	60de      	str	r6, [r3, #12]
 80079e2:	611e      	str	r6, [r3, #16]
    *handle = NULL;
 80079e4:	603e      	str	r6, [r7, #0]
 80079e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80079e8:	20000638 	.word	0x20000638
 80079ec:	20000764 	.word	0x20000764
 80079f0:	20000280 	.word	0x20000280
 80079f4:	200001e0 	.word	0x200001e0

080079f8 <BSP_GYRO_Sensor_Enable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  GYRO_Drv_t *driver = NULL;

  if(ctx == NULL)
 80079f8:	b160      	cbz	r0, 8007a14 <BSP_GYRO_Sensor_Enable+0x1c>
{
 80079fa:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( GYRO_Drv_t * )ctx->pVTable;

  if ( driver->Sensor_Enable == NULL )
 80079fc:	68c3      	ldr	r3, [r0, #12]
 80079fe:	689b      	ldr	r3, [r3, #8]
 8007a00:	b133      	cbz	r3, 8007a10 <BSP_GYRO_Sensor_Enable+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Sensor_Enable( ctx ) == COMPONENT_ERROR )
 8007a02:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007a04:	f1a0 0001 	sub.w	r0, r0, #1
 8007a08:	fab0 f080 	clz	r0, r0
 8007a0c:	0940      	lsrs	r0, r0, #5
 8007a0e:	bd08      	pop	{r3, pc}
 8007a10:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007a12:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007a14:	2001      	movs	r0, #1
 8007a16:	4770      	bx	lr

08007a18 <BSP_GYRO_Sensor_Disable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  GYRO_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007a18:	b160      	cbz	r0, 8007a34 <BSP_GYRO_Sensor_Disable+0x1c>
{
 8007a1a:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( GYRO_Drv_t * )ctx->pVTable;

  if ( driver->Sensor_Disable == NULL )
 8007a1c:	68c3      	ldr	r3, [r0, #12]
 8007a1e:	68db      	ldr	r3, [r3, #12]
 8007a20:	b133      	cbz	r3, 8007a30 <BSP_GYRO_Sensor_Disable+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Sensor_Disable( ctx ) == COMPONENT_ERROR )
 8007a22:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007a24:	f1a0 0001 	sub.w	r0, r0, #1
 8007a28:	fab0 f080 	clz	r0, r0
 8007a2c:	0940      	lsrs	r0, r0, #5
 8007a2e:	bd08      	pop	{r3, pc}
 8007a30:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007a32:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007a34:	2001      	movs	r0, #1
 8007a36:	4770      	bx	lr

08007a38 <BSP_GYRO_IsInitialized>:
 */
DrvStatusTypeDef BSP_GYRO_IsInitialized( void *handle, uint8_t *status )
{
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;

  if(ctx == NULL)
 8007a38:	b120      	cbz	r0, 8007a44 <BSP_GYRO_IsInitialized+0xc>
  {
    return COMPONENT_ERROR;
  }

  if ( status == NULL )
 8007a3a:	b119      	cbz	r1, 8007a44 <BSP_GYRO_IsInitialized+0xc>
  {
    return COMPONENT_ERROR;
  }

  *status = ctx->isInitialized;
 8007a3c:	7943      	ldrb	r3, [r0, #5]
 8007a3e:	700b      	strb	r3, [r1, #0]

  return COMPONENT_OK;
 8007a40:	2000      	movs	r0, #0
 8007a42:	4770      	bx	lr
    return COMPONENT_ERROR;
 8007a44:	2001      	movs	r0, #1
}
 8007a46:	4770      	bx	lr

08007a48 <BSP_GYRO_Get_Instance>:
 */
DrvStatusTypeDef BSP_GYRO_Get_Instance( void *handle, uint8_t *instance )
{
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;

  if(ctx == NULL)
 8007a48:	b120      	cbz	r0, 8007a54 <BSP_GYRO_Get_Instance+0xc>
  {
    return COMPONENT_ERROR;
  }

  if ( instance == NULL )
 8007a4a:	b119      	cbz	r1, 8007a54 <BSP_GYRO_Get_Instance+0xc>
  {
    return COMPONENT_ERROR;
  }

  *instance = ctx->instance;
 8007a4c:	7903      	ldrb	r3, [r0, #4]
 8007a4e:	700b      	strb	r3, [r1, #0]

  return COMPONENT_OK;
 8007a50:	2000      	movs	r0, #0
 8007a52:	4770      	bx	lr
    return COMPONENT_ERROR;
 8007a54:	2001      	movs	r0, #1
}
 8007a56:	4770      	bx	lr

08007a58 <BSP_GYRO_Get_Axes>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  GYRO_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007a58:	b168      	cbz	r0, 8007a76 <BSP_GYRO_Get_Axes+0x1e>
{
 8007a5a:	b508      	push	{r3, lr}
  {
    return COMPONENT_ERROR;
  }

  driver = ( GYRO_Drv_t * )ctx->pVTable;
 8007a5c:	68c2      	ldr	r2, [r0, #12]

  if ( angular_velocity == NULL )
 8007a5e:	b141      	cbz	r1, 8007a72 <BSP_GYRO_Get_Axes+0x1a>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Axes == NULL )
 8007a60:	6993      	ldr	r3, [r2, #24]
 8007a62:	b133      	cbz	r3, 8007a72 <BSP_GYRO_Get_Axes+0x1a>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Axes( ctx, angular_velocity ) == COMPONENT_ERROR )
 8007a64:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007a66:	f1a0 0001 	sub.w	r0, r0, #1
 8007a6a:	fab0 f080 	clz	r0, r0
 8007a6e:	0940      	lsrs	r0, r0, #5
 8007a70:	bd08      	pop	{r3, pc}
 8007a72:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007a74:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007a76:	2001      	movs	r0, #1
 8007a78:	4770      	bx	lr
 8007a7a:	bf00      	nop

08007a7c <BSP_GYRO_Set_ODR_Value>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  GYRO_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007a7c:	b160      	cbz	r0, 8007a98 <BSP_GYRO_Set_ODR_Value+0x1c>
{
 8007a7e:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( GYRO_Drv_t * )ctx->pVTable;

  if ( driver->Set_ODR_Value == NULL )
 8007a80:	68c3      	ldr	r3, [r0, #12]
 8007a82:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007a84:	b133      	cbz	r3, 8007a94 <BSP_GYRO_Set_ODR_Value+0x18>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Set_ODR_Value( ctx, odr ) == COMPONENT_ERROR )
 8007a86:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007a88:	f1a0 0001 	sub.w	r0, r0, #1
 8007a8c:	fab0 f080 	clz	r0, r0
 8007a90:	0940      	lsrs	r0, r0, #5
 8007a92:	bd08      	pop	{r3, pc}
 8007a94:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007a96:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007a98:	2001      	movs	r0, #1
 8007a9a:	4770      	bx	lr

08007a9c <BSP_GYRO_Set_FS_Value>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  GYRO_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007a9c:	b160      	cbz	r0, 8007ab8 <BSP_GYRO_Set_FS_Value+0x1c>
{
 8007a9e:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( GYRO_Drv_t * )ctx->pVTable;

  if ( driver->Set_FS_Value == NULL )
 8007aa0:	68c3      	ldr	r3, [r0, #12]
 8007aa2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007aa4:	b133      	cbz	r3, 8007ab4 <BSP_GYRO_Set_FS_Value+0x18>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Set_FS_Value( ctx, fullScale ) == COMPONENT_ERROR )
 8007aa6:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007aa8:	f1a0 0001 	sub.w	r0, r0, #1
 8007aac:	fab0 f080 	clz	r0, r0
 8007ab0:	0940      	lsrs	r0, r0, #5
 8007ab2:	bd08      	pop	{r3, pc}
 8007ab4:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007ab6:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007ab8:	2001      	movs	r0, #1
 8007aba:	4770      	bx	lr

08007abc <BSP_GYRO_Read_Reg>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  GYRO_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007abc:	b168      	cbz	r0, 8007ada <BSP_GYRO_Read_Reg+0x1e>
{
 8007abe:	b510      	push	{r4, lr}
  {
    return COMPONENT_ERROR;
  }

  driver = ( GYRO_Drv_t * )ctx->pVTable;
 8007ac0:	68c4      	ldr	r4, [r0, #12]

  if(data == NULL)
 8007ac2:	b142      	cbz	r2, 8007ad6 <BSP_GYRO_Read_Reg+0x1a>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Read_Reg == NULL )
 8007ac4:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007ac6:	b133      	cbz	r3, 8007ad6 <BSP_GYRO_Read_Reg+0x1a>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Read_Reg( ctx, reg, data ) == COMPONENT_ERROR )
 8007ac8:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007aca:	f1a0 0001 	sub.w	r0, r0, #1
 8007ace:	fab0 f080 	clz	r0, r0
 8007ad2:	0940      	lsrs	r0, r0, #5
 8007ad4:	bd10      	pop	{r4, pc}
 8007ad6:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007ad8:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 8007ada:	2001      	movs	r0, #1
 8007adc:	4770      	bx	lr
 8007ade:	bf00      	nop

08007ae0 <BSP_GYRO_Write_Reg>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  GYRO_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007ae0:	b160      	cbz	r0, 8007afc <BSP_GYRO_Write_Reg+0x1c>
{
 8007ae2:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( GYRO_Drv_t * )ctx->pVTable;

  if ( driver->Write_Reg == NULL )
 8007ae4:	68c3      	ldr	r3, [r0, #12]
 8007ae6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8007ae8:	b133      	cbz	r3, 8007af8 <BSP_GYRO_Write_Reg+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Write_Reg( ctx, reg, data ) == COMPONENT_ERROR )
 8007aea:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007aec:	f1a0 0001 	sub.w	r0, r0, #1
 8007af0:	fab0 f080 	clz	r0, r0
 8007af4:	0940      	lsrs	r0, r0, #5
 8007af6:	bd08      	pop	{r3, pc}
 8007af8:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007afa:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007afc:	2001      	movs	r0, #1
 8007afe:	4770      	bx	lr

08007b00 <BSP_GYRO_Get_DRDY_Status>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  GYRO_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007b00:	b160      	cbz	r0, 8007b1c <BSP_GYRO_Get_DRDY_Status+0x1c>
{
 8007b02:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( GYRO_Drv_t * )ctx->pVTable;

  if ( driver->Get_DRDY_Status == NULL )
 8007b04:	68c3      	ldr	r3, [r0, #12]
 8007b06:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8007b08:	b133      	cbz	r3, 8007b18 <BSP_GYRO_Get_DRDY_Status+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Get_DRDY_Status( ctx, status ) == COMPONENT_ERROR )
 8007b0a:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007b0c:	f1a0 0001 	sub.w	r0, r0, #1
 8007b10:	fab0 f080 	clz	r0, r0
 8007b14:	0940      	lsrs	r0, r0, #5
 8007b16:	bd08      	pop	{r3, pc}
 8007b18:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007b1a:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007b1c:	2001      	movs	r0, #1
 8007b1e:	4770      	bx	lr

08007b20 <BSP_HUMIDITY_Init>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
DrvStatusTypeDef BSP_HUMIDITY_Init( HUMIDITY_ID_t id, void **handle )
{
 8007b20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  *handle = NULL;
 8007b22:	2600      	movs	r6, #0

static DrvStatusTypeDef BSP_HTS221_HUMIDITY_Init( void **handle )
{
  HUMIDITY_Drv_t *driver = NULL;

  if(HUMIDITY_SensorHandle[ HTS221_H_0 ].isInitialized == 1)
 8007b24:	4c33      	ldr	r4, [pc, #204]	; (8007bf4 <BSP_HUMIDITY_Init+0xd4>)
  *handle = NULL;
 8007b26:	600e      	str	r6, [r1, #0]
{
 8007b28:	460f      	mov	r7, r1
  if(HUMIDITY_SensorHandle[ HTS221_H_0 ].isInitialized == 1)
 8007b2a:	7963      	ldrb	r3, [r4, #5]
  switch(id)
 8007b2c:	b320      	cbz	r0, 8007b78 <BSP_HUMIDITY_Init+0x58>
  if(HUMIDITY_SensorHandle[ HTS221_H_0 ].isInitialized == 1)
 8007b2e:	2b01      	cmp	r3, #1
 8007b30:	d024      	beq.n	8007b7c <BSP_HUMIDITY_Init+0x5c>
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
  }

  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 8007b32:	f7ff fbe9 	bl	8007308 <Sensor_IO_Init>
 8007b36:	2801      	cmp	r0, #1
 8007b38:	d020      	beq.n	8007b7c <BSP_HUMIDITY_Init+0x5c>
  HUMIDITY_SensorHandle[ HTS221_H_0 ].isCombo       = 1;
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pData         = ( void * )&HUMIDITY_Data[ HTS221_H_0 ];
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pVTable       = ( void * )&HTS221_H_Drv;
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pExtVTable    = 0;

  HTS221_H_0_Data.comboData = &HTS221_Combo_Data[0];
 8007b3a:	4623      	mov	r3, r4
 8007b3c:	4a2e      	ldr	r2, [pc, #184]	; (8007bf8 <BSP_HUMIDITY_Init+0xd8>)
 8007b3e:	f843 2f1c 	str.w	r2, [r3, #28]!
  HUMIDITY_SensorHandle[ HTS221_H_0 ].who_am_i      = HTS221_WHO_AM_I_VAL;
 8007b42:	25bc      	movs	r5, #188	; 0xbc
  HUMIDITY_Data[ HTS221_H_0 ].pComponentData = ( void * )&HTS221_H_0_Data;
 8007b44:	6163      	str	r3, [r4, #20]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].address       = HTS221_ADDRESS_DEFAULT;
 8007b46:	20be      	movs	r0, #190	; 0xbe
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pVTable       = ( void * )&HTS221_H_Drv;
 8007b48:	4b2c      	ldr	r3, [pc, #176]	; (8007bfc <BSP_HUMIDITY_Init+0xdc>)
  HUMIDITY_SensorHandle[ HTS221_H_0 ].ifType        = 0; /* I2C interface */
 8007b4a:	7066      	strb	r6, [r4, #1]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].instance      = HTS221_H_0;
 8007b4c:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pData         = ( void * )&HUMIDITY_Data[ HTS221_H_0 ];
 8007b50:	f104 0214 	add.w	r2, r4, #20
  HUMIDITY_SensorHandle[ HTS221_H_0 ].who_am_i      = HTS221_WHO_AM_I_VAL;
 8007b54:	7025      	strb	r5, [r4, #0]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].address       = HTS221_ADDRESS_DEFAULT;
 8007b56:	70a0      	strb	r0, [r4, #2]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].instance      = HTS221_H_0;
 8007b58:	6061      	str	r1, [r4, #4]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pVTable       = ( void * )&HTS221_H_Drv;
 8007b5a:	60e3      	str	r3, [r4, #12]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pExtVTable    = 0;
 8007b5c:	6126      	str	r6, [r4, #16]
  HUMIDITY_Data[ HTS221_H_0 ].pExtData       = 0;
 8007b5e:	61a6      	str	r6, [r4, #24]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pData         = ( void * )&HUMIDITY_Data[ HTS221_H_0 ];
 8007b60:	60a2      	str	r2, [r4, #8]

  *handle = (void *)&HUMIDITY_SensorHandle[ HTS221_H_0 ];
 8007b62:	603c      	str	r4, [r7, #0]

  driver = ( HUMIDITY_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;

  if ( driver->Init == NULL )
 8007b64:	68e3      	ldr	r3, [r4, #12]
 8007b66:	681b      	ldr	r3, [r3, #0]
 8007b68:	2b00      	cmp	r3, #0
 8007b6a:	d032      	beq.n	8007bd2 <BSP_HUMIDITY_Init+0xb2>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }

  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 8007b6c:	4620      	mov	r0, r4
 8007b6e:	4798      	blx	r3
 8007b70:	2801      	cmp	r0, #1
 8007b72:	d037      	beq.n	8007be4 <BSP_HUMIDITY_Init+0xc4>
  return COMPONENT_OK;
 8007b74:	2000      	movs	r0, #0
 8007b76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if(HUMIDITY_SensorHandle[ HTS221_H_0 ].isInitialized == 1)
 8007b78:	2b01      	cmp	r3, #1
 8007b7a:	d101      	bne.n	8007b80 <BSP_HUMIDITY_Init+0x60>
        return COMPONENT_ERROR;
 8007b7c:	2001      	movs	r0, #1
 8007b7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007b80:	4605      	mov	r5, r0
  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 8007b82:	f7ff fbc1 	bl	8007308 <Sensor_IO_Init>
 8007b86:	2801      	cmp	r0, #1
 8007b88:	d0f8      	beq.n	8007b7c <BSP_HUMIDITY_Init+0x5c>
  HTS221_H_0_Data.comboData = &HTS221_Combo_Data[0];
 8007b8a:	4623      	mov	r3, r4
 8007b8c:	4a1a      	ldr	r2, [pc, #104]	; (8007bf8 <BSP_HUMIDITY_Init+0xd8>)
 8007b8e:	f843 2f1c 	str.w	r2, [r3, #28]!
  HUMIDITY_SensorHandle[ HTS221_H_0 ].who_am_i      = HTS221_WHO_AM_I_VAL;
 8007b92:	26bc      	movs	r6, #188	; 0xbc
  HUMIDITY_Data[ HTS221_H_0 ].pComponentData = ( void * )&HTS221_H_0_Data;
 8007b94:	6163      	str	r3, [r4, #20]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].address       = HTS221_ADDRESS_DEFAULT;
 8007b96:	20be      	movs	r0, #190	; 0xbe
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pVTable       = ( void * )&HTS221_H_Drv;
 8007b98:	4b18      	ldr	r3, [pc, #96]	; (8007bfc <BSP_HUMIDITY_Init+0xdc>)
  HUMIDITY_SensorHandle[ HTS221_H_0 ].ifType        = 0; /* I2C interface */
 8007b9a:	7065      	strb	r5, [r4, #1]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].instance      = HTS221_H_0;
 8007b9c:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pData         = ( void * )&HUMIDITY_Data[ HTS221_H_0 ];
 8007ba0:	f104 0214 	add.w	r2, r4, #20
  HUMIDITY_SensorHandle[ HTS221_H_0 ].who_am_i      = HTS221_WHO_AM_I_VAL;
 8007ba4:	7026      	strb	r6, [r4, #0]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].address       = HTS221_ADDRESS_DEFAULT;
 8007ba6:	70a0      	strb	r0, [r4, #2]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].instance      = HTS221_H_0;
 8007ba8:	6061      	str	r1, [r4, #4]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pVTable       = ( void * )&HTS221_H_Drv;
 8007baa:	60e3      	str	r3, [r4, #12]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pExtVTable    = 0;
 8007bac:	6125      	str	r5, [r4, #16]
  HUMIDITY_Data[ HTS221_H_0 ].pExtData       = 0;
 8007bae:	61a5      	str	r5, [r4, #24]
  HUMIDITY_SensorHandle[ HTS221_H_0 ].pData         = ( void * )&HUMIDITY_Data[ HTS221_H_0 ];
 8007bb0:	60a2      	str	r2, [r4, #8]
  *handle = (void *)&HUMIDITY_SensorHandle[ HTS221_H_0 ];
 8007bb2:	603c      	str	r4, [r7, #0]
  if ( driver->Init == NULL )
 8007bb4:	68e3      	ldr	r3, [r4, #12]
 8007bb6:	681b      	ldr	r3, [r3, #0]
 8007bb8:	b15b      	cbz	r3, 8007bd2 <BSP_HUMIDITY_Init+0xb2>
  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 8007bba:	4620      	mov	r0, r4
 8007bbc:	4798      	blx	r3
 8007bbe:	2801      	cmp	r0, #1
 8007bc0:	d1d8      	bne.n	8007b74 <BSP_HUMIDITY_Init+0x54>
  {
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8007bc2:	683b      	ldr	r3, [r7, #0]
 8007bc4:	601d      	str	r5, [r3, #0]
 8007bc6:	605d      	str	r5, [r3, #4]
 8007bc8:	609d      	str	r5, [r3, #8]
 8007bca:	60dd      	str	r5, [r3, #12]
 8007bcc:	611d      	str	r5, [r3, #16]
    *handle = NULL;
 8007bce:	603d      	str	r5, [r7, #0]
}
 8007bd0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8007bd2:	2300      	movs	r3, #0
 8007bd4:	6023      	str	r3, [r4, #0]
 8007bd6:	6063      	str	r3, [r4, #4]
 8007bd8:	60a3      	str	r3, [r4, #8]
 8007bda:	60e3      	str	r3, [r4, #12]
 8007bdc:	6123      	str	r3, [r4, #16]
        return COMPONENT_ERROR;
 8007bde:	2001      	movs	r0, #1
    *handle = NULL;
 8007be0:	603b      	str	r3, [r7, #0]
 8007be2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8007be4:	683b      	ldr	r3, [r7, #0]
 8007be6:	601e      	str	r6, [r3, #0]
 8007be8:	605e      	str	r6, [r3, #4]
 8007bea:	609e      	str	r6, [r3, #8]
 8007bec:	60de      	str	r6, [r3, #12]
 8007bee:	611e      	str	r6, [r3, #16]
    *handle = NULL;
 8007bf0:	603e      	str	r6, [r7, #0]
 8007bf2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007bf4:	2000065c 	.word	0x2000065c
 8007bf8:	20000754 	.word	0x20000754
 8007bfc:	20000034 	.word	0x20000034

08007c00 <BSP_HUMIDITY_Sensor_Enable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  HUMIDITY_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007c00:	b160      	cbz	r0, 8007c1c <BSP_HUMIDITY_Sensor_Enable+0x1c>
{
 8007c02:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( HUMIDITY_Drv_t * )ctx->pVTable;

  if ( driver->Sensor_Enable == NULL )
 8007c04:	68c3      	ldr	r3, [r0, #12]
 8007c06:	689b      	ldr	r3, [r3, #8]
 8007c08:	b133      	cbz	r3, 8007c18 <BSP_HUMIDITY_Sensor_Enable+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Sensor_Enable( ctx ) == COMPONENT_ERROR )
 8007c0a:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007c0c:	f1a0 0001 	sub.w	r0, r0, #1
 8007c10:	fab0 f080 	clz	r0, r0
 8007c14:	0940      	lsrs	r0, r0, #5
 8007c16:	bd08      	pop	{r3, pc}
 8007c18:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007c1a:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007c1c:	2001      	movs	r0, #1
 8007c1e:	4770      	bx	lr

08007c20 <BSP_HUMIDITY_Sensor_Disable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  HUMIDITY_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007c20:	b160      	cbz	r0, 8007c3c <BSP_HUMIDITY_Sensor_Disable+0x1c>
{
 8007c22:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( HUMIDITY_Drv_t * )ctx->pVTable;

  if ( driver->Sensor_Disable == NULL )
 8007c24:	68c3      	ldr	r3, [r0, #12]
 8007c26:	68db      	ldr	r3, [r3, #12]
 8007c28:	b133      	cbz	r3, 8007c38 <BSP_HUMIDITY_Sensor_Disable+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Sensor_Disable( ctx ) == COMPONENT_ERROR )
 8007c2a:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007c2c:	f1a0 0001 	sub.w	r0, r0, #1
 8007c30:	fab0 f080 	clz	r0, r0
 8007c34:	0940      	lsrs	r0, r0, #5
 8007c36:	bd08      	pop	{r3, pc}
 8007c38:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007c3a:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007c3c:	2001      	movs	r0, #1
 8007c3e:	4770      	bx	lr

08007c40 <BSP_HUMIDITY_IsInitialized>:
 */
DrvStatusTypeDef BSP_HUMIDITY_IsInitialized( void *handle, uint8_t *status )
{
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;

  if(ctx == NULL)
 8007c40:	b120      	cbz	r0, 8007c4c <BSP_HUMIDITY_IsInitialized+0xc>
  {
    return COMPONENT_ERROR;
  }

  if ( status == NULL )
 8007c42:	b119      	cbz	r1, 8007c4c <BSP_HUMIDITY_IsInitialized+0xc>
  {
    return COMPONENT_ERROR;
  }

  *status = ctx->isInitialized;
 8007c44:	7943      	ldrb	r3, [r0, #5]
 8007c46:	700b      	strb	r3, [r1, #0]

  return COMPONENT_OK;
 8007c48:	2000      	movs	r0, #0
 8007c4a:	4770      	bx	lr
    return COMPONENT_ERROR;
 8007c4c:	2001      	movs	r0, #1
}
 8007c4e:	4770      	bx	lr

08007c50 <BSP_HUMIDITY_Get_Instance>:
 */
DrvStatusTypeDef BSP_HUMIDITY_Get_Instance( void *handle, uint8_t *instance )
{
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;

  if(ctx == NULL)
 8007c50:	b120      	cbz	r0, 8007c5c <BSP_HUMIDITY_Get_Instance+0xc>
  {
    return COMPONENT_ERROR;
  }

  if ( instance == NULL )
 8007c52:	b119      	cbz	r1, 8007c5c <BSP_HUMIDITY_Get_Instance+0xc>
  {
    return COMPONENT_ERROR;
  }

  *instance = ctx->instance;
 8007c54:	7903      	ldrb	r3, [r0, #4]
 8007c56:	700b      	strb	r3, [r1, #0]

  return COMPONENT_OK;
 8007c58:	2000      	movs	r0, #0
 8007c5a:	4770      	bx	lr
    return COMPONENT_ERROR;
 8007c5c:	2001      	movs	r0, #1
}
 8007c5e:	4770      	bx	lr

08007c60 <BSP_HUMIDITY_Get_Hum>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  HUMIDITY_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007c60:	b168      	cbz	r0, 8007c7e <BSP_HUMIDITY_Get_Hum+0x1e>
{
 8007c62:	b508      	push	{r3, lr}
  {
    return COMPONENT_ERROR;
  }

  driver = ( HUMIDITY_Drv_t * )ctx->pVTable;
 8007c64:	68c2      	ldr	r2, [r0, #12]

  if ( humidity == NULL )
 8007c66:	b141      	cbz	r1, 8007c7a <BSP_HUMIDITY_Get_Hum+0x1a>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Hum == NULL )
 8007c68:	6993      	ldr	r3, [r2, #24]
 8007c6a:	b133      	cbz	r3, 8007c7a <BSP_HUMIDITY_Get_Hum+0x1a>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Hum( ctx, humidity ) == COMPONENT_ERROR )
 8007c6c:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007c6e:	f1a0 0001 	sub.w	r0, r0, #1
 8007c72:	fab0 f080 	clz	r0, r0
 8007c76:	0940      	lsrs	r0, r0, #5
 8007c78:	bd08      	pop	{r3, pc}
 8007c7a:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007c7c:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007c7e:	2001      	movs	r0, #1
 8007c80:	4770      	bx	lr
 8007c82:	bf00      	nop

08007c84 <BSP_HUMIDITY_Set_ODR_Value>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  HUMIDITY_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007c84:	b160      	cbz	r0, 8007ca0 <BSP_HUMIDITY_Set_ODR_Value+0x1c>
{
 8007c86:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( HUMIDITY_Drv_t * )ctx->pVTable;

  if ( driver->Set_ODR_Value == NULL )
 8007c88:	68c3      	ldr	r3, [r0, #12]
 8007c8a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007c8c:	b133      	cbz	r3, 8007c9c <BSP_HUMIDITY_Set_ODR_Value+0x18>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Set_ODR_Value( ctx, odr ) == COMPONENT_ERROR )
 8007c8e:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007c90:	f1a0 0001 	sub.w	r0, r0, #1
 8007c94:	fab0 f080 	clz	r0, r0
 8007c98:	0940      	lsrs	r0, r0, #5
 8007c9a:	bd08      	pop	{r3, pc}
 8007c9c:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007c9e:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007ca0:	2001      	movs	r0, #1
 8007ca2:	4770      	bx	lr

08007ca4 <BSP_HUMIDITY_Read_Reg>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  HUMIDITY_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007ca4:	b168      	cbz	r0, 8007cc2 <BSP_HUMIDITY_Read_Reg+0x1e>
{
 8007ca6:	b510      	push	{r4, lr}
  {
    return COMPONENT_ERROR;
  }

  driver = ( HUMIDITY_Drv_t * )ctx->pVTable;
 8007ca8:	68c4      	ldr	r4, [r0, #12]

  if(data == NULL)
 8007caa:	b142      	cbz	r2, 8007cbe <BSP_HUMIDITY_Read_Reg+0x1a>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Read_Reg == NULL )
 8007cac:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007cae:	b133      	cbz	r3, 8007cbe <BSP_HUMIDITY_Read_Reg+0x1a>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Read_Reg( ctx, reg, data ) == COMPONENT_ERROR )
 8007cb0:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007cb2:	f1a0 0001 	sub.w	r0, r0, #1
 8007cb6:	fab0 f080 	clz	r0, r0
 8007cba:	0940      	lsrs	r0, r0, #5
 8007cbc:	bd10      	pop	{r4, pc}
 8007cbe:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007cc0:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 8007cc2:	2001      	movs	r0, #1
 8007cc4:	4770      	bx	lr
 8007cc6:	bf00      	nop

08007cc8 <BSP_HUMIDITY_Write_Reg>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  HUMIDITY_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007cc8:	b160      	cbz	r0, 8007ce4 <BSP_HUMIDITY_Write_Reg+0x1c>
{
 8007cca:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( HUMIDITY_Drv_t * )ctx->pVTable;

  if ( driver->Write_Reg == NULL )
 8007ccc:	68c3      	ldr	r3, [r0, #12]
 8007cce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007cd0:	b133      	cbz	r3, 8007ce0 <BSP_HUMIDITY_Write_Reg+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Write_Reg( ctx, reg, data ) == COMPONENT_ERROR )
 8007cd2:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007cd4:	f1a0 0001 	sub.w	r0, r0, #1
 8007cd8:	fab0 f080 	clz	r0, r0
 8007cdc:	0940      	lsrs	r0, r0, #5
 8007cde:	bd08      	pop	{r3, pc}
 8007ce0:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007ce2:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007ce4:	2001      	movs	r0, #1
 8007ce6:	4770      	bx	lr

08007ce8 <BSP_HUMIDITY_Get_DRDY_Status>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  HUMIDITY_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007ce8:	b160      	cbz	r0, 8007d04 <BSP_HUMIDITY_Get_DRDY_Status+0x1c>
{
 8007cea:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( HUMIDITY_Drv_t * )ctx->pVTable;

  if ( driver->Get_DRDY_Status == NULL )
 8007cec:	68c3      	ldr	r3, [r0, #12]
 8007cee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007cf0:	b133      	cbz	r3, 8007d00 <BSP_HUMIDITY_Get_DRDY_Status+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Get_DRDY_Status( ctx, status ) == COMPONENT_ERROR )
 8007cf2:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007cf4:	f1a0 0001 	sub.w	r0, r0, #1
 8007cf8:	fab0 f080 	clz	r0, r0
 8007cfc:	0940      	lsrs	r0, r0, #5
 8007cfe:	bd08      	pop	{r3, pc}
 8007d00:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007d02:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007d04:	2001      	movs	r0, #1
 8007d06:	4770      	bx	lr

08007d08 <BSP_MAGNETO_Init>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
DrvStatusTypeDef BSP_MAGNETO_Init( MAGNETO_ID_t id, void **handle )
{
 8007d08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  *handle = NULL;
 8007d0a:	2600      	movs	r6, #0

static DrvStatusTypeDef BSP_LSM303AGR_MAGNETO_Init( void **handle )
{
  MAGNETO_Drv_t *driver = NULL;

  if(MAGNETO_SensorHandle[ LSM303AGR_M_0 ].isInitialized == 1)
 8007d0c:	4c33      	ldr	r4, [pc, #204]	; (8007ddc <BSP_MAGNETO_Init+0xd4>)
  *handle = NULL;
 8007d0e:	600e      	str	r6, [r1, #0]
{
 8007d10:	460f      	mov	r7, r1
  if(MAGNETO_SensorHandle[ LSM303AGR_M_0 ].isInitialized == 1)
 8007d12:	7963      	ldrb	r3, [r4, #5]
  switch(id)
 8007d14:	b320      	cbz	r0, 8007d60 <BSP_MAGNETO_Init+0x58>
  if(MAGNETO_SensorHandle[ LSM303AGR_M_0 ].isInitialized == 1)
 8007d16:	2b01      	cmp	r3, #1
 8007d18:	d024      	beq.n	8007d64 <BSP_MAGNETO_Init+0x5c>
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
  }

  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 8007d1a:	f7ff faf5 	bl	8007308 <Sensor_IO_Init>
 8007d1e:	2801      	cmp	r0, #1
 8007d20:	d020      	beq.n	8007d64 <BSP_MAGNETO_Init+0x5c>
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].isCombo       = 1;
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pData         = ( void * )&MAGNETO_Data[ LSM303AGR_M_0 ];
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pVTable       = ( void * )&LSM303AGR_M_Drv;
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pExtVTable    = 0;

  LSM303AGR_M_0_Data.comboData = &LSM303AGR_Combo_Data[0];
 8007d22:	4623      	mov	r3, r4
 8007d24:	4a2e      	ldr	r2, [pc, #184]	; (8007de0 <BSP_MAGNETO_Init+0xd8>)
 8007d26:	f843 2f1c 	str.w	r2, [r3, #28]!
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].who_am_i      = LSM303AGR_MAG_WHO_AM_I;
 8007d2a:	2540      	movs	r5, #64	; 0x40
  MAGNETO_Data[ LSM303AGR_M_0 ].pComponentData = ( void * )&LSM303AGR_M_0_Data;
 8007d2c:	6163      	str	r3, [r4, #20]
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].address       = LSM303AGR_MAG_I2C_ADDRESS;
 8007d2e:	203c      	movs	r0, #60	; 0x3c
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pVTable       = ( void * )&LSM303AGR_M_Drv;
 8007d30:	4b2c      	ldr	r3, [pc, #176]	; (8007de4 <BSP_MAGNETO_Init+0xdc>)
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].ifType        = 0; /* I2C interface */
 8007d32:	7066      	strb	r6, [r4, #1]
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].instance      = LSM303AGR_M_0;
 8007d34:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pData         = ( void * )&MAGNETO_Data[ LSM303AGR_M_0 ];
 8007d38:	f104 0214 	add.w	r2, r4, #20
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].who_am_i      = LSM303AGR_MAG_WHO_AM_I;
 8007d3c:	7025      	strb	r5, [r4, #0]
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].address       = LSM303AGR_MAG_I2C_ADDRESS;
 8007d3e:	70a0      	strb	r0, [r4, #2]
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].instance      = LSM303AGR_M_0;
 8007d40:	6061      	str	r1, [r4, #4]
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pVTable       = ( void * )&LSM303AGR_M_Drv;
 8007d42:	60e3      	str	r3, [r4, #12]
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pExtVTable    = 0;
 8007d44:	6126      	str	r6, [r4, #16]
  MAGNETO_Data[ LSM303AGR_M_0 ].pExtData       = 0;
 8007d46:	61a6      	str	r6, [r4, #24]
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pData         = ( void * )&MAGNETO_Data[ LSM303AGR_M_0 ];
 8007d48:	60a2      	str	r2, [r4, #8]

  *handle = (void *)&MAGNETO_SensorHandle[ LSM303AGR_M_0 ];
 8007d4a:	603c      	str	r4, [r7, #0]

  driver = ( MAGNETO_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;

  if ( driver->Init == NULL )
 8007d4c:	68e3      	ldr	r3, [r4, #12]
 8007d4e:	681b      	ldr	r3, [r3, #0]
 8007d50:	2b00      	cmp	r3, #0
 8007d52:	d032      	beq.n	8007dba <BSP_MAGNETO_Init+0xb2>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }

  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 8007d54:	4620      	mov	r0, r4
 8007d56:	4798      	blx	r3
 8007d58:	2801      	cmp	r0, #1
 8007d5a:	d037      	beq.n	8007dcc <BSP_MAGNETO_Init+0xc4>
  return COMPONENT_OK;
 8007d5c:	2000      	movs	r0, #0
 8007d5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if(MAGNETO_SensorHandle[ LSM303AGR_M_0 ].isInitialized == 1)
 8007d60:	2b01      	cmp	r3, #1
 8007d62:	d101      	bne.n	8007d68 <BSP_MAGNETO_Init+0x60>
        return COMPONENT_ERROR;
 8007d64:	2001      	movs	r0, #1
 8007d66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007d68:	4605      	mov	r5, r0
  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 8007d6a:	f7ff facd 	bl	8007308 <Sensor_IO_Init>
 8007d6e:	2801      	cmp	r0, #1
 8007d70:	d0f8      	beq.n	8007d64 <BSP_MAGNETO_Init+0x5c>
  LSM303AGR_M_0_Data.comboData = &LSM303AGR_Combo_Data[0];
 8007d72:	4623      	mov	r3, r4
 8007d74:	4a1a      	ldr	r2, [pc, #104]	; (8007de0 <BSP_MAGNETO_Init+0xd8>)
 8007d76:	f843 2f1c 	str.w	r2, [r3, #28]!
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].who_am_i      = LSM303AGR_MAG_WHO_AM_I;
 8007d7a:	2640      	movs	r6, #64	; 0x40
  MAGNETO_Data[ LSM303AGR_M_0 ].pComponentData = ( void * )&LSM303AGR_M_0_Data;
 8007d7c:	6163      	str	r3, [r4, #20]
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].address       = LSM303AGR_MAG_I2C_ADDRESS;
 8007d7e:	203c      	movs	r0, #60	; 0x3c
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pVTable       = ( void * )&LSM303AGR_M_Drv;
 8007d80:	4b18      	ldr	r3, [pc, #96]	; (8007de4 <BSP_MAGNETO_Init+0xdc>)
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].ifType        = 0; /* I2C interface */
 8007d82:	7065      	strb	r5, [r4, #1]
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].instance      = LSM303AGR_M_0;
 8007d84:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pData         = ( void * )&MAGNETO_Data[ LSM303AGR_M_0 ];
 8007d88:	f104 0214 	add.w	r2, r4, #20
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].who_am_i      = LSM303AGR_MAG_WHO_AM_I;
 8007d8c:	7026      	strb	r6, [r4, #0]
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].address       = LSM303AGR_MAG_I2C_ADDRESS;
 8007d8e:	70a0      	strb	r0, [r4, #2]
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].instance      = LSM303AGR_M_0;
 8007d90:	6061      	str	r1, [r4, #4]
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pVTable       = ( void * )&LSM303AGR_M_Drv;
 8007d92:	60e3      	str	r3, [r4, #12]
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pExtVTable    = 0;
 8007d94:	6125      	str	r5, [r4, #16]
  MAGNETO_Data[ LSM303AGR_M_0 ].pExtData       = 0;
 8007d96:	61a5      	str	r5, [r4, #24]
  MAGNETO_SensorHandle[ LSM303AGR_M_0 ].pData         = ( void * )&MAGNETO_Data[ LSM303AGR_M_0 ];
 8007d98:	60a2      	str	r2, [r4, #8]
  *handle = (void *)&MAGNETO_SensorHandle[ LSM303AGR_M_0 ];
 8007d9a:	603c      	str	r4, [r7, #0]
  if ( driver->Init == NULL )
 8007d9c:	68e3      	ldr	r3, [r4, #12]
 8007d9e:	681b      	ldr	r3, [r3, #0]
 8007da0:	b15b      	cbz	r3, 8007dba <BSP_MAGNETO_Init+0xb2>
  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 8007da2:	4620      	mov	r0, r4
 8007da4:	4798      	blx	r3
 8007da6:	2801      	cmp	r0, #1
 8007da8:	d1d8      	bne.n	8007d5c <BSP_MAGNETO_Init+0x54>
  {
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8007daa:	683b      	ldr	r3, [r7, #0]
 8007dac:	601d      	str	r5, [r3, #0]
 8007dae:	605d      	str	r5, [r3, #4]
 8007db0:	609d      	str	r5, [r3, #8]
 8007db2:	60dd      	str	r5, [r3, #12]
 8007db4:	611d      	str	r5, [r3, #16]
    *handle = NULL;
 8007db6:	603d      	str	r5, [r7, #0]
}
 8007db8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8007dba:	2300      	movs	r3, #0
 8007dbc:	6023      	str	r3, [r4, #0]
 8007dbe:	6063      	str	r3, [r4, #4]
 8007dc0:	60a3      	str	r3, [r4, #8]
 8007dc2:	60e3      	str	r3, [r4, #12]
 8007dc4:	6123      	str	r3, [r4, #16]
        return COMPONENT_ERROR;
 8007dc6:	2001      	movs	r0, #1
    *handle = NULL;
 8007dc8:	603b      	str	r3, [r7, #0]
 8007dca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8007dcc:	683b      	ldr	r3, [r7, #0]
 8007dce:	601e      	str	r6, [r3, #0]
 8007dd0:	605e      	str	r6, [r3, #4]
 8007dd2:	609e      	str	r6, [r3, #8]
 8007dd4:	60de      	str	r6, [r3, #12]
 8007dd6:	611e      	str	r6, [r3, #16]
    *handle = NULL;
 8007dd8:	603e      	str	r6, [r7, #0]
 8007dda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007ddc:	2000067c 	.word	0x2000067c
 8007de0:	20000760 	.word	0x20000760
 8007de4:	20000198 	.word	0x20000198

08007de8 <BSP_MAGNETO_Sensor_Enable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  MAGNETO_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007de8:	b160      	cbz	r0, 8007e04 <BSP_MAGNETO_Sensor_Enable+0x1c>
{
 8007dea:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( MAGNETO_Drv_t * )ctx->pVTable;

  if ( driver->Sensor_Enable == NULL )
 8007dec:	68c3      	ldr	r3, [r0, #12]
 8007dee:	689b      	ldr	r3, [r3, #8]
 8007df0:	b133      	cbz	r3, 8007e00 <BSP_MAGNETO_Sensor_Enable+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Sensor_Enable( ctx ) == COMPONENT_ERROR )
 8007df2:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007df4:	f1a0 0001 	sub.w	r0, r0, #1
 8007df8:	fab0 f080 	clz	r0, r0
 8007dfc:	0940      	lsrs	r0, r0, #5
 8007dfe:	bd08      	pop	{r3, pc}
 8007e00:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007e02:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007e04:	2001      	movs	r0, #1
 8007e06:	4770      	bx	lr

08007e08 <BSP_MAGNETO_Sensor_Disable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  MAGNETO_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007e08:	b160      	cbz	r0, 8007e24 <BSP_MAGNETO_Sensor_Disable+0x1c>
{
 8007e0a:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( MAGNETO_Drv_t * )ctx->pVTable;

  if ( driver->Sensor_Disable == NULL )
 8007e0c:	68c3      	ldr	r3, [r0, #12]
 8007e0e:	68db      	ldr	r3, [r3, #12]
 8007e10:	b133      	cbz	r3, 8007e20 <BSP_MAGNETO_Sensor_Disable+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Sensor_Disable( ctx ) == COMPONENT_ERROR )
 8007e12:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007e14:	f1a0 0001 	sub.w	r0, r0, #1
 8007e18:	fab0 f080 	clz	r0, r0
 8007e1c:	0940      	lsrs	r0, r0, #5
 8007e1e:	bd08      	pop	{r3, pc}
 8007e20:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007e22:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007e24:	2001      	movs	r0, #1
 8007e26:	4770      	bx	lr

08007e28 <BSP_MAGNETO_IsInitialized>:
 */
DrvStatusTypeDef BSP_MAGNETO_IsInitialized( void *handle, uint8_t *status )
{
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;

  if(ctx == NULL)
 8007e28:	b120      	cbz	r0, 8007e34 <BSP_MAGNETO_IsInitialized+0xc>
  {
    return COMPONENT_ERROR;
  }

  if ( status == NULL )
 8007e2a:	b119      	cbz	r1, 8007e34 <BSP_MAGNETO_IsInitialized+0xc>
  {
    return COMPONENT_ERROR;
  }

  *status = ctx->isInitialized;
 8007e2c:	7943      	ldrb	r3, [r0, #5]
 8007e2e:	700b      	strb	r3, [r1, #0]

  return COMPONENT_OK;
 8007e30:	2000      	movs	r0, #0
 8007e32:	4770      	bx	lr
    return COMPONENT_ERROR;
 8007e34:	2001      	movs	r0, #1
}
 8007e36:	4770      	bx	lr

08007e38 <BSP_MAGNETO_Get_Instance>:
 */
DrvStatusTypeDef BSP_MAGNETO_Get_Instance( void *handle, uint8_t *instance )
{
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;

  if(ctx == NULL)
 8007e38:	b120      	cbz	r0, 8007e44 <BSP_MAGNETO_Get_Instance+0xc>
  {
    return COMPONENT_ERROR;
  }

  if ( instance == NULL )
 8007e3a:	b119      	cbz	r1, 8007e44 <BSP_MAGNETO_Get_Instance+0xc>
  {
    return COMPONENT_ERROR;
  }

  *instance = ctx->instance;
 8007e3c:	7903      	ldrb	r3, [r0, #4]
 8007e3e:	700b      	strb	r3, [r1, #0]

  return COMPONENT_OK;
 8007e40:	2000      	movs	r0, #0
 8007e42:	4770      	bx	lr
    return COMPONENT_ERROR;
 8007e44:	2001      	movs	r0, #1
}
 8007e46:	4770      	bx	lr

08007e48 <BSP_MAGNETO_Get_Axes>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  MAGNETO_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007e48:	b168      	cbz	r0, 8007e66 <BSP_MAGNETO_Get_Axes+0x1e>
{
 8007e4a:	b508      	push	{r3, lr}
  {
    return COMPONENT_ERROR;
  }

  driver = ( MAGNETO_Drv_t * )ctx->pVTable;
 8007e4c:	68c2      	ldr	r2, [r0, #12]

  if ( magnetic_field == NULL )
 8007e4e:	b141      	cbz	r1, 8007e62 <BSP_MAGNETO_Get_Axes+0x1a>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Axes == NULL )
 8007e50:	6993      	ldr	r3, [r2, #24]
 8007e52:	b133      	cbz	r3, 8007e62 <BSP_MAGNETO_Get_Axes+0x1a>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Axes( ctx, magnetic_field ) == COMPONENT_ERROR )
 8007e54:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007e56:	f1a0 0001 	sub.w	r0, r0, #1
 8007e5a:	fab0 f080 	clz	r0, r0
 8007e5e:	0940      	lsrs	r0, r0, #5
 8007e60:	bd08      	pop	{r3, pc}
 8007e62:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007e64:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007e66:	2001      	movs	r0, #1
 8007e68:	4770      	bx	lr
 8007e6a:	bf00      	nop

08007e6c <BSP_MAGNETO_Set_ODR_Value>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  MAGNETO_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007e6c:	b160      	cbz	r0, 8007e88 <BSP_MAGNETO_Set_ODR_Value+0x1c>
{
 8007e6e:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( MAGNETO_Drv_t * )ctx->pVTable;

  if ( driver->Set_ODR_Value == NULL )
 8007e70:	68c3      	ldr	r3, [r0, #12]
 8007e72:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007e74:	b133      	cbz	r3, 8007e84 <BSP_MAGNETO_Set_ODR_Value+0x18>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Set_ODR_Value( ctx, odr ) == COMPONENT_ERROR )
 8007e76:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007e78:	f1a0 0001 	sub.w	r0, r0, #1
 8007e7c:	fab0 f080 	clz	r0, r0
 8007e80:	0940      	lsrs	r0, r0, #5
 8007e82:	bd08      	pop	{r3, pc}
 8007e84:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007e86:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007e88:	2001      	movs	r0, #1
 8007e8a:	4770      	bx	lr

08007e8c <BSP_MAGNETO_Read_Reg>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  MAGNETO_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007e8c:	b168      	cbz	r0, 8007eaa <BSP_MAGNETO_Read_Reg+0x1e>
{
 8007e8e:	b510      	push	{r4, lr}
  {
    return COMPONENT_ERROR;
  }

  driver = ( MAGNETO_Drv_t * )ctx->pVTable;
 8007e90:	68c4      	ldr	r4, [r0, #12]

  if(data == NULL)
 8007e92:	b142      	cbz	r2, 8007ea6 <BSP_MAGNETO_Read_Reg+0x1a>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Read_Reg == NULL )
 8007e94:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8007e96:	b133      	cbz	r3, 8007ea6 <BSP_MAGNETO_Read_Reg+0x1a>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Read_Reg( ctx, reg, data ) == COMPONENT_ERROR )
 8007e98:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007e9a:	f1a0 0001 	sub.w	r0, r0, #1
 8007e9e:	fab0 f080 	clz	r0, r0
 8007ea2:	0940      	lsrs	r0, r0, #5
 8007ea4:	bd10      	pop	{r4, pc}
 8007ea6:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007ea8:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 8007eaa:	2001      	movs	r0, #1
 8007eac:	4770      	bx	lr
 8007eae:	bf00      	nop

08007eb0 <BSP_MAGNETO_Write_Reg>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  MAGNETO_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007eb0:	b160      	cbz	r0, 8007ecc <BSP_MAGNETO_Write_Reg+0x1c>
{
 8007eb2:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( MAGNETO_Drv_t * )ctx->pVTable;

  if ( driver->Write_Reg == NULL )
 8007eb4:	68c3      	ldr	r3, [r0, #12]
 8007eb6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007eb8:	b133      	cbz	r3, 8007ec8 <BSP_MAGNETO_Write_Reg+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Write_Reg( ctx, reg, data ) == COMPONENT_ERROR )
 8007eba:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007ebc:	f1a0 0001 	sub.w	r0, r0, #1
 8007ec0:	fab0 f080 	clz	r0, r0
 8007ec4:	0940      	lsrs	r0, r0, #5
 8007ec6:	bd08      	pop	{r3, pc}
 8007ec8:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007eca:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007ecc:	2001      	movs	r0, #1
 8007ece:	4770      	bx	lr

08007ed0 <BSP_MAGNETO_Get_DRDY_Status>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  MAGNETO_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007ed0:	b160      	cbz	r0, 8007eec <BSP_MAGNETO_Get_DRDY_Status+0x1c>
{
 8007ed2:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( MAGNETO_Drv_t * )ctx->pVTable;

  if ( driver->Get_DRDY_Status == NULL )
 8007ed4:	68c3      	ldr	r3, [r0, #12]
 8007ed6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8007ed8:	b133      	cbz	r3, 8007ee8 <BSP_MAGNETO_Get_DRDY_Status+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Get_DRDY_Status( ctx, status ) == COMPONENT_ERROR )
 8007eda:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007edc:	f1a0 0001 	sub.w	r0, r0, #1
 8007ee0:	fab0 f080 	clz	r0, r0
 8007ee4:	0940      	lsrs	r0, r0, #5
 8007ee6:	bd08      	pop	{r3, pc}
 8007ee8:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007eea:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8007eec:	2001      	movs	r0, #1
 8007eee:	4770      	bx	lr

08007ef0 <BSP_PRESSURE_Init>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
DrvStatusTypeDef BSP_PRESSURE_Init( PRESSURE_ID_t id, void **handle )
{
 8007ef0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *handle = NULL;
 8007ef2:	2600      	movs	r6, #0

static DrvStatusTypeDef BSP_LPS22HB_PRESSURE_Init( void **handle )
{
  PRESSURE_Drv_t *driver = NULL;

  if(PRESSURE_SensorHandle[ LPS22HB_P_0 ].isInitialized == 1)
 8007ef4:	4c37      	ldr	r4, [pc, #220]	; (8007fd4 <BSP_PRESSURE_Init+0xe4>)
  *handle = NULL;
 8007ef6:	600e      	str	r6, [r1, #0]
{
 8007ef8:	460f      	mov	r7, r1
  if(PRESSURE_SensorHandle[ LPS22HB_P_0 ].isInitialized == 1)
 8007efa:	7963      	ldrb	r3, [r4, #5]
  switch(id)
 8007efc:	b348      	cbz	r0, 8007f52 <BSP_PRESSURE_Init+0x62>
  if(PRESSURE_SensorHandle[ LPS22HB_P_0 ].isInitialized == 1)
 8007efe:	2b01      	cmp	r3, #1
 8007f00:	d029      	beq.n	8007f56 <BSP_PRESSURE_Init+0x66>
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
  }

  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 8007f02:	f7ff fa01 	bl	8007308 <Sensor_IO_Init>
 8007f06:	2801      	cmp	r0, #1
 8007f08:	d025      	beq.n	8007f56 <BSP_PRESSURE_Init+0x66>
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].isCombo       = 1;
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pData         = ( void * )&PRESSURE_Data[ LPS22HB_P_0 ];
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pVTable       = ( void * )&LPS22HB_P_Drv;
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pExtVTable    = ( void * )&LPS22HB_P_ExtDrv;

  LPS22HB_P_0_Data.comboData = &LPS22HB_Combo_Data[0];
 8007f0a:	4623      	mov	r3, r4
 8007f0c:	4a32      	ldr	r2, [pc, #200]	; (8007fd8 <BSP_PRESSURE_Init+0xe8>)
 8007f0e:	f843 2f1c 	str.w	r2, [r3, #28]!
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].who_am_i      = LPS22HB_WHO_AM_I_VAL;
 8007f12:	f04f 0eb1 	mov.w	lr, #177	; 0xb1
  PRESSURE_Data[ LPS22HB_P_0 ].pComponentData = ( void * )&LPS22HB_P_0_Data;
 8007f16:	6163      	str	r3, [r4, #20]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].address       = LPS22HB_ADDRESS_HIGH;
 8007f18:	25ba      	movs	r5, #186	; 0xba
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pExtVTable    = ( void * )&LPS22HB_P_ExtDrv;
 8007f1a:	4b30      	ldr	r3, [pc, #192]	; (8007fdc <BSP_PRESSURE_Init+0xec>)
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pVTable       = ( void * )&LPS22HB_P_Drv;
 8007f1c:	4a30      	ldr	r2, [pc, #192]	; (8007fe0 <BSP_PRESSURE_Init+0xf0>)
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].ifType        = 0; /* I2C interface */
 8007f1e:	7066      	strb	r6, [r4, #1]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].instance      = LPS22HB_P_0;
 8007f20:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pData         = ( void * )&PRESSURE_Data[ LPS22HB_P_0 ];
 8007f24:	f104 0114 	add.w	r1, r4, #20
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].who_am_i      = LPS22HB_WHO_AM_I_VAL;
 8007f28:	f884 e000 	strb.w	lr, [r4]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].address       = LPS22HB_ADDRESS_HIGH;
 8007f2c:	70a5      	strb	r5, [r4, #2]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].instance      = LPS22HB_P_0;
 8007f2e:	6060      	str	r0, [r4, #4]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pVTable       = ( void * )&LPS22HB_P_Drv;
 8007f30:	60e2      	str	r2, [r4, #12]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pExtVTable    = ( void * )&LPS22HB_P_ExtDrv;
 8007f32:	6123      	str	r3, [r4, #16]
  PRESSURE_Data[ LPS22HB_P_0 ].pExtData       = 0;
 8007f34:	61a6      	str	r6, [r4, #24]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pData         = ( void * )&PRESSURE_Data[ LPS22HB_P_0 ];
 8007f36:	60a1      	str	r1, [r4, #8]

  *handle = (void *)&PRESSURE_SensorHandle[ LPS22HB_P_0 ];
 8007f38:	603c      	str	r4, [r7, #0]

  driver = ( PRESSURE_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;

  if ( driver->Init == NULL )
 8007f3a:	68e3      	ldr	r3, [r4, #12]
 8007f3c:	681b      	ldr	r3, [r3, #0]
 8007f3e:	2b00      	cmp	r3, #0
 8007f40:	d037      	beq.n	8007fb2 <BSP_PRESSURE_Init+0xc2>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }

  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 8007f42:	4620      	mov	r0, r4
 8007f44:	4798      	blx	r3
 8007f46:	2801      	cmp	r0, #1
 8007f48:	d03c      	beq.n	8007fc4 <BSP_PRESSURE_Init+0xd4>
    *handle = NULL;
    return COMPONENT_ERROR;
  }

  /* Configure interrupt lines for LPS22HB */
  LPS22HB_Sensor_IO_ITConfig();
 8007f4a:	f7ff fa95 	bl	8007478 <LPS22HB_Sensor_IO_ITConfig>
  return COMPONENT_OK;
 8007f4e:	2000      	movs	r0, #0
 8007f50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if(PRESSURE_SensorHandle[ LPS22HB_P_0 ].isInitialized == 1)
 8007f52:	2b01      	cmp	r3, #1
 8007f54:	d101      	bne.n	8007f5a <BSP_PRESSURE_Init+0x6a>
        return COMPONENT_ERROR;
 8007f56:	2001      	movs	r0, #1
 8007f58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007f5a:	4605      	mov	r5, r0
  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 8007f5c:	f7ff f9d4 	bl	8007308 <Sensor_IO_Init>
 8007f60:	2801      	cmp	r0, #1
 8007f62:	d0f8      	beq.n	8007f56 <BSP_PRESSURE_Init+0x66>
  LPS22HB_P_0_Data.comboData = &LPS22HB_Combo_Data[0];
 8007f64:	4623      	mov	r3, r4
 8007f66:	4a1c      	ldr	r2, [pc, #112]	; (8007fd8 <BSP_PRESSURE_Init+0xe8>)
 8007f68:	f843 2f1c 	str.w	r2, [r3, #28]!
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].who_am_i      = LPS22HB_WHO_AM_I_VAL;
 8007f6c:	f04f 0eb1 	mov.w	lr, #177	; 0xb1
  PRESSURE_Data[ LPS22HB_P_0 ].pComponentData = ( void * )&LPS22HB_P_0_Data;
 8007f70:	6163      	str	r3, [r4, #20]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].address       = LPS22HB_ADDRESS_HIGH;
 8007f72:	26ba      	movs	r6, #186	; 0xba
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pExtVTable    = ( void * )&LPS22HB_P_ExtDrv;
 8007f74:	4b19      	ldr	r3, [pc, #100]	; (8007fdc <BSP_PRESSURE_Init+0xec>)
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pVTable       = ( void * )&LPS22HB_P_Drv;
 8007f76:	4a1a      	ldr	r2, [pc, #104]	; (8007fe0 <BSP_PRESSURE_Init+0xf0>)
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].ifType        = 0; /* I2C interface */
 8007f78:	7065      	strb	r5, [r4, #1]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].instance      = LPS22HB_P_0;
 8007f7a:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pData         = ( void * )&PRESSURE_Data[ LPS22HB_P_0 ];
 8007f7e:	f104 0114 	add.w	r1, r4, #20
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].who_am_i      = LPS22HB_WHO_AM_I_VAL;
 8007f82:	f884 e000 	strb.w	lr, [r4]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].address       = LPS22HB_ADDRESS_HIGH;
 8007f86:	70a6      	strb	r6, [r4, #2]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].instance      = LPS22HB_P_0;
 8007f88:	6060      	str	r0, [r4, #4]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pVTable       = ( void * )&LPS22HB_P_Drv;
 8007f8a:	60e2      	str	r2, [r4, #12]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pExtVTable    = ( void * )&LPS22HB_P_ExtDrv;
 8007f8c:	6123      	str	r3, [r4, #16]
  PRESSURE_Data[ LPS22HB_P_0 ].pExtData       = 0;
 8007f8e:	61a5      	str	r5, [r4, #24]
  PRESSURE_SensorHandle[ LPS22HB_P_0 ].pData         = ( void * )&PRESSURE_Data[ LPS22HB_P_0 ];
 8007f90:	60a1      	str	r1, [r4, #8]
  *handle = (void *)&PRESSURE_SensorHandle[ LPS22HB_P_0 ];
 8007f92:	603c      	str	r4, [r7, #0]
  if ( driver->Init == NULL )
 8007f94:	68e3      	ldr	r3, [r4, #12]
 8007f96:	681b      	ldr	r3, [r3, #0]
 8007f98:	b15b      	cbz	r3, 8007fb2 <BSP_PRESSURE_Init+0xc2>
  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 8007f9a:	4620      	mov	r0, r4
 8007f9c:	4798      	blx	r3
 8007f9e:	2801      	cmp	r0, #1
 8007fa0:	d1d3      	bne.n	8007f4a <BSP_PRESSURE_Init+0x5a>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8007fa2:	683b      	ldr	r3, [r7, #0]
 8007fa4:	601d      	str	r5, [r3, #0]
 8007fa6:	605d      	str	r5, [r3, #4]
 8007fa8:	609d      	str	r5, [r3, #8]
 8007faa:	60dd      	str	r5, [r3, #12]
 8007fac:	611d      	str	r5, [r3, #16]
    *handle = NULL;
 8007fae:	603d      	str	r5, [r7, #0]
}
 8007fb0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8007fb2:	2300      	movs	r3, #0
 8007fb4:	6023      	str	r3, [r4, #0]
 8007fb6:	6063      	str	r3, [r4, #4]
 8007fb8:	60a3      	str	r3, [r4, #8]
 8007fba:	60e3      	str	r3, [r4, #12]
 8007fbc:	6123      	str	r3, [r4, #16]
        return COMPONENT_ERROR;
 8007fbe:	2001      	movs	r0, #1
    *handle = NULL;
 8007fc0:	603b      	str	r3, [r7, #0]
 8007fc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8007fc4:	683b      	ldr	r3, [r7, #0]
 8007fc6:	601e      	str	r6, [r3, #0]
 8007fc8:	605e      	str	r6, [r3, #4]
 8007fca:	609e      	str	r6, [r3, #8]
 8007fcc:	60de      	str	r6, [r3, #12]
 8007fce:	611e      	str	r6, [r3, #16]
    *handle = NULL;
 8007fd0:	603e      	str	r6, [r7, #0]
 8007fd2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007fd4:	2000069c 	.word	0x2000069c
 8007fd8:	20000758 	.word	0x20000758
 8007fdc:	200000a4 	.word	0x200000a4
 8007fe0:	20000114 	.word	0x20000114

08007fe4 <BSP_PRESSURE_Sensor_Enable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  PRESSURE_Drv_t *driver = NULL;

  if(ctx == NULL)
 8007fe4:	b160      	cbz	r0, 8008000 <BSP_PRESSURE_Sensor_Enable+0x1c>
{
 8007fe6:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( PRESSURE_Drv_t * )ctx->pVTable;

  if ( driver->Sensor_Enable == NULL )
 8007fe8:	68c3      	ldr	r3, [r0, #12]
 8007fea:	689b      	ldr	r3, [r3, #8]
 8007fec:	b133      	cbz	r3, 8007ffc <BSP_PRESSURE_Sensor_Enable+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Sensor_Enable( ctx ) == COMPONENT_ERROR )
 8007fee:	4798      	blx	r3
    return COMPONENT_ERROR;
 8007ff0:	f1a0 0001 	sub.w	r0, r0, #1
 8007ff4:	fab0 f080 	clz	r0, r0
 8007ff8:	0940      	lsrs	r0, r0, #5
 8007ffa:	bd08      	pop	{r3, pc}
 8007ffc:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8007ffe:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8008000:	2001      	movs	r0, #1
 8008002:	4770      	bx	lr

08008004 <BSP_PRESSURE_Sensor_Disable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  PRESSURE_Drv_t *driver = NULL;

  if(ctx == NULL)
 8008004:	b160      	cbz	r0, 8008020 <BSP_PRESSURE_Sensor_Disable+0x1c>
{
 8008006:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( PRESSURE_Drv_t * )ctx->pVTable;

  if ( driver->Sensor_Disable == NULL )
 8008008:	68c3      	ldr	r3, [r0, #12]
 800800a:	68db      	ldr	r3, [r3, #12]
 800800c:	b133      	cbz	r3, 800801c <BSP_PRESSURE_Sensor_Disable+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Sensor_Disable( ctx ) == COMPONENT_ERROR )
 800800e:	4798      	blx	r3
    return COMPONENT_ERROR;
 8008010:	f1a0 0001 	sub.w	r0, r0, #1
 8008014:	fab0 f080 	clz	r0, r0
 8008018:	0940      	lsrs	r0, r0, #5
 800801a:	bd08      	pop	{r3, pc}
 800801c:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 800801e:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8008020:	2001      	movs	r0, #1
 8008022:	4770      	bx	lr

08008024 <BSP_PRESSURE_IsInitialized>:
 */
DrvStatusTypeDef BSP_PRESSURE_IsInitialized( void *handle, uint8_t *status )
{
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;

  if(ctx == NULL)
 8008024:	b120      	cbz	r0, 8008030 <BSP_PRESSURE_IsInitialized+0xc>
  {
    return COMPONENT_ERROR;
  }

  if ( status == NULL )
 8008026:	b119      	cbz	r1, 8008030 <BSP_PRESSURE_IsInitialized+0xc>
  {
    return COMPONENT_ERROR;
  }

  *status = ctx->isInitialized;
 8008028:	7943      	ldrb	r3, [r0, #5]
 800802a:	700b      	strb	r3, [r1, #0]

  return COMPONENT_OK;
 800802c:	2000      	movs	r0, #0
 800802e:	4770      	bx	lr
    return COMPONENT_ERROR;
 8008030:	2001      	movs	r0, #1
}
 8008032:	4770      	bx	lr

08008034 <BSP_PRESSURE_Get_Instance>:
 */
DrvStatusTypeDef BSP_PRESSURE_Get_Instance( void *handle, uint8_t *instance )
{
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;

  if(ctx == NULL)
 8008034:	b120      	cbz	r0, 8008040 <BSP_PRESSURE_Get_Instance+0xc>
  {
    return COMPONENT_ERROR;
  }

  if ( instance == NULL )
 8008036:	b119      	cbz	r1, 8008040 <BSP_PRESSURE_Get_Instance+0xc>
  {
    return COMPONENT_ERROR;
  }

  *instance = ctx->instance;
 8008038:	7903      	ldrb	r3, [r0, #4]
 800803a:	700b      	strb	r3, [r1, #0]

  return COMPONENT_OK;
 800803c:	2000      	movs	r0, #0
 800803e:	4770      	bx	lr
    return COMPONENT_ERROR;
 8008040:	2001      	movs	r0, #1
}
 8008042:	4770      	bx	lr

08008044 <BSP_PRESSURE_Get_Press>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  PRESSURE_Drv_t *driver = NULL;

  if(ctx == NULL)
 8008044:	b168      	cbz	r0, 8008062 <BSP_PRESSURE_Get_Press+0x1e>
{
 8008046:	b508      	push	{r3, lr}
  {
    return COMPONENT_ERROR;
  }

  driver = ( PRESSURE_Drv_t * )ctx->pVTable;
 8008048:	68c2      	ldr	r2, [r0, #12]

  if ( pressure == NULL )
 800804a:	b141      	cbz	r1, 800805e <BSP_PRESSURE_Get_Press+0x1a>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Press == NULL )
 800804c:	6993      	ldr	r3, [r2, #24]
 800804e:	b133      	cbz	r3, 800805e <BSP_PRESSURE_Get_Press+0x1a>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Press( ctx, pressure ) == COMPONENT_ERROR )
 8008050:	4798      	blx	r3
    return COMPONENT_ERROR;
 8008052:	f1a0 0001 	sub.w	r0, r0, #1
 8008056:	fab0 f080 	clz	r0, r0
 800805a:	0940      	lsrs	r0, r0, #5
 800805c:	bd08      	pop	{r3, pc}
 800805e:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8008060:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8008062:	2001      	movs	r0, #1
 8008064:	4770      	bx	lr
 8008066:	bf00      	nop

08008068 <BSP_PRESSURE_Set_ODR_Value>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  PRESSURE_Drv_t *driver = NULL;

  if(ctx == NULL)
 8008068:	b160      	cbz	r0, 8008084 <BSP_PRESSURE_Set_ODR_Value+0x1c>
{
 800806a:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( PRESSURE_Drv_t * )ctx->pVTable;

  if ( driver->Set_ODR_Value == NULL )
 800806c:	68c3      	ldr	r3, [r0, #12]
 800806e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008070:	b133      	cbz	r3, 8008080 <BSP_PRESSURE_Set_ODR_Value+0x18>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Set_ODR_Value( ctx, odr ) == COMPONENT_ERROR )
 8008072:	4798      	blx	r3
    return COMPONENT_ERROR;
 8008074:	f1a0 0001 	sub.w	r0, r0, #1
 8008078:	fab0 f080 	clz	r0, r0
 800807c:	0940      	lsrs	r0, r0, #5
 800807e:	bd08      	pop	{r3, pc}
 8008080:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8008082:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8008084:	2001      	movs	r0, #1
 8008086:	4770      	bx	lr

08008088 <BSP_PRESSURE_Read_Reg>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  PRESSURE_Drv_t *driver = NULL;

  if(ctx == NULL)
 8008088:	b168      	cbz	r0, 80080a6 <BSP_PRESSURE_Read_Reg+0x1e>
{
 800808a:	b510      	push	{r4, lr}
  {
    return COMPONENT_ERROR;
  }

  driver = ( PRESSURE_Drv_t * )ctx->pVTable;
 800808c:	68c4      	ldr	r4, [r0, #12]

  if(data == NULL)
 800808e:	b142      	cbz	r2, 80080a2 <BSP_PRESSURE_Read_Reg+0x1a>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Read_Reg == NULL )
 8008090:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8008092:	b133      	cbz	r3, 80080a2 <BSP_PRESSURE_Read_Reg+0x1a>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Read_Reg( ctx, reg, data ) == COMPONENT_ERROR )
 8008094:	4798      	blx	r3
    return COMPONENT_ERROR;
 8008096:	f1a0 0001 	sub.w	r0, r0, #1
 800809a:	fab0 f080 	clz	r0, r0
 800809e:	0940      	lsrs	r0, r0, #5
 80080a0:	bd10      	pop	{r4, pc}
 80080a2:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 80080a4:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 80080a6:	2001      	movs	r0, #1
 80080a8:	4770      	bx	lr
 80080aa:	bf00      	nop

080080ac <BSP_PRESSURE_Write_Reg>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  PRESSURE_Drv_t *driver = NULL;

  if(ctx == NULL)
 80080ac:	b160      	cbz	r0, 80080c8 <BSP_PRESSURE_Write_Reg+0x1c>
{
 80080ae:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( PRESSURE_Drv_t * )ctx->pVTable;

  if ( driver->Write_Reg == NULL )
 80080b0:	68c3      	ldr	r3, [r0, #12]
 80080b2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80080b4:	b133      	cbz	r3, 80080c4 <BSP_PRESSURE_Write_Reg+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Write_Reg( ctx, reg, data ) == COMPONENT_ERROR )
 80080b6:	4798      	blx	r3
    return COMPONENT_ERROR;
 80080b8:	f1a0 0001 	sub.w	r0, r0, #1
 80080bc:	fab0 f080 	clz	r0, r0
 80080c0:	0940      	lsrs	r0, r0, #5
 80080c2:	bd08      	pop	{r3, pc}
 80080c4:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 80080c6:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 80080c8:	2001      	movs	r0, #1
 80080ca:	4770      	bx	lr

080080cc <BSP_PRESSURE_Get_DRDY_Status>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  PRESSURE_Drv_t *driver = NULL;

  if(ctx == NULL)
 80080cc:	b160      	cbz	r0, 80080e8 <BSP_PRESSURE_Get_DRDY_Status+0x1c>
{
 80080ce:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( PRESSURE_Drv_t * )ctx->pVTable;

  if ( driver->Get_DRDY_Status == NULL )
 80080d0:	68c3      	ldr	r3, [r0, #12]
 80080d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80080d4:	b133      	cbz	r3, 80080e4 <BSP_PRESSURE_Get_DRDY_Status+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Get_DRDY_Status( ctx, status ) == COMPONENT_ERROR )
 80080d6:	4798      	blx	r3
    return COMPONENT_ERROR;
 80080d8:	f1a0 0001 	sub.w	r0, r0, #1
 80080dc:	fab0 f080 	clz	r0, r0
 80080e0:	0940      	lsrs	r0, r0, #5
 80080e2:	bd08      	pop	{r3, pc}
 80080e4:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 80080e6:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 80080e8:	2001      	movs	r0, #1
 80080ea:	4770      	bx	lr

080080ec <BSP_TEMPERATURE_Init>:
 * @param handle the device handle
 * @retval COMPONENT_OK in case of success
 * @retval COMPONENT_ERROR in case of failure
 */
DrvStatusTypeDef BSP_TEMPERATURE_Init( TEMPERATURE_ID_t id, void **handle )
{
 80080ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  *handle = NULL;
 80080ee:	2500      	movs	r5, #0
{
 80080f0:	460e      	mov	r6, r1
  *handle = NULL;
 80080f2:	600d      	str	r5, [r1, #0]

  switch(id)
 80080f4:	4604      	mov	r4, r0
 80080f6:	2800      	cmp	r0, #0
 80080f8:	f000 8087 	beq.w	800820a <BSP_TEMPERATURE_Init+0x11e>
 80080fc:	2801      	cmp	r0, #1

static DrvStatusTypeDef BSP_LPS22HB_TEMPERATURE_Init( void **handle )
{
  TEMPERATURE_Drv_t *driver = NULL;

  if(TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].isInitialized == 1)
 80080fe:	4c66      	ldr	r4, [pc, #408]	; (8008298 <BSP_TEMPERATURE_Init+0x1ac>)
  switch(id)
 8008100:	d12e      	bne.n	8008160 <BSP_TEMPERATURE_Init+0x74>
  if(TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].isInitialized == 1)
 8008102:	7e63      	ldrb	r3, [r4, #25]
 8008104:	2b01      	cmp	r3, #1
 8008106:	f000 8088 	beq.w	800821a <BSP_TEMPERATURE_Init+0x12e>
  {
    /* We have reached the max num of instance for this component */
    return COMPONENT_ERROR;
  }

  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 800810a:	f7ff f8fd 	bl	8007308 <Sensor_IO_Init>
 800810e:	2801      	cmp	r0, #1
 8008110:	f000 8083 	beq.w	800821a <BSP_TEMPERATURE_Init+0x12e>
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].isCombo       = 1;
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pData         = ( void * )&TEMPERATURE_Data[ LPS22HB_T_0 ];
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pVTable       = ( void * )&LPS22HB_T_Drv;
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pExtVTable    = ( void * )&LPS22HB_T_ExtDrv;

  LPS22HB_T_0_Data.comboData = &LPS22HB_Combo_Data[0];
 8008114:	4623      	mov	r3, r4
 8008116:	4a61      	ldr	r2, [pc, #388]	; (800829c <BSP_TEMPERATURE_Init+0x1b0>)
 8008118:	f843 2f3c 	str.w	r2, [r3, #60]!
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].who_am_i      = LPS22HB_WHO_AM_I_VAL;
 800811c:	22b1      	movs	r2, #177	; 0xb1
  TEMPERATURE_Data[ LPS22HB_T_0 ].pComponentData = ( void * )&LPS22HB_T_0_Data;
 800811e:	6323      	str	r3, [r4, #48]	; 0x30
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].who_am_i      = LPS22HB_WHO_AM_I_VAL;
 8008120:	7522      	strb	r2, [r4, #20]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].address       = LPS22HB_ADDRESS_HIGH;
 8008122:	f04f 0eba 	mov.w	lr, #186	; 0xba
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pExtVTable    = ( void * )&LPS22HB_T_ExtDrv;
 8008126:	4a5e      	ldr	r2, [pc, #376]	; (80082a0 <BSP_TEMPERATURE_Init+0x1b4>)
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].instance      = LPS22HB_T_0;
 8008128:	4f5e      	ldr	r7, [pc, #376]	; (80082a4 <BSP_TEMPERATURE_Init+0x1b8>)
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pVTable       = ( void * )&LPS22HB_T_Drv;
 800812a:	495f      	ldr	r1, [pc, #380]	; (80082a8 <BSP_TEMPERATURE_Init+0x1bc>)
 800812c:	6221      	str	r1, [r4, #32]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pData         = ( void * )&TEMPERATURE_Data[ LPS22HB_T_0 ];
 800812e:	f104 0030 	add.w	r0, r4, #48	; 0x30
  TEMPERATURE_Data[ LPS22HB_T_0 ].pExtData       = 0;

  *handle = (void *)&TEMPERATURE_SensorHandle[ LPS22HB_T_0 ];
 8008132:	f104 0314 	add.w	r3, r4, #20
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pExtVTable    = ( void * )&LPS22HB_T_ExtDrv;
 8008136:	6262      	str	r2, [r4, #36]	; 0x24
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].ifType        = 0; /* I2C interface */
 8008138:	7565      	strb	r5, [r4, #21]
  TEMPERATURE_Data[ LPS22HB_T_0 ].pExtData       = 0;
 800813a:	6365      	str	r5, [r4, #52]	; 0x34
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].address       = LPS22HB_ADDRESS_HIGH;
 800813c:	f884 e016 	strb.w	lr, [r4, #22]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].instance      = LPS22HB_T_0;
 8008140:	61a7      	str	r7, [r4, #24]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pData         = ( void * )&TEMPERATURE_Data[ LPS22HB_T_0 ];
 8008142:	61e0      	str	r0, [r4, #28]
  *handle = (void *)&TEMPERATURE_SensorHandle[ LPS22HB_T_0 ];
 8008144:	6033      	str	r3, [r6, #0]

  driver = ( TEMPERATURE_Drv_t * )((DrvContextTypeDef *)(*handle))->pVTable;

  if ( driver->Init == NULL )
 8008146:	6a22      	ldr	r2, [r4, #32]
 8008148:	6812      	ldr	r2, [r2, #0]
 800814a:	2a00      	cmp	r2, #0
 800814c:	d054      	beq.n	80081f8 <BSP_TEMPERATURE_Init+0x10c>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
    *handle = NULL;
    return COMPONENT_ERROR;
  }

  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 800814e:	4618      	mov	r0, r3
 8008150:	4790      	blx	r2
 8008152:	2801      	cmp	r0, #1
 8008154:	f000 8081 	beq.w	800825a <BSP_TEMPERATURE_Init+0x16e>
    *handle = NULL;
    return COMPONENT_ERROR;
  }

  /* Configure interrupt lines for LPS22HB */
  LPS22HB_Sensor_IO_ITConfig();
 8008158:	f7ff f98e 	bl	8007478 <LPS22HB_Sensor_IO_ITConfig>
  return COMPONENT_OK;
 800815c:	2000      	movs	r0, #0
 800815e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if(TEMPERATURE_SensorHandle[ HTS221_T_0 ].isInitialized == 1)
 8008160:	7963      	ldrb	r3, [r4, #5]
 8008162:	2b01      	cmp	r3, #1
 8008164:	d027      	beq.n	80081b6 <BSP_TEMPERATURE_Init+0xca>
  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 8008166:	f7ff f8cf 	bl	8007308 <Sensor_IO_Init>
 800816a:	2801      	cmp	r0, #1
 800816c:	d023      	beq.n	80081b6 <BSP_TEMPERATURE_Init+0xca>
  HTS221_T_0_Data.comboData = &HTS221_Combo_Data[0];
 800816e:	4623      	mov	r3, r4
 8008170:	4a4e      	ldr	r2, [pc, #312]	; (80082ac <BSP_TEMPERATURE_Init+0x1c0>)
 8008172:	f843 2f38 	str.w	r2, [r3, #56]!
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].who_am_i      = HTS221_WHO_AM_I_VAL;
 8008176:	27bc      	movs	r7, #188	; 0xbc
  TEMPERATURE_Data[ HTS221_T_0 ].pComponentData = ( void * )&HTS221_T_0_Data;
 8008178:	62a3      	str	r3, [r4, #40]	; 0x28
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].address       = HTS221_ADDRESS_DEFAULT;
 800817a:	20be      	movs	r0, #190	; 0xbe
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pVTable       = ( void * )&HTS221_T_Drv;
 800817c:	4b4c      	ldr	r3, [pc, #304]	; (80082b0 <BSP_TEMPERATURE_Init+0x1c4>)
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].ifType        = 0; /* I2C interface */
 800817e:	7065      	strb	r5, [r4, #1]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].instance      = HTS221_T_0;
 8008180:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pData         = ( void * )&TEMPERATURE_Data[ HTS221_T_0 ];
 8008184:	f104 0228 	add.w	r2, r4, #40	; 0x28
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].who_am_i      = HTS221_WHO_AM_I_VAL;
 8008188:	7027      	strb	r7, [r4, #0]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].address       = HTS221_ADDRESS_DEFAULT;
 800818a:	70a0      	strb	r0, [r4, #2]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].instance      = HTS221_T_0;
 800818c:	6061      	str	r1, [r4, #4]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pVTable       = ( void * )&HTS221_T_Drv;
 800818e:	60e3      	str	r3, [r4, #12]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pExtVTable    = 0;
 8008190:	6125      	str	r5, [r4, #16]
  TEMPERATURE_Data[ HTS221_T_0 ].pExtData       = 0;
 8008192:	62e5      	str	r5, [r4, #44]	; 0x2c
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pData         = ( void * )&TEMPERATURE_Data[ HTS221_T_0 ];
 8008194:	60a2      	str	r2, [r4, #8]
  *handle = (void *)&TEMPERATURE_SensorHandle[ HTS221_T_0 ];
 8008196:	6034      	str	r4, [r6, #0]
  if ( driver->Init == NULL )
 8008198:	68e3      	ldr	r3, [r4, #12]
 800819a:	681b      	ldr	r3, [r3, #0]
 800819c:	2b00      	cmp	r3, #0
 800819e:	d06c      	beq.n	800827a <BSP_TEMPERATURE_Init+0x18e>
  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 80081a0:	4620      	mov	r0, r4
 80081a2:	4798      	blx	r3
 80081a4:	2801      	cmp	r0, #1
 80081a6:	d156      	bne.n	8008256 <BSP_TEMPERATURE_Init+0x16a>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 80081a8:	6833      	ldr	r3, [r6, #0]
 80081aa:	601d      	str	r5, [r3, #0]
 80081ac:	605d      	str	r5, [r3, #4]
 80081ae:	609d      	str	r5, [r3, #8]
 80081b0:	60dd      	str	r5, [r3, #12]
 80081b2:	611d      	str	r5, [r3, #16]
    *handle = NULL;
 80081b4:	6035      	str	r5, [r6, #0]
  if(TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].isInitialized == 1)
 80081b6:	7e63      	ldrb	r3, [r4, #25]
 80081b8:	2b01      	cmp	r3, #1
 80081ba:	d02e      	beq.n	800821a <BSP_TEMPERATURE_Init+0x12e>
  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 80081bc:	f7ff f8a4 	bl	8007308 <Sensor_IO_Init>
 80081c0:	2801      	cmp	r0, #1
 80081c2:	d02a      	beq.n	800821a <BSP_TEMPERATURE_Init+0x12e>
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pData         = ( void * )&TEMPERATURE_Data[ LPS22HB_T_0 ];
 80081c4:	4b3b      	ldr	r3, [pc, #236]	; (80082b4 <BSP_TEMPERATURE_Init+0x1c8>)
 80081c6:	61e3      	str	r3, [r4, #28]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].who_am_i      = LPS22HB_WHO_AM_I_VAL;
 80081c8:	22b1      	movs	r2, #177	; 0xb1
  TEMPERATURE_Data[ LPS22HB_T_0 ].pComponentData = ( void * )&LPS22HB_T_0_Data;
 80081ca:	f103 050c 	add.w	r5, r3, #12
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].who_am_i      = LPS22HB_WHO_AM_I_VAL;
 80081ce:	7522      	strb	r2, [r4, #20]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].address       = LPS22HB_ADDRESS_HIGH;
 80081d0:	22ba      	movs	r2, #186	; 0xba
  TEMPERATURE_Data[ LPS22HB_T_0 ].pComponentData = ( void * )&LPS22HB_T_0_Data;
 80081d2:	6325      	str	r5, [r4, #48]	; 0x30
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].address       = LPS22HB_ADDRESS_HIGH;
 80081d4:	75a2      	strb	r2, [r4, #22]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].ifType        = 0; /* I2C interface */
 80081d6:	2500      	movs	r5, #0
  LPS22HB_T_0_Data.comboData = &LPS22HB_Combo_Data[0];
 80081d8:	4a30      	ldr	r2, [pc, #192]	; (800829c <BSP_TEMPERATURE_Init+0x1b0>)
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].instance      = LPS22HB_T_0;
 80081da:	4f32      	ldr	r7, [pc, #200]	; (80082a4 <BSP_TEMPERATURE_Init+0x1b8>)
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pVTable       = ( void * )&LPS22HB_T_Drv;
 80081dc:	4832      	ldr	r0, [pc, #200]	; (80082a8 <BSP_TEMPERATURE_Init+0x1bc>)
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pExtVTable    = ( void * )&LPS22HB_T_ExtDrv;
 80081de:	4930      	ldr	r1, [pc, #192]	; (80082a0 <BSP_TEMPERATURE_Init+0x1b4>)
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pVTable       = ( void * )&LPS22HB_T_Drv;
 80081e0:	6220      	str	r0, [r4, #32]
  *handle = (void *)&TEMPERATURE_SensorHandle[ LPS22HB_T_0 ];
 80081e2:	3b1c      	subs	r3, #28
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].ifType        = 0; /* I2C interface */
 80081e4:	7565      	strb	r5, [r4, #21]
  TEMPERATURE_Data[ LPS22HB_T_0 ].pExtData       = 0;
 80081e6:	6365      	str	r5, [r4, #52]	; 0x34
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].instance      = LPS22HB_T_0;
 80081e8:	61a7      	str	r7, [r4, #24]
  TEMPERATURE_SensorHandle[ LPS22HB_T_0 ].pExtVTable    = ( void * )&LPS22HB_T_ExtDrv;
 80081ea:	6261      	str	r1, [r4, #36]	; 0x24
  LPS22HB_T_0_Data.comboData = &LPS22HB_Combo_Data[0];
 80081ec:	63e2      	str	r2, [r4, #60]	; 0x3c
  *handle = (void *)&TEMPERATURE_SensorHandle[ LPS22HB_T_0 ];
 80081ee:	6033      	str	r3, [r6, #0]
  if ( driver->Init == NULL )
 80081f0:	6a22      	ldr	r2, [r4, #32]
 80081f2:	6812      	ldr	r2, [r2, #0]
 80081f4:	2a00      	cmp	r2, #0
 80081f6:	d1aa      	bne.n	800814e <BSP_TEMPERATURE_Init+0x62>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 80081f8:	2200      	movs	r2, #0
 80081fa:	6162      	str	r2, [r4, #20]
 80081fc:	605a      	str	r2, [r3, #4]
 80081fe:	609a      	str	r2, [r3, #8]
 8008200:	60da      	str	r2, [r3, #12]
 8008202:	611a      	str	r2, [r3, #16]
          return COMPONENT_ERROR;
 8008204:	2001      	movs	r0, #1
    *handle = NULL;
 8008206:	6032      	str	r2, [r6, #0]
 8008208:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if(TEMPERATURE_SensorHandle[ HTS221_T_0 ].isInitialized == 1)
 800820a:	4d23      	ldr	r5, [pc, #140]	; (8008298 <BSP_TEMPERATURE_Init+0x1ac>)
 800820c:	796b      	ldrb	r3, [r5, #5]
 800820e:	2b01      	cmp	r3, #1
 8008210:	d003      	beq.n	800821a <BSP_TEMPERATURE_Init+0x12e>
  if ( Sensor_IO_Init() == COMPONENT_ERROR )
 8008212:	f7ff f879 	bl	8007308 <Sensor_IO_Init>
 8008216:	2801      	cmp	r0, #1
 8008218:	d101      	bne.n	800821e <BSP_TEMPERATURE_Init+0x132>
          return COMPONENT_ERROR;
 800821a:	2001      	movs	r0, #1
 800821c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  HTS221_T_0_Data.comboData = &HTS221_Combo_Data[0];
 800821e:	462b      	mov	r3, r5
 8008220:	4a22      	ldr	r2, [pc, #136]	; (80082ac <BSP_TEMPERATURE_Init+0x1c0>)
 8008222:	f843 2f38 	str.w	r2, [r3, #56]!
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].who_am_i      = HTS221_WHO_AM_I_VAL;
 8008226:	27bc      	movs	r7, #188	; 0xbc
  TEMPERATURE_Data[ HTS221_T_0 ].pComponentData = ( void * )&HTS221_T_0_Data;
 8008228:	62ab      	str	r3, [r5, #40]	; 0x28
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].address       = HTS221_ADDRESS_DEFAULT;
 800822a:	20be      	movs	r0, #190	; 0xbe
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pVTable       = ( void * )&HTS221_T_Drv;
 800822c:	4b20      	ldr	r3, [pc, #128]	; (80082b0 <BSP_TEMPERATURE_Init+0x1c4>)
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].ifType        = 0; /* I2C interface */
 800822e:	706c      	strb	r4, [r5, #1]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].instance      = HTS221_T_0;
 8008230:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pData         = ( void * )&TEMPERATURE_Data[ HTS221_T_0 ];
 8008234:	f105 0228 	add.w	r2, r5, #40	; 0x28
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].who_am_i      = HTS221_WHO_AM_I_VAL;
 8008238:	702f      	strb	r7, [r5, #0]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].address       = HTS221_ADDRESS_DEFAULT;
 800823a:	70a8      	strb	r0, [r5, #2]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].instance      = HTS221_T_0;
 800823c:	6069      	str	r1, [r5, #4]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pVTable       = ( void * )&HTS221_T_Drv;
 800823e:	60eb      	str	r3, [r5, #12]
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pExtVTable    = 0;
 8008240:	612c      	str	r4, [r5, #16]
  TEMPERATURE_Data[ HTS221_T_0 ].pExtData       = 0;
 8008242:	62ec      	str	r4, [r5, #44]	; 0x2c
  TEMPERATURE_SensorHandle[ HTS221_T_0 ].pData         = ( void * )&TEMPERATURE_Data[ HTS221_T_0 ];
 8008244:	60aa      	str	r2, [r5, #8]
  *handle = (void *)&TEMPERATURE_SensorHandle[ HTS221_T_0 ];
 8008246:	6035      	str	r5, [r6, #0]
  if ( driver->Init == NULL )
 8008248:	68eb      	ldr	r3, [r5, #12]
 800824a:	681b      	ldr	r3, [r3, #0]
 800824c:	b1e3      	cbz	r3, 8008288 <BSP_TEMPERATURE_Init+0x19c>
  if ( driver->Init( (DrvContextTypeDef *)(*handle) ) == COMPONENT_ERROR )
 800824e:	4628      	mov	r0, r5
 8008250:	4798      	blx	r3
 8008252:	2801      	cmp	r0, #1
 8008254:	d009      	beq.n	800826a <BSP_TEMPERATURE_Init+0x17e>
  return COMPONENT_OK;
 8008256:	2000      	movs	r0, #0
 8008258:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 800825a:	6833      	ldr	r3, [r6, #0]
 800825c:	601d      	str	r5, [r3, #0]
 800825e:	605d      	str	r5, [r3, #4]
 8008260:	609d      	str	r5, [r3, #8]
 8008262:	60dd      	str	r5, [r3, #12]
 8008264:	611d      	str	r5, [r3, #16]
    *handle = NULL;
 8008266:	6035      	str	r5, [r6, #0]
 8008268:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 800826a:	6833      	ldr	r3, [r6, #0]
 800826c:	601c      	str	r4, [r3, #0]
 800826e:	605c      	str	r4, [r3, #4]
 8008270:	609c      	str	r4, [r3, #8]
 8008272:	60dc      	str	r4, [r3, #12]
 8008274:	611c      	str	r4, [r3, #16]
    *handle = NULL;
 8008276:	6034      	str	r4, [r6, #0]
 8008278:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 800827a:	6023      	str	r3, [r4, #0]
 800827c:	6063      	str	r3, [r4, #4]
 800827e:	60a3      	str	r3, [r4, #8]
 8008280:	60e3      	str	r3, [r4, #12]
 8008282:	6123      	str	r3, [r4, #16]
    *handle = NULL;
 8008284:	6033      	str	r3, [r6, #0]
 8008286:	e796      	b.n	80081b6 <BSP_TEMPERATURE_Init+0xca>
    memset((*handle), 0, sizeof(DrvContextTypeDef));
 8008288:	602b      	str	r3, [r5, #0]
 800828a:	606b      	str	r3, [r5, #4]
 800828c:	60ab      	str	r3, [r5, #8]
 800828e:	60eb      	str	r3, [r5, #12]
 8008290:	612b      	str	r3, [r5, #16]
        return COMPONENT_ERROR;
 8008292:	2001      	movs	r0, #1
    *handle = NULL;
 8008294:	6033      	str	r3, [r6, #0]
 8008296:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008298:	200006bc 	.word	0x200006bc
 800829c:	20000758 	.word	0x20000758
 80082a0:	20000068 	.word	0x20000068
 80082a4:	01000001 	.word	0x01000001
 80082a8:	200000e0 	.word	0x200000e0
 80082ac:	20000754 	.word	0x20000754
 80082b0:	20000000 	.word	0x20000000
 80082b4:	200006ec 	.word	0x200006ec

080082b8 <BSP_TEMPERATURE_Sensor_Enable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  TEMPERATURE_Drv_t *driver = NULL;

  if(ctx == NULL)
 80082b8:	b160      	cbz	r0, 80082d4 <BSP_TEMPERATURE_Sensor_Enable+0x1c>
{
 80082ba:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( TEMPERATURE_Drv_t * )ctx->pVTable;

  if ( driver->Sensor_Enable == NULL )
 80082bc:	68c3      	ldr	r3, [r0, #12]
 80082be:	689b      	ldr	r3, [r3, #8]
 80082c0:	b133      	cbz	r3, 80082d0 <BSP_TEMPERATURE_Sensor_Enable+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Sensor_Enable( ctx ) == COMPONENT_ERROR )
 80082c2:	4798      	blx	r3
    return COMPONENT_ERROR;
 80082c4:	f1a0 0001 	sub.w	r0, r0, #1
 80082c8:	fab0 f080 	clz	r0, r0
 80082cc:	0940      	lsrs	r0, r0, #5
 80082ce:	bd08      	pop	{r3, pc}
 80082d0:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 80082d2:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 80082d4:	2001      	movs	r0, #1
 80082d6:	4770      	bx	lr

080082d8 <BSP_TEMPERATURE_Sensor_Disable>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  TEMPERATURE_Drv_t *driver = NULL;

  if(ctx == NULL)
 80082d8:	b160      	cbz	r0, 80082f4 <BSP_TEMPERATURE_Sensor_Disable+0x1c>
{
 80082da:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( TEMPERATURE_Drv_t * )ctx->pVTable;

  if ( driver->Sensor_Disable == NULL )
 80082dc:	68c3      	ldr	r3, [r0, #12]
 80082de:	68db      	ldr	r3, [r3, #12]
 80082e0:	b133      	cbz	r3, 80082f0 <BSP_TEMPERATURE_Sensor_Disable+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Sensor_Disable( ctx ) == COMPONENT_ERROR )
 80082e2:	4798      	blx	r3
    return COMPONENT_ERROR;
 80082e4:	f1a0 0001 	sub.w	r0, r0, #1
 80082e8:	fab0 f080 	clz	r0, r0
 80082ec:	0940      	lsrs	r0, r0, #5
 80082ee:	bd08      	pop	{r3, pc}
 80082f0:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 80082f2:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 80082f4:	2001      	movs	r0, #1
 80082f6:	4770      	bx	lr

080082f8 <BSP_TEMPERATURE_IsInitialized>:
 */
DrvStatusTypeDef BSP_TEMPERATURE_IsInitialized( void *handle, uint8_t *status )
{
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;

  if(ctx == NULL)
 80082f8:	b120      	cbz	r0, 8008304 <BSP_TEMPERATURE_IsInitialized+0xc>
  {
    return COMPONENT_ERROR;
  }

  if ( status == NULL )
 80082fa:	b119      	cbz	r1, 8008304 <BSP_TEMPERATURE_IsInitialized+0xc>
  {
    return COMPONENT_ERROR;
  }

  *status = ctx->isInitialized;
 80082fc:	7943      	ldrb	r3, [r0, #5]
 80082fe:	700b      	strb	r3, [r1, #0]

  return COMPONENT_OK;
 8008300:	2000      	movs	r0, #0
 8008302:	4770      	bx	lr
    return COMPONENT_ERROR;
 8008304:	2001      	movs	r0, #1
}
 8008306:	4770      	bx	lr

08008308 <BSP_TEMPERATURE_Get_Instance>:
 */
DrvStatusTypeDef BSP_TEMPERATURE_Get_Instance( void *handle, uint8_t *instance )
{
  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;

  if(ctx == NULL)
 8008308:	b120      	cbz	r0, 8008314 <BSP_TEMPERATURE_Get_Instance+0xc>
  {
    return COMPONENT_ERROR;
  }

  if ( instance == NULL )
 800830a:	b119      	cbz	r1, 8008314 <BSP_TEMPERATURE_Get_Instance+0xc>
  {
    return COMPONENT_ERROR;
  }

  *instance = ctx->instance;
 800830c:	7903      	ldrb	r3, [r0, #4]
 800830e:	700b      	strb	r3, [r1, #0]

  return COMPONENT_OK;
 8008310:	2000      	movs	r0, #0
 8008312:	4770      	bx	lr
    return COMPONENT_ERROR;
 8008314:	2001      	movs	r0, #1
}
 8008316:	4770      	bx	lr

08008318 <BSP_TEMPERATURE_Get_Temp>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  TEMPERATURE_Drv_t *driver = NULL;

  if(ctx == NULL)
 8008318:	b168      	cbz	r0, 8008336 <BSP_TEMPERATURE_Get_Temp+0x1e>
{
 800831a:	b508      	push	{r3, lr}
  {
    return COMPONENT_ERROR;
  }

  driver = ( TEMPERATURE_Drv_t * )ctx->pVTable;
 800831c:	68c2      	ldr	r2, [r0, #12]

  if ( temperature == NULL )
 800831e:	b141      	cbz	r1, 8008332 <BSP_TEMPERATURE_Get_Temp+0x1a>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Temp == NULL )
 8008320:	6993      	ldr	r3, [r2, #24]
 8008322:	b133      	cbz	r3, 8008332 <BSP_TEMPERATURE_Get_Temp+0x1a>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Get_Temp( ctx, temperature ) == COMPONENT_ERROR )
 8008324:	4798      	blx	r3
    return COMPONENT_ERROR;
 8008326:	f1a0 0001 	sub.w	r0, r0, #1
 800832a:	fab0 f080 	clz	r0, r0
 800832e:	0940      	lsrs	r0, r0, #5
 8008330:	bd08      	pop	{r3, pc}
 8008332:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8008334:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8008336:	2001      	movs	r0, #1
 8008338:	4770      	bx	lr
 800833a:	bf00      	nop

0800833c <BSP_TEMPERATURE_Set_ODR_Value>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  TEMPERATURE_Drv_t *driver = NULL;

  if(ctx == NULL)
 800833c:	b160      	cbz	r0, 8008358 <BSP_TEMPERATURE_Set_ODR_Value+0x1c>
{
 800833e:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( TEMPERATURE_Drv_t * )ctx->pVTable;

  if ( driver->Set_ODR_Value == NULL )
 8008340:	68c3      	ldr	r3, [r0, #12]
 8008342:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008344:	b133      	cbz	r3, 8008354 <BSP_TEMPERATURE_Set_ODR_Value+0x18>
  {
    return COMPONENT_ERROR;
  }
  if ( driver->Set_ODR_Value( ctx, odr ) == COMPONENT_ERROR )
 8008346:	4798      	blx	r3
    return COMPONENT_ERROR;
 8008348:	f1a0 0001 	sub.w	r0, r0, #1
 800834c:	fab0 f080 	clz	r0, r0
 8008350:	0940      	lsrs	r0, r0, #5
 8008352:	bd08      	pop	{r3, pc}
 8008354:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8008356:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 8008358:	2001      	movs	r0, #1
 800835a:	4770      	bx	lr

0800835c <BSP_TEMPERATURE_Read_Reg>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  TEMPERATURE_Drv_t *driver = NULL;

  if(ctx == NULL)
 800835c:	b168      	cbz	r0, 800837a <BSP_TEMPERATURE_Read_Reg+0x1e>
{
 800835e:	b510      	push	{r4, lr}
  {
    return COMPONENT_ERROR;
  }

  driver = ( TEMPERATURE_Drv_t * )ctx->pVTable;
 8008360:	68c4      	ldr	r4, [r0, #12]

  if(data == NULL)
 8008362:	b142      	cbz	r2, 8008376 <BSP_TEMPERATURE_Read_Reg+0x1a>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Read_Reg == NULL )
 8008364:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8008366:	b133      	cbz	r3, 8008376 <BSP_TEMPERATURE_Read_Reg+0x1a>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Read_Reg( ctx, reg, data ) == COMPONENT_ERROR )
 8008368:	4798      	blx	r3
    return COMPONENT_ERROR;
 800836a:	f1a0 0001 	sub.w	r0, r0, #1
 800836e:	fab0 f080 	clz	r0, r0
 8008372:	0940      	lsrs	r0, r0, #5
 8008374:	bd10      	pop	{r4, pc}
 8008376:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 8008378:	bd10      	pop	{r4, pc}
    return COMPONENT_ERROR;
 800837a:	2001      	movs	r0, #1
 800837c:	4770      	bx	lr
 800837e:	bf00      	nop

08008380 <BSP_TEMPERATURE_Write_Reg>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  TEMPERATURE_Drv_t *driver = NULL;

  if(ctx == NULL)
 8008380:	b160      	cbz	r0, 800839c <BSP_TEMPERATURE_Write_Reg+0x1c>
{
 8008382:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( TEMPERATURE_Drv_t * )ctx->pVTable;

  if ( driver->Write_Reg == NULL )
 8008384:	68c3      	ldr	r3, [r0, #12]
 8008386:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8008388:	b133      	cbz	r3, 8008398 <BSP_TEMPERATURE_Write_Reg+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Write_Reg( ctx, reg, data ) == COMPONENT_ERROR )
 800838a:	4798      	blx	r3
    return COMPONENT_ERROR;
 800838c:	f1a0 0001 	sub.w	r0, r0, #1
 8008390:	fab0 f080 	clz	r0, r0
 8008394:	0940      	lsrs	r0, r0, #5
 8008396:	bd08      	pop	{r3, pc}
 8008398:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 800839a:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 800839c:	2001      	movs	r0, #1
 800839e:	4770      	bx	lr

080083a0 <BSP_TEMPERATURE_Get_DRDY_Status>:
{

  DrvContextTypeDef *ctx = (DrvContextTypeDef *)handle;
  TEMPERATURE_Drv_t *driver = NULL;

  if(ctx == NULL)
 80083a0:	b160      	cbz	r0, 80083bc <BSP_TEMPERATURE_Get_DRDY_Status+0x1c>
{
 80083a2:	b508      	push	{r3, lr}
    return COMPONENT_ERROR;
  }

  driver = ( TEMPERATURE_Drv_t * )ctx->pVTable;

  if ( driver->Get_DRDY_Status == NULL )
 80083a4:	68c3      	ldr	r3, [r0, #12]
 80083a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80083a8:	b133      	cbz	r3, 80083b8 <BSP_TEMPERATURE_Get_DRDY_Status+0x18>
  {
    return COMPONENT_ERROR;
  }

  if ( driver->Get_DRDY_Status( ctx, status ) == COMPONENT_ERROR )
 80083aa:	4798      	blx	r3
    return COMPONENT_ERROR;
 80083ac:	f1a0 0001 	sub.w	r0, r0, #1
 80083b0:	fab0 f080 	clz	r0, r0
 80083b4:	0940      	lsrs	r0, r0, #5
 80083b6:	bd08      	pop	{r3, pc}
 80083b8:	2001      	movs	r0, #1
  {
    return COMPONENT_ERROR;
  }

  return COMPONENT_OK;
}
 80083ba:	bd08      	pop	{r3, pc}
    return COMPONENT_ERROR;
 80083bc:	2001      	movs	r0, #1
 80083be:	4770      	bx	lr

080083c0 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80083c0:	4910      	ldr	r1, [pc, #64]	; (8008404 <SystemInit+0x44>)
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80083c2:	4b11      	ldr	r3, [pc, #68]	; (8008408 <SystemInit+0x48>)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80083c4:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80083c8:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
{
 80083cc:	b410      	push	{r4}
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80083ce:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  RCC->CR |= (uint32_t)0x00000001;
 80083d2:	681a      	ldr	r2, [r3, #0]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80083d4:	4c0d      	ldr	r4, [pc, #52]	; (800840c <SystemInit+0x4c>)
  RCC->CFGR = 0x00000000;
 80083d6:	2000      	movs	r0, #0
  RCC->CR |= (uint32_t)0x00000001;
 80083d8:	f042 0201 	orr.w	r2, r2, #1
 80083dc:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 80083de:	6098      	str	r0, [r3, #8]
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80083e0:	681a      	ldr	r2, [r3, #0]
 80083e2:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 80083e6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80083ea:	601a      	str	r2, [r3, #0]
  RCC->PLLCFGR = 0x24003010;
 80083ec:	605c      	str	r4, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80083ee:	681a      	ldr	r2, [r3, #0]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80083f0:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80083f4:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80083f8:	601a      	str	r2, [r3, #0]
  RCC->CIR = 0x00000000;
 80083fa:	60d8      	str	r0, [r3, #12]
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80083fc:	608c      	str	r4, [r1, #8]
#endif
}
 80083fe:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008402:	4770      	bx	lr
 8008404:	e000ed00 	.word	0xe000ed00
 8008408:	40023800 	.word	0x40023800
 800840c:	24003010 	.word	0x24003010

08008410 <HAL_MspInit>:
 8008410:	4770      	bx	lr
 8008412:	bf00      	nop

08008414 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8008414:	b570      	push	{r4, r5, r6, lr}
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8008416:	4b0e      	ldr	r3, [pc, #56]	; (8008450 <HAL_InitTick+0x3c>)
 8008418:	4d0e      	ldr	r5, [pc, #56]	; (8008454 <HAL_InitTick+0x40>)
 800841a:	681b      	ldr	r3, [r3, #0]
 800841c:	782a      	ldrb	r2, [r5, #0]
{
 800841e:	4606      	mov	r6, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8008420:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008424:	fbb0 f0f2 	udiv	r0, r0, r2
 8008428:	fbb3 f0f0 	udiv	r0, r3, r0
 800842c:	f000 f8a6 	bl	800857c <HAL_SYSTICK_Config>
 8008430:	b908      	cbnz	r0, 8008436 <HAL_InitTick+0x22>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8008432:	2e0f      	cmp	r6, #15
 8008434:	d901      	bls.n	800843a <HAL_InitTick+0x26>
    return HAL_ERROR;
 8008436:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
 8008438:	bd70      	pop	{r4, r5, r6, pc}
 800843a:	4604      	mov	r4, r0
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800843c:	4602      	mov	r2, r0
 800843e:	4631      	mov	r1, r6
 8008440:	f04f 30ff 	mov.w	r0, #4294967295
 8008444:	f000 f858 	bl	80084f8 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8008448:	606e      	str	r6, [r5, #4]
 800844a:	4620      	mov	r0, r4
 800844c:	bd70      	pop	{r4, r5, r6, pc}
 800844e:	bf00      	nop
 8008450:	2000039c 	.word	0x2000039c
 8008454:	200003a0 	.word	0x200003a0

08008458 <HAL_Init>:
{
 8008458:	b508      	push	{r3, lr}
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 800845a:	4b0b      	ldr	r3, [pc, #44]	; (8008488 <HAL_Init+0x30>)
 800845c:	681a      	ldr	r2, [r3, #0]
 800845e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8008462:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8008464:	681a      	ldr	r2, [r3, #0]
 8008466:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800846a:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800846c:	681a      	ldr	r2, [r3, #0]
 800846e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8008472:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8008474:	2003      	movs	r0, #3
 8008476:	f000 f82d 	bl	80084d4 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 800847a:	200f      	movs	r0, #15
 800847c:	f7ff ffca 	bl	8008414 <HAL_InitTick>
  HAL_MspInit();
 8008480:	f7ff ffc6 	bl	8008410 <HAL_MspInit>
}
 8008484:	2000      	movs	r0, #0
 8008486:	bd08      	pop	{r3, pc}
 8008488:	40023c00 	.word	0x40023c00

0800848c <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 800848c:	4a03      	ldr	r2, [pc, #12]	; (800849c <HAL_IncTick+0x10>)
 800848e:	4b04      	ldr	r3, [pc, #16]	; (80084a0 <HAL_IncTick+0x14>)
 8008490:	6811      	ldr	r1, [r2, #0]
 8008492:	781b      	ldrb	r3, [r3, #0]
 8008494:	440b      	add	r3, r1
 8008496:	6013      	str	r3, [r2, #0]
 8008498:	4770      	bx	lr
 800849a:	bf00      	nop
 800849c:	20000768 	.word	0x20000768
 80084a0:	200003a0 	.word	0x200003a0

080084a4 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80084a4:	4b01      	ldr	r3, [pc, #4]	; (80084ac <HAL_GetTick+0x8>)
 80084a6:	6818      	ldr	r0, [r3, #0]
}
 80084a8:	4770      	bx	lr
 80084aa:	bf00      	nop
 80084ac:	20000768 	.word	0x20000768

080084b0 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 80084b0:	b538      	push	{r3, r4, r5, lr}
 80084b2:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 80084b4:	f7ff fff6 	bl	80084a4 <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 80084b8:	1c63      	adds	r3, r4, #1
  uint32_t tickstart = HAL_GetTick();
 80084ba:	4605      	mov	r5, r0
  if (wait < HAL_MAX_DELAY)
 80084bc:	d002      	beq.n	80084c4 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 80084be:	4b04      	ldr	r3, [pc, #16]	; (80084d0 <HAL_Delay+0x20>)
 80084c0:	781b      	ldrb	r3, [r3, #0]
 80084c2:	441c      	add	r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 80084c4:	f7ff ffee 	bl	80084a4 <HAL_GetTick>
 80084c8:	1b40      	subs	r0, r0, r5
 80084ca:	4284      	cmp	r4, r0
 80084cc:	d8fa      	bhi.n	80084c4 <HAL_Delay+0x14>
  {
  }
}
 80084ce:	bd38      	pop	{r3, r4, r5, pc}
 80084d0:	200003a0 	.word	0x200003a0

080084d4 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80084d4:	4a07      	ldr	r2, [pc, #28]	; (80084f4 <HAL_NVIC_SetPriorityGrouping+0x20>)
 80084d6:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80084d8:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 80084dc:	400b      	ands	r3, r1
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 80084de:	0200      	lsls	r0, r0, #8
 80084e0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80084e4:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 80084e8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
 80084ec:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 80084ee:	60d3      	str	r3, [r2, #12]
 80084f0:	4770      	bx	lr
 80084f2:	bf00      	nop
 80084f4:	e000ed00 	.word	0xe000ed00

080084f8 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80084f8:	4b18      	ldr	r3, [pc, #96]	; (800855c <HAL_NVIC_SetPriority+0x64>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80084fa:	b470      	push	{r4, r5, r6}
 80084fc:	68dc      	ldr	r4, [r3, #12]
 80084fe:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8008502:	f1c4 0607 	rsb	r6, r4, #7
 8008506:	2e04      	cmp	r6, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8008508:	f104 0304 	add.w	r3, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800850c:	bf28      	it	cs
 800850e:	2604      	movcs	r6, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8008510:	2b06      	cmp	r3, #6
 8008512:	d917      	bls.n	8008544 <HAL_NVIC_SetPriority+0x4c>
 8008514:	3c03      	subs	r4, #3
 8008516:	2501      	movs	r5, #1
 8008518:	40a5      	lsls	r5, r4
 800851a:	3d01      	subs	r5, #1
 800851c:	402a      	ands	r2, r5

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800851e:	2301      	movs	r3, #1
 8008520:	40b3      	lsls	r3, r6
 8008522:	3b01      	subs	r3, #1
 8008524:	4019      	ands	r1, r3
 8008526:	40a1      	lsls	r1, r4
  if ((int32_t)(IRQn) < 0)
 8008528:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800852a:	ea41 0102 	orr.w	r1, r1, r2
  if ((int32_t)(IRQn) < 0)
 800852e:	db0c      	blt.n	800854a <HAL_NVIC_SetPriority+0x52>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8008530:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8008534:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8008538:	0109      	lsls	r1, r1, #4
 800853a:	b2c9      	uxtb	r1, r1
 800853c:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8008540:	bc70      	pop	{r4, r5, r6}
 8008542:	4770      	bx	lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8008544:	2200      	movs	r2, #0
 8008546:	4614      	mov	r4, r2
 8008548:	e7e9      	b.n	800851e <HAL_NVIC_SetPriority+0x26>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800854a:	4b05      	ldr	r3, [pc, #20]	; (8008560 <HAL_NVIC_SetPriority+0x68>)
 800854c:	f000 000f 	and.w	r0, r0, #15
 8008550:	0109      	lsls	r1, r1, #4
 8008552:	4403      	add	r3, r0
 8008554:	b2c9      	uxtb	r1, r1
 8008556:	7619      	strb	r1, [r3, #24]
 8008558:	bc70      	pop	{r4, r5, r6}
 800855a:	4770      	bx	lr
 800855c:	e000ed00 	.word	0xe000ed00
 8008560:	e000ecfc 	.word	0xe000ecfc

08008564 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8008564:	f000 011f 	and.w	r1, r0, #31
 8008568:	2301      	movs	r3, #1
 800856a:	0940      	lsrs	r0, r0, #5
 800856c:	4a02      	ldr	r2, [pc, #8]	; (8008578 <HAL_NVIC_EnableIRQ+0x14>)
 800856e:	408b      	lsls	r3, r1
 8008570:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
 8008574:	4770      	bx	lr
 8008576:	bf00      	nop
 8008578:	e000e100 	.word	0xe000e100

0800857c <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800857c:	3801      	subs	r0, #1
 800857e:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8008582:	d20e      	bcs.n	80085a2 <HAL_SYSTICK_Config+0x26>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8008584:	4b08      	ldr	r3, [pc, #32]	; (80085a8 <HAL_SYSTICK_Config+0x2c>)
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8008586:	b410      	push	{r4}
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8008588:	4c08      	ldr	r4, [pc, #32]	; (80085ac <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800858a:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800858c:	20f0      	movs	r0, #240	; 0xf0
 800858e:	f884 0023 	strb.w	r0, [r4, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8008592:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8008594:	2107      	movs	r1, #7
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8008596:	4610      	mov	r0, r2
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8008598:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800859a:	6019      	str	r1, [r3, #0]
   return SysTick_Config(TicksNumb);
}
 800859c:	f85d 4b04 	ldr.w	r4, [sp], #4
 80085a0:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 80085a2:	2001      	movs	r0, #1
   return SysTick_Config(TicksNumb);
 80085a4:	4770      	bx	lr
 80085a6:	bf00      	nop
 80085a8:	e000e010 	.word	0xe000e010
 80085ac:	e000ed00 	.word	0xe000ed00

080085b0 <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 80085b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80085b2:	4604      	mov	r4, r0
  uint32_t tmp = 0U;
  uint32_t tickstart = HAL_GetTick();
 80085b4:	f7ff ff76 	bl	80084a4 <HAL_GetTick>
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 80085b8:	2c00      	cmp	r4, #0
 80085ba:	d073      	beq.n	80086a4 <HAL_DMA_Init+0xf4>
  
  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 80085bc:	2202      	movs	r2, #2
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 80085be:	6823      	ldr	r3, [r4, #0]
  hdma->State = HAL_DMA_STATE_BUSY;
 80085c0:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
  __HAL_DMA_DISABLE(hdma);
 80085c4:	681a      	ldr	r2, [r3, #0]
  __HAL_UNLOCK(hdma);
 80085c6:	2100      	movs	r1, #0
  __HAL_DMA_DISABLE(hdma);
 80085c8:	f022 0201 	bic.w	r2, r2, #1
  __HAL_UNLOCK(hdma);
 80085cc:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
 80085d0:	4605      	mov	r5, r0
  __HAL_DMA_DISABLE(hdma);
 80085d2:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 80085d4:	e005      	b.n	80085e2 <HAL_DMA_Init+0x32>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 80085d6:	f7ff ff65 	bl	80084a4 <HAL_GetTick>
 80085da:	1b40      	subs	r0, r0, r5
 80085dc:	2805      	cmp	r0, #5
 80085de:	d83b      	bhi.n	8008658 <HAL_DMA_Init+0xa8>
 80085e0:	6823      	ldr	r3, [r4, #0]
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 80085e2:	681a      	ldr	r2, [r3, #0]
 80085e4:	07d1      	lsls	r1, r2, #31
 80085e6:	d4f6      	bmi.n	80085d6 <HAL_DMA_Init+0x26>
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 80085e8:	68a7      	ldr	r7, [r4, #8]
 80085ea:	6862      	ldr	r2, [r4, #4]
 80085ec:	68e6      	ldr	r6, [r4, #12]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80085ee:	6925      	ldr	r5, [r4, #16]
 80085f0:	6961      	ldr	r1, [r4, #20]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80085f2:	69a0      	ldr	r0, [r4, #24]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 80085f4:	433a      	orrs	r2, r7
 80085f6:	4332      	orrs	r2, r6
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80085f8:	432a      	orrs	r2, r5
 80085fa:	430a      	orrs	r2, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80085fc:	69e1      	ldr	r1, [r4, #28]
          hdma->Init.Mode                | hdma->Init.Priority;
 80085fe:	6a25      	ldr	r5, [r4, #32]
  tmp = hdma->Instance->CR;
 8008600:	681f      	ldr	r7, [r3, #0]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8008602:	4e35      	ldr	r6, [pc, #212]	; (80086d8 <HAL_DMA_Init+0x128>)
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8008604:	4302      	orrs	r2, r0
 8008606:	430a      	orrs	r2, r1

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8008608:	6a61      	ldr	r1, [r4, #36]	; 0x24
          hdma->Init.Mode                | hdma->Init.Priority;
 800860a:	432a      	orrs	r2, r5
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 800860c:	403e      	ands	r6, r7
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800860e:	2904      	cmp	r1, #4
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8008610:	ea42 0206 	orr.w	r2, r2, r6
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8008614:	d027      	beq.n	8008666 <HAL_DMA_Init+0xb6>
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 8008616:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 8008618:	695a      	ldr	r2, [r3, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 800861a:	f022 0207 	bic.w	r2, r2, #7

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 800861e:	4311      	orrs	r1, r2
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8008620:	b2da      	uxtb	r2, r3
 8008622:	4d2e      	ldr	r5, [pc, #184]	; (80086dc <HAL_DMA_Init+0x12c>)
  hdma->Instance->FCR = tmp;
 8008624:	6159      	str	r1, [r3, #20]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8008626:	3a10      	subs	r2, #16
 8008628:	fba5 1202 	umull	r1, r2, r5, r2
 800862c:	0912      	lsrs	r2, r2, #4
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 800862e:	482c      	ldr	r0, [pc, #176]	; (80086e0 <HAL_DMA_Init+0x130>)
  
  if (stream_number > 3U)
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8008630:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8008634:	5c81      	ldrb	r1, [r0, r2]
 8008636:	65e1      	str	r1, [r4, #92]	; 0x5c
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8008638:	f023 0303 	bic.w	r3, r3, #3
  if (stream_number > 3U)
 800863c:	2a03      	cmp	r2, #3
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 800863e:	bf88      	it	hi
 8008640:	3304      	addhi	r3, #4
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8008642:	223f      	movs	r2, #63	; 0x3f
 8008644:	408a      	lsls	r2, r1
  hdma->State = HAL_DMA_STATE_READY;
 8008646:	2501      	movs	r5, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8008648:	2100      	movs	r1, #0
 800864a:	65a3      	str	r3, [r4, #88]	; 0x58
  return HAL_OK;
 800864c:	4608      	mov	r0, r1
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 800864e:	609a      	str	r2, [r3, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8008650:	6561      	str	r1, [r4, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
 8008652:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
  return HAL_OK;
 8008656:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 8008658:	2303      	movs	r3, #3
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 800865a:	2220      	movs	r2, #32
 800865c:	6562      	str	r2, [r4, #84]	; 0x54
      return HAL_TIMEOUT;
 800865e:	4618      	mov	r0, r3
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 8008660:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      return HAL_TIMEOUT;
 8008664:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8008666:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
 8008668:	6b21      	ldr	r1, [r4, #48]	; 0x30
    tmp |= hdma->Init.FIFOThreshold;
 800866a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 800866c:	4329      	orrs	r1, r5
 800866e:	430a      	orrs	r2, r1
  hdma->Instance->CR = tmp;  
 8008670:	601a      	str	r2, [r3, #0]
  tmp = hdma->Instance->FCR;
 8008672:	695a      	ldr	r2, [r3, #20]
    tmp |= hdma->Init.FIFOThreshold;
 8008674:	f046 0104 	orr.w	r1, r6, #4
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8008678:	f022 0207 	bic.w	r2, r2, #7
    tmp |= hdma->Init.FIFOThreshold;
 800867c:	4311      	orrs	r1, r2
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 800867e:	2d00      	cmp	r5, #0
 8008680:	d0ce      	beq.n	8008620 <HAL_DMA_Init+0x70>
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 8008682:	b188      	cbz	r0, 80086a8 <HAL_DMA_Init+0xf8>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8008684:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 8008688:	d018      	beq.n	80086bc <HAL_DMA_Init+0x10c>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 800868a:	2e02      	cmp	r6, #2
 800868c:	d903      	bls.n	8008696 <HAL_DMA_Init+0xe6>
 800868e:	2e03      	cmp	r6, #3
 8008690:	d1c6      	bne.n	8008620 <HAL_DMA_Init+0x70>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8008692:	01ea      	lsls	r2, r5, #7
 8008694:	d5c4      	bpl.n	8008620 <HAL_DMA_Init+0x70>
        hdma->State = HAL_DMA_STATE_READY;
 8008696:	2301      	movs	r3, #1
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8008698:	2240      	movs	r2, #64	; 0x40
 800869a:	6562      	str	r2, [r4, #84]	; 0x54
        return HAL_ERROR; 
 800869c:	4618      	mov	r0, r3
        hdma->State = HAL_DMA_STATE_READY;
 800869e:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 80086a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 80086a4:	2001      	movs	r0, #1
 80086a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch (tmp)
 80086a8:	2e01      	cmp	r6, #1
 80086aa:	d003      	beq.n	80086b4 <HAL_DMA_Init+0x104>
 80086ac:	d3f1      	bcc.n	8008692 <HAL_DMA_Init+0xe2>
 80086ae:	2e02      	cmp	r6, #2
 80086b0:	d1b6      	bne.n	8008620 <HAL_DMA_Init+0x70>
 80086b2:	e7ee      	b.n	8008692 <HAL_DMA_Init+0xe2>
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 80086b4:	f1b5 7fc0 	cmp.w	r5, #25165824	; 0x1800000
 80086b8:	d1b2      	bne.n	8008620 <HAL_DMA_Init+0x70>
 80086ba:	e7ec      	b.n	8008696 <HAL_DMA_Init+0xe6>
    switch (tmp)
 80086bc:	2e03      	cmp	r6, #3
 80086be:	d8af      	bhi.n	8008620 <HAL_DMA_Init+0x70>
 80086c0:	a201      	add	r2, pc, #4	; (adr r2, 80086c8 <HAL_DMA_Init+0x118>)
 80086c2:	f852 f026 	ldr.w	pc, [r2, r6, lsl #2]
 80086c6:	bf00      	nop
 80086c8:	08008697 	.word	0x08008697
 80086cc:	08008693 	.word	0x08008693
 80086d0:	08008697 	.word	0x08008697
 80086d4:	080086b5 	.word	0x080086b5
 80086d8:	f010803f 	.word	0xf010803f
 80086dc:	aaaaaaab 	.word	0xaaaaaaab
 80086e0:	0800d558 	.word	0x0800d558

080086e4 <HAL_DMA_Start_IT>:
{
 80086e4:	b4f0      	push	{r4, r5, r6, r7}
  __HAL_LOCK(hdma);
 80086e6:	f890 4034 	ldrb.w	r4, [r0, #52]	; 0x34
 80086ea:	2c01      	cmp	r4, #1
 80086ec:	d00d      	beq.n	800870a <HAL_DMA_Start_IT+0x26>
  if(HAL_DMA_STATE_READY == hdma->State)
 80086ee:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 80086f2:	6d86      	ldr	r6, [r0, #88]	; 0x58
  __HAL_LOCK(hdma);
 80086f4:	2501      	movs	r5, #1
  if(HAL_DMA_STATE_READY == hdma->State)
 80086f6:	42ac      	cmp	r4, r5
  __HAL_LOCK(hdma);
 80086f8:	f880 5034 	strb.w	r5, [r0, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
 80086fc:	d008      	beq.n	8008710 <HAL_DMA_Start_IT+0x2c>
    __HAL_UNLOCK(hdma);	  
 80086fe:	2300      	movs	r3, #0
 8008700:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
    status = HAL_BUSY;
 8008704:	2002      	movs	r0, #2
}
 8008706:	bcf0      	pop	{r4, r5, r6, r7}
 8008708:	4770      	bx	lr
  __HAL_LOCK(hdma);
 800870a:	2002      	movs	r0, #2
}
 800870c:	bcf0      	pop	{r4, r5, r6, r7}
 800870e:	4770      	bx	lr
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8008710:	6804      	ldr	r4, [r0, #0]
    hdma->State = HAL_DMA_STATE_BUSY;
 8008712:	2702      	movs	r7, #2
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8008714:	2500      	movs	r5, #0
    hdma->State = HAL_DMA_STATE_BUSY;
 8008716:	f880 7035 	strb.w	r7, [r0, #53]	; 0x35
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800871a:	6545      	str	r5, [r0, #84]	; 0x54
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 800871c:	6825      	ldr	r5, [r4, #0]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 800871e:	6887      	ldr	r7, [r0, #8]
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8008720:	f425 2580 	bic.w	r5, r5, #262144	; 0x40000
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8008724:	2f40      	cmp	r7, #64	; 0x40
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8008726:	6025      	str	r5, [r4, #0]
  hdma->Instance->NDTR = DataLength;
 8008728:	6063      	str	r3, [r4, #4]
    hdma->Instance->PAR = DstAddress;
 800872a:	bf0a      	itet	eq
 800872c:	60a2      	streq	r2, [r4, #8]
    hdma->Instance->PAR = SrcAddress;
 800872e:	60a1      	strne	r1, [r4, #8]
    hdma->Instance->M0AR = SrcAddress;
 8008730:	60e1      	streq	r1, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8008732:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
    hdma->Instance->M0AR = DstAddress;
 8008734:	bf18      	it	ne
 8008736:	60e2      	strne	r2, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8008738:	233f      	movs	r3, #63	; 0x3f
 800873a:	408b      	lsls	r3, r1
    if(hdma->XferHalfCpltCallback != NULL)
 800873c:	6c02      	ldr	r2, [r0, #64]	; 0x40
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 800873e:	60b3      	str	r3, [r6, #8]
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 8008740:	6823      	ldr	r3, [r4, #0]
 8008742:	f043 0316 	orr.w	r3, r3, #22
 8008746:	6023      	str	r3, [r4, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
 8008748:	6963      	ldr	r3, [r4, #20]
 800874a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800874e:	6163      	str	r3, [r4, #20]
    if(hdma->XferHalfCpltCallback != NULL)
 8008750:	b11a      	cbz	r2, 800875a <HAL_DMA_Start_IT+0x76>
      hdma->Instance->CR  |= DMA_IT_HT;
 8008752:	6823      	ldr	r3, [r4, #0]
 8008754:	f043 0308 	orr.w	r3, r3, #8
 8008758:	6023      	str	r3, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
 800875a:	6823      	ldr	r3, [r4, #0]
 800875c:	f043 0301 	orr.w	r3, r3, #1
 8008760:	6023      	str	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8008762:	2000      	movs	r0, #0
 8008764:	e7cf      	b.n	8008706 <HAL_DMA_Start_IT+0x22>
 8008766:	bf00      	nop

08008768 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8008768:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800876c:	f8d1 c000 	ldr.w	ip, [r1]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8008770:	f8df e1cc 	ldr.w	lr, [pc, #460]	; 8008940 <HAL_GPIO_Init+0x1d8>
{
 8008774:	b083      	sub	sp, #12
  for(position = 0U; position < GPIO_NUMBER; position++)
 8008776:	2500      	movs	r5, #0
    ioposition = 0x01U << position;
 8008778:	f04f 0801 	mov.w	r8, #1
 800877c:	e003      	b.n	8008786 <HAL_GPIO_Init+0x1e>
  for(position = 0U; position < GPIO_NUMBER; position++)
 800877e:	3501      	adds	r5, #1
 8008780:	2d10      	cmp	r5, #16
 8008782:	f000 8087 	beq.w	8008894 <HAL_GPIO_Init+0x12c>
    ioposition = 0x01U << position;
 8008786:	fa08 f305 	lsl.w	r3, r8, r5
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 800878a:	ea03 020c 	and.w	r2, r3, ip
    if(iocurrent == ioposition)
 800878e:	4293      	cmp	r3, r2
 8008790:	d1f5      	bne.n	800877e <HAL_GPIO_Init+0x16>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8008792:	684e      	ldr	r6, [r1, #4]
 8008794:	f026 0a10 	bic.w	sl, r6, #16
 8008798:	f1ba 0f02 	cmp.w	sl, #2
 800879c:	d07d      	beq.n	800889a <HAL_GPIO_Init+0x132>
 800879e:	ea4f 0945 	mov.w	r9, r5, lsl #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80087a2:	2403      	movs	r4, #3
      temp = GPIOx->MODER;
 80087a4:	f8d0 b000 	ldr.w	fp, [r0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80087a8:	fa04 f409 	lsl.w	r4, r4, r9
 80087ac:	43e4      	mvns	r4, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80087ae:	f006 0703 	and.w	r7, r6, #3
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80087b2:	ea0b 0b04 	and.w	fp, fp, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80087b6:	fa07 f709 	lsl.w	r7, r7, r9
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80087ba:	f10a 3aff 	add.w	sl, sl, #4294967295
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80087be:	ea47 070b 	orr.w	r7, r7, fp
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80087c2:	f1ba 0f01 	cmp.w	sl, #1
      GPIOx->MODER = temp;
 80087c6:	6007      	str	r7, [r0, #0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80087c8:	f240 808e 	bls.w	80088e8 <HAL_GPIO_Init+0x180>
      temp = GPIOx->PUPDR;
 80087cc:	68c7      	ldr	r7, [r0, #12]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 80087ce:	688b      	ldr	r3, [r1, #8]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 80087d0:	403c      	ands	r4, r7
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 80087d2:	fa03 f309 	lsl.w	r3, r3, r9
 80087d6:	4323      	orrs	r3, r4
      GPIOx->PUPDR = temp;
 80087d8:	60c3      	str	r3, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80087da:	00f3      	lsls	r3, r6, #3
 80087dc:	d5cf      	bpl.n	800877e <HAL_GPIO_Init+0x16>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80087de:	2300      	movs	r3, #0
 80087e0:	9301      	str	r3, [sp, #4]
 80087e2:	4b52      	ldr	r3, [pc, #328]	; (800892c <HAL_GPIO_Init+0x1c4>)
 80087e4:	4c51      	ldr	r4, [pc, #324]	; (800892c <HAL_GPIO_Init+0x1c4>)
 80087e6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80087e8:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80087ec:	6463      	str	r3, [r4, #68]	; 0x44
 80087ee:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80087f0:	f025 0703 	bic.w	r7, r5, #3
 80087f4:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 80087f8:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80087fc:	f507 379c 	add.w	r7, r7, #79872	; 0x13800
 8008800:	9301      	str	r3, [sp, #4]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8008802:	f005 0303 	and.w	r3, r5, #3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8008806:	9c01      	ldr	r4, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2U];
 8008808:	f8d7 9008 	ldr.w	r9, [r7, #8]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 800880c:	009b      	lsls	r3, r3, #2
 800880e:	240f      	movs	r4, #15
 8008810:	409c      	lsls	r4, r3
 8008812:	ea29 0a04 	bic.w	sl, r9, r4
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8008816:	4c46      	ldr	r4, [pc, #280]	; (8008930 <HAL_GPIO_Init+0x1c8>)
 8008818:	42a0      	cmp	r0, r4
 800881a:	d078      	beq.n	800890e <HAL_GPIO_Init+0x1a6>
 800881c:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8008820:	42a0      	cmp	r0, r4
 8008822:	d076      	beq.n	8008912 <HAL_GPIO_Init+0x1aa>
 8008824:	4c43      	ldr	r4, [pc, #268]	; (8008934 <HAL_GPIO_Init+0x1cc>)
 8008826:	42a0      	cmp	r0, r4
 8008828:	d076      	beq.n	8008918 <HAL_GPIO_Init+0x1b0>
 800882a:	4c43      	ldr	r4, [pc, #268]	; (8008938 <HAL_GPIO_Init+0x1d0>)
 800882c:	42a0      	cmp	r0, r4
 800882e:	d078      	beq.n	8008922 <HAL_GPIO_Init+0x1ba>
 8008830:	4c42      	ldr	r4, [pc, #264]	; (800893c <HAL_GPIO_Init+0x1d4>)
 8008832:	42a0      	cmp	r0, r4
 8008834:	bf0c      	ite	eq
 8008836:	f04f 0904 	moveq.w	r9, #4
 800883a:	f04f 0907 	movne.w	r9, #7
 800883e:	fa09 f303 	lsl.w	r3, r9, r3
 8008842:	ea43 030a 	orr.w	r3, r3, sl
        SYSCFG->EXTICR[position >> 2U] = temp;
 8008846:	60bb      	str	r3, [r7, #8]
        temp = EXTI->IMR;
 8008848:	f8de 3000 	ldr.w	r3, [lr]
        temp &= ~((uint32_t)iocurrent);
 800884c:	43d4      	mvns	r4, r2
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800884e:	03f7      	lsls	r7, r6, #15
        temp &= ~((uint32_t)iocurrent);
 8008850:	bf54      	ite	pl
 8008852:	4023      	andpl	r3, r4
        {
          temp |= iocurrent;
 8008854:	4313      	orrmi	r3, r2
        }
        EXTI->IMR = temp;
 8008856:	f8ce 3000 	str.w	r3, [lr]

        temp = EXTI->EMR;
 800885a:	f8de 3004 	ldr.w	r3, [lr, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800885e:	03b7      	lsls	r7, r6, #14
        temp &= ~((uint32_t)iocurrent);
 8008860:	bf54      	ite	pl
 8008862:	4023      	andpl	r3, r4
        {
          temp |= iocurrent;
 8008864:	4313      	orrmi	r3, r2
        }
        EXTI->EMR = temp;
 8008866:	f8ce 3004 	str.w	r3, [lr, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800886a:	f8de 3008 	ldr.w	r3, [lr, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800886e:	02f7      	lsls	r7, r6, #11
        temp &= ~((uint32_t)iocurrent);
 8008870:	bf54      	ite	pl
 8008872:	4023      	andpl	r3, r4
        {
          temp |= iocurrent;
 8008874:	4313      	orrmi	r3, r2
        }
        EXTI->RTSR = temp;
 8008876:	f8ce 3008 	str.w	r3, [lr, #8]

        temp = EXTI->FTSR;
 800887a:	f8de 300c 	ldr.w	r3, [lr, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800887e:	02b6      	lsls	r6, r6, #10
  for(position = 0U; position < GPIO_NUMBER; position++)
 8008880:	f105 0501 	add.w	r5, r5, #1
        temp &= ~((uint32_t)iocurrent);
 8008884:	bf54      	ite	pl
 8008886:	4023      	andpl	r3, r4
        {
          temp |= iocurrent;
 8008888:	4313      	orrmi	r3, r2
  for(position = 0U; position < GPIO_NUMBER; position++)
 800888a:	2d10      	cmp	r5, #16
        }
        EXTI->FTSR = temp;
 800888c:	f8ce 300c 	str.w	r3, [lr, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8008890:	f47f af79 	bne.w	8008786 <HAL_GPIO_Init+0x1e>
      }
    }
  }
}
 8008894:	b003      	add	sp, #12
 8008896:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp = GPIOx->AFR[position >> 3U];
 800889a:	ea4f 09d5 	mov.w	r9, r5, lsr #3
 800889e:	eb00 0989 	add.w	r9, r0, r9, lsl #2
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 80088a2:	f005 0407 	and.w	r4, r5, #7
        temp = GPIOx->AFR[position >> 3U];
 80088a6:	f8d9 7020 	ldr.w	r7, [r9, #32]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 80088aa:	00a4      	lsls	r4, r4, #2
 80088ac:	f04f 0b0f 	mov.w	fp, #15
 80088b0:	fa0b fb04 	lsl.w	fp, fp, r4
 80088b4:	ea27 0a0b 	bic.w	sl, r7, fp
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 80088b8:	690f      	ldr	r7, [r1, #16]
 80088ba:	fa07 f404 	lsl.w	r4, r7, r4
 80088be:	ea44 040a 	orr.w	r4, r4, sl
        GPIOx->AFR[position >> 3U] = temp;
 80088c2:	f8c9 4020 	str.w	r4, [r9, #32]
 80088c6:	ea4f 0945 	mov.w	r9, r5, lsl #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80088ca:	2403      	movs	r4, #3
      temp = GPIOx->MODER;
 80088cc:	f8d0 a000 	ldr.w	sl, [r0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80088d0:	fa04 f409 	lsl.w	r4, r4, r9
 80088d4:	43e4      	mvns	r4, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80088d6:	f006 0703 	and.w	r7, r6, #3
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80088da:	ea0a 0a04 	and.w	sl, sl, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80088de:	fa07 f709 	lsl.w	r7, r7, r9
 80088e2:	ea47 070a 	orr.w	r7, r7, sl
      GPIOx->MODER = temp;
 80088e6:	6007      	str	r7, [r0, #0]
        temp = GPIOx->OSPEEDR; 
 80088e8:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 80088ea:	ea07 0a04 	and.w	sl, r7, r4
        temp |= (GPIO_Init->Speed << (position * 2U));
 80088ee:	68cf      	ldr	r7, [r1, #12]
 80088f0:	fa07 f709 	lsl.w	r7, r7, r9
 80088f4:	ea47 070a 	orr.w	r7, r7, sl
        GPIOx->OSPEEDR = temp;
 80088f8:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 80088fa:	f8d0 a004 	ldr.w	sl, [r0, #4]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80088fe:	f3c6 1700 	ubfx	r7, r6, #4, #1
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8008902:	ea2a 0303 	bic.w	r3, sl, r3
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8008906:	40af      	lsls	r7, r5
 8008908:	431f      	orrs	r7, r3
        GPIOx->OTYPER = temp;
 800890a:	6047      	str	r7, [r0, #4]
 800890c:	e75e      	b.n	80087cc <HAL_GPIO_Init+0x64>
 800890e:	2300      	movs	r3, #0
 8008910:	e797      	b.n	8008842 <HAL_GPIO_Init+0xda>
 8008912:	fa08 f303 	lsl.w	r3, r8, r3
 8008916:	e794      	b.n	8008842 <HAL_GPIO_Init+0xda>
 8008918:	f04f 0902 	mov.w	r9, #2
 800891c:	fa09 f303 	lsl.w	r3, r9, r3
 8008920:	e78f      	b.n	8008842 <HAL_GPIO_Init+0xda>
 8008922:	f04f 0903 	mov.w	r9, #3
 8008926:	fa09 f303 	lsl.w	r3, r9, r3
 800892a:	e78a      	b.n	8008842 <HAL_GPIO_Init+0xda>
 800892c:	40023800 	.word	0x40023800
 8008930:	40020000 	.word	0x40020000
 8008934:	40020800 	.word	0x40020800
 8008938:	40020c00 	.word	0x40020c00
 800893c:	40021000 	.word	0x40021000
 8008940:	40013c00 	.word	0x40013c00

08008944 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8008944:	b902      	cbnz	r2, 8008948 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 8008946:	0409      	lsls	r1, r1, #16
 8008948:	6181      	str	r1, [r0, #24]
 800894a:	4770      	bx	lr

0800894c <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 800894c:	6943      	ldr	r3, [r0, #20]
 800894e:	4059      	eors	r1, r3
 8008950:	6141      	str	r1, [r0, #20]
 8008952:	4770      	bx	lr

08008954 <HAL_GPIO_EXTI_IRQHandler>:
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
 8008954:	4a04      	ldr	r2, [pc, #16]	; (8008968 <HAL_GPIO_EXTI_IRQHandler+0x14>)
 8008956:	6951      	ldr	r1, [r2, #20]
 8008958:	4201      	tst	r1, r0
 800895a:	d100      	bne.n	800895e <HAL_GPIO_EXTI_IRQHandler+0xa>
 800895c:	4770      	bx	lr
{
 800895e:	b508      	push	{r3, lr}
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8008960:	6150      	str	r0, [r2, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8008962:	f002 fd0f 	bl	800b384 <HAL_GPIO_EXTI_Callback>
 8008966:	bd08      	pop	{r3, pc}
 8008968:	40013c00 	.word	0x40013c00

0800896c <I2C_WaitOnMasterAddressFlagUntilTimeout.constprop.10>:
  * @param  Flag specifies the I2C flag to check.
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout, uint32_t Tickstart)
 800896c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800896e:	4604      	mov	r4, r0
 8008970:	460d      	mov	r5, r1
 8008972:	4616      	mov	r6, r2
{
  while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 8008974:	6823      	ldr	r3, [r4, #0]
 8008976:	6958      	ldr	r0, [r3, #20]
 8008978:	43c0      	mvns	r0, r0
 800897a:	f010 0002 	ands.w	r0, r0, #2
 800897e:	d026      	beq.n	80089ce <I2C_WaitOnMasterAddressFlagUntilTimeout.constprop.10+0x62>
  {
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008980:	695a      	ldr	r2, [r3, #20]
 8008982:	0551      	lsls	r1, r2, #21
 8008984:	d511      	bpl.n	80089aa <I2C_WaitOnMasterAddressFlagUntilTimeout.constprop.10+0x3e>
    {
      /* Generate Stop */
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8008986:	681a      	ldr	r2, [r3, #0]

      /* Clear AF Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);

      hi2c->ErrorCode = HAL_I2C_ERROR_AF;
      hi2c->PreviousState = I2C_STATE_NONE;
 8008988:	2100      	movs	r1, #0
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800898a:	f46f 6780 	mvn.w	r7, #1024	; 0x400
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 800898e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
      hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8008992:	2604      	movs	r6, #4
      hi2c->State= HAL_I2C_STATE_READY;
 8008994:	2520      	movs	r5, #32
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8008996:	601a      	str	r2, [r3, #0]

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
 8008998:	2001      	movs	r0, #1
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800899a:	615f      	str	r7, [r3, #20]
      hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 800899c:	6426      	str	r6, [r4, #64]	; 0x40
      __HAL_UNLOCK(hi2c);
 800899e:	f884 103c 	strb.w	r1, [r4, #60]	; 0x3c
      hi2c->PreviousState = I2C_STATE_NONE;
 80089a2:	6321      	str	r1, [r4, #48]	; 0x30
      hi2c->State= HAL_I2C_STATE_READY;
 80089a4:	f884 503d 	strb.w	r5, [r4, #61]	; 0x3d
 80089a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 80089aa:	1c6a      	adds	r2, r5, #1
 80089ac:	d0e3      	beq.n	8008976 <I2C_WaitOnMasterAddressFlagUntilTimeout.constprop.10+0xa>
    {
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 80089ae:	b945      	cbnz	r5, 80089c2 <I2C_WaitOnMasterAddressFlagUntilTimeout.constprop.10+0x56>
      {
        hi2c->PreviousState = I2C_STATE_NONE;
 80089b0:	2300      	movs	r3, #0
        hi2c->State= HAL_I2C_STATE_READY;
 80089b2:	2220      	movs	r2, #32
        hi2c->PreviousState = I2C_STATE_NONE;
 80089b4:	6323      	str	r3, [r4, #48]	; 0x30

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 80089b6:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
        hi2c->State= HAL_I2C_STATE_READY;
 80089ba:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d

        return HAL_TIMEOUT;
 80089be:	2003      	movs	r0, #3
 80089c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 80089c2:	f7ff fd6f 	bl	80084a4 <HAL_GetTick>
 80089c6:	1b80      	subs	r0, r0, r6
 80089c8:	4285      	cmp	r5, r0
 80089ca:	d2d3      	bcs.n	8008974 <I2C_WaitOnMasterAddressFlagUntilTimeout.constprop.10+0x8>
 80089cc:	e7f0      	b.n	80089b0 <I2C_WaitOnMasterAddressFlagUntilTimeout.constprop.10+0x44>
      }
    }
  }
  return HAL_OK;
}
 80089ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080089d0 <I2C_RequestMemoryWrite>:
{
 80089d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80089d4:	4605      	mov	r5, r0
  hi2c->Instance->CR1 |= I2C_CR1_START;
 80089d6:	6800      	ldr	r0, [r0, #0]
{
 80089d8:	b082      	sub	sp, #8
 80089da:	4688      	mov	r8, r1
  hi2c->Instance->CR1 |= I2C_CR1_START;
 80089dc:	6801      	ldr	r1, [r0, #0]
{
 80089de:	9c08      	ldr	r4, [sp, #32]
  hi2c->Instance->CR1 |= I2C_CR1_START;
 80089e0:	f441 7180 	orr.w	r1, r1, #256	; 0x100
{
 80089e4:	4616      	mov	r6, r2
 80089e6:	461f      	mov	r7, r3
  hi2c->Instance->CR1 |= I2C_CR1_START;
 80089e8:	6001      	str	r1, [r0, #0]
 80089ea:	1c62      	adds	r2, r4, #1
 80089ec:	d141      	bne.n	8008a72 <I2C_RequestMemoryWrite+0xa2>
  while((__HAL_I2C_GET_FLAG(hi2c, Flag) ? SET : RESET) == Status) 
 80089ee:	6943      	ldr	r3, [r0, #20]
 80089f0:	07db      	lsls	r3, r3, #31
 80089f2:	d5fc      	bpl.n	80089ee <I2C_RequestMemoryWrite+0x1e>
  hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
 80089f4:	f008 01fe 	and.w	r1, r8, #254	; 0xfe
 80089f8:	6101      	str	r1, [r0, #16]
 80089fa:	1c63      	adds	r3, r4, #1
 80089fc:	d014      	beq.n	8008a28 <I2C_RequestMemoryWrite+0x58>
  while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 80089fe:	6943      	ldr	r3, [r0, #20]
 8008a00:	079b      	lsls	r3, r3, #30
 8008a02:	d414      	bmi.n	8008a2e <I2C_RequestMemoryWrite+0x5e>
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008a04:	6943      	ldr	r3, [r0, #20]
 8008a06:	055a      	lsls	r2, r3, #21
 8008a08:	d43f      	bmi.n	8008a8a <I2C_RequestMemoryWrite+0xba>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 8008a0a:	2c00      	cmp	r4, #0
 8008a0c:	f000 8093 	beq.w	8008b36 <I2C_RequestMemoryWrite+0x166>
 8008a10:	f7ff fd48 	bl	80084a4 <HAL_GetTick>
 8008a14:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008a16:	1ac0      	subs	r0, r0, r3
 8008a18:	4284      	cmp	r4, r0
 8008a1a:	f0c0 808c 	bcc.w	8008b36 <I2C_RequestMemoryWrite+0x166>
 8008a1e:	6828      	ldr	r0, [r5, #0]
 8008a20:	e7eb      	b.n	80089fa <I2C_RequestMemoryWrite+0x2a>
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008a22:	6943      	ldr	r3, [r0, #20]
 8008a24:	055a      	lsls	r2, r3, #21
 8008a26:	d430      	bmi.n	8008a8a <I2C_RequestMemoryWrite+0xba>
  while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 8008a28:	6943      	ldr	r3, [r0, #20]
 8008a2a:	0799      	lsls	r1, r3, #30
 8008a2c:	d5f9      	bpl.n	8008a22 <I2C_RequestMemoryWrite+0x52>
  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8008a2e:	2300      	movs	r3, #0
 8008a30:	9301      	str	r3, [sp, #4]
 8008a32:	6943      	ldr	r3, [r0, #20]
 8008a34:	9301      	str	r3, [sp, #4]
 8008a36:	6983      	ldr	r3, [r0, #24]
 8008a38:	9301      	str	r3, [sp, #4]
 8008a3a:	9b01      	ldr	r3, [sp, #4]
 8008a3c:	1c62      	adds	r2, r4, #1
 8008a3e:	d15c      	bne.n	8008afa <I2C_RequestMemoryWrite+0x12a>
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{    
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8008a40:	6943      	ldr	r3, [r0, #20]
 8008a42:	061b      	lsls	r3, r3, #24
 8008a44:	d448      	bmi.n	8008ad8 <I2C_RequestMemoryWrite+0x108>
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c)
{
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008a46:	6943      	ldr	r3, [r0, #20]
 8008a48:	0559      	lsls	r1, r3, #21
 8008a4a:	d5f9      	bpl.n	8008a40 <I2C_RequestMemoryWrite+0x70>
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);

    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
    hi2c->PreviousState = I2C_STATE_NONE;
 8008a4c:	2300      	movs	r3, #0
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8008a4e:	f46f 6480 	mvn.w	r4, #1024	; 0x400
    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8008a52:	2104      	movs	r1, #4
    hi2c->State= HAL_I2C_STATE_READY;
 8008a54:	2220      	movs	r2, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8008a56:	6144      	str	r4, [r0, #20]
    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8008a58:	6429      	str	r1, [r5, #64]	; 0x40

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8008a5a:	f885 303c 	strb.w	r3, [r5, #60]	; 0x3c
    hi2c->PreviousState = I2C_STATE_NONE;
 8008a5e:	632b      	str	r3, [r5, #48]	; 0x30
    hi2c->State= HAL_I2C_STATE_READY;
 8008a60:	f885 203d 	strb.w	r2, [r5, #61]	; 0x3d
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8008a64:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 8008a66:	2b04      	cmp	r3, #4
 8008a68:	d02f      	beq.n	8008aca <I2C_RequestMemoryWrite+0xfa>
      return HAL_TIMEOUT;
 8008a6a:	2003      	movs	r0, #3
}
 8008a6c:	b002      	add	sp, #8
 8008a6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while((__HAL_I2C_GET_FLAG(hi2c, Flag) ? SET : RESET) == Status) 
 8008a72:	6943      	ldr	r3, [r0, #20]
 8008a74:	07d9      	lsls	r1, r3, #31
 8008a76:	d4bd      	bmi.n	80089f4 <I2C_RequestMemoryWrite+0x24>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 8008a78:	b1e4      	cbz	r4, 8008ab4 <I2C_RequestMemoryWrite+0xe4>
 8008a7a:	f7ff fd13 	bl	80084a4 <HAL_GetTick>
 8008a7e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008a80:	1ac0      	subs	r0, r0, r3
 8008a82:	4284      	cmp	r4, r0
 8008a84:	d316      	bcc.n	8008ab4 <I2C_RequestMemoryWrite+0xe4>
 8008a86:	6828      	ldr	r0, [r5, #0]
 8008a88:	e7af      	b.n	80089ea <I2C_RequestMemoryWrite+0x1a>
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8008a8a:	6803      	ldr	r3, [r0, #0]
      hi2c->PreviousState = I2C_STATE_NONE;
 8008a8c:	2200      	movs	r2, #0
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8008a8e:	f46f 6680 	mvn.w	r6, #1024	; 0x400
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8008a92:	f443 7300 	orr.w	r3, r3, #512	; 0x200
      hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8008a96:	2404      	movs	r4, #4
      hi2c->State= HAL_I2C_STATE_READY;
 8008a98:	2120      	movs	r1, #32
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8008a9a:	6003      	str	r3, [r0, #0]
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8008a9c:	6146      	str	r6, [r0, #20]
      hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8008a9e:	642c      	str	r4, [r5, #64]	; 0x40
      __HAL_UNLOCK(hi2c);
 8008aa0:	f885 203c 	strb.w	r2, [r5, #60]	; 0x3c
      hi2c->PreviousState = I2C_STATE_NONE;
 8008aa4:	632a      	str	r2, [r5, #48]	; 0x30
      hi2c->State= HAL_I2C_STATE_READY;
 8008aa6:	f885 103d 	strb.w	r1, [r5, #61]	; 0x3d
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8008aaa:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 8008aac:	2b04      	cmp	r3, #4
 8008aae:	d1dc      	bne.n	8008a6a <I2C_RequestMemoryWrite+0x9a>
      return HAL_ERROR;
 8008ab0:	2001      	movs	r0, #1
 8008ab2:	e7db      	b.n	8008a6c <I2C_RequestMemoryWrite+0x9c>
        hi2c->PreviousState = I2C_STATE_NONE;
 8008ab4:	2300      	movs	r3, #0
        hi2c->State= HAL_I2C_STATE_READY;
 8008ab6:	2220      	movs	r2, #32
        hi2c->PreviousState = I2C_STATE_NONE;
 8008ab8:	632b      	str	r3, [r5, #48]	; 0x30
        __HAL_UNLOCK(hi2c);
 8008aba:	f885 303c 	strb.w	r3, [r5, #60]	; 0x3c
        hi2c->State= HAL_I2C_STATE_READY;
 8008abe:	f885 203d 	strb.w	r2, [r5, #61]	; 0x3d
    return HAL_TIMEOUT;
 8008ac2:	2003      	movs	r0, #3
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8008ac4:	f885 303e 	strb.w	r3, [r5, #62]	; 0x3e
 8008ac8:	e7d0      	b.n	8008a6c <I2C_RequestMemoryWrite+0x9c>
        hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8008aca:	682a      	ldr	r2, [r5, #0]
 8008acc:	6813      	ldr	r3, [r2, #0]
 8008ace:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8008ad2:	6013      	str	r3, [r2, #0]
        return HAL_ERROR;
 8008ad4:	2001      	movs	r0, #1
 8008ad6:	e7c9      	b.n	8008a6c <I2C_RequestMemoryWrite+0x9c>
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8008ad8:	2f01      	cmp	r7, #1
 8008ada:	d00a      	beq.n	8008af2 <I2C_RequestMemoryWrite+0x122>
    hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
 8008adc:	0a33      	lsrs	r3, r6, #8
 8008ade:	6103      	str	r3, [r0, #16]
 8008ae0:	1c67      	adds	r7, r4, #1
 8008ae2:	d119      	bne.n	8008b18 <I2C_RequestMemoryWrite+0x148>
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8008ae4:	6943      	ldr	r3, [r0, #20]
 8008ae6:	0619      	lsls	r1, r3, #24
 8008ae8:	d403      	bmi.n	8008af2 <I2C_RequestMemoryWrite+0x122>
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008aea:	6943      	ldr	r3, [r0, #20]
 8008aec:	055a      	lsls	r2, r3, #21
 8008aee:	d4ad      	bmi.n	8008a4c <I2C_RequestMemoryWrite+0x7c>
 8008af0:	e7f8      	b.n	8008ae4 <I2C_RequestMemoryWrite+0x114>
    hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
 8008af2:	b2f6      	uxtb	r6, r6
 8008af4:	6106      	str	r6, [r0, #16]
  return HAL_OK;
 8008af6:	2000      	movs	r0, #0
 8008af8:	e7b8      	b.n	8008a6c <I2C_RequestMemoryWrite+0x9c>
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8008afa:	6943      	ldr	r3, [r0, #20]
 8008afc:	061a      	lsls	r2, r3, #24
 8008afe:	d4eb      	bmi.n	8008ad8 <I2C_RequestMemoryWrite+0x108>
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008b00:	6943      	ldr	r3, [r0, #20]
 8008b02:	0559      	lsls	r1, r3, #21
 8008b04:	d4a2      	bmi.n	8008a4c <I2C_RequestMemoryWrite+0x7c>
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 8008b06:	b1f4      	cbz	r4, 8008b46 <I2C_RequestMemoryWrite+0x176>
 8008b08:	f7ff fccc 	bl	80084a4 <HAL_GetTick>
 8008b0c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008b0e:	1ac0      	subs	r0, r0, r3
 8008b10:	4284      	cmp	r4, r0
 8008b12:	d318      	bcc.n	8008b46 <I2C_RequestMemoryWrite+0x176>
 8008b14:	6828      	ldr	r0, [r5, #0]
 8008b16:	e791      	b.n	8008a3c <I2C_RequestMemoryWrite+0x6c>
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8008b18:	6943      	ldr	r3, [r0, #20]
 8008b1a:	061b      	lsls	r3, r3, #24
 8008b1c:	d4e9      	bmi.n	8008af2 <I2C_RequestMemoryWrite+0x122>
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008b1e:	6943      	ldr	r3, [r0, #20]
 8008b20:	055b      	lsls	r3, r3, #21
 8008b22:	d493      	bmi.n	8008a4c <I2C_RequestMemoryWrite+0x7c>
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 8008b24:	b17c      	cbz	r4, 8008b46 <I2C_RequestMemoryWrite+0x176>
 8008b26:	f7ff fcbd 	bl	80084a4 <HAL_GetTick>
 8008b2a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008b2c:	1ac0      	subs	r0, r0, r3
 8008b2e:	4284      	cmp	r4, r0
 8008b30:	d309      	bcc.n	8008b46 <I2C_RequestMemoryWrite+0x176>
 8008b32:	6828      	ldr	r0, [r5, #0]
 8008b34:	e7d4      	b.n	8008ae0 <I2C_RequestMemoryWrite+0x110>
        hi2c->PreviousState = I2C_STATE_NONE;
 8008b36:	2300      	movs	r3, #0
        hi2c->State= HAL_I2C_STATE_READY;
 8008b38:	2220      	movs	r2, #32
        hi2c->PreviousState = I2C_STATE_NONE;
 8008b3a:	632b      	str	r3, [r5, #48]	; 0x30
        __HAL_UNLOCK(hi2c);
 8008b3c:	f885 303c 	strb.w	r3, [r5, #60]	; 0x3c
        hi2c->State= HAL_I2C_STATE_READY;
 8008b40:	f885 203d 	strb.w	r2, [r5, #61]	; 0x3d
 8008b44:	e7b1      	b.n	8008aaa <I2C_RequestMemoryWrite+0xda>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8008b46:	6c2b      	ldr	r3, [r5, #64]	; 0x40
        hi2c->PreviousState = I2C_STATE_NONE;
 8008b48:	2200      	movs	r2, #0
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8008b4a:	f043 0320 	orr.w	r3, r3, #32
        hi2c->State= HAL_I2C_STATE_READY;
 8008b4e:	2120      	movs	r1, #32
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8008b50:	642b      	str	r3, [r5, #64]	; 0x40
        __HAL_UNLOCK(hi2c);
 8008b52:	f885 203c 	strb.w	r2, [r5, #60]	; 0x3c
        hi2c->PreviousState = I2C_STATE_NONE;
 8008b56:	632a      	str	r2, [r5, #48]	; 0x30
        hi2c->State= HAL_I2C_STATE_READY;
 8008b58:	f885 103d 	strb.w	r1, [r5, #61]	; 0x3d
 8008b5c:	e782      	b.n	8008a64 <I2C_RequestMemoryWrite+0x94>
 8008b5e:	bf00      	nop

08008b60 <I2C_RequestMemoryRead>:
{
 8008b60:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008b64:	4604      	mov	r4, r0
  hi2c->Instance->CR1 |= I2C_CR1_ACK;
 8008b66:	6800      	ldr	r0, [r0, #0]
{
 8008b68:	4689      	mov	r9, r1
  hi2c->Instance->CR1 |= I2C_CR1_ACK;
 8008b6a:	6801      	ldr	r1, [r0, #0]
 8008b6c:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 8008b70:	6001      	str	r1, [r0, #0]
{
 8008b72:	b083      	sub	sp, #12
  hi2c->Instance->CR1 |= I2C_CR1_START;
 8008b74:	6801      	ldr	r1, [r0, #0]
{
 8008b76:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 8008b78:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  hi2c->Instance->CR1 |= I2C_CR1_START;
 8008b7a:	f441 7180 	orr.w	r1, r1, #256	; 0x100
{
 8008b7e:	4617      	mov	r7, r2
 8008b80:	4698      	mov	r8, r3
  hi2c->Instance->CR1 |= I2C_CR1_START;
 8008b82:	6001      	str	r1, [r0, #0]
 8008b84:	1c71      	adds	r1, r6, #1
 8008b86:	d142      	bne.n	8008c0e <I2C_RequestMemoryRead+0xae>
  while((__HAL_I2C_GET_FLAG(hi2c, Flag) ? SET : RESET) == Status) 
 8008b88:	6943      	ldr	r3, [r0, #20]
 8008b8a:	07da      	lsls	r2, r3, #31
 8008b8c:	d5fc      	bpl.n	8008b88 <I2C_RequestMemoryRead+0x28>
  hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
 8008b8e:	fa5f f989 	uxtb.w	r9, r9
 8008b92:	f009 03fe 	and.w	r3, r9, #254	; 0xfe
 8008b96:	6103      	str	r3, [r0, #16]
 8008b98:	1c72      	adds	r2, r6, #1
 8008b9a:	d013      	beq.n	8008bc4 <I2C_RequestMemoryRead+0x64>
  while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 8008b9c:	6943      	ldr	r3, [r0, #20]
 8008b9e:	079a      	lsls	r2, r3, #30
 8008ba0:	d413      	bmi.n	8008bca <I2C_RequestMemoryRead+0x6a>
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008ba2:	6943      	ldr	r3, [r0, #20]
 8008ba4:	0559      	lsls	r1, r3, #21
 8008ba6:	d43d      	bmi.n	8008c24 <I2C_RequestMemoryRead+0xc4>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 8008ba8:	2e00      	cmp	r6, #0
 8008baa:	f000 80a8 	beq.w	8008cfe <I2C_RequestMemoryRead+0x19e>
 8008bae:	f7ff fc79 	bl	80084a4 <HAL_GetTick>
 8008bb2:	1b40      	subs	r0, r0, r5
 8008bb4:	4286      	cmp	r6, r0
 8008bb6:	f0c0 80a2 	bcc.w	8008cfe <I2C_RequestMemoryRead+0x19e>
 8008bba:	6820      	ldr	r0, [r4, #0]
 8008bbc:	e7ec      	b.n	8008b98 <I2C_RequestMemoryRead+0x38>
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008bbe:	6943      	ldr	r3, [r0, #20]
 8008bc0:	0559      	lsls	r1, r3, #21
 8008bc2:	d42f      	bmi.n	8008c24 <I2C_RequestMemoryRead+0xc4>
  while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 8008bc4:	6943      	ldr	r3, [r0, #20]
 8008bc6:	079b      	lsls	r3, r3, #30
 8008bc8:	d5f9      	bpl.n	8008bbe <I2C_RequestMemoryRead+0x5e>
  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8008bca:	2300      	movs	r3, #0
 8008bcc:	9301      	str	r3, [sp, #4]
 8008bce:	6943      	ldr	r3, [r0, #20]
 8008bd0:	9301      	str	r3, [sp, #4]
 8008bd2:	6983      	ldr	r3, [r0, #24]
 8008bd4:	9301      	str	r3, [sp, #4]
 8008bd6:	9b01      	ldr	r3, [sp, #4]
 8008bd8:	1c71      	adds	r1, r6, #1
 8008bda:	d163      	bne.n	8008ca4 <I2C_RequestMemoryRead+0x144>
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8008bdc:	6943      	ldr	r3, [r0, #20]
 8008bde:	061a      	lsls	r2, r3, #24
 8008be0:	d447      	bmi.n	8008c72 <I2C_RequestMemoryRead+0x112>
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008be2:	6943      	ldr	r3, [r0, #20]
 8008be4:	055b      	lsls	r3, r3, #21
 8008be6:	d5f9      	bpl.n	8008bdc <I2C_RequestMemoryRead+0x7c>
    hi2c->PreviousState = I2C_STATE_NONE;
 8008be8:	2300      	movs	r3, #0
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8008bea:	f46f 6580 	mvn.w	r5, #1024	; 0x400
    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8008bee:	2104      	movs	r1, #4
    hi2c->State= HAL_I2C_STATE_READY;
 8008bf0:	2220      	movs	r2, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8008bf2:	6145      	str	r5, [r0, #20]
    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8008bf4:	6421      	str	r1, [r4, #64]	; 0x40
    __HAL_UNLOCK(hi2c);
 8008bf6:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    hi2c->PreviousState = I2C_STATE_NONE;
 8008bfa:	6323      	str	r3, [r4, #48]	; 0x30
    hi2c->State= HAL_I2C_STATE_READY;
 8008bfc:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8008c00:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8008c02:	2b04      	cmp	r3, #4
 8008c04:	d02e      	beq.n	8008c64 <I2C_RequestMemoryRead+0x104>
      return HAL_TIMEOUT;
 8008c06:	2003      	movs	r0, #3
}
 8008c08:	b003      	add	sp, #12
 8008c0a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  while((__HAL_I2C_GET_FLAG(hi2c, Flag) ? SET : RESET) == Status) 
 8008c0e:	6943      	ldr	r3, [r0, #20]
 8008c10:	07db      	lsls	r3, r3, #31
 8008c12:	d4bc      	bmi.n	8008b8e <I2C_RequestMemoryRead+0x2e>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 8008c14:	b1de      	cbz	r6, 8008c4e <I2C_RequestMemoryRead+0xee>
 8008c16:	f7ff fc45 	bl	80084a4 <HAL_GetTick>
 8008c1a:	1b40      	subs	r0, r0, r5
 8008c1c:	4286      	cmp	r6, r0
 8008c1e:	d316      	bcc.n	8008c4e <I2C_RequestMemoryRead+0xee>
 8008c20:	6820      	ldr	r0, [r4, #0]
 8008c22:	e7af      	b.n	8008b84 <I2C_RequestMemoryRead+0x24>
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8008c24:	6803      	ldr	r3, [r0, #0]
      hi2c->PreviousState = I2C_STATE_NONE;
 8008c26:	2200      	movs	r2, #0
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8008c28:	f46f 6680 	mvn.w	r6, #1024	; 0x400
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8008c2c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
      hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8008c30:	2504      	movs	r5, #4
      hi2c->State= HAL_I2C_STATE_READY;
 8008c32:	2120      	movs	r1, #32
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8008c34:	6003      	str	r3, [r0, #0]
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8008c36:	6146      	str	r6, [r0, #20]
      hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8008c38:	6425      	str	r5, [r4, #64]	; 0x40
      __HAL_UNLOCK(hi2c);
 8008c3a:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
      hi2c->PreviousState = I2C_STATE_NONE;
 8008c3e:	6322      	str	r2, [r4, #48]	; 0x30
      hi2c->State= HAL_I2C_STATE_READY;
 8008c40:	f884 103d 	strb.w	r1, [r4, #61]	; 0x3d
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8008c44:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8008c46:	2b04      	cmp	r3, #4
 8008c48:	d1dd      	bne.n	8008c06 <I2C_RequestMemoryRead+0xa6>
      return HAL_ERROR;
 8008c4a:	2001      	movs	r0, #1
 8008c4c:	e7dc      	b.n	8008c08 <I2C_RequestMemoryRead+0xa8>
        hi2c->PreviousState = I2C_STATE_NONE;
 8008c4e:	2300      	movs	r3, #0
        hi2c->State= HAL_I2C_STATE_READY;
 8008c50:	2220      	movs	r2, #32
        hi2c->PreviousState = I2C_STATE_NONE;
 8008c52:	6323      	str	r3, [r4, #48]	; 0x30
        __HAL_UNLOCK(hi2c);
 8008c54:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
        hi2c->State= HAL_I2C_STATE_READY;
 8008c58:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    return HAL_TIMEOUT;
 8008c5c:	2003      	movs	r0, #3
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8008c5e:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 8008c62:	e7d1      	b.n	8008c08 <I2C_RequestMemoryRead+0xa8>
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8008c64:	6822      	ldr	r2, [r4, #0]
 8008c66:	6813      	ldr	r3, [r2, #0]
 8008c68:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8008c6c:	6013      	str	r3, [r2, #0]
      return HAL_ERROR;
 8008c6e:	2001      	movs	r0, #1
 8008c70:	e7ca      	b.n	8008c08 <I2C_RequestMemoryRead+0xa8>
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8008c72:	f1b8 0f01 	cmp.w	r8, #1
 8008c76:	d00a      	beq.n	8008c8e <I2C_RequestMemoryRead+0x12e>
    hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
 8008c78:	0a3b      	lsrs	r3, r7, #8
 8008c7a:	6103      	str	r3, [r0, #16]
 8008c7c:	1c73      	adds	r3, r6, #1
 8008c7e:	d12f      	bne.n	8008ce0 <I2C_RequestMemoryRead+0x180>
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8008c80:	6943      	ldr	r3, [r0, #20]
 8008c82:	0619      	lsls	r1, r3, #24
 8008c84:	d403      	bmi.n	8008c8e <I2C_RequestMemoryRead+0x12e>
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008c86:	6943      	ldr	r3, [r0, #20]
 8008c88:	055a      	lsls	r2, r3, #21
 8008c8a:	d4ad      	bmi.n	8008be8 <I2C_RequestMemoryRead+0x88>
 8008c8c:	e7f8      	b.n	8008c80 <I2C_RequestMemoryRead+0x120>
    hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
 8008c8e:	b2ff      	uxtb	r7, r7
 8008c90:	6107      	str	r7, [r0, #16]
 8008c92:	1c71      	adds	r1, r6, #1
 8008c94:	d115      	bne.n	8008cc2 <I2C_RequestMemoryRead+0x162>
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8008c96:	6943      	ldr	r3, [r0, #20]
 8008c98:	061a      	lsls	r2, r3, #24
 8008c9a:	d438      	bmi.n	8008d0e <I2C_RequestMemoryRead+0x1ae>
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008c9c:	6943      	ldr	r3, [r0, #20]
 8008c9e:	055b      	lsls	r3, r3, #21
 8008ca0:	d4a2      	bmi.n	8008be8 <I2C_RequestMemoryRead+0x88>
 8008ca2:	e7f8      	b.n	8008c96 <I2C_RequestMemoryRead+0x136>
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8008ca4:	6943      	ldr	r3, [r0, #20]
 8008ca6:	0619      	lsls	r1, r3, #24
 8008ca8:	d4e3      	bmi.n	8008c72 <I2C_RequestMemoryRead+0x112>
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008caa:	6943      	ldr	r3, [r0, #20]
 8008cac:	055b      	lsls	r3, r3, #21
 8008cae:	d49b      	bmi.n	8008be8 <I2C_RequestMemoryRead+0x88>
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 8008cb0:	2e00      	cmp	r6, #0
 8008cb2:	d04d      	beq.n	8008d50 <I2C_RequestMemoryRead+0x1f0>
 8008cb4:	f7ff fbf6 	bl	80084a4 <HAL_GetTick>
 8008cb8:	1b40      	subs	r0, r0, r5
 8008cba:	4286      	cmp	r6, r0
 8008cbc:	d348      	bcc.n	8008d50 <I2C_RequestMemoryRead+0x1f0>
 8008cbe:	6820      	ldr	r0, [r4, #0]
 8008cc0:	e78a      	b.n	8008bd8 <I2C_RequestMemoryRead+0x78>
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8008cc2:	6943      	ldr	r3, [r0, #20]
 8008cc4:	061f      	lsls	r7, r3, #24
 8008cc6:	d422      	bmi.n	8008d0e <I2C_RequestMemoryRead+0x1ae>
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008cc8:	6943      	ldr	r3, [r0, #20]
 8008cca:	055f      	lsls	r7, r3, #21
 8008ccc:	d48c      	bmi.n	8008be8 <I2C_RequestMemoryRead+0x88>
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 8008cce:	2e00      	cmp	r6, #0
 8008cd0:	d03e      	beq.n	8008d50 <I2C_RequestMemoryRead+0x1f0>
 8008cd2:	f7ff fbe7 	bl	80084a4 <HAL_GetTick>
 8008cd6:	1b40      	subs	r0, r0, r5
 8008cd8:	4286      	cmp	r6, r0
 8008cda:	d339      	bcc.n	8008d50 <I2C_RequestMemoryRead+0x1f0>
 8008cdc:	6820      	ldr	r0, [r4, #0]
 8008cde:	e7d8      	b.n	8008c92 <I2C_RequestMemoryRead+0x132>
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8008ce0:	6943      	ldr	r3, [r0, #20]
 8008ce2:	061b      	lsls	r3, r3, #24
 8008ce4:	d4d3      	bmi.n	8008c8e <I2C_RequestMemoryRead+0x12e>
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008ce6:	6943      	ldr	r3, [r0, #20]
 8008ce8:	055a      	lsls	r2, r3, #21
 8008cea:	f53f af7d 	bmi.w	8008be8 <I2C_RequestMemoryRead+0x88>
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 8008cee:	b37e      	cbz	r6, 8008d50 <I2C_RequestMemoryRead+0x1f0>
 8008cf0:	f7ff fbd8 	bl	80084a4 <HAL_GetTick>
 8008cf4:	1b40      	subs	r0, r0, r5
 8008cf6:	4286      	cmp	r6, r0
 8008cf8:	d32a      	bcc.n	8008d50 <I2C_RequestMemoryRead+0x1f0>
 8008cfa:	6820      	ldr	r0, [r4, #0]
 8008cfc:	e7be      	b.n	8008c7c <I2C_RequestMemoryRead+0x11c>
        hi2c->PreviousState = I2C_STATE_NONE;
 8008cfe:	2300      	movs	r3, #0
        hi2c->State= HAL_I2C_STATE_READY;
 8008d00:	2220      	movs	r2, #32
        hi2c->PreviousState = I2C_STATE_NONE;
 8008d02:	6323      	str	r3, [r4, #48]	; 0x30
        __HAL_UNLOCK(hi2c);
 8008d04:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
        hi2c->State= HAL_I2C_STATE_READY;
 8008d08:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
 8008d0c:	e79a      	b.n	8008c44 <I2C_RequestMemoryRead+0xe4>
  hi2c->Instance->CR1 |= I2C_CR1_START;
 8008d0e:	6803      	ldr	r3, [r0, #0]
 8008d10:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8008d14:	6003      	str	r3, [r0, #0]
 8008d16:	1c71      	adds	r1, r6, #1
 8008d18:	d10e      	bne.n	8008d38 <I2C_RequestMemoryRead+0x1d8>
  while((__HAL_I2C_GET_FLAG(hi2c, Flag) ? SET : RESET) == Status) 
 8008d1a:	6943      	ldr	r3, [r0, #20]
 8008d1c:	07da      	lsls	r2, r3, #31
 8008d1e:	d5fc      	bpl.n	8008d1a <I2C_RequestMemoryRead+0x1ba>
  hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
 8008d20:	f049 0901 	orr.w	r9, r9, #1
 8008d24:	f8c0 9010 	str.w	r9, [r0, #16]
  if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
 8008d28:	462a      	mov	r2, r5
 8008d2a:	4631      	mov	r1, r6
 8008d2c:	4620      	mov	r0, r4
 8008d2e:	f7ff fe1d 	bl	800896c <I2C_WaitOnMasterAddressFlagUntilTimeout.constprop.10>
 8008d32:	2800      	cmp	r0, #0
 8008d34:	d186      	bne.n	8008c44 <I2C_RequestMemoryRead+0xe4>
 8008d36:	e767      	b.n	8008c08 <I2C_RequestMemoryRead+0xa8>
  while((__HAL_I2C_GET_FLAG(hi2c, Flag) ? SET : RESET) == Status) 
 8008d38:	6943      	ldr	r3, [r0, #20]
 8008d3a:	07db      	lsls	r3, r3, #31
 8008d3c:	d4f0      	bmi.n	8008d20 <I2C_RequestMemoryRead+0x1c0>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 8008d3e:	2e00      	cmp	r6, #0
 8008d40:	d085      	beq.n	8008c4e <I2C_RequestMemoryRead+0xee>
 8008d42:	f7ff fbaf 	bl	80084a4 <HAL_GetTick>
 8008d46:	1b40      	subs	r0, r0, r5
 8008d48:	4286      	cmp	r6, r0
 8008d4a:	d380      	bcc.n	8008c4e <I2C_RequestMemoryRead+0xee>
 8008d4c:	6820      	ldr	r0, [r4, #0]
 8008d4e:	e7e2      	b.n	8008d16 <I2C_RequestMemoryRead+0x1b6>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8008d50:	6c23      	ldr	r3, [r4, #64]	; 0x40
        hi2c->PreviousState = I2C_STATE_NONE;
 8008d52:	2200      	movs	r2, #0
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8008d54:	f043 0320 	orr.w	r3, r3, #32
        hi2c->State= HAL_I2C_STATE_READY;
 8008d58:	2120      	movs	r1, #32
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8008d5a:	6423      	str	r3, [r4, #64]	; 0x40
        __HAL_UNLOCK(hi2c);
 8008d5c:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
        hi2c->PreviousState = I2C_STATE_NONE;
 8008d60:	6322      	str	r2, [r4, #48]	; 0x30
        hi2c->State= HAL_I2C_STATE_READY;
 8008d62:	f884 103d 	strb.w	r1, [r4, #61]	; 0x3d
 8008d66:	e74b      	b.n	8008c00 <I2C_RequestMemoryRead+0xa0>

08008d68 <HAL_I2C_MspInit>:
 8008d68:	4770      	bx	lr
 8008d6a:	bf00      	nop

08008d6c <HAL_I2C_Init>:
  if(hi2c == NULL)
 8008d6c:	2800      	cmp	r0, #0
 8008d6e:	d06c      	beq.n	8008e4a <HAL_I2C_Init+0xde>
{
 8008d70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(hi2c->State == HAL_I2C_STATE_RESET)
 8008d72:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8008d76:	4604      	mov	r4, r0
 8008d78:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8008d7c:	2b00      	cmp	r3, #0
 8008d7e:	d04f      	beq.n	8008e20 <HAL_I2C_Init+0xb4>
  __HAL_I2C_DISABLE(hi2c);
 8008d80:	6822      	ldr	r2, [r4, #0]
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8008d82:	4d33      	ldr	r5, [pc, #204]	; (8008e50 <HAL_I2C_Init+0xe4>)
  hi2c->State = HAL_I2C_STATE_BUSY;
 8008d84:	2324      	movs	r3, #36	; 0x24
 8008d86:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_I2C_DISABLE(hi2c);
 8008d8a:	6813      	ldr	r3, [r2, #0]
 8008d8c:	f023 0301 	bic.w	r3, r3, #1
 8008d90:	6013      	str	r3, [r2, #0]
  pclk1 = HAL_RCC_GetPCLK1Freq();
 8008d92:	f000 fd6f 	bl	8009874 <HAL_RCC_GetPCLK1Freq>
  freqrange = I2C_FREQRANGE(pclk1);
 8008d96:	4a2f      	ldr	r2, [pc, #188]	; (8008e54 <HAL_I2C_Init+0xe8>)
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8008d98:	6861      	ldr	r1, [r4, #4]
  hi2c->Instance->CR2 = freqrange;
 8008d9a:	6823      	ldr	r3, [r4, #0]
  freqrange = I2C_FREQRANGE(pclk1);
 8008d9c:	fba2 6200 	umull	r6, r2, r2, r0
 8008da0:	0c92      	lsrs	r2, r2, #18
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8008da2:	42a9      	cmp	r1, r5
  hi2c->Instance->CR2 = freqrange;
 8008da4:	605a      	str	r2, [r3, #4]
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8008da6:	d826      	bhi.n	8008df6 <HAL_I2C_Init+0x8a>
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 8008da8:	0049      	lsls	r1, r1, #1
 8008daa:	fbb0 f0f1 	udiv	r0, r0, r1
 8008dae:	f3c0 010b 	ubfx	r1, r0, #0, #12
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8008db2:	3201      	adds	r2, #1
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 8008db4:	2903      	cmp	r1, #3
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8008db6:	621a      	str	r2, [r3, #32]
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 8008db8:	bf98      	it	ls
 8008dba:	2004      	movls	r0, #4
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8008dbc:	69e5      	ldr	r5, [r4, #28]
 8008dbe:	f8d4 e020 	ldr.w	lr, [r4, #32]
  hi2c->Instance->OAR1 = (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1);
 8008dc2:	6921      	ldr	r1, [r4, #16]
 8008dc4:	68e7      	ldr	r7, [r4, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2);
 8008dc6:	6962      	ldr	r2, [r4, #20]
 8008dc8:	69a6      	ldr	r6, [r4, #24]
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 8008dca:	61d8      	str	r0, [r3, #28]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8008dcc:	ea45 050e 	orr.w	r5, r5, lr
  hi2c->Instance->OAR1 = (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1);
 8008dd0:	4339      	orrs	r1, r7
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2);
 8008dd2:	4332      	orrs	r2, r6
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8008dd4:	601d      	str	r5, [r3, #0]
  hi2c->Instance->OAR1 = (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1);
 8008dd6:	6099      	str	r1, [r3, #8]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2);
 8008dd8:	60da      	str	r2, [r3, #12]
  __HAL_I2C_ENABLE(hi2c);
 8008dda:	6819      	ldr	r1, [r3, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8008ddc:	2200      	movs	r2, #0
  __HAL_I2C_ENABLE(hi2c);
 8008dde:	f041 0101 	orr.w	r1, r1, #1
  hi2c->State = HAL_I2C_STATE_READY;
 8008de2:	2520      	movs	r5, #32
  __HAL_I2C_ENABLE(hi2c);
 8008de4:	6019      	str	r1, [r3, #0]
  return HAL_OK;
 8008de6:	4610      	mov	r0, r2
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8008de8:	6422      	str	r2, [r4, #64]	; 0x40
  hi2c->State = HAL_I2C_STATE_READY;
 8008dea:	f884 503d 	strb.w	r5, [r4, #61]	; 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 8008dee:	6322      	str	r2, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8008df0:	f884 203e 	strb.w	r2, [r4, #62]	; 0x3e
  return HAL_OK;
 8008df4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8008df6:	f44f 7596 	mov.w	r5, #300	; 0x12c
 8008dfa:	4f17      	ldr	r7, [pc, #92]	; (8008e58 <HAL_I2C_Init+0xec>)
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 8008dfc:	68a6      	ldr	r6, [r4, #8]
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8008dfe:	fb05 f202 	mul.w	r2, r5, r2
 8008e02:	fba7 5202 	umull	r5, r2, r7, r2
 8008e06:	0992      	lsrs	r2, r2, #6
 8008e08:	3201      	adds	r2, #1
 8008e0a:	621a      	str	r2, [r3, #32]
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 8008e0c:	b96e      	cbnz	r6, 8008e2a <HAL_I2C_Init+0xbe>
 8008e0e:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 8008e12:	fbb0 f0f1 	udiv	r0, r0, r1
 8008e16:	f3c0 020b 	ubfx	r2, r0, #0, #12
 8008e1a:	b99a      	cbnz	r2, 8008e44 <HAL_I2C_Init+0xd8>
 8008e1c:	2001      	movs	r0, #1
 8008e1e:	e7cd      	b.n	8008dbc <HAL_I2C_Init+0x50>
    hi2c->Lock = HAL_UNLOCKED;
 8008e20:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_I2C_MspInit(hi2c);
 8008e24:	f7ff ffa0 	bl	8008d68 <HAL_I2C_MspInit>
 8008e28:	e7aa      	b.n	8008d80 <HAL_I2C_Init+0x14>
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 8008e2a:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8008e2e:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8008e32:	fbb0 f0f1 	udiv	r0, r0, r1
 8008e36:	f3c0 020b 	ubfx	r2, r0, #0, #12
 8008e3a:	2a00      	cmp	r2, #0
 8008e3c:	d0ee      	beq.n	8008e1c <HAL_I2C_Init+0xb0>
 8008e3e:	f440 4040 	orr.w	r0, r0, #49152	; 0xc000
 8008e42:	e7bb      	b.n	8008dbc <HAL_I2C_Init+0x50>
 8008e44:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
 8008e48:	e7b8      	b.n	8008dbc <HAL_I2C_Init+0x50>
    return HAL_ERROR;
 8008e4a:	2001      	movs	r0, #1
 8008e4c:	4770      	bx	lr
 8008e4e:	bf00      	nop
 8008e50:	000186a0 	.word	0x000186a0
 8008e54:	431bde83 	.word	0x431bde83
 8008e58:	10624dd3 	.word	0x10624dd3

08008e5c <HAL_I2C_MspDeInit>:
 8008e5c:	4770      	bx	lr
 8008e5e:	bf00      	nop

08008e60 <HAL_I2C_DeInit>:
  if(hi2c == NULL)
 8008e60:	b1b0      	cbz	r0, 8008e90 <HAL_I2C_DeInit+0x30>
  __HAL_I2C_DISABLE(hi2c);
 8008e62:	6802      	ldr	r2, [r0, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
 8008e64:	2324      	movs	r3, #36	; 0x24
{
 8008e66:	b510      	push	{r4, lr}
  hi2c->State = HAL_I2C_STATE_BUSY;
 8008e68:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_I2C_DISABLE(hi2c);
 8008e6c:	6813      	ldr	r3, [r2, #0]
 8008e6e:	f023 0301 	bic.w	r3, r3, #1
 8008e72:	4604      	mov	r4, r0
 8008e74:	6013      	str	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
 8008e76:	f7ff fff1 	bl	8008e5c <HAL_I2C_MspDeInit>
  hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
 8008e7a:	2300      	movs	r3, #0
 8008e7c:	6423      	str	r3, [r4, #64]	; 0x40
  __HAL_UNLOCK(hi2c);
 8008e7e:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
  hi2c->State         = HAL_I2C_STATE_RESET;
 8008e82:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8008e86:	4618      	mov	r0, r3
  hi2c->PreviousState = I2C_STATE_NONE;
 8008e88:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8008e8a:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  return HAL_OK;
 8008e8e:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8008e90:	2001      	movs	r0, #1
 8008e92:	4770      	bx	lr

08008e94 <HAL_I2C_Mem_Write>:
{
 8008e94:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008e98:	4604      	mov	r4, r0
 8008e9a:	b082      	sub	sp, #8
 8008e9c:	4698      	mov	r8, r3
 8008e9e:	460e      	mov	r6, r1
 8008ea0:	4617      	mov	r7, r2
 8008ea2:	f8bd 902c 	ldrh.w	r9, [sp, #44]	; 0x2c
  tickstart = HAL_GetTick();
 8008ea6:	f7ff fafd 	bl	80084a4 <HAL_GetTick>
  if(hi2c->State == HAL_I2C_STATE_READY)
 8008eaa:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 8008eae:	2b20      	cmp	r3, #32
 8008eb0:	d004      	beq.n	8008ebc <HAL_I2C_Mem_Write+0x28>
    return HAL_BUSY;
 8008eb2:	2602      	movs	r6, #2
}
 8008eb4:	4630      	mov	r0, r6
 8008eb6:	b002      	add	sp, #8
 8008eb8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008ebc:	4605      	mov	r5, r0
 8008ebe:	e005      	b.n	8008ecc <HAL_I2C_Mem_Write+0x38>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 8008ec0:	f7ff faf0 	bl	80084a4 <HAL_GetTick>
 8008ec4:	1b40      	subs	r0, r0, r5
 8008ec6:	2819      	cmp	r0, #25
 8008ec8:	f200 808b 	bhi.w	8008fe2 <HAL_I2C_Mem_Write+0x14e>
  while((__HAL_I2C_GET_FLAG(hi2c, Flag) ? SET : RESET) == Status) 
 8008ecc:	6822      	ldr	r2, [r4, #0]
 8008ece:	6993      	ldr	r3, [r2, #24]
 8008ed0:	43db      	mvns	r3, r3
 8008ed2:	f013 0a02 	ands.w	sl, r3, #2
 8008ed6:	d0f3      	beq.n	8008ec0 <HAL_I2C_Mem_Write+0x2c>
    __HAL_LOCK(hi2c);
 8008ed8:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 8008edc:	2b01      	cmp	r3, #1
 8008ede:	d0e8      	beq.n	8008eb2 <HAL_I2C_Mem_Write+0x1e>
    if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
 8008ee0:	6813      	ldr	r3, [r2, #0]
    __HAL_LOCK(hi2c);
 8008ee2:	2101      	movs	r1, #1
    if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
 8008ee4:	07db      	lsls	r3, r3, #31
    __HAL_LOCK(hi2c);
 8008ee6:	f884 103c 	strb.w	r1, [r4, #60]	; 0x3c
    if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
 8008eea:	d402      	bmi.n	8008ef2 <HAL_I2C_Mem_Write+0x5e>
      __HAL_I2C_ENABLE(hi2c);
 8008eec:	6813      	ldr	r3, [r2, #0]
 8008eee:	430b      	orrs	r3, r1
 8008ef0:	6013      	str	r3, [r2, #0]
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 8008ef2:	6813      	ldr	r3, [r2, #0]
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8008ef4:	495b      	ldr	r1, [pc, #364]	; (8009064 <HAL_I2C_Mem_Write+0x1d0>)
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 8008ef6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8008efa:	6013      	str	r3, [r2, #0]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8008efc:	f04f 0a00 	mov.w	sl, #0
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8008f00:	2221      	movs	r2, #33	; 0x21
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8008f02:	2340      	movs	r3, #64	; 0x40
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8008f04:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8008f08:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8008f0c:	f8c4 a040 	str.w	sl, [r4, #64]	; 0x40
    hi2c->XferCount   = Size;
 8008f10:	f8a4 902a 	strh.w	r9, [r4, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8008f14:	62e1      	str	r1, [r4, #44]	; 0x2c
    hi2c->XferSize    = hi2c->XferCount;
 8008f16:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
    hi2c->pBuffPtr    = pData;
 8008f18:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008f1a:	6263      	str	r3, [r4, #36]	; 0x24
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8008f1c:	4631      	mov	r1, r6
 8008f1e:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8008f20:	9600      	str	r6, [sp, #0]
 8008f22:	9501      	str	r5, [sp, #4]
 8008f24:	4643      	mov	r3, r8
    hi2c->XferSize    = hi2c->XferCount;
 8008f26:	8520      	strh	r0, [r4, #40]	; 0x28
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8008f28:	463a      	mov	r2, r7
 8008f2a:	4620      	mov	r0, r4
 8008f2c:	f7ff fd50 	bl	80089d0 <I2C_RequestMemoryWrite>
 8008f30:	4606      	mov	r6, r0
 8008f32:	2800      	cmp	r0, #0
 8008f34:	d170      	bne.n	8009018 <HAL_I2C_Mem_Write+0x184>
 8008f36:	6823      	ldr	r3, [r4, #0]
 8008f38:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    while(hi2c->XferSize > 0U)
 8008f3a:	2a00      	cmp	r2, #0
 8008f3c:	d029      	beq.n	8008f92 <HAL_I2C_Mem_Write+0xfe>
 8008f3e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8008f40:	3201      	adds	r2, #1
 8008f42:	d159      	bne.n	8008ff8 <HAL_I2C_Mem_Write+0x164>
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8008f44:	695a      	ldr	r2, [r3, #20]
 8008f46:	0610      	lsls	r0, r2, #24
 8008f48:	d42d      	bmi.n	8008fa6 <HAL_I2C_Mem_Write+0x112>
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008f4a:	695a      	ldr	r2, [r3, #20]
 8008f4c:	0551      	lsls	r1, r2, #21
 8008f4e:	d5f9      	bpl.n	8008f44 <HAL_I2C_Mem_Write+0xb0>
    hi2c->PreviousState = I2C_STATE_NONE;
 8008f50:	2200      	movs	r2, #0
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8008f52:	f46f 6580 	mvn.w	r5, #1024	; 0x400
    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8008f56:	2004      	movs	r0, #4
    hi2c->State= HAL_I2C_STATE_READY;
 8008f58:	2120      	movs	r1, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8008f5a:	615d      	str	r5, [r3, #20]
    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8008f5c:	6420      	str	r0, [r4, #64]	; 0x40
    __HAL_UNLOCK(hi2c);
 8008f5e:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
    hi2c->PreviousState = I2C_STATE_NONE;
 8008f62:	6322      	str	r2, [r4, #48]	; 0x30
    hi2c->State= HAL_I2C_STATE_READY;
 8008f64:	f884 103d 	strb.w	r1, [r4, #61]	; 0x3d
        if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8008f68:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8008f6a:	2b04      	cmp	r3, #4
 8008f6c:	d074      	beq.n	8009058 <HAL_I2C_Mem_Write+0x1c4>
          return HAL_TIMEOUT;
 8008f6e:	2603      	movs	r6, #3
 8008f70:	e7a0      	b.n	8008eb4 <HAL_I2C_Mem_Write+0x20>
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET)
 8008f72:	695a      	ldr	r2, [r3, #20]
 8008f74:	0752      	lsls	r2, r2, #29
 8008f76:	d456      	bmi.n	8009026 <HAL_I2C_Mem_Write+0x192>
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008f78:	695a      	ldr	r2, [r3, #20]
 8008f7a:	0557      	lsls	r7, r2, #21
 8008f7c:	d4e8      	bmi.n	8008f50 <HAL_I2C_Mem_Write+0xbc>
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 8008f7e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008f80:	2b00      	cmp	r3, #0
 8008f82:	d05d      	beq.n	8009040 <HAL_I2C_Mem_Write+0x1ac>
 8008f84:	f7ff fa8e 	bl	80084a4 <HAL_GetTick>
 8008f88:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008f8a:	1b40      	subs	r0, r0, r5
 8008f8c:	4283      	cmp	r3, r0
 8008f8e:	d357      	bcc.n	8009040 <HAL_I2C_Mem_Write+0x1ac>
 8008f90:	6823      	ldr	r3, [r4, #0]
 8008f92:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8008f94:	3201      	adds	r2, #1
 8008f96:	d1ec      	bne.n	8008f72 <HAL_I2C_Mem_Write+0xde>
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET)
 8008f98:	695a      	ldr	r2, [r3, #20]
 8008f9a:	0750      	lsls	r0, r2, #29
 8008f9c:	d443      	bmi.n	8009026 <HAL_I2C_Mem_Write+0x192>
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008f9e:	695a      	ldr	r2, [r3, #20]
 8008fa0:	0551      	lsls	r1, r2, #21
 8008fa2:	d4d5      	bmi.n	8008f50 <HAL_I2C_Mem_Write+0xbc>
 8008fa4:	e7f8      	b.n	8008f98 <HAL_I2C_Mem_Write+0x104>
      hi2c->Instance->DR = (*hi2c->pBuffPtr++);
 8008fa6:	6a61      	ldr	r1, [r4, #36]	; 0x24
      hi2c->XferSize--;
 8008fa8:	8d20      	ldrh	r0, [r4, #40]	; 0x28
      hi2c->Instance->DR = (*hi2c->pBuffPtr++);
 8008faa:	1c4a      	adds	r2, r1, #1
 8008fac:	6262      	str	r2, [r4, #36]	; 0x24
 8008fae:	780a      	ldrb	r2, [r1, #0]
 8008fb0:	611a      	str	r2, [r3, #16]
      hi2c->XferCount--;
 8008fb2:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8008fb4:	3a01      	subs	r2, #1
 8008fb6:	b292      	uxth	r2, r2
 8008fb8:	8562      	strh	r2, [r4, #42]	; 0x2a
      if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
 8008fba:	695f      	ldr	r7, [r3, #20]
      hi2c->XferSize--;
 8008fbc:	1e42      	subs	r2, r0, #1
 8008fbe:	b292      	uxth	r2, r2
      if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
 8008fc0:	077f      	lsls	r7, r7, #29
      hi2c->XferSize--;
 8008fc2:	8522      	strh	r2, [r4, #40]	; 0x28
      if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
 8008fc4:	d5b9      	bpl.n	8008f3a <HAL_I2C_Mem_Write+0xa6>
 8008fc6:	2a00      	cmp	r2, #0
 8008fc8:	d0e3      	beq.n	8008f92 <HAL_I2C_Mem_Write+0xfe>
        hi2c->Instance->DR = (*hi2c->pBuffPtr++);
 8008fca:	1c8a      	adds	r2, r1, #2
 8008fcc:	6262      	str	r2, [r4, #36]	; 0x24
 8008fce:	784a      	ldrb	r2, [r1, #1]
 8008fd0:	611a      	str	r2, [r3, #16]
        hi2c->XferCount--;
 8008fd2:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
        hi2c->XferSize--;
 8008fd4:	1e82      	subs	r2, r0, #2
        hi2c->XferCount--;
 8008fd6:	3901      	subs	r1, #1
        hi2c->XferSize--;
 8008fd8:	b292      	uxth	r2, r2
        hi2c->XferCount--;
 8008fda:	b289      	uxth	r1, r1
        hi2c->XferSize--;
 8008fdc:	8522      	strh	r2, [r4, #40]	; 0x28
        hi2c->XferCount--;
 8008fde:	8561      	strh	r1, [r4, #42]	; 0x2a
 8008fe0:	e7ab      	b.n	8008f3a <HAL_I2C_Mem_Write+0xa6>
        hi2c->State= HAL_I2C_STATE_READY;
 8008fe2:	2320      	movs	r3, #32
        hi2c->PreviousState = I2C_STATE_NONE;
 8008fe4:	f8c4 a030 	str.w	sl, [r4, #48]	; 0x30
        __HAL_UNLOCK(hi2c);
 8008fe8:	f884 a03c 	strb.w	sl, [r4, #60]	; 0x3c
        hi2c->State= HAL_I2C_STATE_READY;
 8008fec:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
      return HAL_BUSY;
 8008ff0:	2602      	movs	r6, #2
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8008ff2:	f884 a03e 	strb.w	sl, [r4, #62]	; 0x3e
 8008ff6:	e75d      	b.n	8008eb4 <HAL_I2C_Mem_Write+0x20>
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8008ff8:	695a      	ldr	r2, [r3, #20]
 8008ffa:	0612      	lsls	r2, r2, #24
 8008ffc:	d4d3      	bmi.n	8008fa6 <HAL_I2C_Mem_Write+0x112>
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8008ffe:	695a      	ldr	r2, [r3, #20]
 8009000:	0557      	lsls	r7, r2, #21
 8009002:	d4a5      	bmi.n	8008f50 <HAL_I2C_Mem_Write+0xbc>
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 8009004:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8009006:	b1db      	cbz	r3, 8009040 <HAL_I2C_Mem_Write+0x1ac>
 8009008:	f7ff fa4c 	bl	80084a4 <HAL_GetTick>
 800900c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800900e:	1b40      	subs	r0, r0, r5
 8009010:	4283      	cmp	r3, r0
 8009012:	d315      	bcc.n	8009040 <HAL_I2C_Mem_Write+0x1ac>
 8009014:	6823      	ldr	r3, [r4, #0]
 8009016:	e792      	b.n	8008f3e <HAL_I2C_Mem_Write+0xaa>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8009018:	6c23      	ldr	r3, [r4, #64]	; 0x40
        __HAL_UNLOCK(hi2c);
 800901a:	f884 a03c 	strb.w	sl, [r4, #60]	; 0x3c
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 800901e:	2b04      	cmp	r3, #4
 8009020:	d1a5      	bne.n	8008f6e <HAL_I2C_Mem_Write+0xda>
        return HAL_ERROR;
 8009022:	2601      	movs	r6, #1
 8009024:	e746      	b.n	8008eb4 <HAL_I2C_Mem_Write+0x20>
    hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8009026:	681a      	ldr	r2, [r3, #0]
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8009028:	2100      	movs	r1, #0
    hi2c->State = HAL_I2C_STATE_READY;
 800902a:	2020      	movs	r0, #32
    hi2c->Instance->CR1 |= I2C_CR1_STOP;
 800902c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8009030:	601a      	str	r2, [r3, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 8009032:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
    __HAL_UNLOCK(hi2c);
 8009036:	f884 103c 	strb.w	r1, [r4, #60]	; 0x3c
    hi2c->Mode = HAL_I2C_MODE_NONE;
 800903a:	f884 103e 	strb.w	r1, [r4, #62]	; 0x3e
    return HAL_OK;
 800903e:	e739      	b.n	8008eb4 <HAL_I2C_Mem_Write+0x20>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8009040:	6c23      	ldr	r3, [r4, #64]	; 0x40
        hi2c->PreviousState = I2C_STATE_NONE;
 8009042:	2200      	movs	r2, #0
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8009044:	f043 0320 	orr.w	r3, r3, #32
        hi2c->State= HAL_I2C_STATE_READY;
 8009048:	2120      	movs	r1, #32
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800904a:	6423      	str	r3, [r4, #64]	; 0x40
        __HAL_UNLOCK(hi2c);
 800904c:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
        hi2c->PreviousState = I2C_STATE_NONE;
 8009050:	6322      	str	r2, [r4, #48]	; 0x30
        hi2c->State= HAL_I2C_STATE_READY;
 8009052:	f884 103d 	strb.w	r1, [r4, #61]	; 0x3d
 8009056:	e787      	b.n	8008f68 <HAL_I2C_Mem_Write+0xd4>
        hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8009058:	6822      	ldr	r2, [r4, #0]
 800905a:	6813      	ldr	r3, [r2, #0]
 800905c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8009060:	6013      	str	r3, [r2, #0]
 8009062:	e7de      	b.n	8009022 <HAL_I2C_Mem_Write+0x18e>
 8009064:	ffff0000 	.word	0xffff0000

08009068 <HAL_I2C_Mem_Read>:
{
 8009068:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800906c:	4604      	mov	r4, r0
 800906e:	b087      	sub	sp, #28
 8009070:	4699      	mov	r9, r3
 8009072:	460f      	mov	r7, r1
 8009074:	4690      	mov	r8, r2
 8009076:	f8bd a044 	ldrh.w	sl, [sp, #68]	; 0x44
 800907a:	9e12      	ldr	r6, [sp, #72]	; 0x48
  tickstart = HAL_GetTick();
 800907c:	f7ff fa12 	bl	80084a4 <HAL_GetTick>
  if(hi2c->State == HAL_I2C_STATE_READY)
 8009080:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 8009084:	2b20      	cmp	r3, #32
 8009086:	d004      	beq.n	8009092 <HAL_I2C_Mem_Read+0x2a>
    return HAL_BUSY;
 8009088:	2702      	movs	r7, #2
}
 800908a:	4638      	mov	r0, r7
 800908c:	b007      	add	sp, #28
 800908e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009092:	4605      	mov	r5, r0
 8009094:	e004      	b.n	80090a0 <HAL_I2C_Mem_Read+0x38>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 8009096:	f7ff fa05 	bl	80084a4 <HAL_GetTick>
 800909a:	1b40      	subs	r0, r0, r5
 800909c:	2819      	cmp	r0, #25
 800909e:	d83a      	bhi.n	8009116 <HAL_I2C_Mem_Read+0xae>
  while((__HAL_I2C_GET_FLAG(hi2c, Flag) ? SET : RESET) == Status) 
 80090a0:	6822      	ldr	r2, [r4, #0]
 80090a2:	6993      	ldr	r3, [r2, #24]
 80090a4:	43db      	mvns	r3, r3
 80090a6:	f013 0b02 	ands.w	fp, r3, #2
 80090aa:	d0f4      	beq.n	8009096 <HAL_I2C_Mem_Read+0x2e>
    __HAL_LOCK(hi2c);
 80090ac:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 80090b0:	2b01      	cmp	r3, #1
 80090b2:	d0e9      	beq.n	8009088 <HAL_I2C_Mem_Read+0x20>
    if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
 80090b4:	6813      	ldr	r3, [r2, #0]
    __HAL_LOCK(hi2c);
 80090b6:	2101      	movs	r1, #1
    if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
 80090b8:	07db      	lsls	r3, r3, #31
    __HAL_LOCK(hi2c);
 80090ba:	f884 103c 	strb.w	r1, [r4, #60]	; 0x3c
    if((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
 80090be:	d402      	bmi.n	80090c6 <HAL_I2C_Mem_Read+0x5e>
      __HAL_I2C_ENABLE(hi2c);
 80090c0:	6813      	ldr	r3, [r2, #0]
 80090c2:	430b      	orrs	r3, r1
 80090c4:	6013      	str	r3, [r2, #0]
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 80090c6:	6813      	ldr	r3, [r2, #0]
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 80090c8:	4999      	ldr	r1, [pc, #612]	; (8009330 <HAL_I2C_Mem_Read+0x2c8>)
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 80090ca:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80090ce:	6013      	str	r3, [r2, #0]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80090d0:	f04f 0b00 	mov.w	fp, #0
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 80090d4:	2222      	movs	r2, #34	; 0x22
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 80090d6:	2340      	movs	r3, #64	; 0x40
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 80090d8:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 80090dc:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80090e0:	f8c4 b040 	str.w	fp, [r4, #64]	; 0x40
    hi2c->XferCount   = Size;
 80090e4:	f8a4 a02a 	strh.w	sl, [r4, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 80090e8:	62e1      	str	r1, [r4, #44]	; 0x2c
    hi2c->XferSize    = hi2c->XferCount;
 80090ea:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
    hi2c->pBuffPtr    = pData;
 80090ec:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80090ee:	6263      	str	r3, [r4, #36]	; 0x24
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80090f0:	4639      	mov	r1, r7
 80090f2:	9501      	str	r5, [sp, #4]
 80090f4:	9600      	str	r6, [sp, #0]
 80090f6:	464b      	mov	r3, r9
    hi2c->XferSize    = hi2c->XferCount;
 80090f8:	8520      	strh	r0, [r4, #40]	; 0x28
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80090fa:	4642      	mov	r2, r8
 80090fc:	4620      	mov	r0, r4
 80090fe:	f7ff fd2f 	bl	8008b60 <I2C_RequestMemoryRead>
 8009102:	4607      	mov	r7, r0
 8009104:	b190      	cbz	r0, 800912c <HAL_I2C_Mem_Read+0xc4>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8009106:	6c23      	ldr	r3, [r4, #64]	; 0x40
        __HAL_UNLOCK(hi2c);
 8009108:	f884 b03c 	strb.w	fp, [r4, #60]	; 0x3c
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 800910c:	2b04      	cmp	r3, #4
 800910e:	f000 80e0 	beq.w	80092d2 <HAL_I2C_Mem_Read+0x26a>
              return HAL_TIMEOUT;
 8009112:	2703      	movs	r7, #3
 8009114:	e7b9      	b.n	800908a <HAL_I2C_Mem_Read+0x22>
        hi2c->State= HAL_I2C_STATE_READY;
 8009116:	2320      	movs	r3, #32
        hi2c->PreviousState = I2C_STATE_NONE;
 8009118:	f8c4 b030 	str.w	fp, [r4, #48]	; 0x30
        __HAL_UNLOCK(hi2c);
 800911c:	f884 b03c 	strb.w	fp, [r4, #60]	; 0x3c
        hi2c->State= HAL_I2C_STATE_READY;
 8009120:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
      return HAL_BUSY;
 8009124:	2702      	movs	r7, #2
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8009126:	f884 b03e 	strb.w	fp, [r4, #62]	; 0x3e
 800912a:	e7ae      	b.n	800908a <HAL_I2C_Mem_Read+0x22>
    if(hi2c->XferSize == 0U)
 800912c:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800912e:	6823      	ldr	r3, [r4, #0]
    if(hi2c->XferSize == 0U)
 8009130:	b992      	cbnz	r2, 8009158 <HAL_I2C_Mem_Read+0xf0>
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8009132:	9002      	str	r0, [sp, #8]
 8009134:	695a      	ldr	r2, [r3, #20]
 8009136:	9202      	str	r2, [sp, #8]
 8009138:	699a      	ldr	r2, [r3, #24]
 800913a:	9202      	str	r2, [sp, #8]
 800913c:	9a02      	ldr	r2, [sp, #8]
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 800913e:	681a      	ldr	r2, [r3, #0]
 8009140:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8009144:	601a      	str	r2, [r3, #0]
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8009146:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8009148:	2220      	movs	r2, #32
 800914a:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    __HAL_UNLOCK(hi2c);
 800914e:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8009152:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    return HAL_OK;
 8009156:	e798      	b.n	800908a <HAL_I2C_Mem_Read+0x22>
    else if(hi2c->XferSize == 1U)
 8009158:	2a01      	cmp	r2, #1
 800915a:	f000 80da 	beq.w	8009312 <HAL_I2C_Mem_Read+0x2aa>
    else if(hi2c->XferSize == 2U)
 800915e:	2a02      	cmp	r2, #2
 8009160:	f000 80e8 	beq.w	8009334 <HAL_I2C_Mem_Read+0x2cc>
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8009164:	9005      	str	r0, [sp, #20]
 8009166:	6959      	ldr	r1, [r3, #20]
 8009168:	9105      	str	r1, [sp, #20]
 800916a:	6999      	ldr	r1, [r3, #24]
 800916c:	9105      	str	r1, [sp, #20]
 800916e:	9905      	ldr	r1, [sp, #20]
      if(hi2c->XferSize <= 3U)
 8009170:	2a03      	cmp	r2, #3
 8009172:	d876      	bhi.n	8009262 <HAL_I2C_Mem_Read+0x1fa>
        if(hi2c->XferSize== 1U)
 8009174:	2a01      	cmp	r2, #1
 8009176:	f000 80ae 	beq.w	80092d6 <HAL_I2C_Mem_Read+0x26e>
        else if(hi2c->XferSize == 2U)
 800917a:	2a02      	cmp	r2, #2
 800917c:	d046      	beq.n	800920c <HAL_I2C_Mem_Read+0x1a4>
 800917e:	1c70      	adds	r0, r6, #1
 8009180:	d150      	bne.n	8009224 <HAL_I2C_Mem_Read+0x1bc>
  while((__HAL_I2C_GET_FLAG(hi2c, Flag) ? SET : RESET) == Status) 
 8009182:	695a      	ldr	r2, [r3, #20]
 8009184:	0751      	lsls	r1, r2, #29
 8009186:	d5fc      	bpl.n	8009182 <HAL_I2C_Mem_Read+0x11a>
          hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8009188:	681a      	ldr	r2, [r3, #0]
          (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 800918a:	6a61      	ldr	r1, [r4, #36]	; 0x24
          hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 800918c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8009190:	601a      	str	r2, [r3, #0]
          (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 8009192:	691b      	ldr	r3, [r3, #16]
 8009194:	1c4a      	adds	r2, r1, #1
 8009196:	6262      	str	r2, [r4, #36]	; 0x24
 8009198:	700b      	strb	r3, [r1, #0]
          hi2c->XferCount--;
 800919a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
          hi2c->XferSize--;
 800919c:	8d22      	ldrh	r2, [r4, #40]	; 0x28
          hi2c->XferCount--;
 800919e:	3b01      	subs	r3, #1
 80091a0:	b29b      	uxth	r3, r3
          hi2c->XferSize--;
 80091a2:	3a01      	subs	r2, #1
          hi2c->XferCount--;
 80091a4:	8563      	strh	r3, [r4, #42]	; 0x2a
          hi2c->XferSize--;
 80091a6:	8522      	strh	r2, [r4, #40]	; 0x28
 80091a8:	1c70      	adds	r0, r6, #1
 80091aa:	6822      	ldr	r2, [r4, #0]
 80091ac:	d145      	bne.n	800923a <HAL_I2C_Mem_Read+0x1d2>
  while((__HAL_I2C_GET_FLAG(hi2c, Flag) ? SET : RESET) == Status) 
 80091ae:	6953      	ldr	r3, [r2, #20]
 80091b0:	0759      	lsls	r1, r3, #29
 80091b2:	d5fc      	bpl.n	80091ae <HAL_I2C_Mem_Read+0x146>
          hi2c->Instance->CR1 |= I2C_CR1_STOP;
 80091b4:	6813      	ldr	r3, [r2, #0]
          (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 80091b6:	6a61      	ldr	r1, [r4, #36]	; 0x24
          hi2c->Instance->CR1 |= I2C_CR1_STOP;
 80091b8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80091bc:	6013      	str	r3, [r2, #0]
          (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 80091be:	6913      	ldr	r3, [r2, #16]
 80091c0:	1c4a      	adds	r2, r1, #1
 80091c2:	6262      	str	r2, [r4, #36]	; 0x24
 80091c4:	700b      	strb	r3, [r1, #0]
          hi2c->XferCount--;
 80091c6:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
          hi2c->XferSize--;
 80091c8:	8d21      	ldrh	r1, [r4, #40]	; 0x28
          (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 80091ca:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80091cc:	6822      	ldr	r2, [r4, #0]
          hi2c->XferCount--;
 80091ce:	3b01      	subs	r3, #1
 80091d0:	b29b      	uxth	r3, r3
 80091d2:	8563      	strh	r3, [r4, #42]	; 0x2a
          (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 80091d4:	6912      	ldr	r2, [r2, #16]
          hi2c->XferSize--;
 80091d6:	1e4b      	subs	r3, r1, #1
          (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 80091d8:	1c41      	adds	r1, r0, #1
          hi2c->XferSize--;
 80091da:	8523      	strh	r3, [r4, #40]	; 0x28
          (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 80091dc:	6261      	str	r1, [r4, #36]	; 0x24
 80091de:	7002      	strb	r2, [r0, #0]
          hi2c->XferSize--;
 80091e0:	8d22      	ldrh	r2, [r4, #40]	; 0x28
          hi2c->XferCount--;
 80091e2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
          hi2c->XferSize--;
 80091e4:	3a01      	subs	r2, #1
          hi2c->XferCount--;
 80091e6:	3b01      	subs	r3, #1
          hi2c->XferSize--;
 80091e8:	b292      	uxth	r2, r2
          hi2c->XferCount--;
 80091ea:	b29b      	uxth	r3, r3
          hi2c->XferSize--;
 80091ec:	8522      	strh	r2, [r4, #40]	; 0x28
          hi2c->XferCount--;
 80091ee:	8563      	strh	r3, [r4, #42]	; 0x2a
    while(hi2c->XferSize > 0U)
 80091f0:	2a00      	cmp	r2, #0
 80091f2:	d0a8      	beq.n	8009146 <HAL_I2C_Mem_Read+0xde>
 80091f4:	6823      	ldr	r3, [r4, #0]
 80091f6:	e7bb      	b.n	8009170 <HAL_I2C_Mem_Read+0x108>
  while((__HAL_I2C_GET_FLAG(hi2c, Flag) ? SET : RESET) == Status) 
 80091f8:	695a      	ldr	r2, [r3, #20]
 80091fa:	0752      	lsls	r2, r2, #29
 80091fc:	d40b      	bmi.n	8009216 <HAL_I2C_Mem_Read+0x1ae>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 80091fe:	b32e      	cbz	r6, 800924c <HAL_I2C_Mem_Read+0x1e4>
 8009200:	f7ff f950 	bl	80084a4 <HAL_GetTick>
 8009204:	1b40      	subs	r0, r0, r5
 8009206:	4286      	cmp	r6, r0
 8009208:	d320      	bcc.n	800924c <HAL_I2C_Mem_Read+0x1e4>
 800920a:	6823      	ldr	r3, [r4, #0]
 800920c:	1c70      	adds	r0, r6, #1
 800920e:	d1f3      	bne.n	80091f8 <HAL_I2C_Mem_Read+0x190>
  while((__HAL_I2C_GET_FLAG(hi2c, Flag) ? SET : RESET) == Status) 
 8009210:	695a      	ldr	r2, [r3, #20]
 8009212:	0751      	lsls	r1, r2, #29
 8009214:	d5fc      	bpl.n	8009210 <HAL_I2C_Mem_Read+0x1a8>
          hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8009216:	681a      	ldr	r2, [r3, #0]
          (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 8009218:	6a61      	ldr	r1, [r4, #36]	; 0x24
          hi2c->Instance->CR1 |= I2C_CR1_STOP;
 800921a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800921e:	601a      	str	r2, [r3, #0]
          (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 8009220:	691b      	ldr	r3, [r3, #16]
 8009222:	e7cd      	b.n	80091c0 <HAL_I2C_Mem_Read+0x158>
  while((__HAL_I2C_GET_FLAG(hi2c, Flag) ? SET : RESET) == Status) 
 8009224:	695a      	ldr	r2, [r3, #20]
 8009226:	0752      	lsls	r2, r2, #29
 8009228:	d4ae      	bmi.n	8009188 <HAL_I2C_Mem_Read+0x120>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 800922a:	b17e      	cbz	r6, 800924c <HAL_I2C_Mem_Read+0x1e4>
 800922c:	f7ff f93a 	bl	80084a4 <HAL_GetTick>
 8009230:	1b40      	subs	r0, r0, r5
 8009232:	4286      	cmp	r6, r0
 8009234:	d30a      	bcc.n	800924c <HAL_I2C_Mem_Read+0x1e4>
 8009236:	6823      	ldr	r3, [r4, #0]
 8009238:	e7a1      	b.n	800917e <HAL_I2C_Mem_Read+0x116>
  while((__HAL_I2C_GET_FLAG(hi2c, Flag) ? SET : RESET) == Status) 
 800923a:	6953      	ldr	r3, [r2, #20]
 800923c:	075b      	lsls	r3, r3, #29
 800923e:	d4b9      	bmi.n	80091b4 <HAL_I2C_Mem_Read+0x14c>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 8009240:	b126      	cbz	r6, 800924c <HAL_I2C_Mem_Read+0x1e4>
 8009242:	f7ff f92f 	bl	80084a4 <HAL_GetTick>
 8009246:	1b40      	subs	r0, r0, r5
 8009248:	4286      	cmp	r6, r0
 800924a:	d2ad      	bcs.n	80091a8 <HAL_I2C_Mem_Read+0x140>
        hi2c->PreviousState = I2C_STATE_NONE;
 800924c:	2300      	movs	r3, #0
        hi2c->State= HAL_I2C_STATE_READY;
 800924e:	2220      	movs	r2, #32
        hi2c->PreviousState = I2C_STATE_NONE;
 8009250:	6323      	str	r3, [r4, #48]	; 0x30
        __HAL_UNLOCK(hi2c);
 8009252:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
        hi2c->State= HAL_I2C_STATE_READY;
 8009256:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
            return HAL_TIMEOUT;
 800925a:	2703      	movs	r7, #3
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800925c:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 8009260:	e713      	b.n	800908a <HAL_I2C_Mem_Read+0x22>
 8009262:	b94e      	cbnz	r6, 8009278 <HAL_I2C_Mem_Read+0x210>
 8009264:	e022      	b.n	80092ac <HAL_I2C_Mem_Read+0x244>
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 8009266:	695a      	ldr	r2, [r3, #20]
 8009268:	06d2      	lsls	r2, r2, #27
 800926a:	d442      	bmi.n	80092f2 <HAL_I2C_Mem_Read+0x28a>
    if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 800926c:	f7ff f91a 	bl	80084a4 <HAL_GetTick>
 8009270:	1b40      	subs	r0, r0, r5
 8009272:	4286      	cmp	r6, r0
 8009274:	d320      	bcc.n	80092b8 <HAL_I2C_Mem_Read+0x250>
 8009276:	6823      	ldr	r3, [r4, #0]
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 8009278:	695a      	ldr	r2, [r3, #20]
 800927a:	0651      	lsls	r1, r2, #25
 800927c:	d5f3      	bpl.n	8009266 <HAL_I2C_Mem_Read+0x1fe>
        (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 800927e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8009280:	691b      	ldr	r3, [r3, #16]
 8009282:	1c51      	adds	r1, r2, #1
 8009284:	6261      	str	r1, [r4, #36]	; 0x24
 8009286:	7013      	strb	r3, [r2, #0]
        hi2c->XferCount--;
 8009288:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
        if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
 800928a:	6823      	ldr	r3, [r4, #0]
        hi2c->XferSize--;
 800928c:	8d22      	ldrh	r2, [r4, #40]	; 0x28
        hi2c->XferCount--;
 800928e:	3901      	subs	r1, #1
 8009290:	b289      	uxth	r1, r1
 8009292:	8561      	strh	r1, [r4, #42]	; 0x2a
        if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
 8009294:	6959      	ldr	r1, [r3, #20]
        hi2c->XferSize--;
 8009296:	3a01      	subs	r2, #1
 8009298:	b292      	uxth	r2, r2
        if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
 800929a:	0749      	lsls	r1, r1, #29
        hi2c->XferSize--;
 800929c:	8522      	strh	r2, [r4, #40]	; 0x28
        if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
 800929e:	d5a7      	bpl.n	80091f0 <HAL_I2C_Mem_Read+0x188>
          (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 80092a0:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80092a2:	691b      	ldr	r3, [r3, #16]
 80092a4:	1c51      	adds	r1, r2, #1
 80092a6:	6261      	str	r1, [r4, #36]	; 0x24
 80092a8:	7013      	strb	r3, [r2, #0]
 80092aa:	e799      	b.n	80091e0 <HAL_I2C_Mem_Read+0x178>
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 80092ac:	695a      	ldr	r2, [r3, #20]
 80092ae:	0650      	lsls	r0, r2, #25
 80092b0:	d4e5      	bmi.n	800927e <HAL_I2C_Mem_Read+0x216>
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 80092b2:	695a      	ldr	r2, [r3, #20]
 80092b4:	06d0      	lsls	r0, r2, #27
 80092b6:	d41c      	bmi.n	80092f2 <HAL_I2C_Mem_Read+0x28a>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80092b8:	6c23      	ldr	r3, [r4, #64]	; 0x40
      hi2c->State= HAL_I2C_STATE_READY;
 80092ba:	2220      	movs	r2, #32
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80092bc:	4313      	orrs	r3, r2
      __HAL_UNLOCK(hi2c);
 80092be:	2100      	movs	r1, #0
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80092c0:	6423      	str	r3, [r4, #64]	; 0x40
      __HAL_UNLOCK(hi2c);
 80092c2:	f884 103c 	strb.w	r1, [r4, #60]	; 0x3c
      hi2c->State= HAL_I2C_STATE_READY;
 80092c6:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
            if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
 80092ca:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80092cc:	2b20      	cmp	r3, #32
 80092ce:	f43f af20 	beq.w	8009112 <HAL_I2C_Mem_Read+0xaa>
              return HAL_ERROR;
 80092d2:	2701      	movs	r7, #1
 80092d4:	e6d9      	b.n	800908a <HAL_I2C_Mem_Read+0x22>
 80092d6:	b936      	cbnz	r6, 80092e6 <HAL_I2C_Mem_Read+0x27e>
 80092d8:	e017      	b.n	800930a <HAL_I2C_Mem_Read+0x2a2>
    if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 80092da:	f7ff f8e3 	bl	80084a4 <HAL_GetTick>
 80092de:	1b40      	subs	r0, r0, r5
 80092e0:	4286      	cmp	r6, r0
 80092e2:	d3e9      	bcc.n	80092b8 <HAL_I2C_Mem_Read+0x250>
 80092e4:	6823      	ldr	r3, [r4, #0]
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 80092e6:	695a      	ldr	r2, [r3, #20]
 80092e8:	0650      	lsls	r0, r2, #25
 80092ea:	d4d9      	bmi.n	80092a0 <HAL_I2C_Mem_Read+0x238>
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 80092ec:	695a      	ldr	r2, [r3, #20]
 80092ee:	06d1      	lsls	r1, r2, #27
 80092f0:	d5f3      	bpl.n	80092da <HAL_I2C_Mem_Read+0x272>
      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80092f2:	2200      	movs	r2, #0
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80092f4:	f06f 0010 	mvn.w	r0, #16
      hi2c->State= HAL_I2C_STATE_READY;
 80092f8:	2120      	movs	r1, #32
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80092fa:	6158      	str	r0, [r3, #20]
      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80092fc:	6422      	str	r2, [r4, #64]	; 0x40
      __HAL_UNLOCK(hi2c);
 80092fe:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
      hi2c->PreviousState = I2C_STATE_NONE;
 8009302:	6322      	str	r2, [r4, #48]	; 0x30
      hi2c->State= HAL_I2C_STATE_READY;
 8009304:	f884 103d 	strb.w	r1, [r4, #61]	; 0x3d
 8009308:	e7df      	b.n	80092ca <HAL_I2C_Mem_Read+0x262>
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 800930a:	695a      	ldr	r2, [r3, #20]
 800930c:	0652      	lsls	r2, r2, #25
 800930e:	d5d0      	bpl.n	80092b2 <HAL_I2C_Mem_Read+0x24a>
 8009310:	e7c6      	b.n	80092a0 <HAL_I2C_Mem_Read+0x238>
      hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8009312:	6819      	ldr	r1, [r3, #0]
 8009314:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8009318:	6019      	str	r1, [r3, #0]
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800931a:	9003      	str	r0, [sp, #12]
 800931c:	6959      	ldr	r1, [r3, #20]
 800931e:	9103      	str	r1, [sp, #12]
 8009320:	6999      	ldr	r1, [r3, #24]
 8009322:	9103      	str	r1, [sp, #12]
 8009324:	9903      	ldr	r1, [sp, #12]
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8009326:	6819      	ldr	r1, [r3, #0]
 8009328:	f441 7100 	orr.w	r1, r1, #512	; 0x200
 800932c:	6019      	str	r1, [r3, #0]
 800932e:	e71f      	b.n	8009170 <HAL_I2C_Mem_Read+0x108>
 8009330:	ffff0000 	.word	0xffff0000
      hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8009334:	6819      	ldr	r1, [r3, #0]
 8009336:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 800933a:	6019      	str	r1, [r3, #0]
      hi2c->Instance->CR1 |= I2C_CR1_POS;
 800933c:	6819      	ldr	r1, [r3, #0]
 800933e:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
 8009342:	6019      	str	r1, [r3, #0]
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8009344:	9004      	str	r0, [sp, #16]
 8009346:	6959      	ldr	r1, [r3, #20]
 8009348:	9104      	str	r1, [sp, #16]
 800934a:	6999      	ldr	r1, [r3, #24]
 800934c:	9104      	str	r1, [sp, #16]
 800934e:	9904      	ldr	r1, [sp, #16]
 8009350:	e70e      	b.n	8009170 <HAL_I2C_Mem_Read+0x108>
 8009352:	bf00      	nop

08009354 <HAL_I2C_GetState>:
  return hi2c->State;
 8009354:	f890 003d 	ldrb.w	r0, [r0, #61]	; 0x3d
}
 8009358:	4770      	bx	lr
 800935a:	bf00      	nop

0800935c <HAL_RCC_OscConfig>:
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 800935c:	2800      	cmp	r0, #0
 800935e:	f000 81b2 	beq.w	80096c6 <HAL_RCC_OscConfig+0x36a>
{
 8009362:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8009366:	6803      	ldr	r3, [r0, #0]
 8009368:	07dd      	lsls	r5, r3, #31
{
 800936a:	b082      	sub	sp, #8
 800936c:	4604      	mov	r4, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800936e:	d52f      	bpl.n	80093d0 <HAL_RCC_OscConfig+0x74>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8009370:	49ab      	ldr	r1, [pc, #684]	; (8009620 <HAL_RCC_OscConfig+0x2c4>)
 8009372:	688a      	ldr	r2, [r1, #8]
 8009374:	f002 020c 	and.w	r2, r2, #12
 8009378:	2a04      	cmp	r2, #4
 800937a:	f000 8123 	beq.w	80095c4 <HAL_RCC_OscConfig+0x268>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800937e:	688a      	ldr	r2, [r1, #8]
 8009380:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8009384:	2a08      	cmp	r2, #8
 8009386:	f000 8119 	beq.w	80095bc <HAL_RCC_OscConfig+0x260>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800938a:	6863      	ldr	r3, [r4, #4]
 800938c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8009390:	f000 815a 	beq.w	8009648 <HAL_RCC_OscConfig+0x2ec>
 8009394:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8009398:	f000 80e5 	beq.w	8009566 <HAL_RCC_OscConfig+0x20a>
 800939c:	4da0      	ldr	r5, [pc, #640]	; (8009620 <HAL_RCC_OscConfig+0x2c4>)
 800939e:	682a      	ldr	r2, [r5, #0]
 80093a0:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80093a4:	602a      	str	r2, [r5, #0]
 80093a6:	682a      	ldr	r2, [r5, #0]
 80093a8:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80093ac:	602a      	str	r2, [r5, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 80093ae:	2b00      	cmp	r3, #0
 80093b0:	f040 80e2 	bne.w	8009578 <HAL_RCC_OscConfig+0x21c>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80093b4:	f7ff f876 	bl	80084a4 <HAL_GetTick>
 80093b8:	4606      	mov	r6, r0

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80093ba:	e005      	b.n	80093c8 <HAL_RCC_OscConfig+0x6c>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80093bc:	f7ff f872 	bl	80084a4 <HAL_GetTick>
 80093c0:	1b80      	subs	r0, r0, r6
 80093c2:	2864      	cmp	r0, #100	; 0x64
 80093c4:	f200 80f6 	bhi.w	80095b4 <HAL_RCC_OscConfig+0x258>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80093c8:	682b      	ldr	r3, [r5, #0]
 80093ca:	039b      	lsls	r3, r3, #14
 80093cc:	d4f6      	bmi.n	80093bc <HAL_RCC_OscConfig+0x60>
 80093ce:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80093d0:	079f      	lsls	r7, r3, #30
 80093d2:	d528      	bpl.n	8009426 <HAL_RCC_OscConfig+0xca>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 80093d4:	4a92      	ldr	r2, [pc, #584]	; (8009620 <HAL_RCC_OscConfig+0x2c4>)
 80093d6:	6891      	ldr	r1, [r2, #8]
 80093d8:	f011 0f0c 	tst.w	r1, #12
 80093dc:	f000 8090 	beq.w	8009500 <HAL_RCC_OscConfig+0x1a4>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80093e0:	6891      	ldr	r1, [r2, #8]
 80093e2:	f001 010c 	and.w	r1, r1, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 80093e6:	2908      	cmp	r1, #8
 80093e8:	f000 8086 	beq.w	80094f8 <HAL_RCC_OscConfig+0x19c>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 80093ec:	68e3      	ldr	r3, [r4, #12]
 80093ee:	2b00      	cmp	r3, #0
 80093f0:	f000 810f 	beq.w	8009612 <HAL_RCC_OscConfig+0x2b6>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80093f4:	4b8b      	ldr	r3, [pc, #556]	; (8009624 <HAL_RCC_OscConfig+0x2c8>)

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80093f6:	4d8a      	ldr	r5, [pc, #552]	; (8009620 <HAL_RCC_OscConfig+0x2c4>)
        __HAL_RCC_HSI_ENABLE();
 80093f8:	2201      	movs	r2, #1
 80093fa:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80093fc:	f7ff f852 	bl	80084a4 <HAL_GetTick>
 8009400:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8009402:	e005      	b.n	8009410 <HAL_RCC_OscConfig+0xb4>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8009404:	f7ff f84e 	bl	80084a4 <HAL_GetTick>
 8009408:	1b80      	subs	r0, r0, r6
 800940a:	2802      	cmp	r0, #2
 800940c:	f200 80d2 	bhi.w	80095b4 <HAL_RCC_OscConfig+0x258>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8009410:	682b      	ldr	r3, [r5, #0]
 8009412:	0798      	lsls	r0, r3, #30
 8009414:	d5f6      	bpl.n	8009404 <HAL_RCC_OscConfig+0xa8>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value. */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8009416:	682b      	ldr	r3, [r5, #0]
 8009418:	6922      	ldr	r2, [r4, #16]
 800941a:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800941e:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8009422:	602b      	str	r3, [r5, #0]
 8009424:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8009426:	071a      	lsls	r2, r3, #28
 8009428:	d452      	bmi.n	80094d0 <HAL_RCC_OscConfig+0x174>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800942a:	0758      	lsls	r0, r3, #29
 800942c:	d530      	bpl.n	8009490 <HAL_RCC_OscConfig+0x134>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800942e:	4a7c      	ldr	r2, [pc, #496]	; (8009620 <HAL_RCC_OscConfig+0x2c4>)
 8009430:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8009432:	f013 5380 	ands.w	r3, r3, #268435456	; 0x10000000
 8009436:	d07e      	beq.n	8009536 <HAL_RCC_OscConfig+0x1da>
    FlagStatus       pwrclkchanged = RESET;
 8009438:	2600      	movs	r6, #0
    {
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800943a:	4d7b      	ldr	r5, [pc, #492]	; (8009628 <HAL_RCC_OscConfig+0x2cc>)
 800943c:	682b      	ldr	r3, [r5, #0]
 800943e:	05d9      	lsls	r1, r3, #23
 8009440:	f140 80a8 	bpl.w	8009594 <HAL_RCC_OscConfig+0x238>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8009444:	68a3      	ldr	r3, [r4, #8]
 8009446:	2b01      	cmp	r3, #1
 8009448:	f000 8104 	beq.w	8009654 <HAL_RCC_OscConfig+0x2f8>
 800944c:	2b05      	cmp	r3, #5
 800944e:	f000 80c3 	beq.w	80095d8 <HAL_RCC_OscConfig+0x27c>
 8009452:	4d73      	ldr	r5, [pc, #460]	; (8009620 <HAL_RCC_OscConfig+0x2c4>)
 8009454:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8009456:	f022 0201 	bic.w	r2, r2, #1
 800945a:	672a      	str	r2, [r5, #112]	; 0x70
 800945c:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 800945e:	f022 0204 	bic.w	r2, r2, #4
 8009462:	672a      	str	r2, [r5, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8009464:	2b00      	cmp	r3, #0
 8009466:	f040 80c0 	bne.w	80095ea <HAL_RCC_OscConfig+0x28e>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800946a:	f7ff f81b 	bl	80084a4 <HAL_GetTick>

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800946e:	f241 3788 	movw	r7, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8009472:	4680      	mov	r8, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8009474:	e006      	b.n	8009484 <HAL_RCC_OscConfig+0x128>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8009476:	f7ff f815 	bl	80084a4 <HAL_GetTick>
 800947a:	eba0 0008 	sub.w	r0, r0, r8
 800947e:	42b8      	cmp	r0, r7
 8009480:	f200 8098 	bhi.w	80095b4 <HAL_RCC_OscConfig+0x258>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8009484:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8009486:	0798      	lsls	r0, r3, #30
 8009488:	d4f5      	bmi.n	8009476 <HAL_RCC_OscConfig+0x11a>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 800948a:	2e00      	cmp	r6, #0
 800948c:	f040 80e8 	bne.w	8009660 <HAL_RCC_OscConfig+0x304>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8009490:	69a3      	ldr	r3, [r4, #24]
 8009492:	b1cb      	cbz	r3, 80094c8 <HAL_RCC_OscConfig+0x16c>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8009494:	4d62      	ldr	r5, [pc, #392]	; (8009620 <HAL_RCC_OscConfig+0x2c4>)
 8009496:	68aa      	ldr	r2, [r5, #8]
 8009498:	f002 020c 	and.w	r2, r2, #12
 800949c:	2a08      	cmp	r2, #8
 800949e:	d036      	beq.n	800950e <HAL_RCC_OscConfig+0x1b2>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80094a0:	2b02      	cmp	r3, #2
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80094a2:	4b62      	ldr	r3, [pc, #392]	; (800962c <HAL_RCC_OscConfig+0x2d0>)
 80094a4:	f04f 0200 	mov.w	r2, #0
 80094a8:	601a      	str	r2, [r3, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80094aa:	f000 80df 	beq.w	800966c <HAL_RCC_OscConfig+0x310>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80094ae:	f7fe fff9 	bl	80084a4 <HAL_GetTick>

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80094b2:	462c      	mov	r4, r5
        tickstart = HAL_GetTick();
 80094b4:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80094b6:	e004      	b.n	80094c2 <HAL_RCC_OscConfig+0x166>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80094b8:	f7fe fff4 	bl	80084a4 <HAL_GetTick>
 80094bc:	1b40      	subs	r0, r0, r5
 80094be:	2802      	cmp	r0, #2
 80094c0:	d878      	bhi.n	80095b4 <HAL_RCC_OscConfig+0x258>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80094c2:	6823      	ldr	r3, [r4, #0]
 80094c4:	019b      	lsls	r3, r3, #6
 80094c6:	d4f7      	bmi.n	80094b8 <HAL_RCC_OscConfig+0x15c>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 80094c8:	2000      	movs	r0, #0
}
 80094ca:	b002      	add	sp, #8
 80094cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 80094d0:	6963      	ldr	r3, [r4, #20]
 80094d2:	b303      	cbz	r3, 8009516 <HAL_RCC_OscConfig+0x1ba>
      __HAL_RCC_LSI_ENABLE();
 80094d4:	4b56      	ldr	r3, [pc, #344]	; (8009630 <HAL_RCC_OscConfig+0x2d4>)
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80094d6:	4d52      	ldr	r5, [pc, #328]	; (8009620 <HAL_RCC_OscConfig+0x2c4>)
      __HAL_RCC_LSI_ENABLE();
 80094d8:	2201      	movs	r2, #1
 80094da:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 80094dc:	f7fe ffe2 	bl	80084a4 <HAL_GetTick>
 80094e0:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80094e2:	e004      	b.n	80094ee <HAL_RCC_OscConfig+0x192>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80094e4:	f7fe ffde 	bl	80084a4 <HAL_GetTick>
 80094e8:	1b80      	subs	r0, r0, r6
 80094ea:	2802      	cmp	r0, #2
 80094ec:	d862      	bhi.n	80095b4 <HAL_RCC_OscConfig+0x258>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80094ee:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 80094f0:	079b      	lsls	r3, r3, #30
 80094f2:	d5f7      	bpl.n	80094e4 <HAL_RCC_OscConfig+0x188>
 80094f4:	6823      	ldr	r3, [r4, #0]
 80094f6:	e798      	b.n	800942a <HAL_RCC_OscConfig+0xce>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80094f8:	6852      	ldr	r2, [r2, #4]
 80094fa:	0256      	lsls	r6, r2, #9
 80094fc:	f53f af76 	bmi.w	80093ec <HAL_RCC_OscConfig+0x90>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8009500:	4a47      	ldr	r2, [pc, #284]	; (8009620 <HAL_RCC_OscConfig+0x2c4>)
 8009502:	6812      	ldr	r2, [r2, #0]
 8009504:	0795      	lsls	r5, r2, #30
 8009506:	d522      	bpl.n	800954e <HAL_RCC_OscConfig+0x1f2>
 8009508:	68e2      	ldr	r2, [r4, #12]
 800950a:	2a01      	cmp	r2, #1
 800950c:	d01f      	beq.n	800954e <HAL_RCC_OscConfig+0x1f2>
    return HAL_ERROR;
 800950e:	2001      	movs	r0, #1
}
 8009510:	b002      	add	sp, #8
 8009512:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_LSI_DISABLE();
 8009516:	4a46      	ldr	r2, [pc, #280]	; (8009630 <HAL_RCC_OscConfig+0x2d4>)
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8009518:	4d41      	ldr	r5, [pc, #260]	; (8009620 <HAL_RCC_OscConfig+0x2c4>)
      __HAL_RCC_LSI_DISABLE();
 800951a:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 800951c:	f7fe ffc2 	bl	80084a4 <HAL_GetTick>
 8009520:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8009522:	e004      	b.n	800952e <HAL_RCC_OscConfig+0x1d2>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8009524:	f7fe ffbe 	bl	80084a4 <HAL_GetTick>
 8009528:	1b80      	subs	r0, r0, r6
 800952a:	2802      	cmp	r0, #2
 800952c:	d842      	bhi.n	80095b4 <HAL_RCC_OscConfig+0x258>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800952e:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8009530:	079f      	lsls	r7, r3, #30
 8009532:	d4f7      	bmi.n	8009524 <HAL_RCC_OscConfig+0x1c8>
 8009534:	e7de      	b.n	80094f4 <HAL_RCC_OscConfig+0x198>
      __HAL_RCC_PWR_CLK_ENABLE();
 8009536:	9301      	str	r3, [sp, #4]
 8009538:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800953a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800953e:	6413      	str	r3, [r2, #64]	; 0x40
 8009540:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8009542:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8009546:	9301      	str	r3, [sp, #4]
 8009548:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 800954a:	2601      	movs	r6, #1
 800954c:	e775      	b.n	800943a <HAL_RCC_OscConfig+0xde>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800954e:	4934      	ldr	r1, [pc, #208]	; (8009620 <HAL_RCC_OscConfig+0x2c4>)
 8009550:	6920      	ldr	r0, [r4, #16]
 8009552:	680a      	ldr	r2, [r1, #0]
 8009554:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8009558:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
 800955c:	600a      	str	r2, [r1, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800955e:	071a      	lsls	r2, r3, #28
 8009560:	f57f af63 	bpl.w	800942a <HAL_RCC_OscConfig+0xce>
 8009564:	e7b4      	b.n	80094d0 <HAL_RCC_OscConfig+0x174>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8009566:	4b2e      	ldr	r3, [pc, #184]	; (8009620 <HAL_RCC_OscConfig+0x2c4>)
 8009568:	681a      	ldr	r2, [r3, #0]
 800956a:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800956e:	601a      	str	r2, [r3, #0]
 8009570:	681a      	ldr	r2, [r3, #0]
 8009572:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8009576:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8009578:	f7fe ff94 	bl	80084a4 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800957c:	4d28      	ldr	r5, [pc, #160]	; (8009620 <HAL_RCC_OscConfig+0x2c4>)
        tickstart = HAL_GetTick();
 800957e:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8009580:	e004      	b.n	800958c <HAL_RCC_OscConfig+0x230>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8009582:	f7fe ff8f 	bl	80084a4 <HAL_GetTick>
 8009586:	1b80      	subs	r0, r0, r6
 8009588:	2864      	cmp	r0, #100	; 0x64
 800958a:	d813      	bhi.n	80095b4 <HAL_RCC_OscConfig+0x258>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800958c:	682b      	ldr	r3, [r5, #0]
 800958e:	039a      	lsls	r2, r3, #14
 8009590:	d5f7      	bpl.n	8009582 <HAL_RCC_OscConfig+0x226>
 8009592:	e71c      	b.n	80093ce <HAL_RCC_OscConfig+0x72>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8009594:	682b      	ldr	r3, [r5, #0]
 8009596:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800959a:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 800959c:	f7fe ff82 	bl	80084a4 <HAL_GetTick>
 80095a0:	4607      	mov	r7, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80095a2:	682b      	ldr	r3, [r5, #0]
 80095a4:	05da      	lsls	r2, r3, #23
 80095a6:	f53f af4d 	bmi.w	8009444 <HAL_RCC_OscConfig+0xe8>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80095aa:	f7fe ff7b 	bl	80084a4 <HAL_GetTick>
 80095ae:	1bc0      	subs	r0, r0, r7
 80095b0:	2802      	cmp	r0, #2
 80095b2:	d9f6      	bls.n	80095a2 <HAL_RCC_OscConfig+0x246>
            return HAL_TIMEOUT;
 80095b4:	2003      	movs	r0, #3
}
 80095b6:	b002      	add	sp, #8
 80095b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80095bc:	684a      	ldr	r2, [r1, #4]
 80095be:	0250      	lsls	r0, r2, #9
 80095c0:	f57f aee3 	bpl.w	800938a <HAL_RCC_OscConfig+0x2e>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80095c4:	4a16      	ldr	r2, [pc, #88]	; (8009620 <HAL_RCC_OscConfig+0x2c4>)
 80095c6:	6812      	ldr	r2, [r2, #0]
 80095c8:	0391      	lsls	r1, r2, #14
 80095ca:	f57f af01 	bpl.w	80093d0 <HAL_RCC_OscConfig+0x74>
 80095ce:	6862      	ldr	r2, [r4, #4]
 80095d0:	2a00      	cmp	r2, #0
 80095d2:	f47f aefd 	bne.w	80093d0 <HAL_RCC_OscConfig+0x74>
 80095d6:	e79a      	b.n	800950e <HAL_RCC_OscConfig+0x1b2>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80095d8:	4b11      	ldr	r3, [pc, #68]	; (8009620 <HAL_RCC_OscConfig+0x2c4>)
 80095da:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80095dc:	f042 0204 	orr.w	r2, r2, #4
 80095e0:	671a      	str	r2, [r3, #112]	; 0x70
 80095e2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80095e4:	f042 0201 	orr.w	r2, r2, #1
 80095e8:	671a      	str	r2, [r3, #112]	; 0x70
      tickstart = HAL_GetTick();
 80095ea:	f7fe ff5b 	bl	80084a4 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80095ee:	4d0c      	ldr	r5, [pc, #48]	; (8009620 <HAL_RCC_OscConfig+0x2c4>)
      tickstart = HAL_GetTick();
 80095f0:	4680      	mov	r8, r0
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80095f2:	f241 3788 	movw	r7, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80095f6:	e005      	b.n	8009604 <HAL_RCC_OscConfig+0x2a8>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80095f8:	f7fe ff54 	bl	80084a4 <HAL_GetTick>
 80095fc:	eba0 0008 	sub.w	r0, r0, r8
 8009600:	42b8      	cmp	r0, r7
 8009602:	d8d7      	bhi.n	80095b4 <HAL_RCC_OscConfig+0x258>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8009604:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8009606:	079b      	lsls	r3, r3, #30
 8009608:	d5f6      	bpl.n	80095f8 <HAL_RCC_OscConfig+0x29c>
    if(pwrclkchanged == SET)
 800960a:	2e00      	cmp	r6, #0
 800960c:	f43f af40 	beq.w	8009490 <HAL_RCC_OscConfig+0x134>
 8009610:	e026      	b.n	8009660 <HAL_RCC_OscConfig+0x304>
        __HAL_RCC_HSI_DISABLE();
 8009612:	4a04      	ldr	r2, [pc, #16]	; (8009624 <HAL_RCC_OscConfig+0x2c8>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8009614:	4d02      	ldr	r5, [pc, #8]	; (8009620 <HAL_RCC_OscConfig+0x2c4>)
        __HAL_RCC_HSI_DISABLE();
 8009616:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8009618:	f7fe ff44 	bl	80084a4 <HAL_GetTick>
 800961c:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800961e:	e00e      	b.n	800963e <HAL_RCC_OscConfig+0x2e2>
 8009620:	40023800 	.word	0x40023800
 8009624:	42470000 	.word	0x42470000
 8009628:	40007000 	.word	0x40007000
 800962c:	42470060 	.word	0x42470060
 8009630:	42470e80 	.word	0x42470e80
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8009634:	f7fe ff36 	bl	80084a4 <HAL_GetTick>
 8009638:	1b80      	subs	r0, r0, r6
 800963a:	2802      	cmp	r0, #2
 800963c:	d8ba      	bhi.n	80095b4 <HAL_RCC_OscConfig+0x258>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800963e:	682b      	ldr	r3, [r5, #0]
 8009640:	0799      	lsls	r1, r3, #30
 8009642:	d4f7      	bmi.n	8009634 <HAL_RCC_OscConfig+0x2d8>
 8009644:	6823      	ldr	r3, [r4, #0]
 8009646:	e6ee      	b.n	8009426 <HAL_RCC_OscConfig+0xca>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8009648:	4a20      	ldr	r2, [pc, #128]	; (80096cc <HAL_RCC_OscConfig+0x370>)
 800964a:	6813      	ldr	r3, [r2, #0]
 800964c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8009650:	6013      	str	r3, [r2, #0]
 8009652:	e791      	b.n	8009578 <HAL_RCC_OscConfig+0x21c>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8009654:	4a1d      	ldr	r2, [pc, #116]	; (80096cc <HAL_RCC_OscConfig+0x370>)
 8009656:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8009658:	f043 0301 	orr.w	r3, r3, #1
 800965c:	6713      	str	r3, [r2, #112]	; 0x70
 800965e:	e7c4      	b.n	80095ea <HAL_RCC_OscConfig+0x28e>
      __HAL_RCC_PWR_CLK_DISABLE();
 8009660:	4a1a      	ldr	r2, [pc, #104]	; (80096cc <HAL_RCC_OscConfig+0x370>)
 8009662:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8009664:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8009668:	6413      	str	r3, [r2, #64]	; 0x40
 800966a:	e711      	b.n	8009490 <HAL_RCC_OscConfig+0x134>
        tickstart = HAL_GetTick();
 800966c:	f7fe ff1a 	bl	80084a4 <HAL_GetTick>
 8009670:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8009672:	e004      	b.n	800967e <HAL_RCC_OscConfig+0x322>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8009674:	f7fe ff16 	bl	80084a4 <HAL_GetTick>
 8009678:	1b80      	subs	r0, r0, r6
 800967a:	2802      	cmp	r0, #2
 800967c:	d89a      	bhi.n	80095b4 <HAL_RCC_OscConfig+0x258>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800967e:	682b      	ldr	r3, [r5, #0]
 8009680:	0199      	lsls	r1, r3, #6
 8009682:	d4f7      	bmi.n	8009674 <HAL_RCC_OscConfig+0x318>
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8009684:	69e3      	ldr	r3, [r4, #28]
 8009686:	6a27      	ldr	r7, [r4, #32]
 8009688:	6a66      	ldr	r6, [r4, #36]	; 0x24
 800968a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800968c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
        __HAL_RCC_PLL_ENABLE();
 800968e:	4910      	ldr	r1, [pc, #64]	; (80096d0 <HAL_RCC_OscConfig+0x374>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8009690:	4c0e      	ldr	r4, [pc, #56]	; (80096cc <HAL_RCC_OscConfig+0x370>)
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8009692:	433b      	orrs	r3, r7
 8009694:	ea43 1386 	orr.w	r3, r3, r6, lsl #6
 8009698:	0852      	lsrs	r2, r2, #1
 800969a:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 800969e:	3a01      	subs	r2, #1
 80096a0:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
        __HAL_RCC_PLL_ENABLE();
 80096a4:	2201      	movs	r2, #1
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 80096a6:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 80096a8:	600a      	str	r2, [r1, #0]
        tickstart = HAL_GetTick();
 80096aa:	f7fe fefb 	bl	80084a4 <HAL_GetTick>
 80096ae:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80096b0:	e005      	b.n	80096be <HAL_RCC_OscConfig+0x362>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80096b2:	f7fe fef7 	bl	80084a4 <HAL_GetTick>
 80096b6:	1b40      	subs	r0, r0, r5
 80096b8:	2802      	cmp	r0, #2
 80096ba:	f63f af7b 	bhi.w	80095b4 <HAL_RCC_OscConfig+0x258>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80096be:	6823      	ldr	r3, [r4, #0]
 80096c0:	019a      	lsls	r2, r3, #6
 80096c2:	d5f6      	bpl.n	80096b2 <HAL_RCC_OscConfig+0x356>
 80096c4:	e700      	b.n	80094c8 <HAL_RCC_OscConfig+0x16c>
    return HAL_ERROR;
 80096c6:	2001      	movs	r0, #1
}
 80096c8:	4770      	bx	lr
 80096ca:	bf00      	nop
 80096cc:	40023800 	.word	0x40023800
 80096d0:	42470060 	.word	0x42470060

080096d4 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80096d4:	4917      	ldr	r1, [pc, #92]	; (8009734 <HAL_RCC_GetSysClockFreq+0x60>)
{
 80096d6:	b508      	push	{r3, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80096d8:	688b      	ldr	r3, [r1, #8]
 80096da:	f003 030c 	and.w	r3, r3, #12
 80096de:	2b04      	cmp	r3, #4
 80096e0:	d01b      	beq.n	800971a <HAL_RCC_GetSysClockFreq+0x46>
 80096e2:	2b08      	cmp	r3, #8
 80096e4:	d117      	bne.n	8009716 <HAL_RCC_GetSysClockFreq+0x42>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80096e6:	684a      	ldr	r2, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80096e8:	684b      	ldr	r3, [r1, #4]
 80096ea:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80096ee:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80096f2:	d114      	bne.n	800971e <HAL_RCC_GetSysClockFreq+0x4a>
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80096f4:	6849      	ldr	r1, [r1, #4]
 80096f6:	4810      	ldr	r0, [pc, #64]	; (8009738 <HAL_RCC_GetSysClockFreq+0x64>)
 80096f8:	f3c1 1188 	ubfx	r1, r1, #6, #9
 80096fc:	fba1 0100 	umull	r0, r1, r1, r0
 8009700:	f7f7 fa08 	bl	8000b14 <__aeabi_uldivmod>
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 8009704:	4b0b      	ldr	r3, [pc, #44]	; (8009734 <HAL_RCC_GetSysClockFreq+0x60>)
 8009706:	685b      	ldr	r3, [r3, #4]
 8009708:	f3c3 4301 	ubfx	r3, r3, #16, #2
 800970c:	3301      	adds	r3, #1
 800970e:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco/pllp;
 8009710:	fbb0 f0f3 	udiv	r0, r0, r3
 8009714:	bd08      	pop	{r3, pc}
      sysclockfreq = HSI_VALUE;
 8009716:	4808      	ldr	r0, [pc, #32]	; (8009738 <HAL_RCC_GetSysClockFreq+0x64>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8009718:	bd08      	pop	{r3, pc}
      sysclockfreq = HSE_VALUE;
 800971a:	4808      	ldr	r0, [pc, #32]	; (800973c <HAL_RCC_GetSysClockFreq+0x68>)
 800971c:	bd08      	pop	{r3, pc}
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800971e:	684b      	ldr	r3, [r1, #4]
 8009720:	4806      	ldr	r0, [pc, #24]	; (800973c <HAL_RCC_GetSysClockFreq+0x68>)
 8009722:	f3c3 1388 	ubfx	r3, r3, #6, #9
 8009726:	fba3 0100 	umull	r0, r1, r3, r0
 800972a:	2300      	movs	r3, #0
 800972c:	f7f7 f9f2 	bl	8000b14 <__aeabi_uldivmod>
 8009730:	e7e8      	b.n	8009704 <HAL_RCC_GetSysClockFreq+0x30>
 8009732:	bf00      	nop
 8009734:	40023800 	.word	0x40023800
 8009738:	00f42400 	.word	0x00f42400
 800973c:	007a1200 	.word	0x007a1200

08009740 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 8009740:	b160      	cbz	r0, 800975c <HAL_RCC_ClockConfig+0x1c>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8009742:	4a48      	ldr	r2, [pc, #288]	; (8009864 <HAL_RCC_ClockConfig+0x124>)
 8009744:	6813      	ldr	r3, [r2, #0]
 8009746:	f003 030f 	and.w	r3, r3, #15
 800974a:	428b      	cmp	r3, r1
 800974c:	d208      	bcs.n	8009760 <HAL_RCC_ClockConfig+0x20>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800974e:	b2cb      	uxtb	r3, r1
 8009750:	7013      	strb	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8009752:	6813      	ldr	r3, [r2, #0]
 8009754:	f003 030f 	and.w	r3, r3, #15
 8009758:	4299      	cmp	r1, r3
 800975a:	d001      	beq.n	8009760 <HAL_RCC_ClockConfig+0x20>
    return HAL_ERROR;
 800975c:	2001      	movs	r0, #1
}
 800975e:	4770      	bx	lr
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8009760:	6803      	ldr	r3, [r0, #0]
{
 8009762:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8009766:	079d      	lsls	r5, r3, #30
 8009768:	d514      	bpl.n	8009794 <HAL_RCC_ClockConfig+0x54>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800976a:	075c      	lsls	r4, r3, #29
 800976c:	d504      	bpl.n	8009778 <HAL_RCC_ClockConfig+0x38>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 800976e:	4c3e      	ldr	r4, [pc, #248]	; (8009868 <HAL_RCC_ClockConfig+0x128>)
 8009770:	68a2      	ldr	r2, [r4, #8]
 8009772:	f442 52e0 	orr.w	r2, r2, #7168	; 0x1c00
 8009776:	60a2      	str	r2, [r4, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8009778:	071a      	lsls	r2, r3, #28
 800977a:	d504      	bpl.n	8009786 <HAL_RCC_ClockConfig+0x46>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 800977c:	4c3a      	ldr	r4, [pc, #232]	; (8009868 <HAL_RCC_ClockConfig+0x128>)
 800977e:	68a2      	ldr	r2, [r4, #8]
 8009780:	f442 4260 	orr.w	r2, r2, #57344	; 0xe000
 8009784:	60a2      	str	r2, [r4, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8009786:	4c38      	ldr	r4, [pc, #224]	; (8009868 <HAL_RCC_ClockConfig+0x128>)
 8009788:	6885      	ldr	r5, [r0, #8]
 800978a:	68a2      	ldr	r2, [r4, #8]
 800978c:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8009790:	432a      	orrs	r2, r5
 8009792:	60a2      	str	r2, [r4, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8009794:	07df      	lsls	r7, r3, #31
 8009796:	4604      	mov	r4, r0
 8009798:	460d      	mov	r5, r1
 800979a:	d522      	bpl.n	80097e2 <HAL_RCC_ClockConfig+0xa2>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800979c:	6842      	ldr	r2, [r0, #4]
 800979e:	2a01      	cmp	r2, #1
 80097a0:	d05b      	beq.n	800985a <HAL_RCC_ClockConfig+0x11a>
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 80097a2:	1e93      	subs	r3, r2, #2
 80097a4:	2b01      	cmp	r3, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80097a6:	4b30      	ldr	r3, [pc, #192]	; (8009868 <HAL_RCC_ClockConfig+0x128>)
 80097a8:	681b      	ldr	r3, [r3, #0]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 80097aa:	d950      	bls.n	800984e <HAL_RCC_ClockConfig+0x10e>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80097ac:	0799      	lsls	r1, r3, #30
 80097ae:	d525      	bpl.n	80097fc <HAL_RCC_ClockConfig+0xbc>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80097b0:	4e2d      	ldr	r6, [pc, #180]	; (8009868 <HAL_RCC_ClockConfig+0x128>)
 80097b2:	68b3      	ldr	r3, [r6, #8]
 80097b4:	f023 0303 	bic.w	r3, r3, #3
 80097b8:	4313      	orrs	r3, r2
 80097ba:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 80097bc:	f7fe fe72 	bl	80084a4 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80097c0:	f241 3788 	movw	r7, #5000	; 0x1388
    tickstart = HAL_GetTick();
 80097c4:	4680      	mov	r8, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80097c6:	e005      	b.n	80097d4 <HAL_RCC_ClockConfig+0x94>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80097c8:	f7fe fe6c 	bl	80084a4 <HAL_GetTick>
 80097cc:	eba0 0008 	sub.w	r0, r0, r8
 80097d0:	42b8      	cmp	r0, r7
 80097d2:	d83f      	bhi.n	8009854 <HAL_RCC_ClockConfig+0x114>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80097d4:	68b3      	ldr	r3, [r6, #8]
 80097d6:	6862      	ldr	r2, [r4, #4]
 80097d8:	f003 030c 	and.w	r3, r3, #12
 80097dc:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 80097e0:	d1f2      	bne.n	80097c8 <HAL_RCC_ClockConfig+0x88>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 80097e2:	4a20      	ldr	r2, [pc, #128]	; (8009864 <HAL_RCC_ClockConfig+0x124>)
 80097e4:	6813      	ldr	r3, [r2, #0]
 80097e6:	f003 030f 	and.w	r3, r3, #15
 80097ea:	429d      	cmp	r5, r3
 80097ec:	d209      	bcs.n	8009802 <HAL_RCC_ClockConfig+0xc2>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80097ee:	b2eb      	uxtb	r3, r5
 80097f0:	7013      	strb	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80097f2:	6813      	ldr	r3, [r2, #0]
 80097f4:	f003 030f 	and.w	r3, r3, #15
 80097f8:	429d      	cmp	r5, r3
 80097fa:	d002      	beq.n	8009802 <HAL_RCC_ClockConfig+0xc2>
    return HAL_ERROR;
 80097fc:	2001      	movs	r0, #1
 80097fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8009802:	6823      	ldr	r3, [r4, #0]
 8009804:	075a      	lsls	r2, r3, #29
 8009806:	d506      	bpl.n	8009816 <HAL_RCC_ClockConfig+0xd6>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8009808:	4917      	ldr	r1, [pc, #92]	; (8009868 <HAL_RCC_ClockConfig+0x128>)
 800980a:	68e0      	ldr	r0, [r4, #12]
 800980c:	688a      	ldr	r2, [r1, #8]
 800980e:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00
 8009812:	4302      	orrs	r2, r0
 8009814:	608a      	str	r2, [r1, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8009816:	071b      	lsls	r3, r3, #28
 8009818:	d507      	bpl.n	800982a <HAL_RCC_ClockConfig+0xea>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 800981a:	4a13      	ldr	r2, [pc, #76]	; (8009868 <HAL_RCC_ClockConfig+0x128>)
 800981c:	6921      	ldr	r1, [r4, #16]
 800981e:	6893      	ldr	r3, [r2, #8]
 8009820:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8009824:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8009828:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 800982a:	f7ff ff53 	bl	80096d4 <HAL_RCC_GetSysClockFreq>
 800982e:	4b0e      	ldr	r3, [pc, #56]	; (8009868 <HAL_RCC_ClockConfig+0x128>)
 8009830:	490e      	ldr	r1, [pc, #56]	; (800986c <HAL_RCC_ClockConfig+0x12c>)
 8009832:	689b      	ldr	r3, [r3, #8]
 8009834:	4a0e      	ldr	r2, [pc, #56]	; (8009870 <HAL_RCC_ClockConfig+0x130>)
 8009836:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800983a:	5ccb      	ldrb	r3, [r1, r3]
 800983c:	fa20 f303 	lsr.w	r3, r0, r3
  HAL_InitTick (TICK_INT_PRIORITY);
 8009840:	200f      	movs	r0, #15
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8009842:	6013      	str	r3, [r2, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 8009844:	f7fe fde6 	bl	8008414 <HAL_InitTick>
  return HAL_OK;
 8009848:	2000      	movs	r0, #0
 800984a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800984e:	0198      	lsls	r0, r3, #6
 8009850:	d4ae      	bmi.n	80097b0 <HAL_RCC_ClockConfig+0x70>
 8009852:	e7d3      	b.n	80097fc <HAL_RCC_ClockConfig+0xbc>
        return HAL_TIMEOUT;
 8009854:	2003      	movs	r0, #3
}
 8009856:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800985a:	4b03      	ldr	r3, [pc, #12]	; (8009868 <HAL_RCC_ClockConfig+0x128>)
 800985c:	681b      	ldr	r3, [r3, #0]
 800985e:	039e      	lsls	r6, r3, #14
 8009860:	d4a6      	bmi.n	80097b0 <HAL_RCC_ClockConfig+0x70>
 8009862:	e7cb      	b.n	80097fc <HAL_RCC_ClockConfig+0xbc>
 8009864:	40023c00 	.word	0x40023c00
 8009868:	40023800 	.word	0x40023800
 800986c:	0800d540 	.word	0x0800d540
 8009870:	2000039c 	.word	0x2000039c

08009874 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 8009874:	4b04      	ldr	r3, [pc, #16]	; (8009888 <HAL_RCC_GetPCLK1Freq+0x14>)
 8009876:	4a05      	ldr	r2, [pc, #20]	; (800988c <HAL_RCC_GetPCLK1Freq+0x18>)
 8009878:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 800987a:	4905      	ldr	r1, [pc, #20]	; (8009890 <HAL_RCC_GetPCLK1Freq+0x1c>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 800987c:	f3c3 2382 	ubfx	r3, r3, #10, #3
 8009880:	6808      	ldr	r0, [r1, #0]
 8009882:	5cd3      	ldrb	r3, [r2, r3]
}
 8009884:	40d8      	lsrs	r0, r3
 8009886:	4770      	bx	lr
 8009888:	40023800 	.word	0x40023800
 800988c:	0800d550 	.word	0x0800d550
 8009890:	2000039c 	.word	0x2000039c

08009894 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 8009894:	4b04      	ldr	r3, [pc, #16]	; (80098a8 <HAL_RCC_GetPCLK2Freq+0x14>)
 8009896:	4a05      	ldr	r2, [pc, #20]	; (80098ac <HAL_RCC_GetPCLK2Freq+0x18>)
 8009898:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 800989a:	4905      	ldr	r1, [pc, #20]	; (80098b0 <HAL_RCC_GetPCLK2Freq+0x1c>)
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 800989c:	f3c3 3342 	ubfx	r3, r3, #13, #3
 80098a0:	6808      	ldr	r0, [r1, #0]
 80098a2:	5cd3      	ldrb	r3, [r2, r3]
}
 80098a4:	40d8      	lsrs	r0, r3
 80098a6:	4770      	bx	lr
 80098a8:	40023800 	.word	0x40023800
 80098ac:	0800d550 	.word	0x0800d550
 80098b0:	2000039c 	.word	0x2000039c

080098b4 <HAL_RCCEx_PeriphCLKConfig>:
  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 80098b4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80098b6:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- I2S configuration ---------------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 80098b8:	6800      	ldr	r0, [r0, #0]
 80098ba:	f010 0f05 	tst.w	r0, #5
{
 80098be:	b083      	sub	sp, #12
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 80098c0:	d10a      	bne.n	80098d8 <HAL_RCCEx_PeriphCLKConfig+0x24>
      }
    }
  }

  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 80098c2:	0785      	lsls	r5, r0, #30
 80098c4:	d442      	bmi.n	800994c <HAL_RCCEx_PeriphCLKConfig+0x98>
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  }
#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)
  /*---------------------------- TIM configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 80098c6:	f010 0008 	ands.w	r0, r0, #8
 80098ca:	d003      	beq.n	80098d4 <HAL_RCCEx_PeriphCLKConfig+0x20>
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 80098cc:	4b48      	ldr	r3, [pc, #288]	; (80099f0 <HAL_RCCEx_PeriphCLKConfig+0x13c>)
 80098ce:	7c22      	ldrb	r2, [r4, #16]
 80098d0:	601a      	str	r2, [r3, #0]
  }
#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
  return HAL_OK;
 80098d2:	2000      	movs	r0, #0
}
 80098d4:	b003      	add	sp, #12
 80098d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_PLLI2S_DISABLE();
 80098d8:	4b46      	ldr	r3, [pc, #280]	; (80099f4 <HAL_RCCEx_PeriphCLKConfig+0x140>)
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 80098da:	4d47      	ldr	r5, [pc, #284]	; (80099f8 <HAL_RCCEx_PeriphCLKConfig+0x144>)
    __HAL_RCC_PLLI2S_DISABLE();
 80098dc:	2200      	movs	r2, #0
 80098de:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 80098e0:	f7fe fde0 	bl	80084a4 <HAL_GetTick>
 80098e4:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 80098e6:	e004      	b.n	80098f2 <HAL_RCCEx_PeriphCLKConfig+0x3e>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 80098e8:	f7fe fddc 	bl	80084a4 <HAL_GetTick>
 80098ec:	1b80      	subs	r0, r0, r6
 80098ee:	2802      	cmp	r0, #2
 80098f0:	d829      	bhi.n	8009946 <HAL_RCCEx_PeriphCLKConfig+0x92>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 80098f2:	682b      	ldr	r3, [r5, #0]
 80098f4:	011b      	lsls	r3, r3, #4
 80098f6:	d4f7      	bmi.n	80098e8 <HAL_RCCEx_PeriphCLKConfig+0x34>
    __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
 80098f8:	68a3      	ldr	r3, [r4, #8]
 80098fa:	6861      	ldr	r1, [r4, #4]
    __HAL_RCC_PLLI2S_ENABLE();
 80098fc:	4a3d      	ldr	r2, [pc, #244]	; (80099f4 <HAL_RCCEx_PeriphCLKConfig+0x140>)
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80098fe:	4e3e      	ldr	r6, [pc, #248]	; (80099f8 <HAL_RCCEx_PeriphCLKConfig+0x144>)
    __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
 8009900:	071b      	lsls	r3, r3, #28
 8009902:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
    __HAL_RCC_PLLI2S_ENABLE();
 8009906:	2101      	movs	r1, #1
    __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
 8009908:	f8c5 3084 	str.w	r3, [r5, #132]	; 0x84
    __HAL_RCC_PLLI2S_ENABLE();
 800990c:	6011      	str	r1, [r2, #0]
    tickstart = HAL_GetTick();
 800990e:	f7fe fdc9 	bl	80084a4 <HAL_GetTick>
 8009912:	4605      	mov	r5, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8009914:	e004      	b.n	8009920 <HAL_RCCEx_PeriphCLKConfig+0x6c>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8009916:	f7fe fdc5 	bl	80084a4 <HAL_GetTick>
 800991a:	1b40      	subs	r0, r0, r5
 800991c:	2802      	cmp	r0, #2
 800991e:	d812      	bhi.n	8009946 <HAL_RCCEx_PeriphCLKConfig+0x92>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8009920:	6833      	ldr	r3, [r6, #0]
 8009922:	011f      	lsls	r7, r3, #4
 8009924:	d5f7      	bpl.n	8009916 <HAL_RCCEx_PeriphCLKConfig+0x62>
 8009926:	6820      	ldr	r0, [r4, #0]
 8009928:	e7cb      	b.n	80098c2 <HAL_RCCEx_PeriphCLKConfig+0xe>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800992a:	460d      	mov	r5, r1
        tickstart = HAL_GetTick();
 800992c:	f7fe fdba 	bl	80084a4 <HAL_GetTick>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8009930:	f241 3688 	movw	r6, #5000	; 0x1388
        tickstart = HAL_GetTick();
 8009934:	4607      	mov	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8009936:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8009938:	079b      	lsls	r3, r3, #30
 800993a:	d43a      	bmi.n	80099b2 <HAL_RCCEx_PeriphCLKConfig+0xfe>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800993c:	f7fe fdb2 	bl	80084a4 <HAL_GetTick>
 8009940:	1bc0      	subs	r0, r0, r7
 8009942:	42b0      	cmp	r0, r6
 8009944:	d9f7      	bls.n	8009936 <HAL_RCCEx_PeriphCLKConfig+0x82>
        return HAL_TIMEOUT;
 8009946:	2003      	movs	r0, #3
}
 8009948:	b003      	add	sp, #12
 800994a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 800994c:	4b2a      	ldr	r3, [pc, #168]	; (80099f8 <HAL_RCCEx_PeriphCLKConfig+0x144>)
    PWR->CR |= PWR_CR_DBP;
 800994e:	4d2b      	ldr	r5, [pc, #172]	; (80099fc <HAL_RCCEx_PeriphCLKConfig+0x148>)
    __HAL_RCC_PWR_CLK_ENABLE();
 8009950:	2200      	movs	r2, #0
 8009952:	9201      	str	r2, [sp, #4]
 8009954:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8009956:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800995a:	641a      	str	r2, [r3, #64]	; 0x40
 800995c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800995e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8009962:	9301      	str	r3, [sp, #4]
 8009964:	9b01      	ldr	r3, [sp, #4]
    PWR->CR |= PWR_CR_DBP;
 8009966:	682b      	ldr	r3, [r5, #0]
 8009968:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800996c:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 800996e:	f7fe fd99 	bl	80084a4 <HAL_GetTick>
 8009972:	4606      	mov	r6, r0
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8009974:	e004      	b.n	8009980 <HAL_RCCEx_PeriphCLKConfig+0xcc>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8009976:	f7fe fd95 	bl	80084a4 <HAL_GetTick>
 800997a:	1b80      	subs	r0, r0, r6
 800997c:	2802      	cmp	r0, #2
 800997e:	d8e2      	bhi.n	8009946 <HAL_RCCEx_PeriphCLKConfig+0x92>
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8009980:	682b      	ldr	r3, [r5, #0]
 8009982:	05d9      	lsls	r1, r3, #23
 8009984:	d5f7      	bpl.n	8009976 <HAL_RCCEx_PeriphCLKConfig+0xc2>
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8009986:	491c      	ldr	r1, [pc, #112]	; (80099f8 <HAL_RCCEx_PeriphCLKConfig+0x144>)
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8009988:	68e3      	ldr	r3, [r4, #12]
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 800998a:	6f0a      	ldr	r2, [r1, #112]	; 0x70
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 800998c:	f412 7240 	ands.w	r2, r2, #768	; 0x300
 8009990:	f403 7040 	and.w	r0, r3, #768	; 0x300
 8009994:	d010      	beq.n	80099b8 <HAL_RCCEx_PeriphCLKConfig+0x104>
 8009996:	4282      	cmp	r2, r0
 8009998:	d00e      	beq.n	80099b8 <HAL_RCCEx_PeriphCLKConfig+0x104>
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800999a:	6f0b      	ldr	r3, [r1, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_FORCE();
 800999c:	4a18      	ldr	r2, [pc, #96]	; (8009a00 <HAL_RCCEx_PeriphCLKConfig+0x14c>)
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800999e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 80099a2:	2501      	movs	r5, #1
      __HAL_RCC_BACKUPRESET_RELEASE();
 80099a4:	2000      	movs	r0, #0
      __HAL_RCC_BACKUPRESET_FORCE();
 80099a6:	6015      	str	r5, [r2, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 80099a8:	6010      	str	r0, [r2, #0]
      RCC->BDCR = tmpreg1;
 80099aa:	670b      	str	r3, [r1, #112]	; 0x70
      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 80099ac:	6f0b      	ldr	r3, [r1, #112]	; 0x70
 80099ae:	07da      	lsls	r2, r3, #31
 80099b0:	d4bb      	bmi.n	800992a <HAL_RCCEx_PeriphCLKConfig+0x76>
 80099b2:	68e3      	ldr	r3, [r4, #12]
 80099b4:	f403 7040 	and.w	r0, r3, #768	; 0x300
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80099b8:	f5b0 7f40 	cmp.w	r0, #768	; 0x300
 80099bc:	d00c      	beq.n	80099d8 <HAL_RCCEx_PeriphCLKConfig+0x124>
 80099be:	490e      	ldr	r1, [pc, #56]	; (80099f8 <HAL_RCCEx_PeriphCLKConfig+0x144>)
 80099c0:	688a      	ldr	r2, [r1, #8]
 80099c2:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 80099c6:	608a      	str	r2, [r1, #8]
 80099c8:	4a0b      	ldr	r2, [pc, #44]	; (80099f8 <HAL_RCCEx_PeriphCLKConfig+0x144>)
 80099ca:	6f11      	ldr	r1, [r2, #112]	; 0x70
 80099cc:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80099d0:	430b      	orrs	r3, r1
 80099d2:	6713      	str	r3, [r2, #112]	; 0x70
 80099d4:	6820      	ldr	r0, [r4, #0]
 80099d6:	e776      	b.n	80098c6 <HAL_RCCEx_PeriphCLKConfig+0x12>
 80099d8:	4807      	ldr	r0, [pc, #28]	; (80099f8 <HAL_RCCEx_PeriphCLKConfig+0x144>)
 80099da:	6882      	ldr	r2, [r0, #8]
 80099dc:	f023 4170 	bic.w	r1, r3, #4026531840	; 0xf0000000
 80099e0:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 80099e4:	f421 7140 	bic.w	r1, r1, #768	; 0x300
 80099e8:	430a      	orrs	r2, r1
 80099ea:	6082      	str	r2, [r0, #8]
 80099ec:	e7ec      	b.n	80099c8 <HAL_RCCEx_PeriphCLKConfig+0x114>
 80099ee:	bf00      	nop
 80099f0:	424711e0 	.word	0x424711e0
 80099f4:	42470068 	.word	0x42470068
 80099f8:	40023800 	.word	0x40023800
 80099fc:	40007000 	.word	0x40007000
 8009a00:	42470e40 	.word	0x42470e40

08009a04 <HAL_RTC_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
  /* Check the RTC peripheral state */
  if(hrtc == NULL)
 8009a04:	2800      	cmp	r0, #0
 8009a06:	d067      	beq.n	8009ad8 <HAL_RTC_Init+0xd4>
{
 8009a08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RTC_SYNCH_PREDIV(hrtc->Init.SynchPrediv));
  assert_param (IS_RTC_OUTPUT(hrtc->Init.OutPut));
  assert_param (IS_RTC_OUTPUT_POL(hrtc->Init.OutPutPolarity));
  assert_param(IS_RTC_OUTPUT_TYPE(hrtc->Init.OutPutType));
    
  if(hrtc->State == HAL_RTC_STATE_RESET)
 8009a0a:	7f43      	ldrb	r3, [r0, #29]
 8009a0c:	4604      	mov	r4, r0
 8009a0e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8009a12:	2b00      	cmp	r3, #0
 8009a14:	d04a      	beq.n	8009aac <HAL_RTC_Init+0xa8>
  
  /* Set RTC state */  
  hrtc->State = HAL_RTC_STATE_BUSY;  
       
  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8009a16:	6823      	ldr	r3, [r4, #0]
 8009a18:	2253      	movs	r2, #83	; 0x53
  hrtc->State = HAL_RTC_STATE_BUSY;  
 8009a1a:	2002      	movs	r0, #2
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8009a1c:	21ca      	movs	r1, #202	; 0xca
  hrtc->State = HAL_RTC_STATE_BUSY;  
 8009a1e:	7760      	strb	r0, [r4, #29]
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8009a20:	6259      	str	r1, [r3, #36]	; 0x24
 8009a22:	625a      	str	r2, [r3, #36]	; 0x24
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
{
  uint32_t tickstart = 0U; 
  
  /* Check if the Initialization mode is set */
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8009a24:	68da      	ldr	r2, [r3, #12]
 8009a26:	0655      	lsls	r5, r2, #25
 8009a28:	d529      	bpl.n	8009a7e <HAL_RTC_Init+0x7a>
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 8009a2a:	6899      	ldr	r1, [r3, #8]
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8009a2c:	6862      	ldr	r2, [r4, #4]
 8009a2e:	6927      	ldr	r7, [r4, #16]
 8009a30:	6966      	ldr	r6, [r4, #20]
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16U);
 8009a32:	68a0      	ldr	r0, [r4, #8]
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 8009a34:	68e5      	ldr	r5, [r4, #12]
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 8009a36:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
 8009a3a:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 8009a3e:	6099      	str	r1, [r3, #8]
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8009a40:	6899      	ldr	r1, [r3, #8]
 8009a42:	433a      	orrs	r2, r7
 8009a44:	4332      	orrs	r2, r6
 8009a46:	430a      	orrs	r2, r1
 8009a48:	609a      	str	r2, [r3, #8]
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 8009a4a:	611d      	str	r5, [r3, #16]
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16U);
 8009a4c:	691a      	ldr	r2, [r3, #16]
 8009a4e:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8009a52:	611a      	str	r2, [r3, #16]
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT; 
 8009a54:	68da      	ldr	r2, [r3, #12]
 8009a56:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8009a5a:	60da      	str	r2, [r3, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8009a5c:	689a      	ldr	r2, [r3, #8]
 8009a5e:	0692      	lsls	r2, r2, #26
 8009a60:	d528      	bpl.n	8009ab4 <HAL_RTC_Init+0xb0>
    hrtc->Instance->TAFCR &= (uint32_t)~RTC_TAFCR_ALARMOUTTYPE;
 8009a62:	6c19      	ldr	r1, [r3, #64]	; 0x40
    hrtc->Instance->TAFCR |= (uint32_t)(hrtc->Init.OutPutType); 
 8009a64:	69a0      	ldr	r0, [r4, #24]
    hrtc->Instance->TAFCR &= (uint32_t)~RTC_TAFCR_ALARMOUTTYPE;
 8009a66:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 8009a6a:	6419      	str	r1, [r3, #64]	; 0x40
    hrtc->Instance->TAFCR |= (uint32_t)(hrtc->Init.OutPutType); 
 8009a6c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 8009a6e:	25ff      	movs	r5, #255	; 0xff
    hrtc->Instance->TAFCR |= (uint32_t)(hrtc->Init.OutPutType); 
 8009a70:	4302      	orrs	r2, r0
    hrtc->State = HAL_RTC_STATE_READY;
 8009a72:	2101      	movs	r1, #1
    hrtc->Instance->TAFCR |= (uint32_t)(hrtc->Init.OutPutType); 
 8009a74:	641a      	str	r2, [r3, #64]	; 0x40
    return HAL_OK;
 8009a76:	2000      	movs	r0, #0
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 8009a78:	625d      	str	r5, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_READY;
 8009a7a:	7761      	strb	r1, [r4, #29]
    return HAL_OK;
 8009a7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  {
    /* Set the Initialization mode */
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 8009a7e:	f04f 32ff 	mov.w	r2, #4294967295
 8009a82:	60da      	str	r2, [r3, #12]

    /* Get tick */
    tickstart = HAL_GetTick();
 8009a84:	f7fe fd0e 	bl	80084a4 <HAL_GetTick>
 8009a88:	4605      	mov	r5, r0

    /* Wait till RTC is in INIT state and if Time out is reached exit */
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8009a8a:	6823      	ldr	r3, [r4, #0]
 8009a8c:	68da      	ldr	r2, [r3, #12]
 8009a8e:	0650      	lsls	r0, r2, #25
 8009a90:	d4cb      	bmi.n	8009a2a <HAL_RTC_Init+0x26>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8009a92:	f7fe fd07 	bl	80084a4 <HAL_GetTick>
 8009a96:	1b40      	subs	r0, r0, r5
 8009a98:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8009a9c:	d9f5      	bls.n	8009a8a <HAL_RTC_Init+0x86>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8009a9e:	6822      	ldr	r2, [r4, #0]
 8009aa0:	21ff      	movs	r1, #255	; 0xff
        hrtc->State = HAL_RTC_STATE_ERROR;
 8009aa2:	2304      	movs	r3, #4
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8009aa4:	6251      	str	r1, [r2, #36]	; 0x24
        return HAL_ERROR;
 8009aa6:	2001      	movs	r0, #1
        hrtc->State = HAL_RTC_STATE_ERROR;
 8009aa8:	7763      	strb	r3, [r4, #29]
}
 8009aaa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrtc->Lock = HAL_UNLOCKED;
 8009aac:	7702      	strb	r2, [r0, #28]
    HAL_RTC_MspInit(hrtc);
 8009aae:	f002 fb73 	bl	800c198 <HAL_RTC_MspInit>
 8009ab2:	e7b0      	b.n	8009a16 <HAL_RTC_Init+0x12>
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8009ab4:	68da      	ldr	r2, [r3, #12]
 8009ab6:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 8009aba:	60da      	str	r2, [r3, #12]
    tickstart = HAL_GetTick();
 8009abc:	f7fe fcf2 	bl	80084a4 <HAL_GetTick>
 8009ac0:	4605      	mov	r5, r0
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8009ac2:	6823      	ldr	r3, [r4, #0]
 8009ac4:	68da      	ldr	r2, [r3, #12]
 8009ac6:	0691      	lsls	r1, r2, #26
 8009ac8:	d4cb      	bmi.n	8009a62 <HAL_RTC_Init+0x5e>
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8009aca:	f7fe fceb 	bl	80084a4 <HAL_GetTick>
 8009ace:	1b40      	subs	r0, r0, r5
 8009ad0:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8009ad4:	d9f5      	bls.n	8009ac2 <HAL_RTC_Init+0xbe>
 8009ad6:	e7e2      	b.n	8009a9e <HAL_RTC_Init+0x9a>
     return HAL_ERROR;
 8009ad8:	2001      	movs	r0, #1
 8009ada:	4770      	bx	lr

08009adc <HAL_RTC_SetTime>:
{
 8009adc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  __HAL_LOCK(hrtc);
 8009ae0:	7f03      	ldrb	r3, [r0, #28]
 8009ae2:	2b01      	cmp	r3, #1
 8009ae4:	d078      	beq.n	8009bd8 <HAL_RTC_SetTime+0xfc>
  hrtc->State = HAL_RTC_STATE_BUSY;
 8009ae6:	2302      	movs	r3, #2
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8009ae8:	6806      	ldr	r6, [r0, #0]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8009aea:	7743      	strb	r3, [r0, #29]
 8009aec:	460c      	mov	r4, r1
  __HAL_LOCK(hrtc);
 8009aee:	2101      	movs	r1, #1
 8009af0:	4605      	mov	r5, r0
 8009af2:	7701      	strb	r1, [r0, #28]
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8009af4:	68b7      	ldr	r7, [r6, #8]
  if(Format == RTC_FORMAT_BIN)
 8009af6:	2a00      	cmp	r2, #0
 8009af8:	d035      	beq.n	8009b66 <HAL_RTC_SetTime+0x8a>
              ((uint32_t)(sTime->Minutes) << 8U) | \
 8009afa:	7861      	ldrb	r1, [r4, #1]
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 8009afc:	7822      	ldrb	r2, [r4, #0]
              ((uint32_t)sTime->Seconds) | \
 8009afe:	78a3      	ldrb	r3, [r4, #2]
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8009b00:	f017 0740 	ands.w	r7, r7, #64	; 0x40
 8009b04:	bf14      	ite	ne
 8009b06:	78e7      	ldrbne	r7, [r4, #3]
      sTime->TimeFormat = 0x00U;
 8009b08:	70e7      	strbeq	r7, [r4, #3]
              ((uint32_t)(sTime->Minutes) << 8U) | \
 8009b0a:	ea4f 2101 	mov.w	r1, r1, lsl #8
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 8009b0e:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 8009b12:	bf18      	it	ne
 8009b14:	043f      	lslne	r7, r7, #16
              ((uint32_t)(sTime->Minutes) << 8U) | \
 8009b16:	4319      	orrs	r1, r3
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 8009b18:	430f      	orrs	r7, r1
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8009b1a:	22ca      	movs	r2, #202	; 0xca
 8009b1c:	2353      	movs	r3, #83	; 0x53
 8009b1e:	6272      	str	r2, [r6, #36]	; 0x24
 8009b20:	6273      	str	r3, [r6, #36]	; 0x24
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8009b22:	68f3      	ldr	r3, [r6, #12]
 8009b24:	065a      	lsls	r2, r3, #25
 8009b26:	d55a      	bpl.n	8009bde <HAL_RTC_SetTime+0x102>
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 8009b28:	f007 377f 	and.w	r7, r7, #2139062143	; 0x7f7f7f7f
 8009b2c:	f027 47fe 	bic.w	r7, r7, #2130706432	; 0x7f000000
 8009b30:	6037      	str	r7, [r6, #0]
    hrtc->Instance->CR &= (uint32_t)~RTC_CR_BCK;
 8009b32:	68b2      	ldr	r2, [r6, #8]
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 8009b34:	68e3      	ldr	r3, [r4, #12]
 8009b36:	6921      	ldr	r1, [r4, #16]
    hrtc->Instance->CR &= (uint32_t)~RTC_CR_BCK;
 8009b38:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8009b3c:	60b2      	str	r2, [r6, #8]
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 8009b3e:	68b2      	ldr	r2, [r6, #8]
 8009b40:	430b      	orrs	r3, r1
 8009b42:	4313      	orrs	r3, r2
 8009b44:	60b3      	str	r3, [r6, #8]
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;  
 8009b46:	68f3      	ldr	r3, [r6, #12]
 8009b48:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8009b4c:	60f3      	str	r3, [r6, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8009b4e:	68b3      	ldr	r3, [r6, #8]
 8009b50:	069b      	lsls	r3, r3, #26
 8009b52:	d560      	bpl.n	8009c16 <HAL_RTC_SetTime+0x13a>
   __HAL_UNLOCK(hrtc); 
 8009b54:	2300      	movs	r3, #0
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8009b56:	21ff      	movs	r1, #255	; 0xff
   hrtc->State = HAL_RTC_STATE_READY;
 8009b58:	2201      	movs	r2, #1
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8009b5a:	6271      	str	r1, [r6, #36]	; 0x24
   return HAL_OK;
 8009b5c:	4618      	mov	r0, r3
   hrtc->State = HAL_RTC_STATE_READY;
 8009b5e:	776a      	strb	r2, [r5, #29]
   __HAL_UNLOCK(hrtc); 
 8009b60:	772b      	strb	r3, [r5, #28]
   return HAL_OK;
 8009b62:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8009b66:	f017 0740 	ands.w	r7, r7, #64	; 0x40
 8009b6a:	bf18      	it	ne
 8009b6c:	78e7      	ldrbne	r7, [r4, #3]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 8009b6e:	7821      	ldrb	r1, [r4, #0]
      sTime->TimeFormat = 0x00U;
 8009b70:	bf0c      	ite	eq
 8009b72:	70e7      	strbeq	r7, [r4, #3]
 8009b74:	043f      	lslne	r7, r7, #16
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0U;
  
  while(Value >= 10U)
 8009b76:	2909      	cmp	r1, #9
 8009b78:	f04f 0000 	mov.w	r0, #0
 8009b7c:	d907      	bls.n	8009b8e <HAL_RTC_SetTime+0xb2>
  {
    bcdhigh++;
    Value -= 10U;
 8009b7e:	390a      	subs	r1, #10
 8009b80:	b2c9      	uxtb	r1, r1
  while(Value >= 10U)
 8009b82:	2909      	cmp	r1, #9
    bcdhigh++;
 8009b84:	f100 0001 	add.w	r0, r0, #1
  while(Value >= 10U)
 8009b88:	d8f9      	bhi.n	8009b7e <HAL_RTC_SetTime+0xa2>
 8009b8a:	0100      	lsls	r0, r0, #4
 8009b8c:	b2c0      	uxtb	r0, r0
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8U) | \
 8009b8e:	7863      	ldrb	r3, [r4, #1]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 8009b90:	4301      	orrs	r1, r0
  while(Value >= 10U)
 8009b92:	2b09      	cmp	r3, #9
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 8009b94:	ea4f 4001 	mov.w	r0, r1, lsl #16
  while(Value >= 10U)
 8009b98:	d958      	bls.n	8009c4c <HAL_RTC_SetTime+0x170>
 8009b9a:	2100      	movs	r1, #0
    Value -= 10U;
 8009b9c:	3b0a      	subs	r3, #10
 8009b9e:	b2db      	uxtb	r3, r3
  while(Value >= 10U)
 8009ba0:	2b09      	cmp	r3, #9
    bcdhigh++;
 8009ba2:	f101 0101 	add.w	r1, r1, #1
  while(Value >= 10U)
 8009ba6:	d8f9      	bhi.n	8009b9c <HAL_RTC_SetTime+0xc0>
 8009ba8:	0109      	lsls	r1, r1, #4
 8009baa:	fa5f fe81 	uxtb.w	lr, r1
                        ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
 8009bae:	78a1      	ldrb	r1, [r4, #2]
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8U) | \
 8009bb0:	ea43 030e 	orr.w	r3, r3, lr
  while(Value >= 10U)
 8009bb4:	2909      	cmp	r1, #9
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8U) | \
 8009bb6:	ea4f 2303 	mov.w	r3, r3, lsl #8
  while(Value >= 10U)
 8009bba:	d94a      	bls.n	8009c52 <HAL_RTC_SetTime+0x176>
    Value -= 10U;
 8009bbc:	390a      	subs	r1, #10
 8009bbe:	b2c9      	uxtb	r1, r1
  while(Value >= 10U)
 8009bc0:	2909      	cmp	r1, #9
    bcdhigh++;
 8009bc2:	f102 0201 	add.w	r2, r2, #1
  while(Value >= 10U)
 8009bc6:	d8f9      	bhi.n	8009bbc <HAL_RTC_SetTime+0xe0>
 8009bc8:	0112      	lsls	r2, r2, #4
 8009bca:	b2d2      	uxtb	r2, r2
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 8009bcc:	4307      	orrs	r7, r0
 8009bce:	433b      	orrs	r3, r7
                        ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
 8009bd0:	4311      	orrs	r1, r2
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 8009bd2:	ea43 0701 	orr.w	r7, r3, r1
 8009bd6:	e7a0      	b.n	8009b1a <HAL_RTC_SetTime+0x3e>
  __HAL_LOCK(hrtc);
 8009bd8:	2002      	movs	r0, #2
 8009bda:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 8009bde:	f04f 33ff 	mov.w	r3, #4294967295
 8009be2:	60f3      	str	r3, [r6, #12]
    tickstart = HAL_GetTick();
 8009be4:	f7fe fc5e 	bl	80084a4 <HAL_GetTick>
 8009be8:	4681      	mov	r9, r0
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8009bea:	682e      	ldr	r6, [r5, #0]
 8009bec:	68f3      	ldr	r3, [r6, #12]
 8009bee:	f013 0840 	ands.w	r8, r3, #64	; 0x40
 8009bf2:	d199      	bne.n	8009b28 <HAL_RTC_SetTime+0x4c>
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8009bf4:	f7fe fc56 	bl	80084a4 <HAL_GetTick>
 8009bf8:	eba0 0009 	sub.w	r0, r0, r9
 8009bfc:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8009c00:	d9f3      	bls.n	8009bea <HAL_RTC_SetTime+0x10e>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 8009c02:	682a      	ldr	r2, [r5, #0]
 8009c04:	21ff      	movs	r1, #255	; 0xff
    hrtc->State = HAL_RTC_STATE_ERROR;
 8009c06:	2304      	movs	r3, #4
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 8009c08:	6251      	str	r1, [r2, #36]	; 0x24
    return HAL_ERROR;
 8009c0a:	2001      	movs	r0, #1
    __HAL_UNLOCK(hrtc);
 8009c0c:	f885 801c 	strb.w	r8, [r5, #28]
    hrtc->State = HAL_RTC_STATE_ERROR;
 8009c10:	776b      	strb	r3, [r5, #29]
    return HAL_ERROR;
 8009c12:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8009c16:	68f3      	ldr	r3, [r6, #12]
 8009c18:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8009c1c:	60f3      	str	r3, [r6, #12]
    tickstart = HAL_GetTick();
 8009c1e:	f7fe fc41 	bl	80084a4 <HAL_GetTick>
 8009c22:	4607      	mov	r7, r0
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8009c24:	682e      	ldr	r6, [r5, #0]
 8009c26:	68f4      	ldr	r4, [r6, #12]
 8009c28:	f014 0420 	ands.w	r4, r4, #32
 8009c2c:	d192      	bne.n	8009b54 <HAL_RTC_SetTime+0x78>
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8009c2e:	f7fe fc39 	bl	80084a4 <HAL_GetTick>
 8009c32:	1bc0      	subs	r0, r0, r7
 8009c34:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8009c38:	d9f4      	bls.n	8009c24 <HAL_RTC_SetTime+0x148>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 8009c3a:	682a      	ldr	r2, [r5, #0]
 8009c3c:	21ff      	movs	r1, #255	; 0xff
        hrtc->State = HAL_RTC_STATE_ERROR;
 8009c3e:	2304      	movs	r3, #4
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 8009c40:	6251      	str	r1, [r2, #36]	; 0x24
        return HAL_ERROR;
 8009c42:	2001      	movs	r0, #1
        __HAL_UNLOCK(hrtc);
 8009c44:	772c      	strb	r4, [r5, #28]
        hrtc->State = HAL_RTC_STATE_ERROR;
 8009c46:	776b      	strb	r3, [r5, #29]
}
 8009c48:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  while(Value >= 10U)
 8009c4c:	f04f 0e00 	mov.w	lr, #0
 8009c50:	e7ad      	b.n	8009bae <HAL_RTC_SetTime+0xd2>
 8009c52:	2200      	movs	r2, #0
 8009c54:	e7ba      	b.n	8009bcc <HAL_RTC_SetTime+0xf0>
 8009c56:	bf00      	nop

08009c58 <HAL_RTC_GetTime>:
  sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
 8009c58:	6803      	ldr	r3, [r0, #0]
{
 8009c5a:	b5f0      	push	{r4, r5, r6, r7, lr}
  sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
 8009c5c:	6a9d      	ldr	r5, [r3, #40]	; 0x28
  sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
 8009c5e:	691c      	ldr	r4, [r3, #16]
  tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK); 
 8009c60:	681b      	ldr	r3, [r3, #0]
  sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
 8009c62:	604d      	str	r5, [r1, #4]
  tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK); 
 8009c64:	f003 337f 	and.w	r3, r3, #2139062143	; 0x7f7f7f7f
 8009c68:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16U);
 8009c6c:	0c18      	lsrs	r0, r3, #16
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >> 8U);
 8009c6e:	f3c3 2706 	ubfx	r7, r3, #8, #7
  sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
 8009c72:	f3c4 040e 	ubfx	r4, r4, #0, #15
  sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8009c76:	b2db      	uxtb	r3, r3
  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16U); 
 8009c78:	f000 0e40 	and.w	lr, r0, #64	; 0x40
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16U);
 8009c7c:	f000 063f 	and.w	r6, r0, #63	; 0x3f
  sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
 8009c80:	608c      	str	r4, [r1, #8]
  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16U); 
 8009c82:	f881 e003 	strb.w	lr, [r1, #3]
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16U);
 8009c86:	700e      	strb	r6, [r1, #0]
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >> 8U);
 8009c88:	704f      	strb	r7, [r1, #1]
  sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8009c8a:	708b      	strb	r3, [r1, #2]
  if(Format == RTC_FORMAT_BIN)
 8009c8c:	b9ba      	cbnz	r2, 8009cbe <HAL_RTC_GetTime+0x66>
  * @retval Converted word
  */
uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint32_t tmp = 0U;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8009c8e:	093d      	lsrs	r5, r7, #4
 8009c90:	091c      	lsrs	r4, r3, #4
 8009c92:	0936      	lsrs	r6, r6, #4
 8009c94:	eb06 0686 	add.w	r6, r6, r6, lsl #2
 8009c98:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 8009c9c:	eb04 0484 	add.w	r4, r4, r4, lsl #2
  return (tmp + (Value & (uint8_t)0x0F));
 8009ca0:	f000 000f 	and.w	r0, r0, #15
 8009ca4:	f007 070f 	and.w	r7, r7, #15
 8009ca8:	f003 030f 	and.w	r3, r3, #15
 8009cac:	eb00 0046 	add.w	r0, r0, r6, lsl #1
 8009cb0:	eb07 0545 	add.w	r5, r7, r5, lsl #1
 8009cb4:	eb03 0444 	add.w	r4, r3, r4, lsl #1
    sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
 8009cb8:	7008      	strb	r0, [r1, #0]
    sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
 8009cba:	704d      	strb	r5, [r1, #1]
    sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);  
 8009cbc:	708c      	strb	r4, [r1, #2]
}
 8009cbe:	2000      	movs	r0, #0
 8009cc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009cc2:	bf00      	nop

08009cc4 <HAL_RTC_SetDate>:
{
 8009cc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 __HAL_LOCK(hrtc);
 8009cc6:	7f03      	ldrb	r3, [r0, #28]
 8009cc8:	2b01      	cmp	r3, #1
 8009cca:	d060      	beq.n	8009d8e <HAL_RTC_SetDate+0xca>
 8009ccc:	4604      	mov	r4, r0
  hrtc->State = HAL_RTC_STATE_BUSY; 
 8009cce:	2302      	movs	r3, #2
 __HAL_LOCK(hrtc);
 8009cd0:	2001      	movs	r0, #1
 8009cd2:	7720      	strb	r0, [r4, #28]
  hrtc->State = HAL_RTC_STATE_BUSY; 
 8009cd4:	7763      	strb	r3, [r4, #29]
  if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 8009cd6:	b32a      	cbz	r2, 8009d24 <HAL_RTC_SetDate+0x60>
                  (((uint32_t)sDate->Month) << 8U) | \
 8009cd8:	7848      	ldrb	r0, [r1, #1]
    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 8009cda:	78ca      	ldrb	r2, [r1, #3]
                  ((uint32_t)sDate->Date) | \
 8009cdc:	788b      	ldrb	r3, [r1, #2]
                  (((uint32_t)sDate->WeekDay) << 13U));  
 8009cde:	780d      	ldrb	r5, [r1, #0]
                  (((uint32_t)sDate->Month) << 8U) | \
 8009ce0:	0200      	lsls	r0, r0, #8
    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 8009ce2:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
                  (((uint32_t)sDate->Month) << 8U) | \
 8009ce6:	4318      	orrs	r0, r3
    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 8009ce8:	ea40 3545 	orr.w	r5, r0, r5, lsl #13
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8009cec:	6822      	ldr	r2, [r4, #0]
 8009cee:	21ca      	movs	r1, #202	; 0xca
 8009cf0:	2353      	movs	r3, #83	; 0x53
 8009cf2:	6251      	str	r1, [r2, #36]	; 0x24
 8009cf4:	6253      	str	r3, [r2, #36]	; 0x24
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8009cf6:	68d3      	ldr	r3, [r2, #12]
 8009cf8:	0659      	lsls	r1, r3, #25
 8009cfa:	d54a      	bpl.n	8009d92 <HAL_RTC_SetDate+0xce>
    hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
 8009cfc:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
 8009d00:	f025 05c0 	bic.w	r5, r5, #192	; 0xc0
 8009d04:	6055      	str	r5, [r2, #4]
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;  
 8009d06:	68d3      	ldr	r3, [r2, #12]
 8009d08:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8009d0c:	60d3      	str	r3, [r2, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8009d0e:	6893      	ldr	r3, [r2, #8]
 8009d10:	069b      	lsls	r3, r3, #26
 8009d12:	d55d      	bpl.n	8009dd0 <HAL_RTC_SetDate+0x10c>
    __HAL_UNLOCK(hrtc);
 8009d14:	2300      	movs	r3, #0
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 8009d16:	20ff      	movs	r0, #255	; 0xff
    hrtc->State = HAL_RTC_STATE_READY ;
 8009d18:	2101      	movs	r1, #1
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 8009d1a:	6250      	str	r0, [r2, #36]	; 0x24
    return HAL_OK;    
 8009d1c:	4618      	mov	r0, r3
    hrtc->State = HAL_RTC_STATE_READY ;
 8009d1e:	7761      	strb	r1, [r4, #29]
    __HAL_UNLOCK(hrtc);
 8009d20:	7723      	strb	r3, [r4, #28]
    return HAL_OK;    
 8009d22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 8009d24:	784e      	ldrb	r6, [r1, #1]
 8009d26:	06f0      	lsls	r0, r6, #27
 8009d28:	d44c      	bmi.n	8009dc4 <HAL_RTC_SetDate+0x100>
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 8009d2a:	78cb      	ldrb	r3, [r1, #3]
  while(Value >= 10U)
 8009d2c:	2b09      	cmp	r3, #9
 8009d2e:	f04f 0000 	mov.w	r0, #0
 8009d32:	d907      	bls.n	8009d44 <HAL_RTC_SetDate+0x80>
    Value -= 10U;
 8009d34:	3b0a      	subs	r3, #10
 8009d36:	b2db      	uxtb	r3, r3
  while(Value >= 10U)
 8009d38:	2b09      	cmp	r3, #9
    bcdhigh++;
 8009d3a:	f100 0001 	add.w	r0, r0, #1
  while(Value >= 10U)
 8009d3e:	d8f9      	bhi.n	8009d34 <HAL_RTC_SetDate+0x70>
 8009d40:	0100      	lsls	r0, r0, #4
 8009d42:	b2c0      	uxtb	r0, r0
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 8009d44:	4303      	orrs	r3, r0
  while(Value >= 10U)
 8009d46:	2e09      	cmp	r6, #9
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 8009d48:	ea4f 4303 	mov.w	r3, r3, lsl #16
  while(Value >= 10U)
 8009d4c:	f04f 0500 	mov.w	r5, #0
 8009d50:	d908      	bls.n	8009d64 <HAL_RTC_SetDate+0xa0>
    Value -= 10U;
 8009d52:	f1a6 000a 	sub.w	r0, r6, #10
 8009d56:	b2c6      	uxtb	r6, r0
  while(Value >= 10U)
 8009d58:	2e09      	cmp	r6, #9
    bcdhigh++;
 8009d5a:	f105 0501 	add.w	r5, r5, #1
  while(Value >= 10U)
 8009d5e:	d8f8      	bhi.n	8009d52 <HAL_RTC_SetDate+0x8e>
 8009d60:	012d      	lsls	r5, r5, #4
 8009d62:	b2ed      	uxtb	r5, r5
                 ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
 8009d64:	7888      	ldrb	r0, [r1, #2]
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8U) | \
 8009d66:	4335      	orrs	r5, r6
  while(Value >= 10U)
 8009d68:	2809      	cmp	r0, #9
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8U) | \
 8009d6a:	ea4f 2505 	mov.w	r5, r5, lsl #8
  while(Value >= 10U)
 8009d6e:	d949      	bls.n	8009e04 <HAL_RTC_SetDate+0x140>
    Value -= 10U;
 8009d70:	380a      	subs	r0, #10
 8009d72:	b2c0      	uxtb	r0, r0
  while(Value >= 10U)
 8009d74:	2809      	cmp	r0, #9
    bcdhigh++;
 8009d76:	f102 0201 	add.w	r2, r2, #1
  while(Value >= 10U)
 8009d7a:	d8f9      	bhi.n	8009d70 <HAL_RTC_SetDate+0xac>
 8009d7c:	0112      	lsls	r2, r2, #4
 8009d7e:	b2d2      	uxtb	r2, r2
                 ((uint32_t)sDate->WeekDay << 13U));   
 8009d80:	7809      	ldrb	r1, [r1, #0]
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 8009d82:	ea43 3341 	orr.w	r3, r3, r1, lsl #13
 8009d86:	431d      	orrs	r5, r3
                 ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
 8009d88:	4310      	orrs	r0, r2
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 8009d8a:	4305      	orrs	r5, r0
 8009d8c:	e7ae      	b.n	8009cec <HAL_RTC_SetDate+0x28>
 __HAL_LOCK(hrtc);
 8009d8e:	2002      	movs	r0, #2
 8009d90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 8009d92:	f04f 33ff 	mov.w	r3, #4294967295
 8009d96:	60d3      	str	r3, [r2, #12]
    tickstart = HAL_GetTick();
 8009d98:	f7fe fb84 	bl	80084a4 <HAL_GetTick>
 8009d9c:	4607      	mov	r7, r0
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8009d9e:	6822      	ldr	r2, [r4, #0]
 8009da0:	68d6      	ldr	r6, [r2, #12]
 8009da2:	f016 0640 	ands.w	r6, r6, #64	; 0x40
 8009da6:	d1a9      	bne.n	8009cfc <HAL_RTC_SetDate+0x38>
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8009da8:	f7fe fb7c 	bl	80084a4 <HAL_GetTick>
 8009dac:	1bc0      	subs	r0, r0, r7
 8009dae:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8009db2:	d9f4      	bls.n	8009d9e <HAL_RTC_SetDate+0xda>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 8009db4:	6822      	ldr	r2, [r4, #0]
 8009db6:	21ff      	movs	r1, #255	; 0xff
    hrtc->State = HAL_RTC_STATE_ERROR;
 8009db8:	2304      	movs	r3, #4
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 8009dba:	6251      	str	r1, [r2, #36]	; 0x24
    return HAL_ERROR;
 8009dbc:	2001      	movs	r0, #1
    __HAL_UNLOCK(hrtc);
 8009dbe:	7726      	strb	r6, [r4, #28]
    hrtc->State = HAL_RTC_STATE_ERROR;
 8009dc0:	7763      	strb	r3, [r4, #29]
    return HAL_ERROR;
 8009dc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 8009dc4:	f026 0510 	bic.w	r5, r6, #16
 8009dc8:	350a      	adds	r5, #10
 8009dca:	b2ee      	uxtb	r6, r5
 8009dcc:	704e      	strb	r6, [r1, #1]
 8009dce:	e7ac      	b.n	8009d2a <HAL_RTC_SetDate+0x66>
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8009dd0:	68d3      	ldr	r3, [r2, #12]
 8009dd2:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8009dd6:	60d3      	str	r3, [r2, #12]
    tickstart = HAL_GetTick();
 8009dd8:	f7fe fb64 	bl	80084a4 <HAL_GetTick>
 8009ddc:	4606      	mov	r6, r0
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8009dde:	6822      	ldr	r2, [r4, #0]
 8009de0:	68d5      	ldr	r5, [r2, #12]
 8009de2:	f015 0520 	ands.w	r5, r5, #32
 8009de6:	d195      	bne.n	8009d14 <HAL_RTC_SetDate+0x50>
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8009de8:	f7fe fb5c 	bl	80084a4 <HAL_GetTick>
 8009dec:	1b80      	subs	r0, r0, r6
 8009dee:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8009df2:	d9f4      	bls.n	8009dde <HAL_RTC_SetDate+0x11a>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 8009df4:	6822      	ldr	r2, [r4, #0]
 8009df6:	21ff      	movs	r1, #255	; 0xff
        hrtc->State = HAL_RTC_STATE_ERROR;
 8009df8:	2304      	movs	r3, #4
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 8009dfa:	6251      	str	r1, [r2, #36]	; 0x24
        return HAL_ERROR;
 8009dfc:	2001      	movs	r0, #1
        __HAL_UNLOCK(hrtc);
 8009dfe:	7725      	strb	r5, [r4, #28]
        hrtc->State = HAL_RTC_STATE_ERROR;
 8009e00:	7763      	strb	r3, [r4, #29]
}
 8009e02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  while(Value >= 10U)
 8009e04:	2200      	movs	r2, #0
 8009e06:	e7bb      	b.n	8009d80 <HAL_RTC_SetDate+0xbc>

08009e08 <HAL_RTC_GetDate>:
  datetmpreg = (uint32_t)(hrtc->Instance->DR & RTC_DR_RESERVED_MASK); 
 8009e08:	6803      	ldr	r3, [r0, #0]
 8009e0a:	685b      	ldr	r3, [r3, #4]
 8009e0c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8009e10:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
{
 8009e14:	b4f0      	push	{r4, r5, r6, r7}
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8U);
 8009e16:	f3c3 2407 	ubfx	r4, r3, #8, #8
  sDate->Date = (uint8_t)(datetmpreg & (RTC_DR_DT | RTC_DR_DU));
 8009e1a:	b2dd      	uxtb	r5, r3
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> 13U); 
 8009e1c:	f3c3 3742 	ubfx	r7, r3, #13, #3
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8U);
 8009e20:	f004 061f 	and.w	r6, r4, #31
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16U);
 8009e24:	0c1b      	lsrs	r3, r3, #16
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> 13U); 
 8009e26:	700f      	strb	r7, [r1, #0]
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8U);
 8009e28:	704e      	strb	r6, [r1, #1]
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16U);
 8009e2a:	70cb      	strb	r3, [r1, #3]
  sDate->Date = (uint8_t)(datetmpreg & (RTC_DR_DT | RTC_DR_DU));
 8009e2c:	708d      	strb	r5, [r1, #2]
  if(Format == RTC_FORMAT_BIN)
 8009e2e:	b9ba      	cbnz	r2, 8009e60 <HAL_RTC_GetDate+0x58>
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8009e30:	0936      	lsrs	r6, r6, #4
 8009e32:	0928      	lsrs	r0, r5, #4
 8009e34:	091a      	lsrs	r2, r3, #4
 8009e36:	00b7      	lsls	r7, r6, #2
 8009e38:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  return (tmp + (Value & (uint8_t)0x0F));
 8009e3c:	f004 040f 	and.w	r4, r4, #15
 8009e40:	f005 050f 	and.w	r5, r5, #15
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8009e44:	443e      	add	r6, r7
 8009e46:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  return (tmp + (Value & (uint8_t)0x0F));
 8009e4a:	f003 030f 	and.w	r3, r3, #15
 8009e4e:	eb05 0040 	add.w	r0, r5, r0, lsl #1
 8009e52:	eb04 0446 	add.w	r4, r4, r6, lsl #1
 8009e56:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    sDate->Date = (uint8_t)RTC_Bcd2ToByte(sDate->Date);  
 8009e5a:	7088      	strb	r0, [r1, #2]
    sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
 8009e5c:	704c      	strb	r4, [r1, #1]
    sDate->Year = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
 8009e5e:	70cb      	strb	r3, [r1, #3]
}
 8009e60:	2000      	movs	r0, #0
 8009e62:	bcf0      	pop	{r4, r5, r6, r7}
 8009e64:	4770      	bx	lr
 8009e66:	bf00      	nop

08009e68 <UART_SetConfig>:
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 8009e68:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
  assert_param(IS_UART_PARITY(huart->Init.Parity));
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = huart->Instance->CR2;
 8009e6c:	6804      	ldr	r4, [r0, #0]
 8009e6e:	6922      	ldr	r2, [r4, #16]
{
 8009e70:	4682      	mov	sl, r0

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
 8009e72:	68c0      	ldr	r0, [r0, #12]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8009e74:	f8da 101c 	ldr.w	r1, [sl, #28]
 8009e78:	f8da 3008 	ldr.w	r3, [sl, #8]
 8009e7c:	f8da 6010 	ldr.w	r6, [sl, #16]
 8009e80:	f8da 5014 	ldr.w	r5, [sl, #20]
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 8009e84:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
  tmpreg |= (uint32_t)huart->Init.StopBits;
 8009e88:	4302      	orrs	r2, r0
  WRITE_REG(huart->Instance->CR2, (uint32_t)tmpreg);
 8009e8a:	6122      	str	r2, [r4, #16]
  tmpreg = huart->Instance->CR1;
 8009e8c:	68e2      	ldr	r2, [r4, #12]
  
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
  
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  tmpreg |= huart->Init.HwFlowCtl;
 8009e8e:	f8da 0018 	ldr.w	r0, [sl, #24]
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8009e92:	4333      	orrs	r3, r6
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 8009e94:	f422 4216 	bic.w	r2, r2, #38400	; 0x9600
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8009e98:	432b      	orrs	r3, r5
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 8009e9a:	f022 020c 	bic.w	r2, r2, #12
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8009e9e:	430b      	orrs	r3, r1
 8009ea0:	4313      	orrs	r3, r2
  WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
 8009ea2:	60e3      	str	r3, [r4, #12]
  tmpreg = huart->Instance->CR3;
 8009ea4:	6963      	ldr	r3, [r4, #20]
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
 8009ea6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  tmpreg |= huart->Init.HwFlowCtl;
 8009eaa:	4303      	orrs	r3, r0
  
  /* Write to USART CR3 */
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8009eac:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
 8009eb0:	6163      	str	r3, [r4, #20]
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
#if defined(USART6) 
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8009eb2:	4bab      	ldr	r3, [pc, #684]	; (800a160 <UART_SetConfig+0x2f8>)
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8009eb4:	d061      	beq.n	8009f7a <UART_SetConfig+0x112>
  }
  else
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
#if defined(USART6) 
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8009eb6:	429c      	cmp	r4, r3
 8009eb8:	f000 8101 	beq.w	800a0be <UART_SetConfig+0x256>
 8009ebc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8009ec0:	429c      	cmp	r4, r3
 8009ec2:	f000 80fc 	beq.w	800a0be <UART_SetConfig+0x256>
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
    }	
#endif /* USART6 */
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8009ec6:	f7ff fcd5 	bl	8009874 <HAL_RCC_GetPCLK1Freq>
 8009eca:	4fa6      	ldr	r7, [pc, #664]	; (800a164 <UART_SetConfig+0x2fc>)
 8009ecc:	f8da 3004 	ldr.w	r3, [sl, #4]
 8009ed0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009ed4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009ed8:	009b      	lsls	r3, r3, #2
 8009eda:	fbb0 f3f3 	udiv	r3, r0, r3
 8009ede:	fba7 2303 	umull	r2, r3, r7, r3
 8009ee2:	095b      	lsrs	r3, r3, #5
 8009ee4:	011d      	lsls	r5, r3, #4
 8009ee6:	f7ff fcc5 	bl	8009874 <HAL_RCC_GetPCLK1Freq>
 8009eea:	f8da 3004 	ldr.w	r3, [sl, #4]
 8009eee:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009ef2:	009b      	lsls	r3, r3, #2
 8009ef4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009ef8:	fbb0 f6f3 	udiv	r6, r0, r3
 8009efc:	f7ff fcba 	bl	8009874 <HAL_RCC_GetPCLK1Freq>
 8009f00:	f8da 2004 	ldr.w	r2, [sl, #4]
 8009f04:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009f08:	0093      	lsls	r3, r2, #2
 8009f0a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009f0e:	fbb0 f3f3 	udiv	r3, r0, r3
 8009f12:	fba7 2303 	umull	r2, r3, r7, r3
 8009f16:	f04f 0964 	mov.w	r9, #100	; 0x64
 8009f1a:	095b      	lsrs	r3, r3, #5
 8009f1c:	fb09 6313 	mls	r3, r9, r3, r6
 8009f20:	011b      	lsls	r3, r3, #4
 8009f22:	3332      	adds	r3, #50	; 0x32
 8009f24:	fba7 2303 	umull	r2, r3, r7, r3
 8009f28:	095b      	lsrs	r3, r3, #5
 8009f2a:	f003 06f0 	and.w	r6, r3, #240	; 0xf0
 8009f2e:	f7ff fca1 	bl	8009874 <HAL_RCC_GetPCLK1Freq>
 8009f32:	f8da 2004 	ldr.w	r2, [sl, #4]
 8009f36:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009f3a:	0093      	lsls	r3, r2, #2
 8009f3c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009f40:	fbb0 f8f3 	udiv	r8, r0, r3
 8009f44:	f7ff fc96 	bl	8009874 <HAL_RCC_GetPCLK1Freq>
 8009f48:	f8da 3004 	ldr.w	r3, [sl, #4]
 8009f4c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009f50:	009b      	lsls	r3, r3, #2
 8009f52:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009f56:	fbb0 f0f3 	udiv	r0, r0, r3
 8009f5a:	fba7 3000 	umull	r3, r0, r7, r0
 8009f5e:	0940      	lsrs	r0, r0, #5
 8009f60:	fb09 8310 	mls	r3, r9, r0, r8
 8009f64:	011b      	lsls	r3, r3, #4
 8009f66:	3332      	adds	r3, #50	; 0x32
 8009f68:	fba7 2303 	umull	r2, r3, r7, r3
 8009f6c:	f3c3 1343 	ubfx	r3, r3, #5, #4
 8009f70:	4333      	orrs	r3, r6
 8009f72:	442b      	add	r3, r5
 8009f74:	60a3      	str	r3, [r4, #8]
 8009f76:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8009f7a:	429c      	cmp	r4, r3
 8009f7c:	d05d      	beq.n	800a03a <UART_SetConfig+0x1d2>
 8009f7e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8009f82:	429c      	cmp	r4, r3
 8009f84:	d059      	beq.n	800a03a <UART_SetConfig+0x1d2>
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8009f86:	f7ff fc75 	bl	8009874 <HAL_RCC_GetPCLK1Freq>
 8009f8a:	4f76      	ldr	r7, [pc, #472]	; (800a164 <UART_SetConfig+0x2fc>)
 8009f8c:	f8da 3004 	ldr.w	r3, [sl, #4]
 8009f90:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009f94:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009f98:	005b      	lsls	r3, r3, #1
 8009f9a:	fbb0 f3f3 	udiv	r3, r0, r3
 8009f9e:	fba7 2303 	umull	r2, r3, r7, r3
 8009fa2:	095b      	lsrs	r3, r3, #5
 8009fa4:	011e      	lsls	r6, r3, #4
 8009fa6:	f7ff fc65 	bl	8009874 <HAL_RCC_GetPCLK1Freq>
 8009faa:	f8da 3004 	ldr.w	r3, [sl, #4]
 8009fae:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009fb2:	005b      	lsls	r3, r3, #1
 8009fb4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009fb8:	fbb0 f5f3 	udiv	r5, r0, r3
 8009fbc:	f7ff fc5a 	bl	8009874 <HAL_RCC_GetPCLK1Freq>
 8009fc0:	f8da 2004 	ldr.w	r2, [sl, #4]
 8009fc4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009fc8:	0053      	lsls	r3, r2, #1
 8009fca:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009fce:	fbb0 f3f3 	udiv	r3, r0, r3
 8009fd2:	fba7 2303 	umull	r2, r3, r7, r3
 8009fd6:	095b      	lsrs	r3, r3, #5
 8009fd8:	f04f 0964 	mov.w	r9, #100	; 0x64
 8009fdc:	fb09 5313 	mls	r3, r9, r3, r5
 8009fe0:	00db      	lsls	r3, r3, #3
 8009fe2:	3332      	adds	r3, #50	; 0x32
 8009fe4:	fba7 2303 	umull	r2, r3, r7, r3
 8009fe8:	091b      	lsrs	r3, r3, #4
 8009fea:	f403 75f8 	and.w	r5, r3, #496	; 0x1f0
 8009fee:	f7ff fc41 	bl	8009874 <HAL_RCC_GetPCLK1Freq>
 8009ff2:	f8da 2004 	ldr.w	r2, [sl, #4]
 8009ff6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009ffa:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8009ffe:	0053      	lsls	r3, r2, #1
 800a000:	fbb0 f8f3 	udiv	r8, r0, r3
 800a004:	f7ff fc36 	bl	8009874 <HAL_RCC_GetPCLK1Freq>
 800a008:	f8da 3004 	ldr.w	r3, [sl, #4]
 800a00c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a010:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a014:	005b      	lsls	r3, r3, #1
 800a016:	fbb0 f3f3 	udiv	r3, r0, r3
 800a01a:	fba7 2303 	umull	r2, r3, r7, r3
 800a01e:	095b      	lsrs	r3, r3, #5
 800a020:	fb09 8313 	mls	r3, r9, r3, r8
 800a024:	00db      	lsls	r3, r3, #3
 800a026:	3332      	adds	r3, #50	; 0x32
 800a028:	fba7 2303 	umull	r2, r3, r7, r3
 800a02c:	f3c3 1342 	ubfx	r3, r3, #5, #3
 800a030:	4433      	add	r3, r6
 800a032:	442b      	add	r3, r5
 800a034:	60a3      	str	r3, [r4, #8]
 800a036:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 800a03a:	f7ff fc2b 	bl	8009894 <HAL_RCC_GetPCLK2Freq>
 800a03e:	4f49      	ldr	r7, [pc, #292]	; (800a164 <UART_SetConfig+0x2fc>)
 800a040:	f8da 3004 	ldr.w	r3, [sl, #4]
 800a044:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a048:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a04c:	005b      	lsls	r3, r3, #1
 800a04e:	fbb0 f3f3 	udiv	r3, r0, r3
 800a052:	fba7 2303 	umull	r2, r3, r7, r3
 800a056:	095b      	lsrs	r3, r3, #5
 800a058:	011e      	lsls	r6, r3, #4
 800a05a:	f7ff fc1b 	bl	8009894 <HAL_RCC_GetPCLK2Freq>
 800a05e:	f8da 3004 	ldr.w	r3, [sl, #4]
 800a062:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a066:	005b      	lsls	r3, r3, #1
 800a068:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a06c:	fbb0 f5f3 	udiv	r5, r0, r3
 800a070:	f7ff fc10 	bl	8009894 <HAL_RCC_GetPCLK2Freq>
 800a074:	f8da 2004 	ldr.w	r2, [sl, #4]
 800a078:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a07c:	0053      	lsls	r3, r2, #1
 800a07e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a082:	fbb0 f3f3 	udiv	r3, r0, r3
 800a086:	fba7 2303 	umull	r2, r3, r7, r3
 800a08a:	f04f 0964 	mov.w	r9, #100	; 0x64
 800a08e:	095b      	lsrs	r3, r3, #5
 800a090:	fb09 5313 	mls	r3, r9, r3, r5
 800a094:	00db      	lsls	r3, r3, #3
 800a096:	3332      	adds	r3, #50	; 0x32
 800a098:	fba7 2303 	umull	r2, r3, r7, r3
 800a09c:	091b      	lsrs	r3, r3, #4
 800a09e:	f403 75f8 	and.w	r5, r3, #496	; 0x1f0
 800a0a2:	f7ff fbf7 	bl	8009894 <HAL_RCC_GetPCLK2Freq>
 800a0a6:	f8da 2004 	ldr.w	r2, [sl, #4]
 800a0aa:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a0ae:	0053      	lsls	r3, r2, #1
 800a0b0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a0b4:	fbb0 f8f3 	udiv	r8, r0, r3
 800a0b8:	f7ff fbec 	bl	8009894 <HAL_RCC_GetPCLK2Freq>
 800a0bc:	e7a4      	b.n	800a008 <UART_SetConfig+0x1a0>
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 800a0be:	f7ff fbe9 	bl	8009894 <HAL_RCC_GetPCLK2Freq>
 800a0c2:	4f28      	ldr	r7, [pc, #160]	; (800a164 <UART_SetConfig+0x2fc>)
 800a0c4:	f8da 3004 	ldr.w	r3, [sl, #4]
 800a0c8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a0cc:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a0d0:	009b      	lsls	r3, r3, #2
 800a0d2:	fbb0 f3f3 	udiv	r3, r0, r3
 800a0d6:	fba7 2303 	umull	r2, r3, r7, r3
 800a0da:	095b      	lsrs	r3, r3, #5
 800a0dc:	011d      	lsls	r5, r3, #4
 800a0de:	f7ff fbd9 	bl	8009894 <HAL_RCC_GetPCLK2Freq>
 800a0e2:	f8da 3004 	ldr.w	r3, [sl, #4]
 800a0e6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a0ea:	009b      	lsls	r3, r3, #2
 800a0ec:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a0f0:	fbb0 f6f3 	udiv	r6, r0, r3
 800a0f4:	f7ff fbce 	bl	8009894 <HAL_RCC_GetPCLK2Freq>
 800a0f8:	f8da 2004 	ldr.w	r2, [sl, #4]
 800a0fc:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a100:	0093      	lsls	r3, r2, #2
 800a102:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a106:	fbb0 f3f3 	udiv	r3, r0, r3
 800a10a:	fba7 2303 	umull	r2, r3, r7, r3
 800a10e:	f04f 0964 	mov.w	r9, #100	; 0x64
 800a112:	095b      	lsrs	r3, r3, #5
 800a114:	fb09 6313 	mls	r3, r9, r3, r6
 800a118:	011b      	lsls	r3, r3, #4
 800a11a:	3332      	adds	r3, #50	; 0x32
 800a11c:	fba7 2303 	umull	r2, r3, r7, r3
 800a120:	095b      	lsrs	r3, r3, #5
 800a122:	f003 06f0 	and.w	r6, r3, #240	; 0xf0
 800a126:	f7ff fbb5 	bl	8009894 <HAL_RCC_GetPCLK2Freq>
 800a12a:	f8da 2004 	ldr.w	r2, [sl, #4]
 800a12e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a132:	0093      	lsls	r3, r2, #2
 800a134:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a138:	fbb0 f8f3 	udiv	r8, r0, r3
 800a13c:	f7ff fbaa 	bl	8009894 <HAL_RCC_GetPCLK2Freq>
 800a140:	f8da 3004 	ldr.w	r3, [sl, #4]
 800a144:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a148:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a14c:	009b      	lsls	r3, r3, #2
 800a14e:	fbb0 f3f3 	udiv	r3, r0, r3
 800a152:	fba7 2303 	umull	r2, r3, r7, r3
 800a156:	095b      	lsrs	r3, r3, #5
 800a158:	fb09 8313 	mls	r3, r9, r3, r8
 800a15c:	e702      	b.n	8009f64 <UART_SetConfig+0xfc>
 800a15e:	bf00      	nop
 800a160:	40011000 	.word	0x40011000
 800a164:	51eb851f 	.word	0x51eb851f

0800a168 <HAL_UART_MspInit>:
 800a168:	4770      	bx	lr
 800a16a:	bf00      	nop

0800a16c <HAL_UART_Init>:
  if(huart == NULL)
 800a16c:	b360      	cbz	r0, 800a1c8 <HAL_UART_Init+0x5c>
{
 800a16e:	b538      	push	{r3, r4, r5, lr}
  if(huart->gState == HAL_UART_STATE_RESET)
 800a170:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 800a174:	4604      	mov	r4, r0
 800a176:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800a17a:	b303      	cbz	r3, 800a1be <HAL_UART_Init+0x52>
  __HAL_UART_DISABLE(huart);
 800a17c:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 800a17e:	2324      	movs	r3, #36	; 0x24
 800a180:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  __HAL_UART_DISABLE(huart);
 800a184:	68d3      	ldr	r3, [r2, #12]
 800a186:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800a18a:	60d3      	str	r3, [r2, #12]
  UART_SetConfig(huart);
 800a18c:	4620      	mov	r0, r4
 800a18e:	f7ff fe6b 	bl	8009e68 <UART_SetConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800a192:	6823      	ldr	r3, [r4, #0]
 800a194:	691a      	ldr	r2, [r3, #16]
 800a196:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 800a19a:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800a19c:	695a      	ldr	r2, [r3, #20]
 800a19e:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 800a1a2:	615a      	str	r2, [r3, #20]
  __HAL_UART_ENABLE(huart);
 800a1a4:	68da      	ldr	r2, [r3, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a1a6:	2500      	movs	r5, #0
  huart->gState= HAL_UART_STATE_READY;
 800a1a8:	2120      	movs	r1, #32
  __HAL_UART_ENABLE(huart);
 800a1aa:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800a1ae:	60da      	str	r2, [r3, #12]
  return HAL_OK;
 800a1b0:	4628      	mov	r0, r5
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a1b2:	63e5      	str	r5, [r4, #60]	; 0x3c
  huart->gState= HAL_UART_STATE_READY;
 800a1b4:	f884 1039 	strb.w	r1, [r4, #57]	; 0x39
  huart->RxState= HAL_UART_STATE_READY;
 800a1b8:	f884 103a 	strb.w	r1, [r4, #58]	; 0x3a
  return HAL_OK;
 800a1bc:	bd38      	pop	{r3, r4, r5, pc}
    huart->Lock = HAL_UNLOCKED;
 800a1be:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    HAL_UART_MspInit(huart);
 800a1c2:	f7ff ffd1 	bl	800a168 <HAL_UART_MspInit>
 800a1c6:	e7d9      	b.n	800a17c <HAL_UART_Init+0x10>
    return HAL_ERROR;
 800a1c8:	2001      	movs	r0, #1
 800a1ca:	4770      	bx	lr

0800a1cc <HAL_UART_Transmit>:
{
 800a1cc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a1ce:	460e      	mov	r6, r1
  if(huart->gState == HAL_UART_STATE_READY) 
 800a1d0:	f890 1039 	ldrb.w	r1, [r0, #57]	; 0x39
 800a1d4:	2920      	cmp	r1, #32
{
 800a1d6:	b083      	sub	sp, #12
  if(huart->gState == HAL_UART_STATE_READY) 
 800a1d8:	d002      	beq.n	800a1e0 <HAL_UART_Transmit+0x14>
    return HAL_BUSY;
 800a1da:	2002      	movs	r0, #2
}
 800a1dc:	b003      	add	sp, #12
 800a1de:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((pData == NULL ) || (Size == 0)) 
 800a1e0:	b35e      	cbz	r6, 800a23a <HAL_UART_Transmit+0x6e>
 800a1e2:	b352      	cbz	r2, 800a23a <HAL_UART_Transmit+0x6e>
 800a1e4:	461f      	mov	r7, r3
    __HAL_LOCK(huart);
 800a1e6:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 800a1ea:	2b01      	cmp	r3, #1
 800a1ec:	4604      	mov	r4, r0
 800a1ee:	d0f4      	beq.n	800a1da <HAL_UART_Transmit+0xe>
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a1f0:	2000      	movs	r0, #0
    __HAL_LOCK(huart);
 800a1f2:	2101      	movs	r1, #1
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800a1f4:	2321      	movs	r3, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a1f6:	63e0      	str	r0, [r4, #60]	; 0x3c
    __HAL_LOCK(huart);
 800a1f8:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800a1fc:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
 800a200:	9201      	str	r2, [sp, #4]
    tickstart = HAL_GetTick();
 800a202:	f7fe f94f 	bl	80084a4 <HAL_GetTick>
    huart->TxXferSize = Size;
 800a206:	9a01      	ldr	r2, [sp, #4]
 800a208:	84a2      	strh	r2, [r4, #36]	; 0x24
    tickstart = HAL_GetTick();
 800a20a:	4605      	mov	r5, r0
 800a20c:	6820      	ldr	r0, [r4, #0]
    huart->TxXferCount = Size;
 800a20e:	84e2      	strh	r2, [r4, #38]	; 0x26
    while(huart->TxXferCount > 0U)
 800a210:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 800a212:	b29b      	uxth	r3, r3
 800a214:	2b00      	cmp	r3, #0
 800a216:	d035      	beq.n	800a284 <HAL_UART_Transmit+0xb8>
      huart->TxXferCount--;
 800a218:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
      if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 800a21a:	68a1      	ldr	r1, [r4, #8]
      huart->TxXferCount--;
 800a21c:	3a01      	subs	r2, #1
 800a21e:	b292      	uxth	r2, r2
      if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 800a220:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
      huart->TxXferCount--;
 800a224:	84e2      	strh	r2, [r4, #38]	; 0x26
      if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 800a226:	d015      	beq.n	800a254 <HAL_UART_Transmit+0x88>
 800a228:	1c79      	adds	r1, r7, #1
 800a22a:	d137      	bne.n	800a29c <HAL_UART_Transmit+0xd0>
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status) 
 800a22c:	6802      	ldr	r2, [r0, #0]
 800a22e:	0612      	lsls	r2, r2, #24
 800a230:	d5fc      	bpl.n	800a22c <HAL_UART_Transmit+0x60>
        huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
 800a232:	7833      	ldrb	r3, [r6, #0]
 800a234:	6043      	str	r3, [r0, #4]
 800a236:	3601      	adds	r6, #1
 800a238:	e7ea      	b.n	800a210 <HAL_UART_Transmit+0x44>
      return  HAL_ERROR;
 800a23a:	2001      	movs	r0, #1
 800a23c:	e7ce      	b.n	800a1dc <HAL_UART_Transmit+0x10>
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status) 
 800a23e:	6803      	ldr	r3, [r0, #0]
 800a240:	061b      	lsls	r3, r3, #24
 800a242:	d40c      	bmi.n	800a25e <HAL_UART_Transmit+0x92>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 800a244:	2f00      	cmp	r7, #0
 800a246:	d033      	beq.n	800a2b0 <HAL_UART_Transmit+0xe4>
 800a248:	f7fe f92c 	bl	80084a4 <HAL_GetTick>
 800a24c:	1b40      	subs	r0, r0, r5
 800a24e:	4287      	cmp	r7, r0
 800a250:	6820      	ldr	r0, [r4, #0]
 800a252:	d32d      	bcc.n	800a2b0 <HAL_UART_Transmit+0xe4>
 800a254:	1c79      	adds	r1, r7, #1
 800a256:	d1f2      	bne.n	800a23e <HAL_UART_Transmit+0x72>
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status) 
 800a258:	6802      	ldr	r2, [r0, #0]
 800a25a:	0612      	lsls	r2, r2, #24
 800a25c:	d5fc      	bpl.n	800a258 <HAL_UART_Transmit+0x8c>
        huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
 800a25e:	8833      	ldrh	r3, [r6, #0]
        if(huart->Init.Parity == UART_PARITY_NONE)
 800a260:	6922      	ldr	r2, [r4, #16]
        huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
 800a262:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a266:	6043      	str	r3, [r0, #4]
        if(huart->Init.Parity == UART_PARITY_NONE)
 800a268:	2a00      	cmp	r2, #0
 800a26a:	d1e4      	bne.n	800a236 <HAL_UART_Transmit+0x6a>
          pData +=2U;
 800a26c:	3602      	adds	r6, #2
 800a26e:	e7cf      	b.n	800a210 <HAL_UART_Transmit+0x44>
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status) 
 800a270:	6803      	ldr	r3, [r0, #0]
 800a272:	065b      	lsls	r3, r3, #25
 800a274:	d40b      	bmi.n	800a28e <HAL_UART_Transmit+0xc2>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 800a276:	b1df      	cbz	r7, 800a2b0 <HAL_UART_Transmit+0xe4>
 800a278:	f7fe f914 	bl	80084a4 <HAL_GetTick>
 800a27c:	1b40      	subs	r0, r0, r5
 800a27e:	4287      	cmp	r7, r0
 800a280:	6820      	ldr	r0, [r4, #0]
 800a282:	d315      	bcc.n	800a2b0 <HAL_UART_Transmit+0xe4>
 800a284:	1c79      	adds	r1, r7, #1
 800a286:	d1f3      	bne.n	800a270 <HAL_UART_Transmit+0xa4>
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status) 
 800a288:	6803      	ldr	r3, [r0, #0]
 800a28a:	065a      	lsls	r2, r3, #25
 800a28c:	d5fc      	bpl.n	800a288 <HAL_UART_Transmit+0xbc>
      huart->gState = HAL_UART_STATE_READY;
 800a28e:	2320      	movs	r3, #32
    __HAL_UNLOCK(huart);
 800a290:	2000      	movs	r0, #0
      huart->gState = HAL_UART_STATE_READY;
 800a292:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
    __HAL_UNLOCK(huart);
 800a296:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38
    return HAL_OK;
 800a29a:	e79f      	b.n	800a1dc <HAL_UART_Transmit+0x10>
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status) 
 800a29c:	6803      	ldr	r3, [r0, #0]
 800a29e:	061b      	lsls	r3, r3, #24
 800a2a0:	d4c7      	bmi.n	800a232 <HAL_UART_Transmit+0x66>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 800a2a2:	b12f      	cbz	r7, 800a2b0 <HAL_UART_Transmit+0xe4>
 800a2a4:	f7fe f8fe 	bl	80084a4 <HAL_GetTick>
 800a2a8:	1b40      	subs	r0, r0, r5
 800a2aa:	4287      	cmp	r7, r0
 800a2ac:	6820      	ldr	r0, [r4, #0]
 800a2ae:	d2bb      	bcs.n	800a228 <HAL_UART_Transmit+0x5c>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800a2b0:	68c3      	ldr	r3, [r0, #12]
 800a2b2:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 800a2b6:	60c3      	str	r3, [r0, #12]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a2b8:	6943      	ldr	r3, [r0, #20]
        huart->gState  = HAL_UART_STATE_READY;
 800a2ba:	2220      	movs	r2, #32
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a2bc:	f023 0301 	bic.w	r3, r3, #1
        __HAL_UNLOCK(huart);
 800a2c0:	2100      	movs	r1, #0
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a2c2:	6143      	str	r3, [r0, #20]
        huart->gState  = HAL_UART_STATE_READY;
 800a2c4:	f884 2039 	strb.w	r2, [r4, #57]	; 0x39
      return HAL_TIMEOUT;
 800a2c8:	2003      	movs	r0, #3
        __HAL_UNLOCK(huart);
 800a2ca:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
        huart->RxState = HAL_UART_STATE_READY;
 800a2ce:	f884 203a 	strb.w	r2, [r4, #58]	; 0x3a
 800a2d2:	e783      	b.n	800a1dc <HAL_UART_Transmit+0x10>

0800a2d4 <HAL_UART_Receive_DMA>:
{  
 800a2d4:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(huart->RxState == HAL_UART_STATE_READY) 
 800a2d6:	f890 403a 	ldrb.w	r4, [r0, #58]	; 0x3a
 800a2da:	2c20      	cmp	r4, #32
{  
 800a2dc:	b083      	sub	sp, #12
  if(huart->RxState == HAL_UART_STATE_READY) 
 800a2de:	d002      	beq.n	800a2e6 <HAL_UART_Receive_DMA+0x12>
    return HAL_BUSY; 
 800a2e0:	2002      	movs	r0, #2
}
 800a2e2:	b003      	add	sp, #12
 800a2e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((pData == NULL ) || (Size == 0)) 
 800a2e6:	2900      	cmp	r1, #0
 800a2e8:	d035      	beq.n	800a356 <HAL_UART_Receive_DMA+0x82>
 800a2ea:	2a00      	cmp	r2, #0
 800a2ec:	d033      	beq.n	800a356 <HAL_UART_Receive_DMA+0x82>
    __HAL_LOCK(huart);
 800a2ee:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 800a2f2:	2b01      	cmp	r3, #1
 800a2f4:	d0f4      	beq.n	800a2e0 <HAL_UART_Receive_DMA+0xc>
 800a2f6:	4604      	mov	r4, r0
 800a2f8:	2701      	movs	r7, #1
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 800a2fa:	6b40      	ldr	r0, [r0, #52]	; 0x34
 800a2fc:	4e17      	ldr	r6, [pc, #92]	; (800a35c <HAL_UART_Receive_DMA+0x88>)
    __HAL_LOCK(huart);
 800a2fe:	f884 7038 	strb.w	r7, [r4, #56]	; 0x38
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a302:	2500      	movs	r5, #0
 800a304:	4613      	mov	r3, r2
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800a306:	2722      	movs	r7, #34	; 0x22
 800a308:	460a      	mov	r2, r1
    HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
 800a30a:	6821      	ldr	r1, [r4, #0]
    huart->pRxBuffPtr = pData;
 800a30c:	62a2      	str	r2, [r4, #40]	; 0x28
    huart->RxXferSize = Size;
 800a30e:	85a3      	strh	r3, [r4, #44]	; 0x2c
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a310:	63e5      	str	r5, [r4, #60]	; 0x3c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800a312:	f884 703a 	strb.w	r7, [r4, #58]	; 0x3a
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 800a316:	63c6      	str	r6, [r0, #60]	; 0x3c
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 800a318:	4f11      	ldr	r7, [pc, #68]	; (800a360 <HAL_UART_Receive_DMA+0x8c>)
    huart->hdmarx->XferErrorCallback = UART_DMAError;
 800a31a:	4e12      	ldr	r6, [pc, #72]	; (800a364 <HAL_UART_Receive_DMA+0x90>)
    huart->hdmarx->XferAbortCallback = NULL;
 800a31c:	6505      	str	r5, [r0, #80]	; 0x50
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 800a31e:	6407      	str	r7, [r0, #64]	; 0x40
    huart->hdmarx->XferErrorCallback = UART_DMAError;
 800a320:	64c6      	str	r6, [r0, #76]	; 0x4c
    HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
 800a322:	3104      	adds	r1, #4
 800a324:	f7fe f9de 	bl	80086e4 <HAL_DMA_Start_IT>
    __HAL_UART_CLEAR_OREFLAG(huart);
 800a328:	6823      	ldr	r3, [r4, #0]
 800a32a:	9501      	str	r5, [sp, #4]
 800a32c:	681a      	ldr	r2, [r3, #0]
 800a32e:	9201      	str	r2, [sp, #4]
 800a330:	685a      	ldr	r2, [r3, #4]
 800a332:	9201      	str	r2, [sp, #4]
 800a334:	9a01      	ldr	r2, [sp, #4]
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 800a336:	68da      	ldr	r2, [r3, #12]
    __HAL_UNLOCK(huart);
 800a338:	f884 5038 	strb.w	r5, [r4, #56]	; 0x38
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 800a33c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800a340:	60da      	str	r2, [r3, #12]
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a342:	695a      	ldr	r2, [r3, #20]
 800a344:	f042 0201 	orr.w	r2, r2, #1
 800a348:	615a      	str	r2, [r3, #20]
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800a34a:	695a      	ldr	r2, [r3, #20]
 800a34c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    return HAL_OK;
 800a350:	4628      	mov	r0, r5
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800a352:	615a      	str	r2, [r3, #20]
    return HAL_OK;
 800a354:	e7c5      	b.n	800a2e2 <HAL_UART_Receive_DMA+0xe>
      return HAL_ERROR;
 800a356:	2001      	movs	r0, #1
 800a358:	e7c3      	b.n	800a2e2 <HAL_UART_Receive_DMA+0xe>
 800a35a:	bf00      	nop
 800a35c:	0800a36d 	.word	0x0800a36d
 800a360:	0800a3a9 	.word	0x0800a3a9
 800a364:	0800a3b9 	.word	0x0800a3b9

0800a368 <HAL_UART_RxCpltCallback>:
 800a368:	4770      	bx	lr
 800a36a:	bf00      	nop

0800a36c <UART_DMAReceiveCplt>:
{
 800a36c:	b508      	push	{r3, lr}
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 800a36e:	6803      	ldr	r3, [r0, #0]
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800a370:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 800a372:	681b      	ldr	r3, [r3, #0]
 800a374:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 800a378:	d110      	bne.n	800a39c <UART_DMAReceiveCplt+0x30>
    CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 800a37a:	6802      	ldr	r2, [r0, #0]
    huart->RxXferCount = 0U;
 800a37c:	85c3      	strh	r3, [r0, #46]	; 0x2e
    CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 800a37e:	68d3      	ldr	r3, [r2, #12]
 800a380:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800a384:	60d3      	str	r3, [r2, #12]
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a386:	6953      	ldr	r3, [r2, #20]
 800a388:	f023 0301 	bic.w	r3, r3, #1
 800a38c:	6153      	str	r3, [r2, #20]
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800a38e:	6953      	ldr	r3, [r2, #20]
    huart->RxState = HAL_UART_STATE_READY;
 800a390:	2120      	movs	r1, #32
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800a392:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800a396:	6153      	str	r3, [r2, #20]
    huart->RxState = HAL_UART_STATE_READY;
 800a398:	f880 103a 	strb.w	r1, [r0, #58]	; 0x3a
  HAL_UART_RxCpltCallback(huart);
 800a39c:	f7ff ffe4 	bl	800a368 <HAL_UART_RxCpltCallback>
 800a3a0:	bd08      	pop	{r3, pc}
 800a3a2:	bf00      	nop

0800a3a4 <HAL_UART_RxHalfCpltCallback>:
 800a3a4:	4770      	bx	lr
 800a3a6:	bf00      	nop

0800a3a8 <UART_DMARxHalfCplt>:
{
 800a3a8:	b508      	push	{r3, lr}
  HAL_UART_RxHalfCpltCallback(huart); 
 800a3aa:	6b80      	ldr	r0, [r0, #56]	; 0x38
 800a3ac:	f7ff fffa 	bl	800a3a4 <HAL_UART_RxHalfCpltCallback>
 800a3b0:	bd08      	pop	{r3, pc}
 800a3b2:	bf00      	nop

0800a3b4 <HAL_UART_ErrorCallback>:
 800a3b4:	4770      	bx	lr
 800a3b6:	bf00      	nop

0800a3b8 <UART_DMAError>:
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800a3b8:	6b80      	ldr	r0, [r0, #56]	; 0x38
{
 800a3ba:	b508      	push	{r3, lr}
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
 800a3bc:	6803      	ldr	r3, [r0, #0]
 800a3be:	6959      	ldr	r1, [r3, #20]
  if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 800a3c0:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
 800a3c4:	2a21      	cmp	r2, #33	; 0x21
 800a3c6:	d01b      	beq.n	800a400 <UART_DMAError+0x48>
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR); 
 800a3c8:	6959      	ldr	r1, [r3, #20]
  if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 800a3ca:	f890 203a 	ldrb.w	r2, [r0, #58]	; 0x3a
 800a3ce:	2a22      	cmp	r2, #34	; 0x22
 800a3d0:	d006      	beq.n	800a3e0 <UART_DMAError+0x28>
  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 800a3d2:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800a3d4:	f043 0310 	orr.w	r3, r3, #16
 800a3d8:	63c3      	str	r3, [r0, #60]	; 0x3c
  HAL_UART_ErrorCallback(huart);
 800a3da:	f7ff ffeb 	bl	800a3b4 <HAL_UART_ErrorCallback>
 800a3de:	bd08      	pop	{r3, pc}
  if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 800a3e0:	064a      	lsls	r2, r1, #25
 800a3e2:	d5f6      	bpl.n	800a3d2 <UART_DMAError+0x1a>
    huart->RxXferCount = 0U;
 800a3e4:	2200      	movs	r2, #0
 800a3e6:	85c2      	strh	r2, [r0, #46]	; 0x2e
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800a3e8:	68da      	ldr	r2, [r3, #12]
 800a3ea:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 800a3ee:	60da      	str	r2, [r3, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a3f0:	695a      	ldr	r2, [r3, #20]
  huart->RxState = HAL_UART_STATE_READY;
 800a3f2:	2120      	movs	r1, #32
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a3f4:	f022 0201 	bic.w	r2, r2, #1
 800a3f8:	615a      	str	r2, [r3, #20]
  huart->RxState = HAL_UART_STATE_READY;
 800a3fa:	f880 103a 	strb.w	r1, [r0, #58]	; 0x3a
 800a3fe:	e7e8      	b.n	800a3d2 <UART_DMAError+0x1a>
  if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 800a400:	0609      	lsls	r1, r1, #24
 800a402:	d5e1      	bpl.n	800a3c8 <UART_DMAError+0x10>
    huart->TxXferCount = 0U;
 800a404:	2200      	movs	r2, #0
 800a406:	84c2      	strh	r2, [r0, #38]	; 0x26
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 800a408:	68da      	ldr	r2, [r3, #12]
  huart->gState = HAL_UART_STATE_READY;
 800a40a:	2120      	movs	r1, #32
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 800a40c:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 800a410:	60da      	str	r2, [r3, #12]
  huart->gState = HAL_UART_STATE_READY;
 800a412:	f880 1039 	strb.w	r1, [r0, #57]	; 0x39
 800a416:	e7d7      	b.n	800a3c8 <UART_DMAError+0x10>

0800a418 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    		 /* set stack pointer */
 800a418:	f8df d034 	ldr.w	sp, [pc, #52]	; 800a450 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 800a41c:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800a41e:	e003      	b.n	800a428 <LoopCopyDataInit>

0800a420 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800a420:	4b0c      	ldr	r3, [pc, #48]	; (800a454 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 800a422:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800a424:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800a426:	3104      	adds	r1, #4

0800a428 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800a428:	480b      	ldr	r0, [pc, #44]	; (800a458 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 800a42a:	4b0c      	ldr	r3, [pc, #48]	; (800a45c <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 800a42c:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800a42e:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800a430:	d3f6      	bcc.n	800a420 <CopyDataInit>
  ldr  r2, =_sbss
 800a432:	4a0b      	ldr	r2, [pc, #44]	; (800a460 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 800a434:	e002      	b.n	800a43c <LoopFillZerobss>

0800a436 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 800a436:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800a438:	f842 3b04 	str.w	r3, [r2], #4

0800a43c <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800a43c:	4b09      	ldr	r3, [pc, #36]	; (800a464 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 800a43e:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800a440:	d3f9      	bcc.n	800a436 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 800a442:	f7fd ffbd 	bl	80083c0 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800a446:	f001 ff41 	bl	800c2cc <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800a44a:	f000 fb73 	bl	800ab34 <main>
  bx  lr    
 800a44e:	4770      	bx	lr
  ldr   sp, =_estack    		 /* set stack pointer */
 800a450:	20018000 	.word	0x20018000
  ldr  r3, =_sidata
 800a454:	0800d72c 	.word	0x0800d72c
  ldr  r0, =_sdata
 800a458:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800a45c:	20000580 	.word	0x20000580
  ldr  r2, =_sbss
 800a460:	20000580 	.word	0x20000580
  ldr  r3, = _ebss
 800a464:	20000dd0 	.word	0x20000dd0

0800a468 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800a468:	e7fe      	b.n	800a468 <ADC_IRQHandler>
	...

0800a46c <BUILD_REPLY_HEADER>:
  */
void BUILD_REPLY_HEADER(TMsg *Msg)
{
  Msg->Data[0] = Msg->Data[1];
  Msg->Data[1] = DEV_ADDR;
  Msg->Data[2] += CMD_Reply_Add;
 800a46c:	7983      	ldrb	r3, [r0, #6]
  Msg->Data[0] = Msg->Data[1];
 800a46e:	7941      	ldrb	r1, [r0, #5]
 800a470:	7101      	strb	r1, [r0, #4]
  Msg->Data[1] = DEV_ADDR;
 800a472:	2232      	movs	r2, #50	; 0x32
  Msg->Data[2] += CMD_Reply_Add;
 800a474:	3b80      	subs	r3, #128	; 0x80
  Msg->Data[1] = DEV_ADDR;
 800a476:	7142      	strb	r2, [r0, #5]
  Msg->Data[2] += CMD_Reply_Add;
 800a478:	7183      	strb	r3, [r0, #6]
 800a47a:	4770      	bx	lr

0800a47c <INIT_STREAMING_HEADER>:
  * @param  Msg the pointer to the header to be initialized
  * @retval None
  */
void INIT_STREAMING_HEADER(TMsg *Msg)
{
  Msg->Data[0] = DataStreamingDest;
 800a47c:	4b04      	ldr	r3, [pc, #16]	; (800a490 <INIT_STREAMING_HEADER+0x14>)
 800a47e:	781b      	ldrb	r3, [r3, #0]
 800a480:	7103      	strb	r3, [r0, #4]
  Msg->Data[1] = DEV_ADDR;
 800a482:	2132      	movs	r1, #50	; 0x32
  Msg->Data[2] = CMD_Start_Data_Streaming;
 800a484:	2208      	movs	r2, #8
  Msg->Len = 3;
 800a486:	2303      	movs	r3, #3
  Msg->Data[1] = DEV_ADDR;
 800a488:	7141      	strb	r1, [r0, #5]
  Msg->Data[2] = CMD_Start_Data_Streaming;
 800a48a:	7182      	strb	r2, [r0, #6]
  Msg->Len = 3;
 800a48c:	6003      	str	r3, [r0, #0]
 800a48e:	4770      	bx	lr
 800a490:	200003a8 	.word	0x200003a8

0800a494 <HandleMSG>:
  * @retval 1 if the message is correctly handled, 0 otherwise
  */
int HandleMSG(TMsg *Msg)
//  DestAddr | SouceAddr | CMD | PAYLOAD
//      1          1        1       N
{
 800a494:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t i;

  if (Msg->Len < 2) return 0;
 800a496:	6803      	ldr	r3, [r0, #0]
 800a498:	2b01      	cmp	r3, #1
 800a49a:	d902      	bls.n	800a4a2 <HandleMSG+0xe>
  if (Msg->Data[0] != DEV_ADDR) return 0;
 800a49c:	7902      	ldrb	r2, [r0, #4]
 800a49e:	2a32      	cmp	r2, #50	; 0x32
 800a4a0:	d001      	beq.n	800a4a6 <HandleMSG+0x12>
  if (Msg->Len < 2) return 0;
 800a4a2:	2000      	movs	r0, #0
      return 1;

    default:
      return 0;
  }
}
 800a4a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  switch (Msg->Data[2])   // CMD
 800a4a6:	7982      	ldrb	r2, [r0, #6]
 800a4a8:	3a01      	subs	r2, #1
 800a4aa:	4604      	mov	r4, r0
 800a4ac:	2a4f      	cmp	r2, #79	; 0x4f
 800a4ae:	d8f8      	bhi.n	800a4a2 <HandleMSG+0xe>
 800a4b0:	a101      	add	r1, pc, #4	; (adr r1, 800a4b8 <HandleMSG+0x24>)
 800a4b2:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
 800a4b6:	bf00      	nop
 800a4b8:	0800a607 	.word	0x0800a607
 800a4bc:	0800a623 	.word	0x0800a623
 800a4c0:	0800a4a3 	.word	0x0800a4a3
 800a4c4:	0800a699 	.word	0x0800a699
 800a4c8:	0800a4a3 	.word	0x0800a4a3
 800a4cc:	0800a4a3 	.word	0x0800a4a3
 800a4d0:	0800a4a3 	.word	0x0800a4a3
 800a4d4:	0800a6c3 	.word	0x0800a6c3
 800a4d8:	0800a6fb 	.word	0x0800a6fb
 800a4dc:	0800a4a3 	.word	0x0800a4a3
 800a4e0:	0800a4a3 	.word	0x0800a4a3
 800a4e4:	0800a721 	.word	0x0800a721
 800a4e8:	0800a4a3 	.word	0x0800a4a3
 800a4ec:	0800a74b 	.word	0x0800a74b
 800a4f0:	0800a4a3 	.word	0x0800a4a3
 800a4f4:	0800a4a3 	.word	0x0800a4a3
 800a4f8:	0800a4a3 	.word	0x0800a4a3
 800a4fc:	0800a4a3 	.word	0x0800a4a3
 800a500:	0800a4a3 	.word	0x0800a4a3
 800a504:	0800a4a3 	.word	0x0800a4a3
 800a508:	0800a4a3 	.word	0x0800a4a3
 800a50c:	0800a4a3 	.word	0x0800a4a3
 800a510:	0800a4a3 	.word	0x0800a4a3
 800a514:	0800a4a3 	.word	0x0800a4a3
 800a518:	0800a4a3 	.word	0x0800a4a3
 800a51c:	0800a4a3 	.word	0x0800a4a3
 800a520:	0800a4a3 	.word	0x0800a4a3
 800a524:	0800a4a3 	.word	0x0800a4a3
 800a528:	0800a4a3 	.word	0x0800a4a3
 800a52c:	0800a4a3 	.word	0x0800a4a3
 800a530:	0800a4a3 	.word	0x0800a4a3
 800a534:	0800a4a3 	.word	0x0800a4a3
 800a538:	0800a4a3 	.word	0x0800a4a3
 800a53c:	0800a4a3 	.word	0x0800a4a3
 800a540:	0800a4a3 	.word	0x0800a4a3
 800a544:	0800a4a3 	.word	0x0800a4a3
 800a548:	0800a4a3 	.word	0x0800a4a3
 800a54c:	0800a4a3 	.word	0x0800a4a3
 800a550:	0800a4a3 	.word	0x0800a4a3
 800a554:	0800a4a3 	.word	0x0800a4a3
 800a558:	0800a4a3 	.word	0x0800a4a3
 800a55c:	0800a4a3 	.word	0x0800a4a3
 800a560:	0800a4a3 	.word	0x0800a4a3
 800a564:	0800a4a3 	.word	0x0800a4a3
 800a568:	0800a4a3 	.word	0x0800a4a3
 800a56c:	0800a4a3 	.word	0x0800a4a3
 800a570:	0800a4a3 	.word	0x0800a4a3
 800a574:	0800a4a3 	.word	0x0800a4a3
 800a578:	0800a4a3 	.word	0x0800a4a3
 800a57c:	0800a4a3 	.word	0x0800a4a3
 800a580:	0800a4a3 	.word	0x0800a4a3
 800a584:	0800a4a3 	.word	0x0800a4a3
 800a588:	0800a4a3 	.word	0x0800a4a3
 800a58c:	0800a4a3 	.word	0x0800a4a3
 800a590:	0800a4a3 	.word	0x0800a4a3
 800a594:	0800a4a3 	.word	0x0800a4a3
 800a598:	0800a4a3 	.word	0x0800a4a3
 800a59c:	0800a4a3 	.word	0x0800a4a3
 800a5a0:	0800a4a3 	.word	0x0800a4a3
 800a5a4:	0800a4a3 	.word	0x0800a4a3
 800a5a8:	0800a4a3 	.word	0x0800a4a3
 800a5ac:	0800a4a3 	.word	0x0800a4a3
 800a5b0:	0800a4a3 	.word	0x0800a4a3
 800a5b4:	0800a4a3 	.word	0x0800a4a3
 800a5b8:	0800a4a3 	.word	0x0800a4a3
 800a5bc:	0800a4a3 	.word	0x0800a4a3
 800a5c0:	0800a4a3 	.word	0x0800a4a3
 800a5c4:	0800a4a3 	.word	0x0800a4a3
 800a5c8:	0800a4a3 	.word	0x0800a4a3
 800a5cc:	0800a4a3 	.word	0x0800a4a3
 800a5d0:	0800a4a3 	.word	0x0800a4a3
 800a5d4:	0800a4a3 	.word	0x0800a4a3
 800a5d8:	0800a4a3 	.word	0x0800a4a3
 800a5dc:	0800a4a3 	.word	0x0800a4a3
 800a5e0:	0800a4a3 	.word	0x0800a4a3
 800a5e4:	0800a4a3 	.word	0x0800a4a3
 800a5e8:	0800a4a3 	.word	0x0800a4a3
 800a5ec:	0800a4a3 	.word	0x0800a4a3
 800a5f0:	0800a4a3 	.word	0x0800a4a3
 800a5f4:	0800a5f9 	.word	0x0800a5f9
      if (Msg->Len < 5) return 0;
 800a5f8:	2b04      	cmp	r3, #4
 800a5fa:	f67f af52 	bls.w	800a4a2 <HandleMSG+0xe>
      Handle_Sensor_command(Msg);
 800a5fe:	f001 fc49 	bl	800be94 <Handle_Sensor_command>
      return 1;
 800a602:	2001      	movs	r0, #1
 800a604:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (Msg->Len != 3) return 0;
 800a606:	2b03      	cmp	r3, #3
 800a608:	f47f af4b 	bne.w	800a4a2 <HandleMSG+0xe>
  Msg->Data[0] = Msg->Data[1];
 800a60c:	7941      	ldrb	r1, [r0, #5]
      Msg->Len = 3;
 800a60e:	6003      	str	r3, [r0, #0]
  Msg->Data[1] = DEV_ADDR;
 800a610:	2232      	movs	r2, #50	; 0x32
  Msg->Data[2] += CMD_Reply_Add;
 800a612:	2381      	movs	r3, #129	; 0x81
  Msg->Data[0] = Msg->Data[1];
 800a614:	7101      	strb	r1, [r0, #4]
  Msg->Data[1] = DEV_ADDR;
 800a616:	7142      	strb	r2, [r0, #5]
  Msg->Data[2] += CMD_Reply_Add;
 800a618:	7183      	strb	r3, [r0, #6]
      UART_SendMsg(Msg);
 800a61a:	f000 f92d 	bl	800a878 <UART_SendMsg>
      return 1;
 800a61e:	2001      	movs	r0, #1
 800a620:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (Msg->Len != 3) return 0;
 800a622:	2b03      	cmp	r3, #3
 800a624:	f47f af3d 	bne.w	800a4a2 <HandleMSG+0xe>
 800a628:	4a53      	ldr	r2, [pc, #332]	; (800a778 <HandleMSG+0x2e4>)
  Msg->Data[0] = Msg->Data[1];
 800a62a:	7943      	ldrb	r3, [r0, #5]
 800a62c:	7103      	strb	r3, [r0, #4]
 800a62e:	f102 0108 	add.w	r1, r2, #8
 800a632:	1de3      	adds	r3, r4, #7
  Msg->Data[1] = DEV_ADDR;
 800a634:	2532      	movs	r5, #50	; 0x32
  Msg->Data[2] += CMD_Reply_Add;
 800a636:	2082      	movs	r0, #130	; 0x82
 800a638:	428b      	cmp	r3, r1
 800a63a:	f102 0604 	add.w	r6, r2, #4
  Msg->Data[1] = DEV_ADDR;
 800a63e:	7165      	strb	r5, [r4, #5]
  Msg->Data[2] += CMD_Reply_Add;
 800a640:	71a0      	strb	r0, [r4, #6]
 800a642:	d204      	bcs.n	800a64e <HandleMSG+0x1ba>
 800a644:	f104 030b 	add.w	r3, r4, #11
 800a648:	42b3      	cmp	r3, r6
 800a64a:	f200 808a 	bhi.w	800a762 <HandleMSG+0x2ce>
        Msg->Data[3 + i] = PresentationString[i];
 800a64e:	6853      	ldr	r3, [r2, #4]
 800a650:	f8c4 3007 	str.w	r3, [r4, #7]
 800a654:	6893      	ldr	r3, [r2, #8]
 800a656:	f8c4 300b 	str.w	r3, [r4, #11]
 800a65a:	68d3      	ldr	r3, [r2, #12]
 800a65c:	f8c4 300f 	str.w	r3, [r4, #15]
 800a660:	6913      	ldr	r3, [r2, #16]
 800a662:	f8c4 3013 	str.w	r3, [r4, #19]
 800a666:	6953      	ldr	r3, [r2, #20]
 800a668:	f8c4 3017 	str.w	r3, [r4, #23]
 800a66c:	6993      	ldr	r3, [r2, #24]
 800a66e:	f8c4 301b 	str.w	r3, [r4, #27]
 800a672:	69d3      	ldr	r3, [r2, #28]
 800a674:	f8c4 301f 	str.w	r3, [r4, #31]
 800a678:	6a13      	ldr	r3, [r2, #32]
 800a67a:	f8c4 3023 	str.w	r3, [r4, #35]	; 0x23
 800a67e:	6a53      	ldr	r3, [r2, #36]	; 0x24
 800a680:	f8c4 3027 	str.w	r3, [r4, #39]	; 0x27
 800a684:	6a93      	ldr	r3, [r2, #40]	; 0x28
 800a686:	f8c4 302b 	str.w	r3, [r4, #43]	; 0x2b
      Msg->Len = 3 + i;
 800a68a:	232b      	movs	r3, #43	; 0x2b
      UART_SendMsg(Msg);
 800a68c:	4620      	mov	r0, r4
      Msg->Len = 3 + i;
 800a68e:	6023      	str	r3, [r4, #0]
      UART_SendMsg(Msg);
 800a690:	f000 f8f2 	bl	800a878 <UART_SendMsg>
      return 1;
 800a694:	2001      	movs	r0, #1
 800a696:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (Msg->Len < 3) return 0;
 800a698:	2b02      	cmp	r3, #2
 800a69a:	f43f af02 	beq.w	800a4a2 <HandleMSG+0xe>
  Msg->Data[0] = Msg->Data[1];
 800a69e:	7943      	ldrb	r3, [r0, #5]
 800a6a0:	7103      	strb	r3, [r0, #4]
  Msg->Data[1] = DEV_ADDR;
 800a6a2:	2232      	movs	r2, #50	; 0x32
  Msg->Data[2] += CMD_Reply_Add;
 800a6a4:	2384      	movs	r3, #132	; 0x84
  Msg->Data[1] = DEV_ADDR;
 800a6a6:	7142      	strb	r2, [r0, #5]
  Msg->Data[2] += CMD_Reply_Add;
 800a6a8:	7183      	strb	r3, [r0, #6]
      Serialize_s32(&Msg->Data[3], DATALOG_EXT_MODE, 4);
 800a6aa:	2204      	movs	r2, #4
 800a6ac:	2165      	movs	r1, #101	; 0x65
 800a6ae:	3007      	adds	r0, #7
 800a6b0:	f001 fd68 	bl	800c184 <Serialize_s32>
      Msg->Len = 3 + 4;
 800a6b4:	2307      	movs	r3, #7
      UART_SendMsg(Msg);
 800a6b6:	4620      	mov	r0, r4
      Msg->Len = 3 + 4;
 800a6b8:	6023      	str	r3, [r4, #0]
      UART_SendMsg(Msg);
 800a6ba:	f000 f8dd 	bl	800a878 <UART_SendMsg>
      return 1;
 800a6be:	2001      	movs	r0, #1
 800a6c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (Msg->Len < 3) return 0;
 800a6c2:	2b02      	cmp	r3, #2
 800a6c4:	f43f aeed 	beq.w	800a4a2 <HandleMSG+0xe>
      Sensors_Enabled = Deserialize(&Msg->Data[3], 4);
 800a6c8:	2104      	movs	r1, #4
 800a6ca:	3007      	adds	r0, #7
 800a6cc:	f001 fd4e 	bl	800c16c <Deserialize>
  Msg->Data[2] += CMD_Reply_Add;
 800a6d0:	79a3      	ldrb	r3, [r4, #6]
      Sensors_Enabled = Deserialize(&Msg->Data[3], 4);
 800a6d2:	492a      	ldr	r1, [pc, #168]	; (800a77c <HandleMSG+0x2e8>)
      DataLoggerActive = 1;
 800a6d4:	4f2a      	ldr	r7, [pc, #168]	; (800a780 <HandleMSG+0x2ec>)
      DataStreamingDest = Msg->Data[1];
 800a6d6:	4e28      	ldr	r6, [pc, #160]	; (800a778 <HandleMSG+0x2e4>)
      Sensors_Enabled = Deserialize(&Msg->Data[3], 4);
 800a6d8:	6008      	str	r0, [r1, #0]
      DataStreamingDest = Msg->Data[1];
 800a6da:	7962      	ldrb	r2, [r4, #5]
  Msg->Data[0] = Msg->Data[1];
 800a6dc:	7122      	strb	r2, [r4, #4]
      DataLoggerActive = 1;
 800a6de:	2501      	movs	r5, #1
  Msg->Data[2] += CMD_Reply_Add;
 800a6e0:	3b80      	subs	r3, #128	; 0x80
      Msg->Len = 3;
 800a6e2:	2103      	movs	r1, #3
  Msg->Data[1] = DEV_ADDR;
 800a6e4:	2032      	movs	r0, #50	; 0x32
      DataLoggerActive = 1;
 800a6e6:	703d      	strb	r5, [r7, #0]
  Msg->Data[1] = DEV_ADDR;
 800a6e8:	7160      	strb	r0, [r4, #5]
      DataStreamingDest = Msg->Data[1];
 800a6ea:	7032      	strb	r2, [r6, #0]
      UART_SendMsg(Msg);
 800a6ec:	4620      	mov	r0, r4
  Msg->Data[2] += CMD_Reply_Add;
 800a6ee:	71a3      	strb	r3, [r4, #6]
      Msg->Len = 3;
 800a6f0:	6021      	str	r1, [r4, #0]
      UART_SendMsg(Msg);
 800a6f2:	f000 f8c1 	bl	800a878 <UART_SendMsg>
      return 1;
 800a6f6:	4628      	mov	r0, r5
 800a6f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (Msg->Len < 3) return 0;
 800a6fa:	2b02      	cmp	r3, #2
 800a6fc:	f43f aed1 	beq.w	800a4a2 <HandleMSG+0xe>
  Msg->Data[0] = Msg->Data[1];
 800a700:	7943      	ldrb	r3, [r0, #5]
 800a702:	7103      	strb	r3, [r0, #4]
      Sensors_Enabled = 0;
 800a704:	491d      	ldr	r1, [pc, #116]	; (800a77c <HandleMSG+0x2e8>)
      DataLoggerActive = 0;
 800a706:	4a1e      	ldr	r2, [pc, #120]	; (800a780 <HandleMSG+0x2ec>)
  Msg->Data[1] = DEV_ADDR;
 800a708:	2532      	movs	r5, #50	; 0x32
  Msg->Data[2] += CMD_Reply_Add;
 800a70a:	2089      	movs	r0, #137	; 0x89
      Sensors_Enabled = 0;
 800a70c:	2300      	movs	r3, #0
  Msg->Data[2] += CMD_Reply_Add;
 800a70e:	71a0      	strb	r0, [r4, #6]
  Msg->Data[1] = DEV_ADDR;
 800a710:	7165      	strb	r5, [r4, #5]
      UART_SendMsg(Msg);
 800a712:	4620      	mov	r0, r4
      Sensors_Enabled = 0;
 800a714:	600b      	str	r3, [r1, #0]
      DataLoggerActive = 0;
 800a716:	7013      	strb	r3, [r2, #0]
      UART_SendMsg(Msg);
 800a718:	f000 f8ae 	bl	800a878 <UART_SendMsg>
      return 1;
 800a71c:	2001      	movs	r0, #1
 800a71e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (Msg->Len < 3) return 0;
 800a720:	2b02      	cmp	r3, #2
 800a722:	f43f aebe 	beq.w	800a4a2 <HandleMSG+0xe>
  Msg->Data[0] = Msg->Data[1];
 800a726:	7943      	ldrb	r3, [r0, #5]
 800a728:	7103      	strb	r3, [r0, #4]
  Msg->Data[1] = DEV_ADDR;
 800a72a:	2132      	movs	r1, #50	; 0x32
      Msg->Len = 3;
 800a72c:	2303      	movs	r3, #3
  Msg->Data[2] += CMD_Reply_Add;
 800a72e:	228c      	movs	r2, #140	; 0x8c
      Msg->Len = 3;
 800a730:	6003      	str	r3, [r0, #0]
  Msg->Data[1] = DEV_ADDR;
 800a732:	7141      	strb	r1, [r0, #5]
  Msg->Data[2] += CMD_Reply_Add;
 800a734:	7182      	strb	r2, [r0, #6]
      RTC_TimeRegulate(Msg->Data[3], Msg->Data[4], Msg->Data[5]);
 800a736:	7a01      	ldrb	r1, [r0, #8]
 800a738:	7a42      	ldrb	r2, [r0, #9]
 800a73a:	79c0      	ldrb	r0, [r0, #7]
 800a73c:	f000 fe4c 	bl	800b3d8 <RTC_TimeRegulate>
      UART_SendMsg(Msg);
 800a740:	4620      	mov	r0, r4
 800a742:	f000 f899 	bl	800a878 <UART_SendMsg>
      return 1;
 800a746:	2001      	movs	r0, #1
 800a748:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (Msg->Len != 3) return 0;
 800a74a:	2b03      	cmp	r3, #3
 800a74c:	f47f aea9 	bne.w	800a4a2 <HandleMSG+0xe>
  Msg->Data[0] = Msg->Data[1];
 800a750:	7941      	ldrb	r1, [r0, #5]
      Msg->Len = 3;
 800a752:	6003      	str	r3, [r0, #0]
  Msg->Data[1] = DEV_ADDR;
 800a754:	2232      	movs	r2, #50	; 0x32
  Msg->Data[2] += CMD_Reply_Add;
 800a756:	238e      	movs	r3, #142	; 0x8e
  Msg->Data[0] = Msg->Data[1];
 800a758:	7101      	strb	r1, [r0, #4]
  Msg->Data[1] = DEV_ADDR;
 800a75a:	7142      	strb	r2, [r0, #5]
  Msg->Data[2] += CMD_Reply_Add;
 800a75c:	7183      	strb	r3, [r0, #6]
      return 1;
 800a75e:	2001      	movs	r0, #1
 800a760:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a762:	1cd3      	adds	r3, r2, #3
 800a764:	1da1      	adds	r1, r4, #6
 800a766:	322b      	adds	r2, #43	; 0x2b
        Msg->Data[3 + i] = PresentationString[i];
 800a768:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 800a76c:	f801 0f01 	strb.w	r0, [r1, #1]!
      while (i < (sizeof(PresentationString) - 1))
 800a770:	4293      	cmp	r3, r2
 800a772:	d1f9      	bne.n	800a768 <HandleMSG+0x2d4>
 800a774:	e789      	b.n	800a68a <HandleMSG+0x1f6>
 800a776:	bf00      	nop
 800a778:	200003a8 	.word	0x200003a8
 800a77c:	20000718 	.word	0x20000718
 800a780:	2000076c 	.word	0x2000076c

0800a784 <UART_ReceivedMSG>:
  * @brief  Check if a message is received via UART
  * @param  Msg the pointer to the message to be received
  * @retval 1 if a complete message is found, 0 otherwise
  */
int UART_ReceivedMSG(TMsg *Msg)
{
 800a784:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a788:	4681      	mov	r9, r0
 800a78a:	b083      	sub	sp, #12
  uint16_t DmaCounter, length;
  uint8_t Data;
  uint16_t source = 0;
  uint8_t inc = 0;

  if(Get_DMA_Flag_Status(&hdma_rx) == RESET)
 800a78c:	4837      	ldr	r0, [pc, #220]	; (800a86c <UART_ReceivedMSG+0xe8>)
 800a78e:	f000 f947 	bl	800aa20 <Get_DMA_Flag_Status>
 800a792:	b118      	cbz	r0, 800a79c <UART_ReceivedMSG+0x18>
    if (length > Uart_Msg_Max_Size)
    {
      Uart_Engine.StartOfMsg = DmaCounter;
    }
  }
  return 0;
 800a794:	2000      	movs	r0, #0
}
 800a796:	b003      	add	sp, #12
 800a798:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    DmaCounter = UART_RxBufferSize - Get_DMA_Counter(&hdma_rx);
 800a79c:	4833      	ldr	r0, [pc, #204]	; (800a86c <UART_ReceivedMSG+0xe8>)
 800a79e:	f000 f9a5 	bl	800aaec <Get_DMA_Counter>
    if (DmaCounter >= Uart_Engine.StartOfMsg)
 800a7a2:	4b33      	ldr	r3, [pc, #204]	; (800a870 <UART_ReceivedMSG+0xec>)
    DmaCounter = UART_RxBufferSize - Get_DMA_Counter(&hdma_rx);
 800a7a4:	f5c0 7000 	rsb	r0, r0, #512	; 0x200
    if (DmaCounter >= Uart_Engine.StartOfMsg)
 800a7a8:	889c      	ldrh	r4, [r3, #4]
    DmaCounter = UART_RxBufferSize - Get_DMA_Counter(&hdma_rx);
 800a7aa:	b283      	uxth	r3, r0
    if (DmaCounter >= Uart_Engine.StartOfMsg)
 800a7ac:	42a3      	cmp	r3, r4
      length = UART_RxBufferSize + DmaCounter - Uart_Engine.StartOfMsg;
 800a7ae:	bf36      	itet	cc
 800a7b0:	f5c4 7b00 	rsbcc	fp, r4, #512	; 0x200
      length = DmaCounter - Uart_Engine.StartOfMsg;
 800a7b4:	eba3 0b04 	subcs.w	fp, r3, r4
      length = UART_RxBufferSize + DmaCounter - Uart_Engine.StartOfMsg;
 800a7b8:	449b      	addcc	fp, r3
    DmaCounter = UART_RxBufferSize - Get_DMA_Counter(&hdma_rx);
 800a7ba:	9301      	str	r3, [sp, #4]
      length = UART_RxBufferSize + DmaCounter - Uart_Engine.StartOfMsg;
 800a7bc:	fa1f f38b 	uxth.w	r3, fp
 800a7c0:	9300      	str	r3, [sp, #0]
    for (k = 0; k < length; k++)
 800a7c2:	2b00      	cmp	r3, #0
 800a7c4:	d0e6      	beq.n	800a794 <UART_ReceivedMSG+0x10>
 800a7c6:	f04f 0a00 	mov.w	sl, #0
 800a7ca:	f8df b0a8 	ldr.w	fp, [pc, #168]	; 800a874 <UART_ReceivedMSG+0xf0>
 800a7ce:	4655      	mov	r5, sl
 800a7d0:	46d0      	mov	r8, sl
 800a7d2:	4656      	mov	r6, sl
 800a7d4:	e005      	b.n	800a7e2 <UART_ReceivedMSG+0x5e>
 800a7d6:	3601      	adds	r6, #1
 800a7d8:	9b00      	ldr	r3, [sp, #0]
 800a7da:	fa1f f886 	uxth.w	r8, r6
 800a7de:	4543      	cmp	r3, r8
 800a7e0:	d93b      	bls.n	800a85a <UART_ReceivedMSG+0xd6>
      j++;
 800a7e2:	1c62      	adds	r2, r4, #1
      Data = UART_RxBuffer[j];
 800a7e4:	f81b 3004 	ldrb.w	r3, [fp, r4]
      j++;
 800a7e8:	b294      	uxth	r4, r2
        j = 0;
 800a7ea:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
 800a7ee:	bf28      	it	cs
 800a7f0:	2400      	movcs	r4, #0
      if (Data == TMsg_EOF)
 800a7f2:	2bf0      	cmp	r3, #240	; 0xf0
 800a7f4:	d1ef      	bne.n	800a7d6 <UART_ReceivedMSG+0x52>
        j = Uart_Engine.StartOfMsg;
 800a7f6:	4b1e      	ldr	r3, [pc, #120]	; (800a870 <UART_ReceivedMSG+0xec>)
 800a7f8:	889c      	ldrh	r4, [r3, #4]
        for (i = 0; i < k; i += inc)
 800a7fa:	b306      	cbz	r6, 800a83e <UART_ReceivedMSG+0xba>
 800a7fc:	2700      	movs	r7, #0
 800a7fe:	e001      	b.n	800a804 <UART_ReceivedMSG+0x80>
 800a800:	4547      	cmp	r7, r8
 800a802:	d21c      	bcs.n	800a83e <UART_ReceivedMSG+0xba>
          j2 = (j + 1) % UART_RxBufferSize;
 800a804:	f104 0a01 	add.w	sl, r4, #1
 800a808:	f3ca 0a08 	ubfx	sl, sl, #0, #9
          Dest    = &Msg->Data[source];
 800a80c:	1d2a      	adds	r2, r5, #4
          Source0 = UART_RxBuffer[j];
 800a80e:	f81b 0004 	ldrb.w	r0, [fp, r4]
          Source1 = UART_RxBuffer[j2];
 800a812:	f81b 100a 	ldrb.w	r1, [fp, sl]
          inc = ReverseByteStuffCopyByte2( Source0, Source1, Dest );
 800a816:	444a      	add	r2, r9
 800a818:	f001 fbb8 	bl	800bf8c <ReverseByteStuffCopyByte2>
 800a81c:	b2c0      	uxtb	r0, r0
          j = (j + inc) % UART_RxBufferSize;
 800a81e:	b283      	uxth	r3, r0
        for (i = 0; i < k; i += inc)
 800a820:	441f      	add	r7, r3
          source++;
 800a822:	3501      	adds	r5, #1
          j = (j + inc) % UART_RxBufferSize;
 800a824:	4423      	add	r3, r4
        for (i = 0; i < k; i += inc)
 800a826:	b2bf      	uxth	r7, r7
          j = (j + inc) % UART_RxBufferSize;
 800a828:	f3c3 0408 	ubfx	r4, r3, #0, #9
          source++;
 800a82c:	b2ad      	uxth	r5, r5
          if (inc == 0)
 800a82e:	2800      	cmp	r0, #0
 800a830:	d1e6      	bne.n	800a800 <UART_ReceivedMSG+0x7c>
          j2 = (j + 1) % UART_RxBufferSize;
 800a832:	4b0f      	ldr	r3, [pc, #60]	; (800a870 <UART_ReceivedMSG+0xec>)
 800a834:	f8a3 a004 	strh.w	sl, [r3, #4]
}
 800a838:	b003      	add	sp, #12
 800a83a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        j = (j + 1) % UART_RxBufferSize; // skip TMsg_EOF
 800a83e:	3401      	adds	r4, #1
        Uart_Engine.StartOfMsg = j;
 800a840:	4b0b      	ldr	r3, [pc, #44]	; (800a870 <UART_ReceivedMSG+0xec>)
        Msg->Len = source;
 800a842:	f8c9 5000 	str.w	r5, [r9]
        j = (j + 1) % UART_RxBufferSize; // skip TMsg_EOF
 800a846:	f3c4 0408 	ubfx	r4, r4, #0, #9
        if (CHK_CheckAndRemove(Msg))   // check message integrity
 800a84a:	4648      	mov	r0, r9
        Uart_Engine.StartOfMsg = j;
 800a84c:	809c      	strh	r4, [r3, #4]
        if (CHK_CheckAndRemove(Msg))   // check message integrity
 800a84e:	f001 fc1d 	bl	800c08c <CHK_CheckAndRemove>
 800a852:	2800      	cmp	r0, #0
 800a854:	d0bf      	beq.n	800a7d6 <UART_ReceivedMSG+0x52>
          return 1;
 800a856:	2001      	movs	r0, #1
 800a858:	e79d      	b.n	800a796 <UART_ReceivedMSG+0x12>
    if (length > Uart_Msg_Max_Size)
 800a85a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800a85e:	d999      	bls.n	800a794 <UART_ReceivedMSG+0x10>
      Uart_Engine.StartOfMsg = DmaCounter;
 800a860:	4b03      	ldr	r3, [pc, #12]	; (800a870 <UART_ReceivedMSG+0xec>)
 800a862:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 800a866:	809a      	strh	r2, [r3, #4]
 800a868:	e794      	b.n	800a794 <UART_ReceivedMSG+0x10>
 800a86a:	bf00      	nop
 800a86c:	20000770 	.word	0x20000770
 800a870:	200007d0 	.word	0x200007d0
 800a874:	20000878 	.word	0x20000878

0800a878 <UART_SendMsg>:
  * @brief  Send a message via UART
  * @param  Msg the pointer to the message to be sent
  * @retval None
  */
void UART_SendMsg(TMsg *Msg)
{
 800a878:	b570      	push	{r4, r5, r6, lr}
  uint16_t CountOut;

  CHK_ComputeAndAdd(Msg);

  CountOut = ByteStuffCopy((uint8_t*) UART_TxBuffer, Msg);
 800a87a:	4c08      	ldr	r4, [pc, #32]	; (800a89c <UART_SendMsg+0x24>)
{
 800a87c:	4605      	mov	r5, r0
  CHK_ComputeAndAdd(Msg);
 800a87e:	f001 fb97 	bl	800bfb0 <CHK_ComputeAndAdd>
  CountOut = ByteStuffCopy((uint8_t*) UART_TxBuffer, Msg);
 800a882:	4629      	mov	r1, r5
 800a884:	4620      	mov	r0, r4
 800a886:	f001 fb51 	bl	800bf2c <ByteStuffCopy>

  HAL_UART_Transmit(&UartHandle, (uint8_t*)UART_TxBuffer, CountOut, 5000);
 800a88a:	4621      	mov	r1, r4
 800a88c:	b282      	uxth	r2, r0
 800a88e:	f241 3388 	movw	r3, #5000	; 0x1388
 800a892:	4803      	ldr	r0, [pc, #12]	; (800a8a0 <UART_SendMsg+0x28>)
}
 800a894:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  HAL_UART_Transmit(&UartHandle, (uint8_t*)UART_TxBuffer, CountOut, 5000);
 800a898:	f7ff bc98 	b.w	800a1cc <HAL_UART_Transmit>
 800a89c:	20000a78 	.word	0x20000a78
 800a8a0:	200007d8 	.word	0x200007d8

0800a8a4 <USART_DMA_Configuration>:
 * @brief  Configure DMA for the reception via USART
 * @param  None
 * @retval None
 */
void USART_DMA_Configuration(void)
{
 800a8a4:	b510      	push	{r4, lr}
  Config_DMA_Handler(&hdma_rx);
 800a8a6:	4c05      	ldr	r4, [pc, #20]	; (800a8bc <USART_DMA_Configuration+0x18>)
 800a8a8:	4620      	mov	r0, r4
 800a8aa:	f000 f923 	bl	800aaf4 <Config_DMA_Handler>

  HAL_DMA_Init(&hdma_rx);
 800a8ae:	4620      	mov	r0, r4
 800a8b0:	f7fd fe7e 	bl	80085b0 <HAL_DMA_Init>

  /* Associate the initialized DMA handle to the the UART handle */
  __HAL_LINKDMA(&UartHandle, hdmarx, hdma_rx);
 800a8b4:	4b02      	ldr	r3, [pc, #8]	; (800a8c0 <USART_DMA_Configuration+0x1c>)
 800a8b6:	63a3      	str	r3, [r4, #56]	; 0x38
 800a8b8:	635c      	str	r4, [r3, #52]	; 0x34
 800a8ba:	bd10      	pop	{r4, pc}
 800a8bc:	20000770 	.word	0x20000770
 800a8c0:	200007d8 	.word	0x200007d8

0800a8c4 <USARTConfig>:
 * @brief  Configure the USART
 * @param  None
 * @retval None
 */
void USARTConfig(void)
{
 800a8c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a8c6:	b08b      	sub	sp, #44	; 0x2c
  GPIO_InitTypeDef GPIO_InitStruct;

  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* Enable GPIO TX/RX clock */
  USARTx_TX_GPIO_CLK_ENABLE();
 800a8c8:	4b2e      	ldr	r3, [pc, #184]	; (800a984 <USARTConfig+0xc0>)
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Alternate = USARTx_TX_AF;

  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);
 800a8ca:	482f      	ldr	r0, [pc, #188]	; (800a988 <USARTConfig+0xc4>)
  HAL_GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStruct);


  /*##-1- Configure the UART peripheral ######################################*/
  /* Put the USART peripheral in the Asynchronous mode (UART Mode) */
  UartHandle.Instance        = USARTx;
 800a8cc:	4c2f      	ldr	r4, [pc, #188]	; (800a98c <USARTConfig+0xc8>)
  USARTx_TX_GPIO_CLK_ENABLE();
 800a8ce:	2500      	movs	r5, #0
 800a8d0:	9501      	str	r5, [sp, #4]
 800a8d2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a8d4:	f042 0201 	orr.w	r2, r2, #1
 800a8d8:	631a      	str	r2, [r3, #48]	; 0x30
 800a8da:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a8dc:	f002 0201 	and.w	r2, r2, #1
 800a8e0:	9201      	str	r2, [sp, #4]
 800a8e2:	9a01      	ldr	r2, [sp, #4]
  USARTx_RX_GPIO_CLK_ENABLE();
 800a8e4:	9502      	str	r5, [sp, #8]
 800a8e6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a8e8:	f042 0201 	orr.w	r2, r2, #1
 800a8ec:	631a      	str	r2, [r3, #48]	; 0x30
 800a8ee:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a8f0:	f002 0201 	and.w	r2, r2, #1
 800a8f4:	9202      	str	r2, [sp, #8]
 800a8f6:	9a02      	ldr	r2, [sp, #8]
  USARTx_CLK_ENABLE();
 800a8f8:	9503      	str	r5, [sp, #12]
 800a8fa:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800a8fc:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800a900:	641a      	str	r2, [r3, #64]	; 0x40
 800a902:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800a904:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 800a908:	9203      	str	r2, [sp, #12]
 800a90a:	9a03      	ldr	r2, [sp, #12]
  DMAx_CLK_ENABLE();
 800a90c:	9504      	str	r5, [sp, #16]
 800a90e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a910:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800a914:	631a      	str	r2, [r3, #48]	; 0x30
 800a916:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
 800a918:	9507      	str	r5, [sp, #28]
  DMAx_CLK_ENABLE();
 800a91a:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
  GPIO_InitStruct.Pin       = USARTx_TX_PIN;
 800a91e:	2204      	movs	r2, #4
  DMAx_CLK_ENABLE();
 800a920:	9304      	str	r3, [sp, #16]
  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);
 800a922:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 800a924:	2302      	movs	r3, #2
  GPIO_InitStruct.Alternate = USARTx_TX_AF;
 800a926:	2607      	movs	r6, #7
  GPIO_InitStruct.Pin       = USARTx_TX_PIN;
 800a928:	9205      	str	r2, [sp, #20]
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 800a92a:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_HIGH;
 800a92c:	9308      	str	r3, [sp, #32]
  DMAx_CLK_ENABLE();
 800a92e:	9f04      	ldr	r7, [sp, #16]
  GPIO_InitStruct.Alternate = USARTx_TX_AF;
 800a930:	9609      	str	r6, [sp, #36]	; 0x24
  HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);
 800a932:	f7fd ff19 	bl	8008768 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = USARTx_RX_PIN;
 800a936:	2308      	movs	r3, #8
  HAL_GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStruct);
 800a938:	4813      	ldr	r0, [pc, #76]	; (800a988 <USARTConfig+0xc4>)
  GPIO_InitStruct.Pin = USARTx_RX_PIN;
 800a93a:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStruct);
 800a93c:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Alternate = USARTx_RX_AF;
 800a93e:	9609      	str	r6, [sp, #36]	; 0x24
  HAL_GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStruct);
 800a940:	f7fd ff12 	bl	8008768 <HAL_GPIO_Init>
  UartHandle.Init.BaudRate   = Usart_BaudRate;
 800a944:	4b12      	ldr	r3, [pc, #72]	; (800a990 <USARTConfig+0xcc>)
  UartHandle.Instance        = USARTx;
 800a946:	4a13      	ldr	r2, [pc, #76]	; (800a994 <USARTConfig+0xd0>)
  UartHandle.Init.BaudRate   = Usart_BaudRate;
 800a948:	681b      	ldr	r3, [r3, #0]
 800a94a:	6063      	str	r3, [r4, #4]
  UartHandle.Init.StopBits   = UART_STOPBITS_1;
  UartHandle.Init.Parity     = UART_PARITY_NONE;
  UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
  UartHandle.Init.Mode       = UART_MODE_TX_RX;

  if(HAL_UART_Init(&UartHandle) != HAL_OK)
 800a94c:	4620      	mov	r0, r4
  UartHandle.Init.Mode       = UART_MODE_TX_RX;
 800a94e:	230c      	movs	r3, #12
  UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 800a950:	60a5      	str	r5, [r4, #8]
  UartHandle.Init.StopBits   = UART_STOPBITS_1;
 800a952:	60e5      	str	r5, [r4, #12]
  UartHandle.Init.Parity     = UART_PARITY_NONE;
 800a954:	6125      	str	r5, [r4, #16]
  UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
 800a956:	61a5      	str	r5, [r4, #24]
  UartHandle.Instance        = USARTx;
 800a958:	6022      	str	r2, [r4, #0]
  UartHandle.Init.Mode       = UART_MODE_TX_RX;
 800a95a:	6163      	str	r3, [r4, #20]
  if(HAL_UART_Init(&UartHandle) != HAL_OK)
 800a95c:	f7ff fc06 	bl	800a16c <HAL_UART_Init>
 800a960:	b100      	cbz	r0, 800a964 <USARTConfig+0xa0>
 800a962:	e7fe      	b.n	800a962 <USARTConfig+0x9e>
    while(1);
  }

  USART_DMA_Configuration();

  UartHandle.pRxBuffPtr = (uint8_t*)UART_RxBuffer;
 800a964:	4d0c      	ldr	r5, [pc, #48]	; (800a998 <USARTConfig+0xd4>)
 800a966:	4606      	mov	r6, r0
  USART_DMA_Configuration();
 800a968:	f7ff ff9c 	bl	800a8a4 <USART_DMA_Configuration>
  UartHandle.RxXferSize = UART_RxBufferSize;
 800a96c:	f44f 7300 	mov.w	r3, #512	; 0x200
  UartHandle.ErrorCode = HAL_UART_ERROR_NONE;

  /* Enable the DMA transfer for the receiver request by setting the DMAR bit
  in the UART CR3 register */
  HAL_UART_Receive_DMA(&UartHandle, (uint8_t*)UART_RxBuffer, UART_RxBufferSize);
 800a970:	4629      	mov	r1, r5
 800a972:	461a      	mov	r2, r3
 800a974:	4620      	mov	r0, r4
  UartHandle.ErrorCode = HAL_UART_ERROR_NONE;
 800a976:	63e6      	str	r6, [r4, #60]	; 0x3c
  UartHandle.pRxBuffPtr = (uint8_t*)UART_RxBuffer;
 800a978:	62a5      	str	r5, [r4, #40]	; 0x28
  UartHandle.RxXferSize = UART_RxBufferSize;
 800a97a:	85a3      	strh	r3, [r4, #44]	; 0x2c
  HAL_UART_Receive_DMA(&UartHandle, (uint8_t*)UART_RxBuffer, UART_RxBufferSize);
 800a97c:	f7ff fcaa 	bl	800a2d4 <HAL_UART_Receive_DMA>
}
 800a980:	b00b      	add	sp, #44	; 0x2c
 800a982:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a984:	40023800 	.word	0x40023800
 800a988:	40020000 	.word	0x40020000
 800a98c:	200007d8 	.word	0x200007d8
 800a990:	200003d8 	.word	0x200003d8
 800a994:	40004400 	.word	0x40004400
 800a998:	20000878 	.word	0x20000878

0800a99c <SystemClock_Config>:
 * @brief  System Clock Configuration
 * @param  None
 * @retval None
 */
void SystemClock_Config(void)
{
 800a99c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a99e:	b095      	sub	sp, #84	; 0x54
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;

  /* Enable Power Control clock */
  __PWR_CLK_ENABLE();
 800a9a0:	2400      	movs	r4, #0
 800a9a2:	4b1d      	ldr	r3, [pc, #116]	; (800aa18 <SystemClock_Config+0x7c>)
 800a9a4:	9401      	str	r4, [sp, #4]
 800a9a6:	6c19      	ldr	r1, [r3, #64]	; 0x40

  /* The voltage scaling allows optimizing the power consumption when the device is
  clocked below the maximum system frequency, to update the voltage scaling value
  regarding system frequency refer to product datasheet.  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
 800a9a8:	4a1c      	ldr	r2, [pc, #112]	; (800aa1c <SystemClock_Config+0x80>)
  __PWR_CLK_ENABLE();
 800a9aa:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 800a9ae:	6419      	str	r1, [r3, #64]	; 0x40
 800a9b0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800a9b2:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800a9b6:	9301      	str	r3, [sp, #4]
 800a9b8:	9b01      	ldr	r3, [sp, #4]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
 800a9ba:	9402      	str	r4, [sp, #8]
 800a9bc:	6813      	ldr	r3, [r2, #0]
 800a9be:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 800a9c2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a9c6:	6013      	str	r3, [r2, #0]
 800a9c8:	6813      	ldr	r3, [r2, #0]
  /* Enable HSE Oscillator and activate PLL with HSI as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 800a9ca:	940f      	str	r4, [sp, #60]	; 0x3c
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
 800a9cc:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 800a9d0:	2502      	movs	r5, #2
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
 800a9d2:	9302      	str	r3, [sp, #8]
  RCC_OscInitStruct.PLL.PLLM = 16;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
 800a9d4:	2104      	movs	r1, #4
  RCC_OscInitStruct.HSICalibrationValue = 16;
 800a9d6:	2310      	movs	r3, #16
  RCC_OscInitStruct.PLL.PLLQ = 7;
 800a9d8:	2207      	movs	r2, #7
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 800a9da:	2701      	movs	r7, #1
  RCC_OscInitStruct.PLL.PLLN = 336;
 800a9dc:	f44f 76a8 	mov.w	r6, #336	; 0x150
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 800a9e0:	a808      	add	r0, sp, #32
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
 800a9e2:	f8dd e008 	ldr.w	lr, [sp, #8]
  RCC_OscInitStruct.HSICalibrationValue = 16;
 800a9e6:	930c      	str	r3, [sp, #48]	; 0x30
  RCC_OscInitStruct.PLL.PLLM = 16;
 800a9e8:	9310      	str	r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
 800a9ea:	9112      	str	r1, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLQ = 7;
 800a9ec:	9213      	str	r2, [sp, #76]	; 0x4c
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 800a9ee:	9508      	str	r5, [sp, #32]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800a9f0:	950e      	str	r5, [sp, #56]	; 0x38
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 800a9f2:	970b      	str	r7, [sp, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLN = 336;
 800a9f4:	9611      	str	r6, [sp, #68]	; 0x44
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 800a9f6:	f7fe fcb1 	bl	800935c <HAL_RCC_OscConfig>

  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
    clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 800a9fa:	220f      	movs	r2, #15
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 800a9fc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
 800aa00:	4629      	mov	r1, r5
 800aa02:	a803      	add	r0, sp, #12
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800aa04:	9504      	str	r5, [sp, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800aa06:	9405      	str	r4, [sp, #20]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 800aa08:	9407      	str	r4, [sp, #28]
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 800aa0a:	9203      	str	r2, [sp, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 800aa0c:	9306      	str	r3, [sp, #24]
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
 800aa0e:	f7fe fe97 	bl	8009740 <HAL_RCC_ClockConfig>
}
 800aa12:	b015      	add	sp, #84	; 0x54
 800aa14:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800aa16:	bf00      	nop
 800aa18:	40023800 	.word	0x40023800
 800aa1c:	40007000 	.word	0x40007000

0800aa20 <Get_DMA_Flag_Status>:
 * @param  handle_dma DMA handle
 * @retval The state of FLAG (SET or RESET)
 */
uint32_t Get_DMA_Flag_Status(DMA_HandleTypeDef *handle_dma)
{
  return (__HAL_DMA_GET_FLAG(handle_dma, __HAL_DMA_GET_FE_FLAG_INDEX(handle_dma)));
 800aa20:	6803      	ldr	r3, [r0, #0]
 800aa22:	4a29      	ldr	r2, [pc, #164]	; (800aac8 <Get_DMA_Flag_Status+0xa8>)
 800aa24:	4293      	cmp	r3, r2
 800aa26:	d90f      	bls.n	800aa48 <Get_DMA_Flag_Status+0x28>
 800aa28:	4928      	ldr	r1, [pc, #160]	; (800aacc <Get_DMA_Flag_Status+0xac>)
 800aa2a:	3218      	adds	r2, #24
 800aa2c:	4293      	cmp	r3, r2
 800aa2e:	6849      	ldr	r1, [r1, #4]
 800aa30:	d041      	beq.n	800aab6 <Get_DMA_Flag_Status+0x96>
 800aa32:	3218      	adds	r2, #24
 800aa34:	4293      	cmp	r3, r2
 800aa36:	d043      	beq.n	800aac0 <Get_DMA_Flag_Status+0xa0>
 800aa38:	4825      	ldr	r0, [pc, #148]	; (800aad0 <Get_DMA_Flag_Status+0xb0>)
 800aa3a:	4283      	cmp	r3, r0
 800aa3c:	bf0c      	ite	eq
 800aa3e:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 800aa42:	f44f 0080 	movne.w	r0, #4194304	; 0x400000
 800aa46:	e037      	b.n	800aab8 <Get_DMA_Flag_Status+0x98>
 800aa48:	4a22      	ldr	r2, [pc, #136]	; (800aad4 <Get_DMA_Flag_Status+0xb4>)
 800aa4a:	4293      	cmp	r3, r2
 800aa4c:	d911      	bls.n	800aa72 <Get_DMA_Flag_Status+0x52>
 800aa4e:	491f      	ldr	r1, [pc, #124]	; (800aacc <Get_DMA_Flag_Status+0xac>)
 800aa50:	f502 7256 	add.w	r2, r2, #856	; 0x358
 800aa54:	4293      	cmp	r3, r2
 800aa56:	6808      	ldr	r0, [r1, #0]
 800aa58:	d034      	beq.n	800aac4 <Get_DMA_Flag_Status+0xa4>
 800aa5a:	3218      	adds	r2, #24
 800aa5c:	4293      	cmp	r3, r2
 800aa5e:	d02d      	beq.n	800aabc <Get_DMA_Flag_Status+0x9c>
 800aa60:	3218      	adds	r2, #24
 800aa62:	4293      	cmp	r3, r2
 800aa64:	bf0c      	ite	eq
 800aa66:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800aa6a:	f44f 0380 	movne.w	r3, #4194304	; 0x400000
 800aa6e:	4018      	ands	r0, r3
 800aa70:	4770      	bx	lr
 800aa72:	4a19      	ldr	r2, [pc, #100]	; (800aad8 <Get_DMA_Flag_Status+0xb8>)
 800aa74:	4919      	ldr	r1, [pc, #100]	; (800aadc <Get_DMA_Flag_Status+0xbc>)
 800aa76:	4293      	cmp	r3, r2
 800aa78:	d90e      	bls.n	800aa98 <Get_DMA_Flag_Status+0x78>
 800aa7a:	3218      	adds	r2, #24
 800aa7c:	4293      	cmp	r3, r2
 800aa7e:	6849      	ldr	r1, [r1, #4]
 800aa80:	d019      	beq.n	800aab6 <Get_DMA_Flag_Status+0x96>
 800aa82:	3218      	adds	r2, #24
 800aa84:	4293      	cmp	r3, r2
 800aa86:	d01b      	beq.n	800aac0 <Get_DMA_Flag_Status+0xa0>
 800aa88:	4815      	ldr	r0, [pc, #84]	; (800aae0 <Get_DMA_Flag_Status+0xc0>)
 800aa8a:	4283      	cmp	r3, r0
 800aa8c:	bf0c      	ite	eq
 800aa8e:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 800aa92:	f44f 0080 	movne.w	r0, #4194304	; 0x400000
 800aa96:	e00f      	b.n	800aab8 <Get_DMA_Flag_Status+0x98>
 800aa98:	4a12      	ldr	r2, [pc, #72]	; (800aae4 <Get_DMA_Flag_Status+0xc4>)
 800aa9a:	6809      	ldr	r1, [r1, #0]
 800aa9c:	4293      	cmp	r3, r2
 800aa9e:	d00a      	beq.n	800aab6 <Get_DMA_Flag_Status+0x96>
 800aaa0:	3218      	adds	r2, #24
 800aaa2:	4293      	cmp	r3, r2
 800aaa4:	d00c      	beq.n	800aac0 <Get_DMA_Flag_Status+0xa0>
 800aaa6:	4810      	ldr	r0, [pc, #64]	; (800aae8 <Get_DMA_Flag_Status+0xc8>)
 800aaa8:	4283      	cmp	r3, r0
 800aaaa:	bf0c      	ite	eq
 800aaac:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 800aab0:	f44f 0080 	movne.w	r0, #4194304	; 0x400000
 800aab4:	e000      	b.n	800aab8 <Get_DMA_Flag_Status+0x98>
 800aab6:	2001      	movs	r0, #1
 800aab8:	4008      	ands	r0, r1
}
 800aaba:	4770      	bx	lr
  return (__HAL_DMA_GET_FLAG(handle_dma, __HAL_DMA_GET_FE_FLAG_INDEX(handle_dma)));
 800aabc:	2340      	movs	r3, #64	; 0x40
 800aabe:	e7d6      	b.n	800aa6e <Get_DMA_Flag_Status+0x4e>
 800aac0:	2040      	movs	r0, #64	; 0x40
 800aac2:	e7f9      	b.n	800aab8 <Get_DMA_Flag_Status+0x98>
 800aac4:	2301      	movs	r3, #1
 800aac6:	e7d2      	b.n	800aa6e <Get_DMA_Flag_Status+0x4e>
 800aac8:	40026458 	.word	0x40026458
 800aacc:	40026400 	.word	0x40026400
 800aad0:	400264a0 	.word	0x400264a0
 800aad4:	400260b8 	.word	0x400260b8
 800aad8:	40026058 	.word	0x40026058
 800aadc:	40026000 	.word	0x40026000
 800aae0:	400260a0 	.word	0x400260a0
 800aae4:	40026010 	.word	0x40026010
 800aae8:	40026040 	.word	0x40026040

0800aaec <Get_DMA_Counter>:
 * @param  handle_dma DMA handle
 * @retval The number of remaining data units in the current DMA Stream transfer
 */
uint32_t Get_DMA_Counter(DMA_HandleTypeDef *handle_dma)
{
  return (__HAL_DMA_GET_COUNTER(handle_dma));
 800aaec:	6803      	ldr	r3, [r0, #0]
 800aaee:	6858      	ldr	r0, [r3, #4]
}
 800aaf0:	4770      	bx	lr
 800aaf2:	bf00      	nop

0800aaf4 <Config_DMA_Handler>:
 * @brief  Configure the DMA handler for transmission process
 * @param  handle_dma DMA handle
 * @retval None
 */
void Config_DMA_Handler(DMA_HandleTypeDef *handle_dma)
{
 800aaf4:	b4f0      	push	{r4, r5, r6, r7}
  handle_dma->Instance                 = DMA1_Stream5;
 800aaf6:	4b0e      	ldr	r3, [pc, #56]	; (800ab30 <Config_DMA_Handler+0x3c>)
 800aaf8:	6003      	str	r3, [r0, #0]

  handle_dma->Init.Channel             = DMA_CHANNEL_4;
 800aafa:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
  handle_dma->Init.Direction           = DMA_PERIPH_TO_MEMORY;
 800aafe:	2300      	movs	r3, #0
  handle_dma->Init.PeriphInc           = DMA_PINC_DISABLE;
  handle_dma->Init.MemInc              = DMA_MINC_ENABLE;
 800ab00:	f44f 6680 	mov.w	r6, #1024	; 0x400
  handle_dma->Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
  handle_dma->Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
  handle_dma->Init.Mode                = DMA_CIRCULAR;//DMA_CIRCULAR;
 800ab04:	f44f 7580 	mov.w	r5, #256	; 0x100
  handle_dma->Init.Priority            = DMA_PRIORITY_MEDIUM;
 800ab08:	f44f 3480 	mov.w	r4, #65536	; 0x10000
  handle_dma->Init.FIFOMode            = DMA_FIFOMODE_DISABLE;
  handle_dma->Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
  handle_dma->Init.MemBurst            = DMA_MBURST_INC4;
 800ab0c:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
  handle_dma->Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 800ab10:	2103      	movs	r1, #3
  handle_dma->Init.Channel             = DMA_CHANNEL_4;
 800ab12:	6047      	str	r7, [r0, #4]
  handle_dma->Init.MemInc              = DMA_MINC_ENABLE;
 800ab14:	6106      	str	r6, [r0, #16]
  handle_dma->Init.Mode                = DMA_CIRCULAR;//DMA_CIRCULAR;
 800ab16:	61c5      	str	r5, [r0, #28]
  handle_dma->Init.Priority            = DMA_PRIORITY_MEDIUM;
 800ab18:	6204      	str	r4, [r0, #32]
  handle_dma->Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 800ab1a:	6281      	str	r1, [r0, #40]	; 0x28
  handle_dma->Init.Direction           = DMA_PERIPH_TO_MEMORY;
 800ab1c:	6083      	str	r3, [r0, #8]
  handle_dma->Init.PeriphInc           = DMA_PINC_DISABLE;
 800ab1e:	60c3      	str	r3, [r0, #12]
  handle_dma->Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 800ab20:	6143      	str	r3, [r0, #20]
  handle_dma->Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
 800ab22:	6183      	str	r3, [r0, #24]
  handle_dma->Init.FIFOMode            = DMA_FIFOMODE_DISABLE;
 800ab24:	6243      	str	r3, [r0, #36]	; 0x24
  handle_dma->Init.MemBurst            = DMA_MBURST_INC4;
 800ab26:	62c2      	str	r2, [r0, #44]	; 0x2c
  handle_dma->Init.PeriphBurst         = DMA_MBURST_INC4;
 800ab28:	6302      	str	r2, [r0, #48]	; 0x30
}
 800ab2a:	bcf0      	pop	{r4, r5, r6, r7}
 800ab2c:	4770      	bx	lr
 800ab2e:	bf00      	nop
 800ab30:	40026088 	.word	0x40026088

0800ab34 <main>:
 *         - the user can also visualize this data as graphs using Sensors_DataLog application provided with this package
 * @param  None
 * @retval Integer
 */
int main(void)
{
 800ab34:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 800ab38:	b0cd      	sub	sp, #308	; 0x134
  - Configure the Flash prefetch, instruction and Data caches
  - Configure the Systick to generate an interrupt each 1 msec
  - Set NVIC Group Priority to 4
  - Global MSP (MCU Support Package) initialization
   */
  HAL_Init();
 800ab3a:	f7fd fc8d 	bl	8008458 <HAL_Init>

  /* Configure the system clock */
  SystemClock_Config();
 800ab3e:	f7ff ff2d 	bl	800a99c <SystemClock_Config>

  /* Initialize LEDs */
  BSP_LED_Init(LED2);
 800ab42:	2000      	movs	r0, #0
 800ab44:	f7fc fb02 	bl	800714c <BSP_LED_Init>
  BSP_LED_Off(LED2);
 800ab48:	2000      	movs	r0, #0
 800ab4a:	f7fc fb27 	bl	800719c <BSP_LED_Off>

  /* Initialize Button */
  BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_EXTI);
 800ab4e:	2101      	movs	r1, #1
 800ab50:	2000      	movs	r0, #0
 800ab52:	f7fc fb35 	bl	80071c0 <BSP_PB_Init>
  RCC_OscInitTypeDef        RCC_OscInitStruct;

  /*##-1- Configue LSE as RTC clock soucre ###################################*/
  RCC_OscInitStruct.OscillatorType =  RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 800ab56:	2401      	movs	r4, #1
  USARTConfig();
 800ab58:	f7ff feb4 	bl	800a8c4 <USARTConfig>
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 800ab5c:	2300      	movs	r3, #0
  RCC_OscInitStruct.OscillatorType =  RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_LSE;
 800ab5e:	220c      	movs	r2, #12
  RCC_OscInitStruct.LSIState = RCC_LSI_OFF;
  if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800ab60:	a80b      	add	r0, sp, #44	; 0x2c
  RCC_OscInitStruct.OscillatorType =  RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_LSE;
 800ab62:	920b      	str	r2, [sp, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 800ab64:	9311      	str	r3, [sp, #68]	; 0x44
  RCC_OscInitStruct.LSIState = RCC_LSI_OFF;
 800ab66:	9310      	str	r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 800ab68:	940d      	str	r4, [sp, #52]	; 0x34
  if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800ab6a:	f7fe fbf7 	bl	800935c <HAL_RCC_OscConfig>
  {
    /* LSE not available, we use LSI */
    use_LSI = 1;
    RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV_LSI;
    RtcHandle.Init.SynchPrediv = RTC_SYNCH_PREDIV_LSI;
    RTC_SYNCH_PREDIV = RTC_SYNCH_PREDIV_LSI;
 800ab6e:	4f31      	ldr	r7, [pc, #196]	; (800ac34 <main+0x100>)
    use_LSI = 1;
 800ab70:	4a31      	ldr	r2, [pc, #196]	; (800ac38 <main+0x104>)
    RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV_LSI;
 800ab72:	4b32      	ldr	r3, [pc, #200]	; (800ac3c <main+0x108>)
  if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800ab74:	b1e0      	cbz	r0, 800abb0 <main+0x7c>
    use_LSI = 1;
 800ab76:	6014      	str	r4, [r2, #0]
    RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV_LSI;
 800ab78:	217f      	movs	r1, #127	; 0x7f
    RtcHandle.Init.SynchPrediv = RTC_SYNCH_PREDIV_LSI;
 800ab7a:	22f9      	movs	r2, #249	; 0xf9
    RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV_LSI;
 800ab7c:	6099      	str	r1, [r3, #8]
    RtcHandle.Init.SynchPrediv = RTC_SYNCH_PREDIV_LSI;
 800ab7e:	60da      	str	r2, [r3, #12]
    RTC_SYNCH_PREDIV = RTC_SYNCH_PREDIV_LSI;
 800ab80:	603a      	str	r2, [r7, #0]
    use_LSI = 0;
    RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV_LSE;
    RtcHandle.Init.SynchPrediv = RTC_SYNCH_PREDIV_LSE;
    RTC_SYNCH_PREDIV = RTC_SYNCH_PREDIV_LSE;
  }
  RtcHandle.Instance = RTC;
 800ab82:	4a2f      	ldr	r2, [pc, #188]	; (800ac40 <main+0x10c>)
 800ab84:	601a      	str	r2, [r3, #0]
  - Asynch Prediv  = Value according to source clock
  - Synch Prediv   = Value according to source clock
  - OutPut         = Output Disable
  - OutPutPolarity = High Polarity
  - OutPutType     = Open Drain */
  RtcHandle.Init.HourFormat = RTC_HOURFORMAT_12;
 800ab86:	2140      	movs	r1, #64	; 0x40
  RtcHandle.Init.OutPut = RTC_OUTPUT_DISABLE;
 800ab88:	2200      	movs	r2, #0
  RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  RtcHandle.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;

  if(HAL_RTC_Init(&RtcHandle) != HAL_OK)
 800ab8a:	482c      	ldr	r0, [pc, #176]	; (800ac3c <main+0x108>)
  RtcHandle.Init.HourFormat = RTC_HOURFORMAT_12;
 800ab8c:	6059      	str	r1, [r3, #4]
  RtcHandle.Init.OutPut = RTC_OUTPUT_DISABLE;
 800ab8e:	611a      	str	r2, [r3, #16]
  RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 800ab90:	615a      	str	r2, [r3, #20]
  RtcHandle.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 800ab92:	619a      	str	r2, [r3, #24]
  if(HAL_RTC_Init(&RtcHandle) != HAL_OK)
 800ab94:	f7fe ff36 	bl	8009a04 <HAL_RTC_Init>
 800ab98:	b100      	cbz	r0, 800ab9c <main+0x68>
 800ab9a:	e7fe      	b.n	800ab9a <main+0x66>
  /*##-3- Configure the Date #################################################*/
  /* Set Date: Tuesday February 18th 2014 */
  sdatestructure.Year = 0x14;
  sdatestructure.Month = RTC_MONTH_FEBRUARY;
  sdatestructure.Date = 0x18;
  sdatestructure.WeekDay = RTC_WEEKDAY_TUESDAY;
 800ab9c:	4b29      	ldr	r3, [pc, #164]	; (800ac44 <main+0x110>)

  if(HAL_RTC_SetDate(&RtcHandle, &sdatestructure, FORMAT_BCD) != HAL_OK)
 800ab9e:	4827      	ldr	r0, [pc, #156]	; (800ac3c <main+0x108>)
  sdatestructure.WeekDay = RTC_WEEKDAY_TUESDAY;
 800aba0:	9306      	str	r3, [sp, #24]
  if(HAL_RTC_SetDate(&RtcHandle, &sdatestructure, FORMAT_BCD) != HAL_OK)
 800aba2:	a906      	add	r1, sp, #24
 800aba4:	2201      	movs	r2, #1
 800aba6:	f7ff f88d 	bl	8009cc4 <HAL_RTC_SetDate>
 800abaa:	4603      	mov	r3, r0
 800abac:	b138      	cbz	r0, 800abbe <main+0x8a>
 800abae:	e7fe      	b.n	800abae <main+0x7a>
    use_LSI = 0;
 800abb0:	6010      	str	r0, [r2, #0]
    RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV_LSE;
 800abb2:	217f      	movs	r1, #127	; 0x7f
    RtcHandle.Init.SynchPrediv = RTC_SYNCH_PREDIV_LSE;
 800abb4:	22ff      	movs	r2, #255	; 0xff
    RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV_LSE;
 800abb6:	6099      	str	r1, [r3, #8]
    RtcHandle.Init.SynchPrediv = RTC_SYNCH_PREDIV_LSE;
 800abb8:	60da      	str	r2, [r3, #12]
    RTC_SYNCH_PREDIV = RTC_SYNCH_PREDIV_LSE;
 800abba:	603a      	str	r2, [r7, #0]
 800abbc:	e7e1      	b.n	800ab82 <main+0x4e>
    Error_Handler();
  }

  /*##-4- Configure the Time #################################################*/
  /* Set Time: 08:10:00 */
  stimestructure.Hours = 0x08;
 800abbe:	f241 0408 	movw	r4, #4104	; 0x1008
  stimestructure.Seconds = 0x00;
  stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;
  stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE ;
  stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;

  if(HAL_RTC_SetTime(&RtcHandle, &stimestructure, FORMAT_BCD) != HAL_OK)
 800abc2:	2201      	movs	r2, #1
 800abc4:	a90b      	add	r1, sp, #44	; 0x2c
 800abc6:	481d      	ldr	r0, [pc, #116]	; (800ac3c <main+0x108>)
  stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE ;
 800abc8:	930e      	str	r3, [sp, #56]	; 0x38
  stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;
 800abca:	930f      	str	r3, [sp, #60]	; 0x3c
  stimestructure.Hours = 0x08;
 800abcc:	940b      	str	r4, [sp, #44]	; 0x2c
  if(HAL_RTC_SetTime(&RtcHandle, &stimestructure, FORMAT_BCD) != HAL_OK)
 800abce:	f7fe ff85 	bl	8009adc <HAL_RTC_SetTime>
 800abd2:	b100      	cbz	r0, 800abd6 <main+0xa2>
 800abd4:	e7fe      	b.n	800abd4 <main+0xa0>
  BSP_ACCELERO_Init( ACCELERO_SENSORS_AUTO, &ACCELERO_handle );
 800abd6:	491c      	ldr	r1, [pc, #112]	; (800ac48 <main+0x114>)
 800abd8:	4d1c      	ldr	r5, [pc, #112]	; (800ac4c <main+0x118>)
 800abda:	f8df b074 	ldr.w	fp, [pc, #116]	; 800ac50 <main+0x11c>
 800abde:	f8df a074 	ldr.w	sl, [pc, #116]	; 800ac54 <main+0x120>
 800abe2:	f8df 9074 	ldr.w	r9, [pc, #116]	; 800ac58 <main+0x124>
    HAL_RTC_GetTime(&RtcHandle, &stimestructure, FORMAT_BIN);
 800abe6:	4e15      	ldr	r6, [pc, #84]	; (800ac3c <main+0x108>)
    snprintf(dataOut, MAX_BUF_SIZE, "TimeStamp: %d:%d:%d.%d\r\n", stimestructure.Hours, stimestructure.Minutes, stimestructure.Seconds,
 800abe8:	f8df 8070 	ldr.w	r8, [pc, #112]	; 800ac5c <main+0x128>
 800abec:	460c      	mov	r4, r1
  BSP_ACCELERO_Init( ACCELERO_SENSORS_AUTO, &ACCELERO_handle );
 800abee:	f04f 30ff 	mov.w	r0, #4294967295
 800abf2:	f7fc fd09 	bl	8007608 <BSP_ACCELERO_Init>
  BSP_GYRO_Init( GYRO_SENSORS_AUTO, &GYRO_handle );
 800abf6:	1d21      	adds	r1, r4, #4
 800abf8:	f04f 30ff 	mov.w	r0, #4294967295
 800abfc:	f7fc fe82 	bl	8007904 <BSP_GYRO_Init>
  BSP_MAGNETO_Init( MAGNETO_SENSORS_AUTO, &MAGNETO_handle );
 800ac00:	f104 0108 	add.w	r1, r4, #8
 800ac04:	f04f 30ff 	mov.w	r0, #4294967295
 800ac08:	f7fd f87e 	bl	8007d08 <BSP_MAGNETO_Init>
  BSP_HUMIDITY_Init( HUMIDITY_SENSORS_AUTO, &HUMIDITY_handle );
 800ac0c:	f104 010c 	add.w	r1, r4, #12
 800ac10:	f04f 30ff 	mov.w	r0, #4294967295
 800ac14:	f7fc ff84 	bl	8007b20 <BSP_HUMIDITY_Init>
  BSP_TEMPERATURE_Init( TEMPERATURE_SENSORS_AUTO, &TEMPERATURE_handle );
 800ac18:	f104 0110 	add.w	r1, r4, #16
 800ac1c:	f04f 30ff 	mov.w	r0, #4294967295
 800ac20:	f7fd fa64 	bl	80080ec <BSP_TEMPERATURE_Init>
  BSP_PRESSURE_Init( PRESSURE_SENSORS_AUTO, &PRESSURE_handle );
 800ac24:	f104 0114 	add.w	r1, r4, #20
 800ac28:	f04f 30ff 	mov.w	r0, #4294967295
 800ac2c:	f7fd f960 	bl	8007ef0 <BSP_PRESSURE_Init>
 800ac30:	e05f      	b.n	800acf2 <main+0x1be>
 800ac32:	bf00      	nop
 800ac34:	20000dc8 	.word	0x20000dc8
 800ac38:	20000740 	.word	0x20000740
 800ac3c:	20000d9c 	.word	0x20000d9c
 800ac40:	40002800 	.word	0x40002800
 800ac44:	14180202 	.word	0x14180202
 800ac48:	200006fc 	.word	0x200006fc
 800ac4c:	2000076c 	.word	0x2000076c
 800ac50:	20000d90 	.word	0x20000d90
 800ac54:	20000c80 	.word	0x20000c80
 800ac58:	20000dbc 	.word	0x20000dbc
 800ac5c:	0800d5c4 	.word	0x0800d5c4
  else if(AutoInit)
 800ac60:	7e23      	ldrb	r3, [r4, #24]
 800ac62:	b1c3      	cbz	r3, 800ac96 <main+0x162>
    snprintf(dataOut, MAX_BUF_SIZE, "TimeStamp: %d:%d:%d.%d\r\n", stimestructure.Hours, stimestructure.Minutes, stimestructure.Seconds,
 800ac64:	f89d 001a 	ldrb.w	r0, [sp, #26]
 800ac68:	f89d 1019 	ldrb.w	r1, [sp, #25]
 800ac6c:	f89d 3018 	ldrb.w	r3, [sp, #24]
 800ac70:	9202      	str	r2, [sp, #8]
 800ac72:	9001      	str	r0, [sp, #4]
 800ac74:	4642      	mov	r2, r8
 800ac76:	9100      	str	r1, [sp, #0]
 800ac78:	48b5      	ldr	r0, [pc, #724]	; (800af50 <main+0x41c>)
 800ac7a:	f44f 7180 	mov.w	r1, #256	; 0x100
 800ac7e:	f001 fb69 	bl	800c354 <sniprintf>
    HAL_UART_Transmit(&UartHandle, (uint8_t*)dataOut, strlen(dataOut), 5000);
 800ac82:	48b3      	ldr	r0, [pc, #716]	; (800af50 <main+0x41c>)
 800ac84:	f7f5 faac 	bl	80001e0 <strlen>
 800ac88:	f241 3388 	movw	r3, #5000	; 0x1388
 800ac8c:	b282      	uxth	r2, r0
 800ac8e:	49b0      	ldr	r1, [pc, #704]	; (800af50 <main+0x41c>)
 800ac90:	48b0      	ldr	r0, [pc, #704]	; (800af54 <main+0x420>)
 800ac92:	f7ff fa9b 	bl	800a1cc <HAL_UART_Transmit>
    if (Sensors_Enabled & PRESSURE_SENSOR)
 800ac96:	69e3      	ldr	r3, [r4, #28]
 800ac98:	07da      	lsls	r2, r3, #31
 800ac9a:	f100 8093 	bmi.w	800adc4 <main+0x290>
    if (Sensors_Enabled & HUMIDITY_SENSOR)
 800ac9e:	69e3      	ldr	r3, [r4, #28]
 800aca0:	075b      	lsls	r3, r3, #29
 800aca2:	f100 80f1 	bmi.w	800ae88 <main+0x354>
    if (Sensors_Enabled & TEMPERATURE_SENSOR)
 800aca6:	69e3      	ldr	r3, [r4, #28]
 800aca8:	0798      	lsls	r0, r3, #30
 800acaa:	f100 815f 	bmi.w	800af6c <main+0x438>
    if (Sensors_Enabled & ACCELEROMETER_SENSOR)
 800acae:	69e3      	ldr	r3, [r4, #28]
 800acb0:	06d9      	lsls	r1, r3, #27
 800acb2:	f100 81bd 	bmi.w	800b030 <main+0x4fc>
    if (Sensors_Enabled & GYROSCOPE_SENSOR)
 800acb6:	69e3      	ldr	r3, [r4, #28]
 800acb8:	069a      	lsls	r2, r3, #26
 800acba:	f100 8206 	bmi.w	800b0ca <main+0x596>
    if (Sensors_Enabled & MAGNETIC_SENSOR)
 800acbe:	69e3      	ldr	r3, [r4, #28]
 800acc0:	065b      	lsls	r3, r3, #25
 800acc2:	f100 824f 	bmi.w	800b164 <main+0x630>
    if ( DataLoggerActive || AutoInit )
 800acc6:	782b      	ldrb	r3, [r5, #0]
 800acc8:	b92b      	cbnz	r3, 800acd6 <main+0x1a2>
 800acca:	7e23      	ldrb	r3, [r4, #24]
 800accc:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 800acd0:	2b00      	cmp	r3, #0
 800acd2:	f000 82af 	beq.w	800b234 <main+0x700>
      BSP_LED_Toggle(LED2);
 800acd6:	2000      	movs	r0, #0
 800acd8:	f7fc fa6a 	bl	80071b0 <BSP_LED_Toggle>
    if(DataLoggerActive)
 800acdc:	782b      	ldrb	r3, [r5, #0]
 800acde:	b123      	cbz	r3, 800acea <main+0x1b6>
      if (new_data != 0)
 800ace0:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 800ace4:	2b00      	cmp	r3, #0
 800ace6:	f040 82a8 	bne.w	800b23a <main+0x706>
    if ( AutoInit )
 800acea:	7e23      	ldrb	r3, [r4, #24]
 800acec:	2b00      	cmp	r3, #0
 800acee:	f040 82b9 	bne.w	800b264 <main+0x730>
    if (UART_ReceivedMSG((TMsg*) &Msg))
 800acf2:	a80b      	add	r0, sp, #44	; 0x2c
 800acf4:	f7ff fd46 	bl	800a784 <UART_ReceivedMSG>
 800acf8:	b120      	cbz	r0, 800ad04 <main+0x1d0>
      if (Msg.Data[0] == DEV_ADDR)
 800acfa:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
 800acfe:	2b32      	cmp	r3, #50	; 0x32
 800ad00:	f000 82b5 	beq.w	800b26e <main+0x73a>
    if (Previous_Sensors_Enabled != Sensors_Enabled)
 800ad04:	69e3      	ldr	r3, [r4, #28]
 800ad06:	6a22      	ldr	r2, [r4, #32]
 800ad08:	429a      	cmp	r2, r3
 800ad0a:	d02b      	beq.n	800ad64 <main+0x230>
      Previous_Sensors_Enabled = Sensors_Enabled;
 800ad0c:	69e2      	ldr	r2, [r4, #28]
  if (Sensors_Enabled & PRESSURE_SENSOR)
 800ad0e:	69e3      	ldr	r3, [r4, #28]
      Previous_Sensors_Enabled = Sensors_Enabled;
 800ad10:	6222      	str	r2, [r4, #32]
  if (Sensors_Enabled & PRESSURE_SENSOR)
 800ad12:	07da      	lsls	r2, r3, #31
    BSP_PRESSURE_Sensor_Enable( PRESSURE_handle );
 800ad14:	6960      	ldr	r0, [r4, #20]
  if (Sensors_Enabled & PRESSURE_SENSOR)
 800ad16:	f140 828a 	bpl.w	800b22e <main+0x6fa>
    BSP_PRESSURE_Sensor_Enable( PRESSURE_handle );
 800ad1a:	f7fd f963 	bl	8007fe4 <BSP_PRESSURE_Sensor_Enable>
  if (Sensors_Enabled & HUMIDITY_SENSOR)
 800ad1e:	69e3      	ldr	r3, [r4, #28]
    BSP_HUMIDITY_Sensor_Enable( HUMIDITY_handle );
 800ad20:	68e0      	ldr	r0, [r4, #12]
  if (Sensors_Enabled & HUMIDITY_SENSOR)
 800ad22:	075b      	lsls	r3, r3, #29
 800ad24:	f140 8279 	bpl.w	800b21a <main+0x6e6>
    BSP_HUMIDITY_Sensor_Enable( HUMIDITY_handle );
 800ad28:	f7fc ff6a 	bl	8007c00 <BSP_HUMIDITY_Sensor_Enable>
  if (Sensors_Enabled & TEMPERATURE_SENSOR)
 800ad2c:	69e3      	ldr	r3, [r4, #28]
    BSP_TEMPERATURE_Sensor_Enable( TEMPERATURE_handle );
 800ad2e:	6920      	ldr	r0, [r4, #16]
  if (Sensors_Enabled & TEMPERATURE_SENSOR)
 800ad30:	0799      	lsls	r1, r3, #30
 800ad32:	f140 8279 	bpl.w	800b228 <main+0x6f4>
    BSP_TEMPERATURE_Sensor_Enable( TEMPERATURE_handle );
 800ad36:	f7fd fabf 	bl	80082b8 <BSP_TEMPERATURE_Sensor_Enable>
  if (Sensors_Enabled & ACCELEROMETER_SENSOR)
 800ad3a:	69e3      	ldr	r3, [r4, #28]
    BSP_ACCELERO_Sensor_Enable( ACCELERO_handle );
 800ad3c:	6820      	ldr	r0, [r4, #0]
  if (Sensors_Enabled & ACCELEROMETER_SENSOR)
 800ad3e:	06da      	lsls	r2, r3, #27
 800ad40:	f140 825a 	bpl.w	800b1f8 <main+0x6c4>
    BSP_ACCELERO_Sensor_Enable( ACCELERO_handle );
 800ad44:	f7fc fd4a 	bl	80077dc <BSP_ACCELERO_Sensor_Enable>
  if (Sensors_Enabled & GYROSCOPE_SENSOR)
 800ad48:	69e3      	ldr	r3, [r4, #28]
    BSP_GYRO_Sensor_Enable( GYRO_handle );
 800ad4a:	6860      	ldr	r0, [r4, #4]
  if (Sensors_Enabled & GYROSCOPE_SENSOR)
 800ad4c:	069b      	lsls	r3, r3, #26
 800ad4e:	f140 825a 	bpl.w	800b206 <main+0x6d2>
    BSP_GYRO_Sensor_Enable( GYRO_handle );
 800ad52:	f7fc fe51 	bl	80079f8 <BSP_GYRO_Sensor_Enable>
  if (Sensors_Enabled & MAGNETIC_SENSOR)
 800ad56:	69e3      	ldr	r3, [r4, #28]
    BSP_MAGNETO_Sensor_Enable( MAGNETO_handle );
 800ad58:	68a0      	ldr	r0, [r4, #8]
  if (Sensors_Enabled & MAGNETIC_SENSOR)
 800ad5a:	0659      	lsls	r1, r3, #25
 800ad5c:	f100 825a 	bmi.w	800b214 <main+0x6e0>
    BSP_MAGNETO_Sensor_Disable( MAGNETO_handle );
 800ad60:	f7fd f852 	bl	8007e08 <BSP_MAGNETO_Sensor_Disable>
  if(DataLoggerActive || AutoInit)
 800ad64:	782b      	ldrb	r3, [r5, #0]
 800ad66:	b91b      	cbnz	r3, 800ad70 <main+0x23c>
 800ad68:	7e23      	ldrb	r3, [r4, #24]
 800ad6a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800ad6e:	b19b      	cbz	r3, 800ad98 <main+0x264>
    HAL_RTC_GetTime(&RtcHandle, &stimestructure, FORMAT_BIN);
 800ad70:	2200      	movs	r2, #0
 800ad72:	a906      	add	r1, sp, #24
 800ad74:	4630      	mov	r0, r6
 800ad76:	f7fe ff6f 	bl	8009c58 <HAL_RTC_GetTime>
    HAL_RTC_GetDate(&RtcHandle, &sdatestructureget, FORMAT_BIN);
 800ad7a:	2200      	movs	r2, #0
 800ad7c:	a905      	add	r1, sp, #20
 800ad7e:	4630      	mov	r0, r6
 800ad80:	f7ff f842 	bl	8009e08 <HAL_RTC_GetDate>
    subSec = ((((((int) RTC_SYNCH_PREDIV) - ((int) stimestructure.SubSeconds)) * 100) / (RTC_SYNCH_PREDIV + 1)) & 0xff);
 800ad84:	683b      	ldr	r3, [r7, #0]
 800ad86:	9907      	ldr	r1, [sp, #28]
 800ad88:	2264      	movs	r2, #100	; 0x64
 800ad8a:	1a59      	subs	r1, r3, r1
 800ad8c:	fb02 f201 	mul.w	r2, r2, r1
 800ad90:	3301      	adds	r3, #1
 800ad92:	fb92 f2f3 	sdiv	r2, r2, r3
 800ad96:	b2d2      	uxtb	r2, r2
  if(DataLoggerActive)
 800ad98:	782b      	ldrb	r3, [r5, #0]
 800ad9a:	2b00      	cmp	r3, #0
 800ad9c:	f43f af60 	beq.w	800ac60 <main+0x12c>
    Msg->Data[3] = (uint8_t)stimestructure.Hours;
 800ada0:	f89d 3018 	ldrb.w	r3, [sp, #24]
 800ada4:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    Msg->Data[5] = (uint8_t)stimestructure.Seconds;
 800ada8:	f89d 301a 	ldrb.w	r3, [sp, #26]
 800adac:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
    if (Sensors_Enabled & PRESSURE_SENSOR)
 800adb0:	69e3      	ldr	r3, [r4, #28]
    Msg->Data[6] = subSec;
 800adb2:	f88d 2036 	strb.w	r2, [sp, #54]	; 0x36
    Msg->Data[4] = (uint8_t)stimestructure.Minutes;
 800adb6:	f89d 2019 	ldrb.w	r2, [sp, #25]
 800adba:	f88d 2034 	strb.w	r2, [sp, #52]	; 0x34
    if (Sensors_Enabled & PRESSURE_SENSOR)
 800adbe:	07da      	lsls	r2, r3, #31
 800adc0:	f57f af6d 	bpl.w	800ac9e <main+0x16a>
  uint8_t status = 0;
 800adc4:	2300      	movs	r3, #0
  if(BSP_PRESSURE_IsInitialized(PRESSURE_handle, &status) == COMPONENT_OK && status == 1)
 800adc6:	a905      	add	r1, sp, #20
 800adc8:	6960      	ldr	r0, [r4, #20]
  uint8_t status = 0;
 800adca:	f88d 3014 	strb.w	r3, [sp, #20]
  uint8_t drdy = 0;
 800adce:	f88d 3018 	strb.w	r3, [sp, #24]
  if(BSP_PRESSURE_IsInitialized(PRESSURE_handle, &status) == COMPONENT_OK && status == 1)
 800add2:	f7fd f927 	bl	8008024 <BSP_PRESSURE_IsInitialized>
 800add6:	2800      	cmp	r0, #0
 800add8:	f47f af61 	bne.w	800ac9e <main+0x16a>
 800addc:	f89d 3014 	ldrb.w	r3, [sp, #20]
 800ade0:	2b01      	cmp	r3, #1
 800ade2:	f47f af5c 	bne.w	800ac9e <main+0x16a>
    BSP_PRESSURE_Get_DRDY_Status(PRESSURE_handle, &drdy);
 800ade6:	a906      	add	r1, sp, #24
 800ade8:	6960      	ldr	r0, [r4, #20]
 800adea:	f7fd f96f 	bl	80080cc <BSP_PRESSURE_Get_DRDY_Status>
    if (drdy != 0)
 800adee:	f89d 3018 	ldrb.w	r3, [sp, #24]
 800adf2:	2b00      	cmp	r3, #0
 800adf4:	f43f af53 	beq.w	800ac9e <main+0x16a>
      new_data++;
 800adf8:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
      new_data_flags |= 8;
 800adfc:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
      BSP_PRESSURE_Get_Press(PRESSURE_handle, &PRESSURE_Value);
 800ae00:	4955      	ldr	r1, [pc, #340]	; (800af58 <main+0x424>)
 800ae02:	6960      	ldr	r0, [r4, #20]
      new_data_flags |= 8;
 800ae04:	f043 0308 	orr.w	r3, r3, #8
      new_data++;
 800ae08:	3201      	adds	r2, #1
      new_data_flags |= 8;
 800ae0a:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
      new_data++;
 800ae0e:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
      BSP_PRESSURE_Get_Press(PRESSURE_handle, &PRESSURE_Value);
 800ae12:	f7fd f917 	bl	8008044 <BSP_PRESSURE_Get_Press>
      if ( DataLoggerActive )
 800ae16:	782b      	ldrb	r3, [r5, #0]
 800ae18:	2b00      	cmp	r3, #0
 800ae1a:	f040 823c 	bne.w	800b296 <main+0x762>
      else if ( AutoInit )
 800ae1e:	7e23      	ldrb	r3, [r4, #24]
 800ae20:	2b00      	cmp	r3, #0
 800ae22:	f43f af3c 	beq.w	800ac9e <main+0x16a>
        floatToInt(PRESSURE_Value, &out_value, 2);
 800ae26:	4b4c      	ldr	r3, [pc, #304]	; (800af58 <main+0x424>)
 800ae28:	edd3 7a00 	vldr	s15, [r3]
  if(in >= 0.0f)
 800ae2c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800ae30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    in = -in;
 800ae34:	bfb8      	it	lt
 800ae36:	eef1 7a67 	vneglt.f32	s15, s15
  out_value->out_int = (int32_t)in;
 800ae3a:	eebd 8ae7 	vcvt.s32.f32	s16, s15
  in = in - (float)(out_value->out_int);
 800ae3e:	eeb8 7a48 	vcvt.f32.u32	s14, s16
  out_value->out_dec = (int32_t)trunc(in * pow(10, dec_prec));
 800ae42:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800ae46:	ee17 0a90 	vmov	r0, s15
 800ae4a:	f7f5 fb85 	bl	8000558 <__aeabi_f2d>
 800ae4e:	2200      	movs	r2, #0
 800ae50:	4b42      	ldr	r3, [pc, #264]	; (800af5c <main+0x428>)
 800ae52:	f7f5 fbd5 	bl	8000600 <__aeabi_dmul>
 800ae56:	f7f5 fde5 	bl	8000a24 <__aeabi_d2iz>
        snprintf(dataOut, MAX_BUF_SIZE, "PRESS: %d.%02d\r\n", (int)out_value.out_int, (int)out_value.out_dec);
 800ae5a:	ee18 3a10 	vmov	r3, s16
 800ae5e:	4a40      	ldr	r2, [pc, #256]	; (800af60 <main+0x42c>)
 800ae60:	9000      	str	r0, [sp, #0]
 800ae62:	f44f 7180 	mov.w	r1, #256	; 0x100
 800ae66:	483a      	ldr	r0, [pc, #232]	; (800af50 <main+0x41c>)
 800ae68:	f001 fa74 	bl	800c354 <sniprintf>
        HAL_UART_Transmit(&UartHandle, (uint8_t*)dataOut, strlen(dataOut), 5000);
 800ae6c:	4838      	ldr	r0, [pc, #224]	; (800af50 <main+0x41c>)
 800ae6e:	f7f5 f9b7 	bl	80001e0 <strlen>
 800ae72:	f241 3388 	movw	r3, #5000	; 0x1388
 800ae76:	b282      	uxth	r2, r0
 800ae78:	4935      	ldr	r1, [pc, #212]	; (800af50 <main+0x41c>)
 800ae7a:	4836      	ldr	r0, [pc, #216]	; (800af54 <main+0x420>)
 800ae7c:	f7ff f9a6 	bl	800a1cc <HAL_UART_Transmit>
    if (Sensors_Enabled & HUMIDITY_SENSOR)
 800ae80:	69e3      	ldr	r3, [r4, #28]
 800ae82:	075b      	lsls	r3, r3, #29
 800ae84:	f57f af0f 	bpl.w	800aca6 <main+0x172>
  uint8_t status = 0;
 800ae88:	2300      	movs	r3, #0
  if (BSP_HUMIDITY_IsInitialized(HUMIDITY_handle, &status) == COMPONENT_OK && status == 1)
 800ae8a:	a905      	add	r1, sp, #20
 800ae8c:	68e0      	ldr	r0, [r4, #12]
  uint8_t status = 0;
 800ae8e:	f88d 3014 	strb.w	r3, [sp, #20]
  uint8_t drdy = 0;
 800ae92:	f88d 3018 	strb.w	r3, [sp, #24]
  if (BSP_HUMIDITY_IsInitialized(HUMIDITY_handle, &status) == COMPONENT_OK && status == 1)
 800ae96:	f7fc fed3 	bl	8007c40 <BSP_HUMIDITY_IsInitialized>
 800ae9a:	2800      	cmp	r0, #0
 800ae9c:	f47f af03 	bne.w	800aca6 <main+0x172>
 800aea0:	f89d 3014 	ldrb.w	r3, [sp, #20]
 800aea4:	2b01      	cmp	r3, #1
 800aea6:	f47f aefe 	bne.w	800aca6 <main+0x172>
    BSP_HUMIDITY_Get_DRDY_Status(HUMIDITY_handle, &drdy);
 800aeaa:	a906      	add	r1, sp, #24
 800aeac:	68e0      	ldr	r0, [r4, #12]
 800aeae:	f7fc ff1b 	bl	8007ce8 <BSP_HUMIDITY_Get_DRDY_Status>
    if (drdy != 0)
 800aeb2:	f89d 3018 	ldrb.w	r3, [sp, #24]
 800aeb6:	2b00      	cmp	r3, #0
 800aeb8:	f43f aef5 	beq.w	800aca6 <main+0x172>
      new_data++;
 800aebc:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
      new_data_flags |= 16;
 800aec0:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
      BSP_HUMIDITY_Get_Hum(HUMIDITY_handle, &HUMIDITY_Value);
 800aec4:	4927      	ldr	r1, [pc, #156]	; (800af64 <main+0x430>)
 800aec6:	68e0      	ldr	r0, [r4, #12]
      new_data_flags |= 16;
 800aec8:	f043 0310 	orr.w	r3, r3, #16
      new_data++;
 800aecc:	3201      	adds	r2, #1
      new_data_flags |= 16;
 800aece:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
      new_data++;
 800aed2:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
      BSP_HUMIDITY_Get_Hum(HUMIDITY_handle, &HUMIDITY_Value);
 800aed6:	f7fc fec3 	bl	8007c60 <BSP_HUMIDITY_Get_Hum>
      if ( DataLoggerActive )
 800aeda:	782b      	ldrb	r3, [r5, #0]
 800aedc:	2b00      	cmp	r3, #0
 800aede:	f040 81d0 	bne.w	800b282 <main+0x74e>
      else if ( AutoInit )
 800aee2:	7e23      	ldrb	r3, [r4, #24]
 800aee4:	2b00      	cmp	r3, #0
 800aee6:	f43f aede 	beq.w	800aca6 <main+0x172>
        floatToInt(HUMIDITY_Value, &out_value, 2);
 800aeea:	4b1e      	ldr	r3, [pc, #120]	; (800af64 <main+0x430>)
 800aeec:	edd3 7a00 	vldr	s15, [r3]
  if(in >= 0.0f)
 800aef0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800aef4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    in = -in;
 800aef8:	bfb8      	it	lt
 800aefa:	eef1 7a67 	vneglt.f32	s15, s15
  out_value->out_int = (int32_t)in;
 800aefe:	eebd 8ae7 	vcvt.s32.f32	s16, s15
  in = in - (float)(out_value->out_int);
 800af02:	eeb8 7a48 	vcvt.f32.u32	s14, s16
  out_value->out_dec = (int32_t)trunc(in * pow(10, dec_prec));
 800af06:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800af0a:	ee17 0a90 	vmov	r0, s15
 800af0e:	f7f5 fb23 	bl	8000558 <__aeabi_f2d>
 800af12:	2200      	movs	r2, #0
 800af14:	4b11      	ldr	r3, [pc, #68]	; (800af5c <main+0x428>)
 800af16:	f7f5 fb73 	bl	8000600 <__aeabi_dmul>
 800af1a:	f7f5 fd83 	bl	8000a24 <__aeabi_d2iz>
        snprintf(dataOut, MAX_BUF_SIZE, "HUM: %d.%02d\r\n", (int)out_value.out_int, (int)out_value.out_dec);
 800af1e:	ee18 3a10 	vmov	r3, s16
 800af22:	4a11      	ldr	r2, [pc, #68]	; (800af68 <main+0x434>)
 800af24:	9000      	str	r0, [sp, #0]
 800af26:	f44f 7180 	mov.w	r1, #256	; 0x100
 800af2a:	4809      	ldr	r0, [pc, #36]	; (800af50 <main+0x41c>)
 800af2c:	f001 fa12 	bl	800c354 <sniprintf>
        HAL_UART_Transmit(&UartHandle, (uint8_t*)dataOut, strlen(dataOut), 5000);
 800af30:	4807      	ldr	r0, [pc, #28]	; (800af50 <main+0x41c>)
 800af32:	f7f5 f955 	bl	80001e0 <strlen>
 800af36:	f241 3388 	movw	r3, #5000	; 0x1388
 800af3a:	b282      	uxth	r2, r0
 800af3c:	4904      	ldr	r1, [pc, #16]	; (800af50 <main+0x41c>)
 800af3e:	4805      	ldr	r0, [pc, #20]	; (800af54 <main+0x420>)
 800af40:	f7ff f944 	bl	800a1cc <HAL_UART_Transmit>
    if (Sensors_Enabled & TEMPERATURE_SENSOR)
 800af44:	69e3      	ldr	r3, [r4, #28]
 800af46:	0798      	lsls	r0, r3, #30
 800af48:	f57f aeb1 	bpl.w	800acae <main+0x17a>
 800af4c:	e00e      	b.n	800af6c <main+0x438>
 800af4e:	bf00      	nop
 800af50:	20000c90 	.word	0x20000c90
 800af54:	200007d8 	.word	0x200007d8
 800af58:	20000c7c 	.word	0x20000c7c
 800af5c:	40590000 	.word	0x40590000
 800af60:	0800d5e0 	.word	0x0800d5e0
 800af64:	20000c8c 	.word	0x20000c8c
 800af68:	0800d5f4 	.word	0x0800d5f4
  uint8_t status = 0;
 800af6c:	2300      	movs	r3, #0
  if (BSP_TEMPERATURE_IsInitialized(TEMPERATURE_handle, &status) == COMPONENT_OK && status == 1)
 800af6e:	a905      	add	r1, sp, #20
 800af70:	6920      	ldr	r0, [r4, #16]
  uint8_t status = 0;
 800af72:	f88d 3014 	strb.w	r3, [sp, #20]
  uint8_t drdy = 0;
 800af76:	f88d 3018 	strb.w	r3, [sp, #24]
  if (BSP_TEMPERATURE_IsInitialized(TEMPERATURE_handle, &status) == COMPONENT_OK && status == 1)
 800af7a:	f7fd f9bd 	bl	80082f8 <BSP_TEMPERATURE_IsInitialized>
 800af7e:	2800      	cmp	r0, #0
 800af80:	f47f ae95 	bne.w	800acae <main+0x17a>
 800af84:	f89d 3014 	ldrb.w	r3, [sp, #20]
 800af88:	2b01      	cmp	r3, #1
 800af8a:	f47f ae90 	bne.w	800acae <main+0x17a>
    BSP_TEMPERATURE_Get_DRDY_Status(TEMPERATURE_handle, &drdy);
 800af8e:	a906      	add	r1, sp, #24
 800af90:	6920      	ldr	r0, [r4, #16]
 800af92:	f7fd fa05 	bl	80083a0 <BSP_TEMPERATURE_Get_DRDY_Status>
    if (drdy != 0)
 800af96:	f89d 3018 	ldrb.w	r3, [sp, #24]
 800af9a:	2b00      	cmp	r3, #0
 800af9c:	f43f ae87 	beq.w	800acae <main+0x17a>
      new_data++;
 800afa0:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
      new_data_flags |= 32;
 800afa4:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
      BSP_TEMPERATURE_Get_Temp(TEMPERATURE_handle, &TEMPERATURE_Value);
 800afa8:	49bd      	ldr	r1, [pc, #756]	; (800b2a0 <main+0x76c>)
 800afaa:	6920      	ldr	r0, [r4, #16]
      new_data_flags |= 32;
 800afac:	f043 0320 	orr.w	r3, r3, #32
      new_data++;
 800afb0:	3201      	adds	r2, #1
      new_data_flags |= 32;
 800afb2:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
      new_data++;
 800afb6:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
      BSP_TEMPERATURE_Get_Temp(TEMPERATURE_handle, &TEMPERATURE_Value);
 800afba:	f7fd f9ad 	bl	8008318 <BSP_TEMPERATURE_Get_Temp>
      if ( DataLoggerActive )
 800afbe:	782b      	ldrb	r3, [r5, #0]
 800afc0:	2b00      	cmp	r3, #0
 800afc2:	f040 8163 	bne.w	800b28c <main+0x758>
      else if ( AutoInit )
 800afc6:	7e23      	ldrb	r3, [r4, #24]
 800afc8:	2b00      	cmp	r3, #0
 800afca:	f43f ae70 	beq.w	800acae <main+0x17a>
        floatToInt(TEMPERATURE_Value, &out_value, 2);
 800afce:	4bb4      	ldr	r3, [pc, #720]	; (800b2a0 <main+0x76c>)
 800afd0:	edd3 7a00 	vldr	s15, [r3]
  if(in >= 0.0f)
 800afd4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800afd8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800afdc:	f2c0 81bc 	blt.w	800b358 <main+0x824>
  out_value->out_int = (int32_t)in;
 800afe0:	eebd 8ae7 	vcvt.s32.f32	s16, s15
  in = in - (float)(out_value->out_int);
 800afe4:	eeb8 7a48 	vcvt.f32.u32	s14, s16
  out_value->out_dec = (int32_t)trunc(in * pow(10, dec_prec));
 800afe8:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800afec:	ee17 0a90 	vmov	r0, s15
 800aff0:	f7f5 fab2 	bl	8000558 <__aeabi_f2d>
 800aff4:	4bab      	ldr	r3, [pc, #684]	; (800b2a4 <main+0x770>)
 800aff6:	2200      	movs	r2, #0
 800aff8:	f7f5 fb02 	bl	8000600 <__aeabi_dmul>
 800affc:	f7f5 fd12 	bl	8000a24 <__aeabi_d2iz>
        snprintf(dataOut, MAX_BUF_SIZE, "TEMP: %c%d.%02d\r\n", ((out_value.sign) ? '-' : '+'), (int)out_value.out_int, (int)out_value.out_dec);
 800b000:	232b      	movs	r3, #43	; 0x2b
 800b002:	4aa9      	ldr	r2, [pc, #676]	; (800b2a8 <main+0x774>)
 800b004:	9001      	str	r0, [sp, #4]
 800b006:	f44f 7180 	mov.w	r1, #256	; 0x100
 800b00a:	ed8d 8a00 	vstr	s16, [sp]
 800b00e:	48a7      	ldr	r0, [pc, #668]	; (800b2ac <main+0x778>)
 800b010:	f001 f9a0 	bl	800c354 <sniprintf>
        HAL_UART_Transmit(&UartHandle, (uint8_t*)dataOut, strlen(dataOut), 5000);
 800b014:	48a5      	ldr	r0, [pc, #660]	; (800b2ac <main+0x778>)
 800b016:	f7f5 f8e3 	bl	80001e0 <strlen>
 800b01a:	f241 3388 	movw	r3, #5000	; 0x1388
 800b01e:	b282      	uxth	r2, r0
 800b020:	49a2      	ldr	r1, [pc, #648]	; (800b2ac <main+0x778>)
 800b022:	48a3      	ldr	r0, [pc, #652]	; (800b2b0 <main+0x77c>)
 800b024:	f7ff f8d2 	bl	800a1cc <HAL_UART_Transmit>
    if (Sensors_Enabled & ACCELEROMETER_SENSOR)
 800b028:	69e3      	ldr	r3, [r4, #28]
 800b02a:	06d9      	lsls	r1, r3, #27
 800b02c:	f57f ae43 	bpl.w	800acb6 <main+0x182>
  uint8_t status = 0;
 800b030:	2300      	movs	r3, #0
  if(BSP_ACCELERO_IsInitialized(ACCELERO_handle, &status) == COMPONENT_OK && status == 1)
 800b032:	a905      	add	r1, sp, #20
 800b034:	6820      	ldr	r0, [r4, #0]
  uint8_t status = 0;
 800b036:	f88d 3014 	strb.w	r3, [sp, #20]
  uint8_t drdy = 0;
 800b03a:	f88d 3018 	strb.w	r3, [sp, #24]
  if(BSP_ACCELERO_IsInitialized(ACCELERO_handle, &status) == COMPONENT_OK && status == 1)
 800b03e:	f7fc fbed 	bl	800781c <BSP_ACCELERO_IsInitialized>
 800b042:	2800      	cmp	r0, #0
 800b044:	f47f ae37 	bne.w	800acb6 <main+0x182>
 800b048:	f89d 3014 	ldrb.w	r3, [sp, #20]
 800b04c:	2b01      	cmp	r3, #1
 800b04e:	f47f ae32 	bne.w	800acb6 <main+0x182>
    BSP_ACCELERO_Get_DRDY_Status(ACCELERO_handle, &drdy);
 800b052:	a906      	add	r1, sp, #24
 800b054:	6820      	ldr	r0, [r4, #0]
 800b056:	f7fc fc45 	bl	80078e4 <BSP_ACCELERO_Get_DRDY_Status>
    if (drdy != 0)
 800b05a:	f89d 3018 	ldrb.w	r3, [sp, #24]
 800b05e:	2b00      	cmp	r3, #0
 800b060:	f43f ae29 	beq.w	800acb6 <main+0x182>
      new_data++;
 800b064:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
      new_data_flags |= 1;
 800b068:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
      BSP_ACCELERO_Get_Axes(ACCELERO_handle, &ACC_Value);
 800b06c:	4991      	ldr	r1, [pc, #580]	; (800b2b4 <main+0x780>)
 800b06e:	6820      	ldr	r0, [r4, #0]
      new_data_flags |= 1;
 800b070:	f043 0301 	orr.w	r3, r3, #1
      new_data++;
 800b074:	3201      	adds	r2, #1
      new_data_flags |= 1;
 800b076:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
      new_data++;
 800b07a:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
      BSP_ACCELERO_Get_Axes(ACCELERO_handle, &ACC_Value);
 800b07e:	f7fc fbdd 	bl	800783c <BSP_ACCELERO_Get_Axes>
      if ( DataLoggerActive )
 800b082:	782b      	ldrb	r3, [r5, #0]
 800b084:	2b00      	cmp	r3, #0
 800b086:	f040 8151 	bne.w	800b32c <main+0x7f8>
      else if ( AutoInit )
 800b08a:	7e23      	ldrb	r3, [r4, #24]
 800b08c:	2b00      	cmp	r3, #0
 800b08e:	f43f ae12 	beq.w	800acb6 <main+0x182>
        snprintf(dataOut, MAX_BUF_SIZE, "ACC_X: %d, ACC_Y: %d, ACC_Z: %d\r\n", (int)data[0], (int)data[1], (int)data[2]);
 800b092:	f8db 1008 	ldr.w	r1, [fp, #8]
 800b096:	f8db 2004 	ldr.w	r2, [fp, #4]
 800b09a:	f8db 3000 	ldr.w	r3, [fp]
 800b09e:	9101      	str	r1, [sp, #4]
 800b0a0:	9200      	str	r2, [sp, #0]
 800b0a2:	f44f 7180 	mov.w	r1, #256	; 0x100
 800b0a6:	4a84      	ldr	r2, [pc, #528]	; (800b2b8 <main+0x784>)
 800b0a8:	4880      	ldr	r0, [pc, #512]	; (800b2ac <main+0x778>)
 800b0aa:	f001 f953 	bl	800c354 <sniprintf>
        HAL_UART_Transmit(&UartHandle, (uint8_t*)dataOut, strlen(dataOut), 5000);
 800b0ae:	487f      	ldr	r0, [pc, #508]	; (800b2ac <main+0x778>)
 800b0b0:	f7f5 f896 	bl	80001e0 <strlen>
 800b0b4:	f241 3388 	movw	r3, #5000	; 0x1388
 800b0b8:	b282      	uxth	r2, r0
 800b0ba:	497c      	ldr	r1, [pc, #496]	; (800b2ac <main+0x778>)
 800b0bc:	487c      	ldr	r0, [pc, #496]	; (800b2b0 <main+0x77c>)
 800b0be:	f7ff f885 	bl	800a1cc <HAL_UART_Transmit>
    if (Sensors_Enabled & GYROSCOPE_SENSOR)
 800b0c2:	69e3      	ldr	r3, [r4, #28]
 800b0c4:	069a      	lsls	r2, r3, #26
 800b0c6:	f57f adfa 	bpl.w	800acbe <main+0x18a>
  uint8_t status = 0;
 800b0ca:	2300      	movs	r3, #0
  if(BSP_GYRO_IsInitialized(GYRO_handle, &status) == COMPONENT_OK && status == 1)
 800b0cc:	a905      	add	r1, sp, #20
 800b0ce:	6860      	ldr	r0, [r4, #4]
  uint8_t status = 0;
 800b0d0:	f88d 3014 	strb.w	r3, [sp, #20]
  uint8_t drdy = 0;
 800b0d4:	f88d 3018 	strb.w	r3, [sp, #24]
  if(BSP_GYRO_IsInitialized(GYRO_handle, &status) == COMPONENT_OK && status == 1)
 800b0d8:	f7fc fcae 	bl	8007a38 <BSP_GYRO_IsInitialized>
 800b0dc:	2800      	cmp	r0, #0
 800b0de:	f47f adee 	bne.w	800acbe <main+0x18a>
 800b0e2:	f89d 3014 	ldrb.w	r3, [sp, #20]
 800b0e6:	2b01      	cmp	r3, #1
 800b0e8:	f47f ade9 	bne.w	800acbe <main+0x18a>
    BSP_GYRO_Get_DRDY_Status(GYRO_handle, &drdy);
 800b0ec:	a906      	add	r1, sp, #24
 800b0ee:	6860      	ldr	r0, [r4, #4]
 800b0f0:	f7fc fd06 	bl	8007b00 <BSP_GYRO_Get_DRDY_Status>
    if (drdy != 0)
 800b0f4:	f89d 3018 	ldrb.w	r3, [sp, #24]
 800b0f8:	2b00      	cmp	r3, #0
 800b0fa:	f43f ade0 	beq.w	800acbe <main+0x18a>
      new_data++;
 800b0fe:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
      new_data_flags |= 2;
 800b102:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
      BSP_GYRO_Get_Axes(GYRO_handle, &GYR_Value);
 800b106:	496d      	ldr	r1, [pc, #436]	; (800b2bc <main+0x788>)
 800b108:	6860      	ldr	r0, [r4, #4]
      new_data_flags |= 2;
 800b10a:	f043 0302 	orr.w	r3, r3, #2
      new_data++;
 800b10e:	3201      	adds	r2, #1
      new_data_flags |= 2;
 800b110:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
      new_data++;
 800b114:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
      BSP_GYRO_Get_Axes(GYRO_handle, &GYR_Value);
 800b118:	f7fc fc9e 	bl	8007a58 <BSP_GYRO_Get_Axes>
      if ( DataLoggerActive )
 800b11c:	782b      	ldrb	r3, [r5, #0]
 800b11e:	2b00      	cmp	r3, #0
 800b120:	f040 80ee 	bne.w	800b300 <main+0x7cc>
      else if ( AutoInit )
 800b124:	7e23      	ldrb	r3, [r4, #24]
 800b126:	2b00      	cmp	r3, #0
 800b128:	f43f adc9 	beq.w	800acbe <main+0x18a>
        snprintf(dataOut, MAX_BUF_SIZE, "GYR_X: %d, GYR_Y: %d, GYR_Z: %d\r\n", (int)data[3], (int)data[4], (int)data[5]);
 800b12c:	f8da 1008 	ldr.w	r1, [sl, #8]
 800b130:	f8da 2004 	ldr.w	r2, [sl, #4]
 800b134:	f8da 3000 	ldr.w	r3, [sl]
 800b138:	9101      	str	r1, [sp, #4]
 800b13a:	9200      	str	r2, [sp, #0]
 800b13c:	f44f 7180 	mov.w	r1, #256	; 0x100
 800b140:	4a5f      	ldr	r2, [pc, #380]	; (800b2c0 <main+0x78c>)
 800b142:	485a      	ldr	r0, [pc, #360]	; (800b2ac <main+0x778>)
 800b144:	f001 f906 	bl	800c354 <sniprintf>
        HAL_UART_Transmit(&UartHandle, (uint8_t*)dataOut, strlen(dataOut), 5000);
 800b148:	4858      	ldr	r0, [pc, #352]	; (800b2ac <main+0x778>)
 800b14a:	f7f5 f849 	bl	80001e0 <strlen>
 800b14e:	f241 3388 	movw	r3, #5000	; 0x1388
 800b152:	b282      	uxth	r2, r0
 800b154:	4955      	ldr	r1, [pc, #340]	; (800b2ac <main+0x778>)
 800b156:	4856      	ldr	r0, [pc, #344]	; (800b2b0 <main+0x77c>)
 800b158:	f7ff f838 	bl	800a1cc <HAL_UART_Transmit>
    if (Sensors_Enabled & MAGNETIC_SENSOR)
 800b15c:	69e3      	ldr	r3, [r4, #28]
 800b15e:	065b      	lsls	r3, r3, #25
 800b160:	f57f adb1 	bpl.w	800acc6 <main+0x192>
  uint8_t status = 0;
 800b164:	2300      	movs	r3, #0
  if(BSP_MAGNETO_IsInitialized(MAGNETO_handle, &status) == COMPONENT_OK && status == 1)
 800b166:	a905      	add	r1, sp, #20
 800b168:	68a0      	ldr	r0, [r4, #8]
  uint8_t status = 0;
 800b16a:	f88d 3014 	strb.w	r3, [sp, #20]
  uint8_t drdy = 0;
 800b16e:	f88d 3018 	strb.w	r3, [sp, #24]
  if(BSP_MAGNETO_IsInitialized(MAGNETO_handle, &status) == COMPONENT_OK && status == 1)
 800b172:	f7fc fe59 	bl	8007e28 <BSP_MAGNETO_IsInitialized>
 800b176:	2800      	cmp	r0, #0
 800b178:	f47f ada5 	bne.w	800acc6 <main+0x192>
 800b17c:	f89d 3014 	ldrb.w	r3, [sp, #20]
 800b180:	2b01      	cmp	r3, #1
 800b182:	f47f ada0 	bne.w	800acc6 <main+0x192>
    BSP_MAGNETO_Get_DRDY_Status(MAGNETO_handle, &drdy);
 800b186:	a906      	add	r1, sp, #24
 800b188:	68a0      	ldr	r0, [r4, #8]
 800b18a:	f7fc fea1 	bl	8007ed0 <BSP_MAGNETO_Get_DRDY_Status>
    if (drdy != 0)
 800b18e:	f89d 3018 	ldrb.w	r3, [sp, #24]
 800b192:	2b00      	cmp	r3, #0
 800b194:	f43f ad97 	beq.w	800acc6 <main+0x192>
      new_data++;
 800b198:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
      new_data_flags |= 4;
 800b19c:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
      BSP_MAGNETO_Get_Axes(MAGNETO_handle, &MAG_Value);
 800b1a0:	4948      	ldr	r1, [pc, #288]	; (800b2c4 <main+0x790>)
 800b1a2:	68a0      	ldr	r0, [r4, #8]
      new_data_flags |= 4;
 800b1a4:	f043 0304 	orr.w	r3, r3, #4
      new_data++;
 800b1a8:	3201      	adds	r2, #1
      new_data_flags |= 4;
 800b1aa:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
      new_data++;
 800b1ae:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
      BSP_MAGNETO_Get_Axes(MAGNETO_handle, &MAG_Value);
 800b1b2:	f7fc fe49 	bl	8007e48 <BSP_MAGNETO_Get_Axes>
      if ( DataLoggerActive )
 800b1b6:	782b      	ldrb	r3, [r5, #0]
 800b1b8:	2b00      	cmp	r3, #0
 800b1ba:	f040 808b 	bne.w	800b2d4 <main+0x7a0>
      else if ( AutoInit )
 800b1be:	7e23      	ldrb	r3, [r4, #24]
 800b1c0:	2b00      	cmp	r3, #0
 800b1c2:	f43f ad80 	beq.w	800acc6 <main+0x192>
        snprintf(dataOut, MAX_BUF_SIZE, "MAG_X: %d, MAG_Y: %d, MAG_Z: %d\r\n", (int)data[0], (int)data[1], (int)data[2]);
 800b1c6:	f8d9 1008 	ldr.w	r1, [r9, #8]
 800b1ca:	f8d9 2004 	ldr.w	r2, [r9, #4]
 800b1ce:	f8d9 3000 	ldr.w	r3, [r9]
 800b1d2:	9101      	str	r1, [sp, #4]
 800b1d4:	9200      	str	r2, [sp, #0]
 800b1d6:	f44f 7180 	mov.w	r1, #256	; 0x100
 800b1da:	4a3b      	ldr	r2, [pc, #236]	; (800b2c8 <main+0x794>)
 800b1dc:	4833      	ldr	r0, [pc, #204]	; (800b2ac <main+0x778>)
 800b1de:	f001 f8b9 	bl	800c354 <sniprintf>
        HAL_UART_Transmit(&UartHandle, (uint8_t*)dataOut, strlen(dataOut), 5000);
 800b1e2:	4832      	ldr	r0, [pc, #200]	; (800b2ac <main+0x778>)
 800b1e4:	f7f4 fffc 	bl	80001e0 <strlen>
 800b1e8:	f241 3388 	movw	r3, #5000	; 0x1388
 800b1ec:	b282      	uxth	r2, r0
 800b1ee:	492f      	ldr	r1, [pc, #188]	; (800b2ac <main+0x778>)
 800b1f0:	482f      	ldr	r0, [pc, #188]	; (800b2b0 <main+0x77c>)
 800b1f2:	f7fe ffeb 	bl	800a1cc <HAL_UART_Transmit>
 800b1f6:	e566      	b.n	800acc6 <main+0x192>
    BSP_ACCELERO_Sensor_Disable( ACCELERO_handle );
 800b1f8:	f7fc fb00 	bl	80077fc <BSP_ACCELERO_Sensor_Disable>
  if (Sensors_Enabled & GYROSCOPE_SENSOR)
 800b1fc:	69e3      	ldr	r3, [r4, #28]
    BSP_GYRO_Sensor_Enable( GYRO_handle );
 800b1fe:	6860      	ldr	r0, [r4, #4]
  if (Sensors_Enabled & GYROSCOPE_SENSOR)
 800b200:	069b      	lsls	r3, r3, #26
 800b202:	f53f ada6 	bmi.w	800ad52 <main+0x21e>
    BSP_GYRO_Sensor_Disable( GYRO_handle );
 800b206:	f7fc fc07 	bl	8007a18 <BSP_GYRO_Sensor_Disable>
  if (Sensors_Enabled & MAGNETIC_SENSOR)
 800b20a:	69e3      	ldr	r3, [r4, #28]
    BSP_MAGNETO_Sensor_Enable( MAGNETO_handle );
 800b20c:	68a0      	ldr	r0, [r4, #8]
  if (Sensors_Enabled & MAGNETIC_SENSOR)
 800b20e:	0659      	lsls	r1, r3, #25
 800b210:	f57f ada6 	bpl.w	800ad60 <main+0x22c>
    BSP_MAGNETO_Sensor_Enable( MAGNETO_handle );
 800b214:	f7fc fde8 	bl	8007de8 <BSP_MAGNETO_Sensor_Enable>
 800b218:	e5a4      	b.n	800ad64 <main+0x230>
    BSP_HUMIDITY_Sensor_Disable( HUMIDITY_handle );
 800b21a:	f7fc fd01 	bl	8007c20 <BSP_HUMIDITY_Sensor_Disable>
  if (Sensors_Enabled & TEMPERATURE_SENSOR)
 800b21e:	69e3      	ldr	r3, [r4, #28]
    BSP_TEMPERATURE_Sensor_Enable( TEMPERATURE_handle );
 800b220:	6920      	ldr	r0, [r4, #16]
  if (Sensors_Enabled & TEMPERATURE_SENSOR)
 800b222:	0799      	lsls	r1, r3, #30
 800b224:	f53f ad87 	bmi.w	800ad36 <main+0x202>
    BSP_TEMPERATURE_Sensor_Disable( TEMPERATURE_handle );
 800b228:	f7fd f856 	bl	80082d8 <BSP_TEMPERATURE_Sensor_Disable>
 800b22c:	e585      	b.n	800ad3a <main+0x206>
    BSP_PRESSURE_Sensor_Disable( PRESSURE_handle );
 800b22e:	f7fc fee9 	bl	8008004 <BSP_PRESSURE_Sensor_Disable>
 800b232:	e574      	b.n	800ad1e <main+0x1ea>
      BSP_LED_Off(LED2);
 800b234:	f7fb ffb2 	bl	800719c <BSP_LED_Off>
 800b238:	e550      	b.n	800acdc <main+0x1a8>
        INIT_STREAMING_HEADER(&Msg);
 800b23a:	a80b      	add	r0, sp, #44	; 0x2c
 800b23c:	f7ff f91e 	bl	800a47c <INIT_STREAMING_HEADER>
        Msg.Data[55] = new_data_flags;
 800b240:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 800b244:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
        UART_SendMsg(&Msg);
 800b248:	a80b      	add	r0, sp, #44	; 0x2c
        Msg.Len = STREAMING_MSG_LENGTH;
 800b24a:	2338      	movs	r3, #56	; 0x38
 800b24c:	930b      	str	r3, [sp, #44]	; 0x2c
        UART_SendMsg(&Msg);
 800b24e:	f7ff fb13 	bl	800a878 <UART_SendMsg>
        new_data = 0;
 800b252:	2300      	movs	r3, #0
 800b254:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
        new_data_flags = 0;
 800b258:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
    if ( AutoInit )
 800b25c:	7e23      	ldrb	r3, [r4, #24]
 800b25e:	2b00      	cmp	r3, #0
 800b260:	f43f ad47 	beq.w	800acf2 <main+0x1be>
      HAL_Delay(500);
 800b264:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800b268:	f7fd f922 	bl	80084b0 <HAL_Delay>
 800b26c:	e541      	b.n	800acf2 <main+0x1be>
        HandleMSG((TMsg*) &Msg);
 800b26e:	a80b      	add	r0, sp, #44	; 0x2c
 800b270:	f7ff f910 	bl	800a494 <HandleMSG>
        if ( DataLoggerActive )
 800b274:	782b      	ldrb	r3, [r5, #0]
 800b276:	2b00      	cmp	r3, #0
 800b278:	f43f ad44 	beq.w	800ad04 <main+0x1d0>
          AutoInit = 0;
 800b27c:	2300      	movs	r3, #0
 800b27e:	7623      	strb	r3, [r4, #24]
 800b280:	e540      	b.n	800ad04 <main+0x1d0>
        memcpy(&Msg->Data[15], (void *)&HUMIDITY_Value, sizeof(float));
 800b282:	4b12      	ldr	r3, [pc, #72]	; (800b2cc <main+0x798>)
 800b284:	681b      	ldr	r3, [r3, #0]
 800b286:	f8cd 303f 	str.w	r3, [sp, #63]	; 0x3f
 800b28a:	e50c      	b.n	800aca6 <main+0x172>
        memcpy(&Msg->Data[11], (void *)&TEMPERATURE_Value, sizeof(float));
 800b28c:	4b04      	ldr	r3, [pc, #16]	; (800b2a0 <main+0x76c>)
 800b28e:	681b      	ldr	r3, [r3, #0]
 800b290:	f8cd 303b 	str.w	r3, [sp, #59]	; 0x3b
 800b294:	e50b      	b.n	800acae <main+0x17a>
        memcpy(&Msg->Data[7], (void *)&PRESSURE_Value, sizeof(float));
 800b296:	4b0e      	ldr	r3, [pc, #56]	; (800b2d0 <main+0x79c>)
 800b298:	681b      	ldr	r3, [r3, #0]
 800b29a:	f8cd 3037 	str.w	r3, [sp, #55]	; 0x37
 800b29e:	e4fe      	b.n	800ac9e <main+0x16a>
 800b2a0:	20000c78 	.word	0x20000c78
 800b2a4:	40590000 	.word	0x40590000
 800b2a8:	0800d604 	.word	0x0800d604
 800b2ac:	20000c90 	.word	0x20000c90
 800b2b0:	200007d8 	.word	0x200007d8
 800b2b4:	20000d90 	.word	0x20000d90
 800b2b8:	0800d618 	.word	0x0800d618
 800b2bc:	20000c80 	.word	0x20000c80
 800b2c0:	0800d63c 	.word	0x0800d63c
 800b2c4:	20000dbc 	.word	0x20000dbc
 800b2c8:	0800d660 	.word	0x0800d660
 800b2cc:	20000c8c 	.word	0x20000c8c
 800b2d0:	20000c7c 	.word	0x20000c7c
        Serialize_s32(&Msg->Data[43], (int32_t)MAG_Value.AXIS_X, 4);
 800b2d4:	f8d9 1000 	ldr.w	r1, [r9]
 800b2d8:	f10d 005b 	add.w	r0, sp, #91	; 0x5b
 800b2dc:	2204      	movs	r2, #4
 800b2de:	f000 ff51 	bl	800c184 <Serialize_s32>
        Serialize_s32(&Msg->Data[47], (int32_t)MAG_Value.AXIS_Y, 4);
 800b2e2:	f8d9 1004 	ldr.w	r1, [r9, #4]
 800b2e6:	f10d 005f 	add.w	r0, sp, #95	; 0x5f
 800b2ea:	2204      	movs	r2, #4
 800b2ec:	f000 ff4a 	bl	800c184 <Serialize_s32>
        Serialize_s32(&Msg->Data[51], (int32_t)MAG_Value.AXIS_Z, 4);
 800b2f0:	2204      	movs	r2, #4
 800b2f2:	f8d9 1008 	ldr.w	r1, [r9, #8]
 800b2f6:	f10d 0063 	add.w	r0, sp, #99	; 0x63
 800b2fa:	f000 ff43 	bl	800c184 <Serialize_s32>
 800b2fe:	e4e2      	b.n	800acc6 <main+0x192>
        Serialize_s32(&Msg->Data[31], GYR_Value.AXIS_X, 4);
 800b300:	f8da 1000 	ldr.w	r1, [sl]
 800b304:	f10d 004f 	add.w	r0, sp, #79	; 0x4f
 800b308:	2204      	movs	r2, #4
 800b30a:	f000 ff3b 	bl	800c184 <Serialize_s32>
        Serialize_s32(&Msg->Data[35], GYR_Value.AXIS_Y, 4);
 800b30e:	f8da 1004 	ldr.w	r1, [sl, #4]
 800b312:	f10d 0053 	add.w	r0, sp, #83	; 0x53
 800b316:	2204      	movs	r2, #4
 800b318:	f000 ff34 	bl	800c184 <Serialize_s32>
        Serialize_s32(&Msg->Data[39], GYR_Value.AXIS_Z, 4);
 800b31c:	2204      	movs	r2, #4
 800b31e:	f8da 1008 	ldr.w	r1, [sl, #8]
 800b322:	f10d 0057 	add.w	r0, sp, #87	; 0x57
 800b326:	f000 ff2d 	bl	800c184 <Serialize_s32>
 800b32a:	e4c8      	b.n	800acbe <main+0x18a>
        Serialize_s32(&Msg->Data[19], ACC_Value.AXIS_X, 4);
 800b32c:	f8db 1000 	ldr.w	r1, [fp]
 800b330:	f10d 0043 	add.w	r0, sp, #67	; 0x43
 800b334:	2204      	movs	r2, #4
 800b336:	f000 ff25 	bl	800c184 <Serialize_s32>
        Serialize_s32(&Msg->Data[23], ACC_Value.AXIS_Y, 4);
 800b33a:	f8db 1004 	ldr.w	r1, [fp, #4]
 800b33e:	f10d 0047 	add.w	r0, sp, #71	; 0x47
 800b342:	2204      	movs	r2, #4
 800b344:	f000 ff1e 	bl	800c184 <Serialize_s32>
        Serialize_s32(&Msg->Data[27], ACC_Value.AXIS_Z, 4);
 800b348:	2204      	movs	r2, #4
 800b34a:	f8db 1008 	ldr.w	r1, [fp, #8]
 800b34e:	f10d 004b 	add.w	r0, sp, #75	; 0x4b
 800b352:	f000 ff17 	bl	800c184 <Serialize_s32>
 800b356:	e4ae      	b.n	800acb6 <main+0x182>
    in = -in;
 800b358:	eef1 7a67 	vneg.f32	s15, s15
  out_value->out_int = (int32_t)in;
 800b35c:	eebd 8ae7 	vcvt.s32.f32	s16, s15
  in = in - (float)(out_value->out_int);
 800b360:	eeb8 7a48 	vcvt.f32.u32	s14, s16
  out_value->out_dec = (int32_t)trunc(in * pow(10, dec_prec));
 800b364:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800b368:	ee17 0a90 	vmov	r0, s15
 800b36c:	f7f5 f8f4 	bl	8000558 <__aeabi_f2d>
 800b370:	4b03      	ldr	r3, [pc, #12]	; (800b380 <main+0x84c>)
 800b372:	2200      	movs	r2, #0
 800b374:	f7f5 f944 	bl	8000600 <__aeabi_dmul>
 800b378:	f7f5 fb54 	bl	8000a24 <__aeabi_d2iz>
        snprintf(dataOut, MAX_BUF_SIZE, "TEMP: %c%d.%02d\r\n", ((out_value.sign) ? '-' : '+'), (int)out_value.out_int, (int)out_value.out_dec);
 800b37c:	232d      	movs	r3, #45	; 0x2d
 800b37e:	e640      	b.n	800b002 <main+0x4ce>
 800b380:	40590000 	.word	0x40590000

0800b384 <HAL_GPIO_EXTI_Callback>:
 * @param  GPIO_Pin the pin connected to EXTI line
 * @retval None
 */
void HAL_GPIO_EXTI_Callback( uint16_t GPIO_Pin )
{
  if(GPIO_Pin == KEY_BUTTON_PIN)
 800b384:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 800b388:	d000      	beq.n	800b38c <HAL_GPIO_EXTI_Callback+0x8>
 800b38a:	4770      	bx	lr
{
 800b38c:	b510      	push	{r4, lr}
  {
    /* Manage software debouncing*/
    int doOperation = 0;

    if(Int_Current_Time1 == 0 && Int_Current_Time2 == 0)
 800b38e:	4c10      	ldr	r4, [pc, #64]	; (800b3d0 <HAL_GPIO_EXTI_Callback+0x4c>)
 800b390:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800b392:	b90b      	cbnz	r3, 800b398 <HAL_GPIO_EXTI_Callback+0x14>
 800b394:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b396:	b1a3      	cbz	r3, 800b3c2 <HAL_GPIO_EXTI_Callback+0x3e>
 * @param  None
 * @retval The tick value
 */
uint32_t user_currentTimeGetTick(void)
{
  return HAL_GetTick();
 800b398:	f7fd f884 	bl	80084a4 <HAL_GetTick>
      Int_Current_Time2 = user_currentTimeGetTick();
 800b39c:	62e0      	str	r0, [r4, #44]	; 0x2c
      i2 = Int_Current_Time2;
 800b39e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
      if((i2 - Int_Current_Time1)  > 300)
 800b3a0:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800b3a2:	1a9b      	subs	r3, r3, r2
 800b3a4:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 800b3a8:	d90a      	bls.n	800b3c0 <HAL_GPIO_EXTI_Callback+0x3c>
        Int_Current_Time1 = Int_Current_Time2;
 800b3aa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b3ac:	62a3      	str	r3, [r4, #40]	; 0x28
      if ( DataLoggerActive )
 800b3ae:	4b09      	ldr	r3, [pc, #36]	; (800b3d4 <HAL_GPIO_EXTI_Callback+0x50>)
 800b3b0:	781b      	ldrb	r3, [r3, #0]
 800b3b2:	b953      	cbnz	r3, 800b3ca <HAL_GPIO_EXTI_Callback+0x46>
        AutoInit = ( AutoInit ) ? 0 : 1;    /* toggle on each button pressed */
 800b3b4:	7e23      	ldrb	r3, [r4, #24]
 800b3b6:	fab3 f383 	clz	r3, r3
 800b3ba:	095b      	lsrs	r3, r3, #5
 800b3bc:	7623      	strb	r3, [r4, #24]
}
 800b3be:	bd10      	pop	{r4, pc}
 800b3c0:	bd10      	pop	{r4, pc}
  return HAL_GetTick();
 800b3c2:	f7fd f86f 	bl	80084a4 <HAL_GetTick>
      Int_Current_Time1 = user_currentTimeGetTick();
 800b3c6:	62a0      	str	r0, [r4, #40]	; 0x28
      doOperation = 1;
 800b3c8:	e7f1      	b.n	800b3ae <HAL_GPIO_EXTI_Callback+0x2a>
        AutoInit = 0;                       /* always off */
 800b3ca:	2300      	movs	r3, #0
 800b3cc:	7623      	strb	r3, [r4, #24]
 800b3ce:	bd10      	pop	{r4, pc}
 800b3d0:	200006fc 	.word	0x200006fc
 800b3d4:	2000076c 	.word	0x2000076c

0800b3d8 <RTC_TimeRegulate>:
{
 800b3d8:	b500      	push	{lr}
 800b3da:	b087      	sub	sp, #28
  stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;
 800b3dc:	2300      	movs	r3, #0
  stimestructure.Hours = hh;
 800b3de:	f88d 0004 	strb.w	r0, [sp, #4]
  stimestructure.Minutes = mm;
 800b3e2:	f88d 1005 	strb.w	r1, [sp, #5]
  stimestructure.Seconds = ss;
 800b3e6:	f88d 2006 	strb.w	r2, [sp, #6]
  if(HAL_RTC_SetTime(&RtcHandle, &stimestructure, FORMAT_BIN) != HAL_OK)
 800b3ea:	a901      	add	r1, sp, #4
 800b3ec:	461a      	mov	r2, r3
 800b3ee:	4806      	ldr	r0, [pc, #24]	; (800b408 <RTC_TimeRegulate+0x30>)
  stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;
 800b3f0:	f88d 3007 	strb.w	r3, [sp, #7]
  stimestructure.SubSeconds = 0;
 800b3f4:	9302      	str	r3, [sp, #8]
  stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 800b3f6:	9304      	str	r3, [sp, #16]
  stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;
 800b3f8:	9305      	str	r3, [sp, #20]
  if(HAL_RTC_SetTime(&RtcHandle, &stimestructure, FORMAT_BIN) != HAL_OK)
 800b3fa:	f7fe fb6f 	bl	8009adc <HAL_RTC_SetTime>
 800b3fe:	b100      	cbz	r0, 800b402 <RTC_TimeRegulate+0x2a>
 800b400:	e7fe      	b.n	800b400 <RTC_TimeRegulate+0x28>
}
 800b402:	b007      	add	sp, #28
 800b404:	f85d fb04 	ldr.w	pc, [sp], #4
 800b408:	20000d9c 	.word	0x20000d9c

0800b40c <Error_Handler>:
{
 800b40c:	e7fe      	b.n	800b40c <Error_Handler>
 800b40e:	bf00      	nop

0800b410 <SC_Get_Sensor_Name>:
      return 0;
  }
}

int SC_Get_Sensor_Name(TMsg *Msg)
{
 800b410:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint8_t instance;

  /* Sensor Type */
  switch (Msg->Data[4])
 800b414:	7a03      	ldrb	r3, [r0, #8]
 800b416:	3b01      	subs	r3, #1
{
 800b418:	b082      	sub	sp, #8
 800b41a:	4605      	mov	r5, r0
  switch (Msg->Data[4])
 800b41c:	2b05      	cmp	r3, #5
 800b41e:	d80f      	bhi.n	800b440 <SC_Get_Sensor_Name+0x30>
 800b420:	e8df f003 	tbb	[pc, r3]
 800b424:	96785a38 	.word	0x96785a38
 800b428:	1203      	.short	0x1203
        default:
          return 0;
      }

    case SC_HUMIDITY:
      BSP_HUMIDITY_Get_Instance( HUMIDITY_handle, &instance );
 800b42a:	4b78      	ldr	r3, [pc, #480]	; (800b60c <SC_Get_Sensor_Name+0x1fc>)
 800b42c:	f10d 0107 	add.w	r1, sp, #7
 800b430:	6818      	ldr	r0, [r3, #0]
 800b432:	f7fc fc0d 	bl	8007c50 <BSP_HUMIDITY_Get_Instance>
      switch (instance)
 800b436:	f89d 4007 	ldrb.w	r4, [sp, #7]
 800b43a:	2c00      	cmp	r4, #0
 800b43c:	f000 80a9 	beq.w	800b592 <SC_Get_Sensor_Name+0x182>
      {
        case LPS22HB_P_0:
          Send_Sensor_Name(Msg, lps22hb);
          return 1;
        default:
          return 0;
 800b440:	2000      	movs	r0, #0
      }

    default:
      return 0;
  }
}
 800b442:	b002      	add	sp, #8
 800b444:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      BSP_PRESSURE_Get_Instance( PRESSURE_handle, &instance );
 800b448:	4b71      	ldr	r3, [pc, #452]	; (800b610 <SC_Get_Sensor_Name+0x200>)
 800b44a:	f10d 0107 	add.w	r1, sp, #7
 800b44e:	6818      	ldr	r0, [r3, #0]
 800b450:	f7fc fdf0 	bl	8008034 <BSP_PRESSURE_Get_Instance>
      switch (instance)
 800b454:	f89d 4007 	ldrb.w	r4, [sp, #7]
 800b458:	2c00      	cmp	r4, #0
 800b45a:	d1f1      	bne.n	800b440 <SC_Get_Sensor_Name+0x30>
 800b45c:	4e6d      	ldr	r6, [pc, #436]	; (800b614 <SC_Get_Sensor_Name+0x204>)
}

void Send_Sensor_Name(TMsg *Msg, uint8_t* sensor_name)
{
  int i = 0;
  BUILD_REPLY_HEADER(Msg);
 800b45e:	4628      	mov	r0, r5

  while (i < strlen((char const*)sensor_name))
 800b460:	f106 0801 	add.w	r8, r6, #1
  BUILD_REPLY_HEADER(Msg);
 800b464:	f7ff f802 	bl	800a46c <BUILD_REPLY_HEADER>
 800b468:	f105 0708 	add.w	r7, r5, #8
 800b46c:	e004      	b.n	800b478 <SC_Get_Sensor_Name+0x68>
  {
    Msg->Data[5 + i] = sensor_name[i];
 800b46e:	f816 3f01 	ldrb.w	r3, [r6, #1]!
 800b472:	f807 3f01 	strb.w	r3, [r7, #1]!
    i++;
 800b476:	3401      	adds	r4, #1
  while (i < strlen((char const*)sensor_name))
 800b478:	4640      	mov	r0, r8
 800b47a:	f7f4 feb1 	bl	80001e0 <strlen>
 800b47e:	4284      	cmp	r4, r0
 800b480:	d3f5      	bcc.n	800b46e <SC_Get_Sensor_Name+0x5e>
  }

  Msg->Len = 5 + i;
 800b482:	3405      	adds	r4, #5
  UART_SendMsg(Msg);
 800b484:	4628      	mov	r0, r5
  Msg->Len = 5 + i;
 800b486:	602c      	str	r4, [r5, #0]
  UART_SendMsg(Msg);
 800b488:	f7ff f9f6 	bl	800a878 <UART_SendMsg>
          return 1;
 800b48c:	2001      	movs	r0, #1
}
 800b48e:	b002      	add	sp, #8
 800b490:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      BSP_ACCELERO_Get_Instance( ACCELERO_handle, &instance );
 800b494:	4b60      	ldr	r3, [pc, #384]	; (800b618 <SC_Get_Sensor_Name+0x208>)
 800b496:	f10d 0107 	add.w	r1, sp, #7
 800b49a:	6818      	ldr	r0, [r3, #0]
 800b49c:	f7fc f9c6 	bl	800782c <BSP_ACCELERO_Get_Instance>
      switch (instance)
 800b4a0:	f89d 4007 	ldrb.w	r4, [sp, #7]
 800b4a4:	2c00      	cmp	r4, #0
 800b4a6:	f000 809c 	beq.w	800b5e2 <SC_Get_Sensor_Name+0x1d2>
 800b4aa:	2c01      	cmp	r4, #1
 800b4ac:	d1c8      	bne.n	800b440 <SC_Get_Sensor_Name+0x30>
 800b4ae:	4e5b      	ldr	r6, [pc, #364]	; (800b61c <SC_Get_Sensor_Name+0x20c>)
  BUILD_REPLY_HEADER(Msg);
 800b4b0:	4628      	mov	r0, r5
  while (i < strlen((char const*)sensor_name))
 800b4b2:	f106 0801 	add.w	r8, r6, #1
  BUILD_REPLY_HEADER(Msg);
 800b4b6:	f7fe ffd9 	bl	800a46c <BUILD_REPLY_HEADER>
 800b4ba:	f105 0708 	add.w	r7, r5, #8
  int i = 0;
 800b4be:	2400      	movs	r4, #0
 800b4c0:	e004      	b.n	800b4cc <SC_Get_Sensor_Name+0xbc>
    Msg->Data[5 + i] = sensor_name[i];
 800b4c2:	f816 3f01 	ldrb.w	r3, [r6, #1]!
 800b4c6:	f807 3f01 	strb.w	r3, [r7, #1]!
    i++;
 800b4ca:	3401      	adds	r4, #1
  while (i < strlen((char const*)sensor_name))
 800b4cc:	4640      	mov	r0, r8
 800b4ce:	f7f4 fe87 	bl	80001e0 <strlen>
 800b4d2:	4284      	cmp	r4, r0
 800b4d4:	d3f5      	bcc.n	800b4c2 <SC_Get_Sensor_Name+0xb2>
 800b4d6:	e7d4      	b.n	800b482 <SC_Get_Sensor_Name+0x72>
      BSP_GYRO_Get_Instance( GYRO_handle, &instance );
 800b4d8:	4b51      	ldr	r3, [pc, #324]	; (800b620 <SC_Get_Sensor_Name+0x210>)
 800b4da:	f10d 0107 	add.w	r1, sp, #7
 800b4de:	6818      	ldr	r0, [r3, #0]
 800b4e0:	f7fc fab2 	bl	8007a48 <BSP_GYRO_Get_Instance>
      switch (instance)
 800b4e4:	f89d 4007 	ldrb.w	r4, [sp, #7]
 800b4e8:	2c00      	cmp	r4, #0
 800b4ea:	d1a9      	bne.n	800b440 <SC_Get_Sensor_Name+0x30>
 800b4ec:	4e4d      	ldr	r6, [pc, #308]	; (800b624 <SC_Get_Sensor_Name+0x214>)
  BUILD_REPLY_HEADER(Msg);
 800b4ee:	4628      	mov	r0, r5
  while (i < strlen((char const*)sensor_name))
 800b4f0:	f106 0801 	add.w	r8, r6, #1
  BUILD_REPLY_HEADER(Msg);
 800b4f4:	f7fe ffba 	bl	800a46c <BUILD_REPLY_HEADER>
 800b4f8:	f105 0708 	add.w	r7, r5, #8
 800b4fc:	e004      	b.n	800b508 <SC_Get_Sensor_Name+0xf8>
    Msg->Data[5 + i] = sensor_name[i];
 800b4fe:	f816 3f01 	ldrb.w	r3, [r6, #1]!
 800b502:	f807 3f01 	strb.w	r3, [r7, #1]!
    i++;
 800b506:	3401      	adds	r4, #1
  while (i < strlen((char const*)sensor_name))
 800b508:	4640      	mov	r0, r8
 800b50a:	f7f4 fe69 	bl	80001e0 <strlen>
 800b50e:	4284      	cmp	r4, r0
 800b510:	d3f5      	bcc.n	800b4fe <SC_Get_Sensor_Name+0xee>
 800b512:	e7b6      	b.n	800b482 <SC_Get_Sensor_Name+0x72>
      BSP_MAGNETO_Get_Instance( MAGNETO_handle, &instance );
 800b514:	4b44      	ldr	r3, [pc, #272]	; (800b628 <SC_Get_Sensor_Name+0x218>)
 800b516:	f10d 0107 	add.w	r1, sp, #7
 800b51a:	6818      	ldr	r0, [r3, #0]
 800b51c:	f7fc fc8c 	bl	8007e38 <BSP_MAGNETO_Get_Instance>
      switch (instance)
 800b520:	f89d 4007 	ldrb.w	r4, [sp, #7]
 800b524:	2c00      	cmp	r4, #0
 800b526:	d18b      	bne.n	800b440 <SC_Get_Sensor_Name+0x30>
 800b528:	4e3c      	ldr	r6, [pc, #240]	; (800b61c <SC_Get_Sensor_Name+0x20c>)
  BUILD_REPLY_HEADER(Msg);
 800b52a:	4628      	mov	r0, r5
  while (i < strlen((char const*)sensor_name))
 800b52c:	f106 0801 	add.w	r8, r6, #1
  BUILD_REPLY_HEADER(Msg);
 800b530:	f7fe ff9c 	bl	800a46c <BUILD_REPLY_HEADER>
 800b534:	f105 0708 	add.w	r7, r5, #8
 800b538:	e004      	b.n	800b544 <SC_Get_Sensor_Name+0x134>
    Msg->Data[5 + i] = sensor_name[i];
 800b53a:	f816 3f01 	ldrb.w	r3, [r6, #1]!
 800b53e:	f807 3f01 	strb.w	r3, [r7, #1]!
    i++;
 800b542:	3401      	adds	r4, #1
  while (i < strlen((char const*)sensor_name))
 800b544:	4640      	mov	r0, r8
 800b546:	f7f4 fe4b 	bl	80001e0 <strlen>
 800b54a:	4284      	cmp	r4, r0
 800b54c:	d3f5      	bcc.n	800b53a <SC_Get_Sensor_Name+0x12a>
 800b54e:	e798      	b.n	800b482 <SC_Get_Sensor_Name+0x72>
      BSP_TEMPERATURE_Get_Instance( TEMPERATURE_handle, &instance );
 800b550:	4b36      	ldr	r3, [pc, #216]	; (800b62c <SC_Get_Sensor_Name+0x21c>)
 800b552:	f10d 0107 	add.w	r1, sp, #7
 800b556:	6818      	ldr	r0, [r3, #0]
 800b558:	f7fc fed6 	bl	8008308 <BSP_TEMPERATURE_Get_Instance>
      switch (instance)
 800b55c:	f89d 4007 	ldrb.w	r4, [sp, #7]
 800b560:	b35c      	cbz	r4, 800b5ba <SC_Get_Sensor_Name+0x1aa>
 800b562:	2c01      	cmp	r4, #1
 800b564:	f47f af6c 	bne.w	800b440 <SC_Get_Sensor_Name+0x30>
 800b568:	4e2a      	ldr	r6, [pc, #168]	; (800b614 <SC_Get_Sensor_Name+0x204>)
  BUILD_REPLY_HEADER(Msg);
 800b56a:	4628      	mov	r0, r5
  while (i < strlen((char const*)sensor_name))
 800b56c:	f106 0801 	add.w	r8, r6, #1
  BUILD_REPLY_HEADER(Msg);
 800b570:	f7fe ff7c 	bl	800a46c <BUILD_REPLY_HEADER>
 800b574:	f105 0708 	add.w	r7, r5, #8
  int i = 0;
 800b578:	2400      	movs	r4, #0
 800b57a:	e004      	b.n	800b586 <SC_Get_Sensor_Name+0x176>
    Msg->Data[5 + i] = sensor_name[i];
 800b57c:	f816 3f01 	ldrb.w	r3, [r6, #1]!
 800b580:	f807 3f01 	strb.w	r3, [r7, #1]!
    i++;
 800b584:	3401      	adds	r4, #1
  while (i < strlen((char const*)sensor_name))
 800b586:	4640      	mov	r0, r8
 800b588:	f7f4 fe2a 	bl	80001e0 <strlen>
 800b58c:	4284      	cmp	r4, r0
 800b58e:	d3f5      	bcc.n	800b57c <SC_Get_Sensor_Name+0x16c>
 800b590:	e777      	b.n	800b482 <SC_Get_Sensor_Name+0x72>
 800b592:	4e27      	ldr	r6, [pc, #156]	; (800b630 <SC_Get_Sensor_Name+0x220>)
  BUILD_REPLY_HEADER(Msg);
 800b594:	4628      	mov	r0, r5
  while (i < strlen((char const*)sensor_name))
 800b596:	f106 0801 	add.w	r8, r6, #1
  BUILD_REPLY_HEADER(Msg);
 800b59a:	f7fe ff67 	bl	800a46c <BUILD_REPLY_HEADER>
 800b59e:	f105 0708 	add.w	r7, r5, #8
 800b5a2:	e004      	b.n	800b5ae <SC_Get_Sensor_Name+0x19e>
    Msg->Data[5 + i] = sensor_name[i];
 800b5a4:	f816 3f01 	ldrb.w	r3, [r6, #1]!
 800b5a8:	f807 3f01 	strb.w	r3, [r7, #1]!
    i++;
 800b5ac:	3401      	adds	r4, #1
  while (i < strlen((char const*)sensor_name))
 800b5ae:	4640      	mov	r0, r8
 800b5b0:	f7f4 fe16 	bl	80001e0 <strlen>
 800b5b4:	4284      	cmp	r4, r0
 800b5b6:	d3f5      	bcc.n	800b5a4 <SC_Get_Sensor_Name+0x194>
 800b5b8:	e763      	b.n	800b482 <SC_Get_Sensor_Name+0x72>
 800b5ba:	4e1d      	ldr	r6, [pc, #116]	; (800b630 <SC_Get_Sensor_Name+0x220>)
  BUILD_REPLY_HEADER(Msg);
 800b5bc:	4628      	mov	r0, r5
  while (i < strlen((char const*)sensor_name))
 800b5be:	f106 0801 	add.w	r8, r6, #1
  BUILD_REPLY_HEADER(Msg);
 800b5c2:	f7fe ff53 	bl	800a46c <BUILD_REPLY_HEADER>
 800b5c6:	f105 0708 	add.w	r7, r5, #8
 800b5ca:	e004      	b.n	800b5d6 <SC_Get_Sensor_Name+0x1c6>
    Msg->Data[5 + i] = sensor_name[i];
 800b5cc:	f816 3f01 	ldrb.w	r3, [r6, #1]!
 800b5d0:	f807 3f01 	strb.w	r3, [r7, #1]!
    i++;
 800b5d4:	3401      	adds	r4, #1
  while (i < strlen((char const*)sensor_name))
 800b5d6:	4640      	mov	r0, r8
 800b5d8:	f7f4 fe02 	bl	80001e0 <strlen>
 800b5dc:	4284      	cmp	r4, r0
 800b5de:	d3f5      	bcc.n	800b5cc <SC_Get_Sensor_Name+0x1bc>
 800b5e0:	e74f      	b.n	800b482 <SC_Get_Sensor_Name+0x72>
 800b5e2:	4e10      	ldr	r6, [pc, #64]	; (800b624 <SC_Get_Sensor_Name+0x214>)
  BUILD_REPLY_HEADER(Msg);
 800b5e4:	4628      	mov	r0, r5
  while (i < strlen((char const*)sensor_name))
 800b5e6:	f106 0801 	add.w	r8, r6, #1
  BUILD_REPLY_HEADER(Msg);
 800b5ea:	f7fe ff3f 	bl	800a46c <BUILD_REPLY_HEADER>
 800b5ee:	f105 0708 	add.w	r7, r5, #8
 800b5f2:	e004      	b.n	800b5fe <SC_Get_Sensor_Name+0x1ee>
    Msg->Data[5 + i] = sensor_name[i];
 800b5f4:	f816 3f01 	ldrb.w	r3, [r6, #1]!
 800b5f8:	f807 3f01 	strb.w	r3, [r7, #1]!
    i++;
 800b5fc:	3401      	adds	r4, #1
  while (i < strlen((char const*)sensor_name))
 800b5fe:	4640      	mov	r0, r8
 800b600:	f7f4 fdee 	bl	80001e0 <strlen>
 800b604:	4284      	cmp	r4, r0
 800b606:	d3f5      	bcc.n	800b5f4 <SC_Get_Sensor_Name+0x1e4>
 800b608:	e73b      	b.n	800b482 <SC_Get_Sensor_Name+0x72>
 800b60a:	bf00      	nop
 800b60c:	20000708 	.word	0x20000708
 800b610:	20000710 	.word	0x20000710
 800b614:	200003f7 	.word	0x200003f7
 800b618:	200006fc 	.word	0x200006fc
 800b61c:	200003e3 	.word	0x200003e3
 800b620:	20000700 	.word	0x20000700
 800b624:	200003db 	.word	0x200003db
 800b628:	20000704 	.word	0x20000704
 800b62c:	2000070c 	.word	0x2000070c
 800b630:	200003ef 	.word	0x200003ef

0800b634 <SC_Read_Register>:
{
 800b634:	b510      	push	{r4, lr}
  switch (Msg->Data[4])
 800b636:	7a03      	ldrb	r3, [r0, #8]
 800b638:	3b01      	subs	r3, #1
{
 800b63a:	b082      	sub	sp, #8
 800b63c:	4604      	mov	r4, r0
  switch (Msg->Data[4])
 800b63e:	2b05      	cmp	r3, #5
 800b640:	d841      	bhi.n	800b6c6 <SC_Read_Register+0x92>
 800b642:	e8df f003 	tbb	[pc, r3]
 800b646:	2018      	.short	0x2018
 800b648:	03383028 	.word	0x03383028
      BSP_PRESSURE_Read_Reg( PRESSURE_handle, Msg->Data[5],  &reg_value );
 800b64c:	4b1f      	ldr	r3, [pc, #124]	; (800b6cc <SC_Read_Register+0x98>)
 800b64e:	7a41      	ldrb	r1, [r0, #9]
 800b650:	6818      	ldr	r0, [r3, #0]
 800b652:	f10d 0207 	add.w	r2, sp, #7
 800b656:	f7fc fd17 	bl	8008088 <BSP_PRESSURE_Read_Reg>
  BUILD_REPLY_HEADER(Msg);
 800b65a:	4620      	mov	r0, r4
 800b65c:	f7fe ff06 	bl	800a46c <BUILD_REPLY_HEADER>
  Msg->Data[6] = reg_value;
 800b660:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b664:	72a3      	strb	r3, [r4, #10]
  Msg->Len = 7;
 800b666:	2307      	movs	r3, #7
  UART_SendMsg(Msg);
 800b668:	4620      	mov	r0, r4
  Msg->Len = 7;
 800b66a:	6023      	str	r3, [r4, #0]
  UART_SendMsg(Msg);
 800b66c:	f7ff f904 	bl	800a878 <UART_SendMsg>
  return 1;
 800b670:	2001      	movs	r0, #1
}
 800b672:	b002      	add	sp, #8
 800b674:	bd10      	pop	{r4, pc}
      BSP_ACCELERO_Read_Reg( ACCELERO_handle, Msg->Data[5], &reg_value );
 800b676:	4b16      	ldr	r3, [pc, #88]	; (800b6d0 <SC_Read_Register+0x9c>)
 800b678:	7a41      	ldrb	r1, [r0, #9]
 800b67a:	6818      	ldr	r0, [r3, #0]
 800b67c:	f10d 0207 	add.w	r2, sp, #7
 800b680:	f7fc f90e 	bl	80078a0 <BSP_ACCELERO_Read_Reg>
      break;
 800b684:	e7e9      	b.n	800b65a <SC_Read_Register+0x26>
      BSP_GYRO_Read_Reg( GYRO_handle, Msg->Data[5], &reg_value );
 800b686:	4b13      	ldr	r3, [pc, #76]	; (800b6d4 <SC_Read_Register+0xa0>)
 800b688:	7a41      	ldrb	r1, [r0, #9]
 800b68a:	6818      	ldr	r0, [r3, #0]
 800b68c:	f10d 0207 	add.w	r2, sp, #7
 800b690:	f7fc fa14 	bl	8007abc <BSP_GYRO_Read_Reg>
      break;
 800b694:	e7e1      	b.n	800b65a <SC_Read_Register+0x26>
      BSP_MAGNETO_Read_Reg( MAGNETO_handle, Msg->Data[5],  &reg_value );
 800b696:	4b10      	ldr	r3, [pc, #64]	; (800b6d8 <SC_Read_Register+0xa4>)
 800b698:	7a41      	ldrb	r1, [r0, #9]
 800b69a:	6818      	ldr	r0, [r3, #0]
 800b69c:	f10d 0207 	add.w	r2, sp, #7
 800b6a0:	f7fc fbf4 	bl	8007e8c <BSP_MAGNETO_Read_Reg>
      break;
 800b6a4:	e7d9      	b.n	800b65a <SC_Read_Register+0x26>
      BSP_TEMPERATURE_Read_Reg( TEMPERATURE_handle, Msg->Data[5],  &reg_value );
 800b6a6:	4b0d      	ldr	r3, [pc, #52]	; (800b6dc <SC_Read_Register+0xa8>)
 800b6a8:	7a41      	ldrb	r1, [r0, #9]
 800b6aa:	6818      	ldr	r0, [r3, #0]
 800b6ac:	f10d 0207 	add.w	r2, sp, #7
 800b6b0:	f7fc fe54 	bl	800835c <BSP_TEMPERATURE_Read_Reg>
      break;
 800b6b4:	e7d1      	b.n	800b65a <SC_Read_Register+0x26>
      BSP_HUMIDITY_Read_Reg( HUMIDITY_handle, Msg->Data[5],  &reg_value );
 800b6b6:	4b0a      	ldr	r3, [pc, #40]	; (800b6e0 <SC_Read_Register+0xac>)
 800b6b8:	7a41      	ldrb	r1, [r0, #9]
 800b6ba:	6818      	ldr	r0, [r3, #0]
 800b6bc:	f10d 0207 	add.w	r2, sp, #7
 800b6c0:	f7fc faf0 	bl	8007ca4 <BSP_HUMIDITY_Read_Reg>
      break;
 800b6c4:	e7c9      	b.n	800b65a <SC_Read_Register+0x26>
      return 0;
 800b6c6:	2000      	movs	r0, #0
 800b6c8:	e7d3      	b.n	800b672 <SC_Read_Register+0x3e>
 800b6ca:	bf00      	nop
 800b6cc:	20000710 	.word	0x20000710
 800b6d0:	200006fc 	.word	0x200006fc
 800b6d4:	20000700 	.word	0x20000700
 800b6d8:	20000704 	.word	0x20000704
 800b6dc:	2000070c 	.word	0x2000070c
 800b6e0:	20000708 	.word	0x20000708

0800b6e4 <SC_Write_Register>:
{
 800b6e4:	b510      	push	{r4, lr}
  switch (Msg->Data[4])
 800b6e6:	7a03      	ldrb	r3, [r0, #8]
 800b6e8:	3b01      	subs	r3, #1
{
 800b6ea:	4604      	mov	r4, r0
  switch (Msg->Data[4])
 800b6ec:	2b05      	cmp	r3, #5
 800b6ee:	d837      	bhi.n	800b760 <SC_Write_Register+0x7c>
 800b6f0:	e8df f003 	tbb	[pc, r3]
 800b6f4:	28211a13 	.word	0x28211a13
 800b6f8:	032f      	.short	0x032f
      BSP_PRESSURE_Write_Reg( PRESSURE_handle, Msg->Data[5], Msg->Data[6] );
 800b6fa:	4b1a      	ldr	r3, [pc, #104]	; (800b764 <SC_Write_Register+0x80>)
 800b6fc:	7a82      	ldrb	r2, [r0, #10]
 800b6fe:	7a61      	ldrb	r1, [r4, #9]
 800b700:	6818      	ldr	r0, [r3, #0]
 800b702:	f7fc fcd3 	bl	80080ac <BSP_PRESSURE_Write_Reg>
  BUILD_REPLY_HEADER(Msg);
 800b706:	4620      	mov	r0, r4
 800b708:	f7fe feb0 	bl	800a46c <BUILD_REPLY_HEADER>
  Msg->Len = 7;
 800b70c:	2307      	movs	r3, #7
  UART_SendMsg(Msg);
 800b70e:	4620      	mov	r0, r4
  Msg->Len = 7;
 800b710:	6023      	str	r3, [r4, #0]
  UART_SendMsg(Msg);
 800b712:	f7ff f8b1 	bl	800a878 <UART_SendMsg>
  return 1;
 800b716:	2001      	movs	r0, #1
 800b718:	bd10      	pop	{r4, pc}
      BSP_ACCELERO_Write_Reg( ACCELERO_handle, Msg->Data[5], Msg->Data[6] );
 800b71a:	4b13      	ldr	r3, [pc, #76]	; (800b768 <SC_Write_Register+0x84>)
 800b71c:	7a82      	ldrb	r2, [r0, #10]
 800b71e:	7a61      	ldrb	r1, [r4, #9]
 800b720:	6818      	ldr	r0, [r3, #0]
 800b722:	f7fc f8cf 	bl	80078c4 <BSP_ACCELERO_Write_Reg>
      break;
 800b726:	e7ee      	b.n	800b706 <SC_Write_Register+0x22>
      BSP_GYRO_Write_Reg( GYRO_handle, Msg->Data[5], Msg->Data[6] );
 800b728:	4b10      	ldr	r3, [pc, #64]	; (800b76c <SC_Write_Register+0x88>)
 800b72a:	7a82      	ldrb	r2, [r0, #10]
 800b72c:	7a61      	ldrb	r1, [r4, #9]
 800b72e:	6818      	ldr	r0, [r3, #0]
 800b730:	f7fc f9d6 	bl	8007ae0 <BSP_GYRO_Write_Reg>
      break;
 800b734:	e7e7      	b.n	800b706 <SC_Write_Register+0x22>
      BSP_MAGNETO_Write_Reg( MAGNETO_handle, Msg->Data[5], Msg->Data[6] );
 800b736:	4b0e      	ldr	r3, [pc, #56]	; (800b770 <SC_Write_Register+0x8c>)
 800b738:	7a82      	ldrb	r2, [r0, #10]
 800b73a:	7a61      	ldrb	r1, [r4, #9]
 800b73c:	6818      	ldr	r0, [r3, #0]
 800b73e:	f7fc fbb7 	bl	8007eb0 <BSP_MAGNETO_Write_Reg>
      break;
 800b742:	e7e0      	b.n	800b706 <SC_Write_Register+0x22>
      BSP_TEMPERATURE_Write_Reg( TEMPERATURE_handle, Msg->Data[5], Msg->Data[6] );
 800b744:	4b0b      	ldr	r3, [pc, #44]	; (800b774 <SC_Write_Register+0x90>)
 800b746:	7a82      	ldrb	r2, [r0, #10]
 800b748:	7a61      	ldrb	r1, [r4, #9]
 800b74a:	6818      	ldr	r0, [r3, #0]
 800b74c:	f7fc fe18 	bl	8008380 <BSP_TEMPERATURE_Write_Reg>
      break;
 800b750:	e7d9      	b.n	800b706 <SC_Write_Register+0x22>
      BSP_HUMIDITY_Write_Reg( HUMIDITY_handle, Msg->Data[5], Msg->Data[6] );
 800b752:	4b09      	ldr	r3, [pc, #36]	; (800b778 <SC_Write_Register+0x94>)
 800b754:	7a82      	ldrb	r2, [r0, #10]
 800b756:	7a61      	ldrb	r1, [r4, #9]
 800b758:	6818      	ldr	r0, [r3, #0]
 800b75a:	f7fc fab5 	bl	8007cc8 <BSP_HUMIDITY_Write_Reg>
      break;
 800b75e:	e7d2      	b.n	800b706 <SC_Write_Register+0x22>
      return 0;
 800b760:	2000      	movs	r0, #0
}
 800b762:	bd10      	pop	{r4, pc}
 800b764:	20000710 	.word	0x20000710
 800b768:	200006fc 	.word	0x200006fc
 800b76c:	20000700 	.word	0x20000700
 800b770:	20000704 	.word	0x20000704
 800b774:	2000070c 	.word	0x2000070c
 800b778:	20000708 	.word	0x20000708

0800b77c <SC_Get_Full_Scale_List>:
{
 800b77c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  switch (Msg->Data[4])
 800b780:	7a03      	ldrb	r3, [r0, #8]
 800b782:	3b01      	subs	r3, #1
{
 800b784:	b082      	sub	sp, #8
 800b786:	4604      	mov	r4, r0
  switch (Msg->Data[4])
 800b788:	2b05      	cmp	r3, #5
 800b78a:	d80f      	bhi.n	800b7ac <SC_Get_Full_Scale_List+0x30>
 800b78c:	e8df f003 	tbb	[pc, r3]
 800b790:	c49a7144 	.word	0xc49a7144
 800b794:	1203      	.short	0x1203
      BSP_HUMIDITY_Get_Instance( HUMIDITY_handle, &instance );
 800b796:	4ba3      	ldr	r3, [pc, #652]	; (800ba24 <SC_Get_Full_Scale_List+0x2a8>)
 800b798:	f10d 0107 	add.w	r1, sp, #7
 800b79c:	6818      	ldr	r0, [r3, #0]
 800b79e:	f7fc fa57 	bl	8007c50 <BSP_HUMIDITY_Get_Instance>
      switch (instance)
 800b7a2:	f89d 6007 	ldrb.w	r6, [sp, #7]
 800b7a6:	2e00      	cmp	r6, #0
 800b7a8:	f000 80e2 	beq.w	800b970 <SC_Get_Full_Scale_List+0x1f4>
          return 0;
 800b7ac:	2000      	movs	r0, #0
}
 800b7ae:	b002      	add	sp, #8
 800b7b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      BSP_PRESSURE_Get_Instance( PRESSURE_handle, &instance );
 800b7b4:	4b9c      	ldr	r3, [pc, #624]	; (800ba28 <SC_Get_Full_Scale_List+0x2ac>)
 800b7b6:	f10d 0107 	add.w	r1, sp, #7
 800b7ba:	6818      	ldr	r0, [r3, #0]
 800b7bc:	f7fc fc3a 	bl	8008034 <BSP_PRESSURE_Get_Instance>
      switch (instance)
 800b7c0:	f89d 6007 	ldrb.w	r6, [sp, #7]
 800b7c4:	2e00      	cmp	r6, #0
 800b7c6:	d1f1      	bne.n	800b7ac <SC_Get_Full_Scale_List+0x30>
void Send_Sensor_FS_List(TMsg *Msg, uint32_t* fs_list)
{
  int i = 0;
  BUILD_REPLY_HEADER(Msg);

  Serialize(&Msg->Data[5], fs_list[0], 4);
 800b7c8:	4d98      	ldr	r5, [pc, #608]	; (800ba2c <SC_Get_Full_Scale_List+0x2b0>)
  BUILD_REPLY_HEADER(Msg);
 800b7ca:	4620      	mov	r0, r4
 800b7cc:	f7fe fe4e 	bl	800a46c <BUILD_REPLY_HEADER>
  Serialize(&Msg->Data[5], fs_list[0], 4);
 800b7d0:	68e9      	ldr	r1, [r5, #12]
 800b7d2:	2204      	movs	r2, #4
 800b7d4:	f104 0009 	add.w	r0, r4, #9
 800b7d8:	f000 fcbe 	bl	800c158 <Serialize>

  for (i = 0; i < fs_list[0]; i++)
 800b7dc:	68eb      	ldr	r3, [r5, #12]
 800b7de:	2b00      	cmp	r3, #0
 800b7e0:	f000 811d 	beq.w	800ba1e <SC_Get_Full_Scale_List+0x2a2>
 800b7e4:	f105 080c 	add.w	r8, r5, #12
 800b7e8:	f104 070d 	add.w	r7, r4, #13
  {
    Serialize(&Msg->Data[9 + i * 4], fs_list[i + 1], 4);
 800b7ec:	4638      	mov	r0, r7
 800b7ee:	2204      	movs	r2, #4
 800b7f0:	f858 1f04 	ldr.w	r1, [r8, #4]!
 800b7f4:	f000 fcb0 	bl	800c158 <Serialize>
  for (i = 0; i < fs_list[0]; i++)
 800b7f8:	68eb      	ldr	r3, [r5, #12]
 800b7fa:	3601      	adds	r6, #1
 800b7fc:	429e      	cmp	r6, r3
 800b7fe:	f107 0704 	add.w	r7, r7, #4
 800b802:	d3f3      	bcc.n	800b7ec <SC_Get_Full_Scale_List+0x70>
 800b804:	00b6      	lsls	r6, r6, #2
 800b806:	3609      	adds	r6, #9
  }

  Msg->Len = 9 + i * 4;
  UART_SendMsg(Msg);
 800b808:	4620      	mov	r0, r4
  Msg->Len = 9 + i * 4;
 800b80a:	6026      	str	r6, [r4, #0]
  UART_SendMsg(Msg);
 800b80c:	f7ff f834 	bl	800a878 <UART_SendMsg>
          return 1;
 800b810:	2001      	movs	r0, #1
}
 800b812:	b002      	add	sp, #8
 800b814:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      BSP_ACCELERO_Get_Instance( ACCELERO_handle, &instance );
 800b818:	4b85      	ldr	r3, [pc, #532]	; (800ba30 <SC_Get_Full_Scale_List+0x2b4>)
 800b81a:	f10d 0107 	add.w	r1, sp, #7
 800b81e:	6818      	ldr	r0, [r3, #0]
 800b820:	f7fc f804 	bl	800782c <BSP_ACCELERO_Get_Instance>
      switch (instance)
 800b824:	f89d 6007 	ldrb.w	r6, [sp, #7]
 800b828:	2e00      	cmp	r6, #0
 800b82a:	f000 80db 	beq.w	800b9e4 <SC_Get_Full_Scale_List+0x268>
 800b82e:	2e01      	cmp	r6, #1
 800b830:	d1bc      	bne.n	800b7ac <SC_Get_Full_Scale_List+0x30>
  Serialize(&Msg->Data[5], fs_list[0], 4);
 800b832:	4d80      	ldr	r5, [pc, #512]	; (800ba34 <SC_Get_Full_Scale_List+0x2b8>)
  BUILD_REPLY_HEADER(Msg);
 800b834:	4620      	mov	r0, r4
 800b836:	f7fe fe19 	bl	800a46c <BUILD_REPLY_HEADER>
  Serialize(&Msg->Data[5], fs_list[0], 4);
 800b83a:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 800b83c:	2204      	movs	r2, #4
 800b83e:	f104 0009 	add.w	r0, r4, #9
 800b842:	f000 fc89 	bl	800c158 <Serialize>
  for (i = 0; i < fs_list[0]; i++)
 800b846:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800b848:	2b00      	cmp	r3, #0
 800b84a:	f000 80e8 	beq.w	800ba1e <SC_Get_Full_Scale_List+0x2a2>
 800b84e:	f105 0838 	add.w	r8, r5, #56	; 0x38
 800b852:	f104 070d 	add.w	r7, r4, #13
 800b856:	2600      	movs	r6, #0
    Serialize(&Msg->Data[9 + i * 4], fs_list[i + 1], 4);
 800b858:	4638      	mov	r0, r7
 800b85a:	2204      	movs	r2, #4
 800b85c:	f858 1f04 	ldr.w	r1, [r8, #4]!
 800b860:	f000 fc7a 	bl	800c158 <Serialize>
  for (i = 0; i < fs_list[0]; i++)
 800b864:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800b866:	3601      	adds	r6, #1
 800b868:	429e      	cmp	r6, r3
 800b86a:	f107 0704 	add.w	r7, r7, #4
 800b86e:	d3f3      	bcc.n	800b858 <SC_Get_Full_Scale_List+0xdc>
 800b870:	e7c8      	b.n	800b804 <SC_Get_Full_Scale_List+0x88>
      BSP_GYRO_Get_Instance( GYRO_handle, &instance );
 800b872:	4b71      	ldr	r3, [pc, #452]	; (800ba38 <SC_Get_Full_Scale_List+0x2bc>)
 800b874:	f10d 0107 	add.w	r1, sp, #7
 800b878:	6818      	ldr	r0, [r3, #0]
 800b87a:	f7fc f8e5 	bl	8007a48 <BSP_GYRO_Get_Instance>
      switch (instance)
 800b87e:	f89d 6007 	ldrb.w	r6, [sp, #7]
 800b882:	2e00      	cmp	r6, #0
 800b884:	d192      	bne.n	800b7ac <SC_Get_Full_Scale_List+0x30>
  Serialize(&Msg->Data[5], fs_list[0], 4);
 800b886:	4d6b      	ldr	r5, [pc, #428]	; (800ba34 <SC_Get_Full_Scale_List+0x2b8>)
  BUILD_REPLY_HEADER(Msg);
 800b888:	4620      	mov	r0, r4
 800b88a:	f7fe fdef 	bl	800a46c <BUILD_REPLY_HEADER>
  Serialize(&Msg->Data[5], fs_list[0], 4);
 800b88e:	6ce9      	ldr	r1, [r5, #76]	; 0x4c
 800b890:	2204      	movs	r2, #4
 800b892:	f104 0009 	add.w	r0, r4, #9
 800b896:	f000 fc5f 	bl	800c158 <Serialize>
  for (i = 0; i < fs_list[0]; i++)
 800b89a:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
 800b89c:	2b00      	cmp	r3, #0
 800b89e:	f000 80be 	beq.w	800ba1e <SC_Get_Full_Scale_List+0x2a2>
 800b8a2:	f105 084c 	add.w	r8, r5, #76	; 0x4c
 800b8a6:	f104 070d 	add.w	r7, r4, #13
    Serialize(&Msg->Data[9 + i * 4], fs_list[i + 1], 4);
 800b8aa:	4638      	mov	r0, r7
 800b8ac:	2204      	movs	r2, #4
 800b8ae:	f858 1f04 	ldr.w	r1, [r8, #4]!
 800b8b2:	f000 fc51 	bl	800c158 <Serialize>
  for (i = 0; i < fs_list[0]; i++)
 800b8b6:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
 800b8b8:	3601      	adds	r6, #1
 800b8ba:	429e      	cmp	r6, r3
 800b8bc:	f107 0704 	add.w	r7, r7, #4
 800b8c0:	d3f3      	bcc.n	800b8aa <SC_Get_Full_Scale_List+0x12e>
 800b8c2:	e79f      	b.n	800b804 <SC_Get_Full_Scale_List+0x88>
      BSP_MAGNETO_Get_Instance( MAGNETO_handle, &instance );
 800b8c4:	4b5d      	ldr	r3, [pc, #372]	; (800ba3c <SC_Get_Full_Scale_List+0x2c0>)
 800b8c6:	f10d 0107 	add.w	r1, sp, #7
 800b8ca:	6818      	ldr	r0, [r3, #0]
 800b8cc:	f7fc fab4 	bl	8007e38 <BSP_MAGNETO_Get_Instance>
      switch (instance)
 800b8d0:	f89d 6007 	ldrb.w	r6, [sp, #7]
 800b8d4:	2e00      	cmp	r6, #0
 800b8d6:	f47f af69 	bne.w	800b7ac <SC_Get_Full_Scale_List+0x30>
  Serialize(&Msg->Data[5], fs_list[0], 4);
 800b8da:	4d56      	ldr	r5, [pc, #344]	; (800ba34 <SC_Get_Full_Scale_List+0x2b8>)
  BUILD_REPLY_HEADER(Msg);
 800b8dc:	4620      	mov	r0, r4
 800b8de:	f7fe fdc5 	bl	800a46c <BUILD_REPLY_HEADER>
  Serialize(&Msg->Data[5], fs_list[0], 4);
 800b8e2:	6e29      	ldr	r1, [r5, #96]	; 0x60
 800b8e4:	2204      	movs	r2, #4
 800b8e6:	f104 0009 	add.w	r0, r4, #9
 800b8ea:	f000 fc35 	bl	800c158 <Serialize>
  for (i = 0; i < fs_list[0]; i++)
 800b8ee:	6e2b      	ldr	r3, [r5, #96]	; 0x60
 800b8f0:	2b00      	cmp	r3, #0
 800b8f2:	f000 8094 	beq.w	800ba1e <SC_Get_Full_Scale_List+0x2a2>
 800b8f6:	f105 0860 	add.w	r8, r5, #96	; 0x60
 800b8fa:	f104 070d 	add.w	r7, r4, #13
    Serialize(&Msg->Data[9 + i * 4], fs_list[i + 1], 4);
 800b8fe:	4638      	mov	r0, r7
 800b900:	2204      	movs	r2, #4
 800b902:	f858 1f04 	ldr.w	r1, [r8, #4]!
 800b906:	f000 fc27 	bl	800c158 <Serialize>
  for (i = 0; i < fs_list[0]; i++)
 800b90a:	6e2b      	ldr	r3, [r5, #96]	; 0x60
 800b90c:	3601      	adds	r6, #1
 800b90e:	429e      	cmp	r6, r3
 800b910:	f107 0704 	add.w	r7, r7, #4
 800b914:	d3f3      	bcc.n	800b8fe <SC_Get_Full_Scale_List+0x182>
 800b916:	e775      	b.n	800b804 <SC_Get_Full_Scale_List+0x88>
      BSP_TEMPERATURE_Get_Instance( TEMPERATURE_handle, &instance );
 800b918:	4b49      	ldr	r3, [pc, #292]	; (800ba40 <SC_Get_Full_Scale_List+0x2c4>)
 800b91a:	f10d 0107 	add.w	r1, sp, #7
 800b91e:	6818      	ldr	r0, [r3, #0]
 800b920:	f7fc fcf2 	bl	8008308 <BSP_TEMPERATURE_Get_Instance>
      switch (instance)
 800b924:	f89d 6007 	ldrb.w	r6, [sp, #7]
 800b928:	2e00      	cmp	r6, #0
 800b92a:	d03f      	beq.n	800b9ac <SC_Get_Full_Scale_List+0x230>
 800b92c:	2e01      	cmp	r6, #1
 800b92e:	f47f af3d 	bne.w	800b7ac <SC_Get_Full_Scale_List+0x30>
  Serialize(&Msg->Data[5], fs_list[0], 4);
 800b932:	4d3e      	ldr	r5, [pc, #248]	; (800ba2c <SC_Get_Full_Scale_List+0x2b0>)
  BUILD_REPLY_HEADER(Msg);
 800b934:	4620      	mov	r0, r4
 800b936:	f7fe fd99 	bl	800a46c <BUILD_REPLY_HEADER>
  Serialize(&Msg->Data[5], fs_list[0], 4);
 800b93a:	6869      	ldr	r1, [r5, #4]
 800b93c:	2204      	movs	r2, #4
 800b93e:	f104 0009 	add.w	r0, r4, #9
 800b942:	f000 fc09 	bl	800c158 <Serialize>
  for (i = 0; i < fs_list[0]; i++)
 800b946:	686b      	ldr	r3, [r5, #4]
 800b948:	2b00      	cmp	r3, #0
 800b94a:	d068      	beq.n	800ba1e <SC_Get_Full_Scale_List+0x2a2>
 800b94c:	f105 0804 	add.w	r8, r5, #4
 800b950:	f104 070d 	add.w	r7, r4, #13
 800b954:	2600      	movs	r6, #0
    Serialize(&Msg->Data[9 + i * 4], fs_list[i + 1], 4);
 800b956:	4638      	mov	r0, r7
 800b958:	2204      	movs	r2, #4
 800b95a:	f858 1f04 	ldr.w	r1, [r8, #4]!
 800b95e:	f000 fbfb 	bl	800c158 <Serialize>
  for (i = 0; i < fs_list[0]; i++)
 800b962:	686b      	ldr	r3, [r5, #4]
 800b964:	3601      	adds	r6, #1
 800b966:	429e      	cmp	r6, r3
 800b968:	f107 0704 	add.w	r7, r7, #4
 800b96c:	d3f3      	bcc.n	800b956 <SC_Get_Full_Scale_List+0x1da>
 800b96e:	e749      	b.n	800b804 <SC_Get_Full_Scale_List+0x88>
  Serialize(&Msg->Data[5], fs_list[0], 4);
 800b970:	4d2e      	ldr	r5, [pc, #184]	; (800ba2c <SC_Get_Full_Scale_List+0x2b0>)
  BUILD_REPLY_HEADER(Msg);
 800b972:	4620      	mov	r0, r4
 800b974:	f7fe fd7a 	bl	800a46c <BUILD_REPLY_HEADER>
  Serialize(&Msg->Data[5], fs_list[0], 4);
 800b978:	68a9      	ldr	r1, [r5, #8]
 800b97a:	2204      	movs	r2, #4
 800b97c:	f104 0009 	add.w	r0, r4, #9
 800b980:	f000 fbea 	bl	800c158 <Serialize>
  for (i = 0; i < fs_list[0]; i++)
 800b984:	68ab      	ldr	r3, [r5, #8]
 800b986:	2b00      	cmp	r3, #0
 800b988:	d049      	beq.n	800ba1e <SC_Get_Full_Scale_List+0x2a2>
 800b98a:	f105 0808 	add.w	r8, r5, #8
 800b98e:	f104 070d 	add.w	r7, r4, #13
    Serialize(&Msg->Data[9 + i * 4], fs_list[i + 1], 4);
 800b992:	4638      	mov	r0, r7
 800b994:	2204      	movs	r2, #4
 800b996:	f858 1f04 	ldr.w	r1, [r8, #4]!
 800b99a:	f000 fbdd 	bl	800c158 <Serialize>
  for (i = 0; i < fs_list[0]; i++)
 800b99e:	68ab      	ldr	r3, [r5, #8]
 800b9a0:	3601      	adds	r6, #1
 800b9a2:	429e      	cmp	r6, r3
 800b9a4:	f107 0704 	add.w	r7, r7, #4
 800b9a8:	d3f3      	bcc.n	800b992 <SC_Get_Full_Scale_List+0x216>
 800b9aa:	e72b      	b.n	800b804 <SC_Get_Full_Scale_List+0x88>
  Serialize(&Msg->Data[5], fs_list[0], 4);
 800b9ac:	4d1f      	ldr	r5, [pc, #124]	; (800ba2c <SC_Get_Full_Scale_List+0x2b0>)
  BUILD_REPLY_HEADER(Msg);
 800b9ae:	4620      	mov	r0, r4
 800b9b0:	f7fe fd5c 	bl	800a46c <BUILD_REPLY_HEADER>
  Serialize(&Msg->Data[5], fs_list[0], 4);
 800b9b4:	6829      	ldr	r1, [r5, #0]
 800b9b6:	2204      	movs	r2, #4
 800b9b8:	f104 0009 	add.w	r0, r4, #9
 800b9bc:	f000 fbcc 	bl	800c158 <Serialize>
  for (i = 0; i < fs_list[0]; i++)
 800b9c0:	682b      	ldr	r3, [r5, #0]
 800b9c2:	b363      	cbz	r3, 800ba1e <SC_Get_Full_Scale_List+0x2a2>
 800b9c4:	46a8      	mov	r8, r5
 800b9c6:	f104 070d 	add.w	r7, r4, #13
    Serialize(&Msg->Data[9 + i * 4], fs_list[i + 1], 4);
 800b9ca:	4638      	mov	r0, r7
 800b9cc:	2204      	movs	r2, #4
 800b9ce:	f858 1f04 	ldr.w	r1, [r8, #4]!
 800b9d2:	f000 fbc1 	bl	800c158 <Serialize>
  for (i = 0; i < fs_list[0]; i++)
 800b9d6:	682b      	ldr	r3, [r5, #0]
 800b9d8:	3601      	adds	r6, #1
 800b9da:	429e      	cmp	r6, r3
 800b9dc:	f107 0704 	add.w	r7, r7, #4
 800b9e0:	d3f3      	bcc.n	800b9ca <SC_Get_Full_Scale_List+0x24e>
 800b9e2:	e70f      	b.n	800b804 <SC_Get_Full_Scale_List+0x88>
  Serialize(&Msg->Data[5], fs_list[0], 4);
 800b9e4:	4d13      	ldr	r5, [pc, #76]	; (800ba34 <SC_Get_Full_Scale_List+0x2b8>)
  BUILD_REPLY_HEADER(Msg);
 800b9e6:	4620      	mov	r0, r4
 800b9e8:	f7fe fd40 	bl	800a46c <BUILD_REPLY_HEADER>
  Serialize(&Msg->Data[5], fs_list[0], 4);
 800b9ec:	6a69      	ldr	r1, [r5, #36]	; 0x24
 800b9ee:	2204      	movs	r2, #4
 800b9f0:	f104 0009 	add.w	r0, r4, #9
 800b9f4:	f000 fbb0 	bl	800c158 <Serialize>
  for (i = 0; i < fs_list[0]; i++)
 800b9f8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800b9fa:	b183      	cbz	r3, 800ba1e <SC_Get_Full_Scale_List+0x2a2>
 800b9fc:	f105 0824 	add.w	r8, r5, #36	; 0x24
 800ba00:	f104 070d 	add.w	r7, r4, #13
    Serialize(&Msg->Data[9 + i * 4], fs_list[i + 1], 4);
 800ba04:	4638      	mov	r0, r7
 800ba06:	2204      	movs	r2, #4
 800ba08:	f858 1f04 	ldr.w	r1, [r8, #4]!
 800ba0c:	f000 fba4 	bl	800c158 <Serialize>
  for (i = 0; i < fs_list[0]; i++)
 800ba10:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800ba12:	3601      	adds	r6, #1
 800ba14:	429e      	cmp	r6, r3
 800ba16:	f107 0704 	add.w	r7, r7, #4
 800ba1a:	d3f3      	bcc.n	800ba04 <SC_Get_Full_Scale_List+0x288>
 800ba1c:	e6f2      	b.n	800b804 <SC_Get_Full_Scale_List+0x88>
 800ba1e:	2609      	movs	r6, #9
 800ba20:	e6f2      	b.n	800b808 <SC_Get_Full_Scale_List+0x8c>
 800ba22:	bf00      	nop
 800ba24:	20000708 	.word	0x20000708
 800ba28:	20000710 	.word	0x20000710
 800ba2c:	20000730 	.word	0x20000730
 800ba30:	200006fc 	.word	0x200006fc
 800ba34:	200003dc 	.word	0x200003dc
 800ba38:	20000700 	.word	0x20000700
 800ba3c:	20000704 	.word	0x20000704
 800ba40:	2000070c 	.word	0x2000070c

0800ba44 <SC_Get_ODR_List>:
{
 800ba44:	b570      	push	{r4, r5, r6, lr}
  switch (Msg->Data[4])
 800ba46:	7a03      	ldrb	r3, [r0, #8]
 800ba48:	3b01      	subs	r3, #1
{
 800ba4a:	b082      	sub	sp, #8
 800ba4c:	4605      	mov	r5, r0
  switch (Msg->Data[4])
 800ba4e:	2b05      	cmp	r3, #5
 800ba50:	d812      	bhi.n	800ba78 <SC_Get_ODR_List+0x34>
 800ba52:	e8df f013 	tbh	[pc, r3, lsl #1]
 800ba56:	0053      	.short	0x0053
 800ba58:	00c5008d 	.word	0x00c5008d
 800ba5c:	000600fd 	.word	0x000600fd
 800ba60:	0014      	.short	0x0014
      BSP_HUMIDITY_Get_Instance( HUMIDITY_handle, &instance );
 800ba62:	4bdb      	ldr	r3, [pc, #876]	; (800bdd0 <SC_Get_ODR_List+0x38c>)
 800ba64:	f10d 0107 	add.w	r1, sp, #7
 800ba68:	6818      	ldr	r0, [r3, #0]
 800ba6a:	f7fc f8f1 	bl	8007c50 <BSP_HUMIDITY_Get_Instance>
      switch (instance)
 800ba6e:	f89d 6007 	ldrb.w	r6, [sp, #7]
 800ba72:	2e00      	cmp	r6, #0
 800ba74:	f000 8126 	beq.w	800bcc4 <SC_Get_ODR_List+0x280>
          return 0;
 800ba78:	2000      	movs	r0, #0
}
 800ba7a:	b002      	add	sp, #8
 800ba7c:	bd70      	pop	{r4, r5, r6, pc}
      BSP_PRESSURE_Get_Instance( PRESSURE_handle, &instance );
 800ba7e:	4bd5      	ldr	r3, [pc, #852]	; (800bdd4 <SC_Get_ODR_List+0x390>)
 800ba80:	f10d 0107 	add.w	r1, sp, #7
 800ba84:	6818      	ldr	r0, [r3, #0]
 800ba86:	f7fc fad5 	bl	8008034 <BSP_PRESSURE_Get_Instance>
      switch (instance)
 800ba8a:	f89d 6007 	ldrb.w	r6, [sp, #7]
 800ba8e:	2e00      	cmp	r6, #0
 800ba90:	d1f2      	bne.n	800ba78 <SC_Get_ODR_List+0x34>
void Send_Sensor_ODR_List(TMsg *Msg, float* odr_list)
{
  int i = 0;
  BUILD_REPLY_HEADER(Msg);

  Serialize(&Msg->Data[5], (int) odr_list[0], 4);
 800ba92:	4cd1      	ldr	r4, [pc, #836]	; (800bdd8 <SC_Get_ODR_List+0x394>)
  BUILD_REPLY_HEADER(Msg);
 800ba94:	4628      	mov	r0, r5
 800ba96:	f7fe fce9 	bl	800a46c <BUILD_REPLY_HEADER>
  Serialize(&Msg->Data[5], (int) odr_list[0], 4);
 800ba9a:	edd4 7a4a 	vldr	s15, [r4, #296]	; 0x128
 800ba9e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800baa2:	2204      	movs	r2, #4
 800baa4:	ee17 1a90 	vmov	r1, s15
 800baa8:	f105 0009 	add.w	r0, r5, #9
 800baac:	f000 fb54 	bl	800c158 <Serialize>

  for (i = 0; i < odr_list[0]; i++)
 800bab0:	edd4 7a4a 	vldr	s15, [r4, #296]	; 0x128
 800bab4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800bab8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800babc:	f340 8186 	ble.w	800bdcc <SC_Get_ODR_List+0x388>
 800bac0:	4633      	mov	r3, r6
 800bac2:	f504 7196 	add.w	r1, r4, #300	; 0x12c
 800bac6:	f105 020d 	add.w	r2, r5, #13
  {
    FloatToArray(&Msg->Data[9 + i * 4], odr_list[i + 1]);
 800baca:	f851 0b04 	ldr.w	r0, [r1], #4
  UART_SendMsg(Msg);
}

void FloatToArray(uint8_t *Dest, float data)
{
  memcpy(Dest, (void *) &data, 4);
 800bace:	f842 0b04 	str.w	r0, [r2], #4
  for (i = 0; i < odr_list[0]; i++)
 800bad2:	3301      	adds	r3, #1
 800bad4:	ee07 3a10 	vmov	s14, r3
 800bad8:	edd4 7a4a 	vldr	s15, [r4, #296]	; 0x128
 800badc:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800bae0:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800bae4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bae8:	d4ef      	bmi.n	800baca <SC_Get_ODR_List+0x86>
 800baea:	009b      	lsls	r3, r3, #2
 800baec:	3309      	adds	r3, #9
  UART_SendMsg(Msg);
 800baee:	4628      	mov	r0, r5
  Msg->Len = 9 + i * 4;
 800baf0:	602b      	str	r3, [r5, #0]
  UART_SendMsg(Msg);
 800baf2:	f7fe fec1 	bl	800a878 <UART_SendMsg>
          return 1;
 800baf6:	2001      	movs	r0, #1
}
 800baf8:	b002      	add	sp, #8
 800bafa:	bd70      	pop	{r4, r5, r6, pc}
      BSP_ACCELERO_Get_Instance( ACCELERO_handle, &instance );
 800bafc:	4bb7      	ldr	r3, [pc, #732]	; (800bddc <SC_Get_ODR_List+0x398>)
 800bafe:	f10d 0107 	add.w	r1, sp, #7
 800bb02:	6818      	ldr	r0, [r3, #0]
 800bb04:	f7fb fe92 	bl	800782c <BSP_ACCELERO_Get_Instance>
      switch (instance)
 800bb08:	f89d 6007 	ldrb.w	r6, [sp, #7]
 800bb0c:	2e00      	cmp	r6, #0
 800bb0e:	f000 8131 	beq.w	800bd74 <SC_Get_ODR_List+0x330>
 800bb12:	2e01      	cmp	r6, #1
 800bb14:	d1b0      	bne.n	800ba78 <SC_Get_ODR_List+0x34>
  Serialize(&Msg->Data[5], (int) odr_list[0], 4);
 800bb16:	4cb0      	ldr	r4, [pc, #704]	; (800bdd8 <SC_Get_ODR_List+0x394>)
  BUILD_REPLY_HEADER(Msg);
 800bb18:	4628      	mov	r0, r5
 800bb1a:	f7fe fca7 	bl	800a46c <BUILD_REPLY_HEADER>
  Serialize(&Msg->Data[5], (int) odr_list[0], 4);
 800bb1e:	edd4 7a25 	vldr	s15, [r4, #148]	; 0x94
 800bb22:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800bb26:	2204      	movs	r2, #4
 800bb28:	ee17 1a90 	vmov	r1, s15
 800bb2c:	f105 0009 	add.w	r0, r5, #9
 800bb30:	f000 fb12 	bl	800c158 <Serialize>
  for (i = 0; i < odr_list[0]; i++)
 800bb34:	edd4 7a25 	vldr	s15, [r4, #148]	; 0x94
 800bb38:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800bb3c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bb40:	f340 8144 	ble.w	800bdcc <SC_Get_ODR_List+0x388>
 800bb44:	f104 0198 	add.w	r1, r4, #152	; 0x98
 800bb48:	f105 020d 	add.w	r2, r5, #13
 800bb4c:	2300      	movs	r3, #0
    FloatToArray(&Msg->Data[9 + i * 4], odr_list[i + 1]);
 800bb4e:	f851 0b04 	ldr.w	r0, [r1], #4
  memcpy(Dest, (void *) &data, 4);
 800bb52:	f842 0b04 	str.w	r0, [r2], #4
  for (i = 0; i < odr_list[0]; i++)
 800bb56:	3301      	adds	r3, #1
 800bb58:	ee07 3a10 	vmov	s14, r3
 800bb5c:	edd4 7a25 	vldr	s15, [r4, #148]	; 0x94
 800bb60:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800bb64:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800bb68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bb6c:	d4ef      	bmi.n	800bb4e <SC_Get_ODR_List+0x10a>
 800bb6e:	e7bc      	b.n	800baea <SC_Get_ODR_List+0xa6>
      BSP_GYRO_Get_Instance( GYRO_handle, &instance );
 800bb70:	4b9b      	ldr	r3, [pc, #620]	; (800bde0 <SC_Get_ODR_List+0x39c>)
 800bb72:	f10d 0107 	add.w	r1, sp, #7
 800bb76:	6818      	ldr	r0, [r3, #0]
 800bb78:	f7fb ff66 	bl	8007a48 <BSP_GYRO_Get_Instance>
      switch (instance)
 800bb7c:	f89d 6007 	ldrb.w	r6, [sp, #7]
 800bb80:	2e00      	cmp	r6, #0
 800bb82:	f47f af79 	bne.w	800ba78 <SC_Get_ODR_List+0x34>
  Serialize(&Msg->Data[5], (int) odr_list[0], 4);
 800bb86:	4c94      	ldr	r4, [pc, #592]	; (800bdd8 <SC_Get_ODR_List+0x394>)
  BUILD_REPLY_HEADER(Msg);
 800bb88:	4628      	mov	r0, r5
 800bb8a:	f7fe fc6f 	bl	800a46c <BUILD_REPLY_HEADER>
  Serialize(&Msg->Data[5], (int) odr_list[0], 4);
 800bb8e:	edd4 7a2d 	vldr	s15, [r4, #180]	; 0xb4
 800bb92:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800bb96:	2204      	movs	r2, #4
 800bb98:	ee17 1a90 	vmov	r1, s15
 800bb9c:	f105 0009 	add.w	r0, r5, #9
 800bba0:	f000 fada 	bl	800c158 <Serialize>
  for (i = 0; i < odr_list[0]; i++)
 800bba4:	edd4 7a2d 	vldr	s15, [r4, #180]	; 0xb4
 800bba8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800bbac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bbb0:	f340 810c 	ble.w	800bdcc <SC_Get_ODR_List+0x388>
 800bbb4:	4633      	mov	r3, r6
 800bbb6:	f104 01b8 	add.w	r1, r4, #184	; 0xb8
 800bbba:	f105 020d 	add.w	r2, r5, #13
    FloatToArray(&Msg->Data[9 + i * 4], odr_list[i + 1]);
 800bbbe:	f851 0b04 	ldr.w	r0, [r1], #4
  memcpy(Dest, (void *) &data, 4);
 800bbc2:	f842 0b04 	str.w	r0, [r2], #4
  for (i = 0; i < odr_list[0]; i++)
 800bbc6:	3301      	adds	r3, #1
 800bbc8:	ee07 3a10 	vmov	s14, r3
 800bbcc:	edd4 7a2d 	vldr	s15, [r4, #180]	; 0xb4
 800bbd0:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800bbd4:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800bbd8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bbdc:	d4ef      	bmi.n	800bbbe <SC_Get_ODR_List+0x17a>
 800bbde:	e784      	b.n	800baea <SC_Get_ODR_List+0xa6>
      BSP_MAGNETO_Get_Instance( MAGNETO_handle, &instance );
 800bbe0:	4b80      	ldr	r3, [pc, #512]	; (800bde4 <SC_Get_ODR_List+0x3a0>)
 800bbe2:	f10d 0107 	add.w	r1, sp, #7
 800bbe6:	6818      	ldr	r0, [r3, #0]
 800bbe8:	f7fc f926 	bl	8007e38 <BSP_MAGNETO_Get_Instance>
      switch (instance)
 800bbec:	f89d 6007 	ldrb.w	r6, [sp, #7]
 800bbf0:	2e00      	cmp	r6, #0
 800bbf2:	f47f af41 	bne.w	800ba78 <SC_Get_ODR_List+0x34>
  Serialize(&Msg->Data[5], (int) odr_list[0], 4);
 800bbf6:	4c78      	ldr	r4, [pc, #480]	; (800bdd8 <SC_Get_ODR_List+0x394>)
  BUILD_REPLY_HEADER(Msg);
 800bbf8:	4628      	mov	r0, r5
 800bbfa:	f7fe fc37 	bl	800a46c <BUILD_REPLY_HEADER>
  Serialize(&Msg->Data[5], (int) odr_list[0], 4);
 800bbfe:	edd4 7a38 	vldr	s15, [r4, #224]	; 0xe0
 800bc02:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800bc06:	2204      	movs	r2, #4
 800bc08:	ee17 1a90 	vmov	r1, s15
 800bc0c:	f105 0009 	add.w	r0, r5, #9
 800bc10:	f000 faa2 	bl	800c158 <Serialize>
  for (i = 0; i < odr_list[0]; i++)
 800bc14:	edd4 7a38 	vldr	s15, [r4, #224]	; 0xe0
 800bc18:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800bc1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bc20:	f340 80d4 	ble.w	800bdcc <SC_Get_ODR_List+0x388>
 800bc24:	4633      	mov	r3, r6
 800bc26:	f104 01e4 	add.w	r1, r4, #228	; 0xe4
 800bc2a:	f105 020d 	add.w	r2, r5, #13
    FloatToArray(&Msg->Data[9 + i * 4], odr_list[i + 1]);
 800bc2e:	f851 0b04 	ldr.w	r0, [r1], #4
  memcpy(Dest, (void *) &data, 4);
 800bc32:	f842 0b04 	str.w	r0, [r2], #4
  for (i = 0; i < odr_list[0]; i++)
 800bc36:	3301      	adds	r3, #1
 800bc38:	ee07 3a10 	vmov	s14, r3
 800bc3c:	edd4 7a38 	vldr	s15, [r4, #224]	; 0xe0
 800bc40:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800bc44:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800bc48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bc4c:	d4ef      	bmi.n	800bc2e <SC_Get_ODR_List+0x1ea>
 800bc4e:	e74c      	b.n	800baea <SC_Get_ODR_List+0xa6>
      BSP_TEMPERATURE_Get_Instance( TEMPERATURE_handle, &instance );
 800bc50:	4b65      	ldr	r3, [pc, #404]	; (800bde8 <SC_Get_ODR_List+0x3a4>)
 800bc52:	f10d 0107 	add.w	r1, sp, #7
 800bc56:	6818      	ldr	r0, [r3, #0]
 800bc58:	f7fc fb56 	bl	8008308 <BSP_TEMPERATURE_Get_Instance>
      switch (instance)
 800bc5c:	f89d 6007 	ldrb.w	r6, [sp, #7]
 800bc60:	2e00      	cmp	r6, #0
 800bc62:	d05b      	beq.n	800bd1c <SC_Get_ODR_List+0x2d8>
 800bc64:	2e01      	cmp	r6, #1
 800bc66:	f47f af07 	bne.w	800ba78 <SC_Get_ODR_List+0x34>
  Serialize(&Msg->Data[5], (int) odr_list[0], 4);
 800bc6a:	4c5b      	ldr	r4, [pc, #364]	; (800bdd8 <SC_Get_ODR_List+0x394>)
  BUILD_REPLY_HEADER(Msg);
 800bc6c:	4628      	mov	r0, r5
 800bc6e:	f7fe fbfd 	bl	800a46c <BUILD_REPLY_HEADER>
  Serialize(&Msg->Data[5], (int) odr_list[0], 4);
 800bc72:	edd4 7a40 	vldr	s15, [r4, #256]	; 0x100
 800bc76:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800bc7a:	2204      	movs	r2, #4
 800bc7c:	ee17 1a90 	vmov	r1, s15
 800bc80:	f105 0009 	add.w	r0, r5, #9
 800bc84:	f000 fa68 	bl	800c158 <Serialize>
  for (i = 0; i < odr_list[0]; i++)
 800bc88:	edd4 7a40 	vldr	s15, [r4, #256]	; 0x100
 800bc8c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800bc90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bc94:	f340 809a 	ble.w	800bdcc <SC_Get_ODR_List+0x388>
 800bc98:	f504 7182 	add.w	r1, r4, #260	; 0x104
 800bc9c:	f105 020d 	add.w	r2, r5, #13
 800bca0:	2300      	movs	r3, #0
    FloatToArray(&Msg->Data[9 + i * 4], odr_list[i + 1]);
 800bca2:	f851 0b04 	ldr.w	r0, [r1], #4
  memcpy(Dest, (void *) &data, 4);
 800bca6:	f842 0b04 	str.w	r0, [r2], #4
  for (i = 0; i < odr_list[0]; i++)
 800bcaa:	3301      	adds	r3, #1
 800bcac:	ee07 3a10 	vmov	s14, r3
 800bcb0:	edd4 7a40 	vldr	s15, [r4, #256]	; 0x100
 800bcb4:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800bcb8:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800bcbc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bcc0:	d4ef      	bmi.n	800bca2 <SC_Get_ODR_List+0x25e>
 800bcc2:	e712      	b.n	800baea <SC_Get_ODR_List+0xa6>
  Serialize(&Msg->Data[5], (int) odr_list[0], 4);
 800bcc4:	4c44      	ldr	r4, [pc, #272]	; (800bdd8 <SC_Get_ODR_List+0x394>)
  BUILD_REPLY_HEADER(Msg);
 800bcc6:	4628      	mov	r0, r5
 800bcc8:	f7fe fbd0 	bl	800a46c <BUILD_REPLY_HEADER>
  Serialize(&Msg->Data[5], (int) odr_list[0], 4);
 800bccc:	edd4 7a46 	vldr	s15, [r4, #280]	; 0x118
 800bcd0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800bcd4:	2204      	movs	r2, #4
 800bcd6:	ee17 1a90 	vmov	r1, s15
 800bcda:	f105 0009 	add.w	r0, r5, #9
 800bcde:	f000 fa3b 	bl	800c158 <Serialize>
  for (i = 0; i < odr_list[0]; i++)
 800bce2:	edd4 7a46 	vldr	s15, [r4, #280]	; 0x118
 800bce6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800bcea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bcee:	dd6d      	ble.n	800bdcc <SC_Get_ODR_List+0x388>
 800bcf0:	4633      	mov	r3, r6
 800bcf2:	f504 718e 	add.w	r1, r4, #284	; 0x11c
 800bcf6:	f105 020d 	add.w	r2, r5, #13
    FloatToArray(&Msg->Data[9 + i * 4], odr_list[i + 1]);
 800bcfa:	f851 0b04 	ldr.w	r0, [r1], #4
  memcpy(Dest, (void *) &data, 4);
 800bcfe:	f842 0b04 	str.w	r0, [r2], #4
  for (i = 0; i < odr_list[0]; i++)
 800bd02:	3301      	adds	r3, #1
 800bd04:	ee07 3a10 	vmov	s14, r3
 800bd08:	edd4 7a46 	vldr	s15, [r4, #280]	; 0x118
 800bd0c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800bd10:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800bd14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bd18:	d4ef      	bmi.n	800bcfa <SC_Get_ODR_List+0x2b6>
 800bd1a:	e6e6      	b.n	800baea <SC_Get_ODR_List+0xa6>
  Serialize(&Msg->Data[5], (int) odr_list[0], 4);
 800bd1c:	4c2e      	ldr	r4, [pc, #184]	; (800bdd8 <SC_Get_ODR_List+0x394>)
  BUILD_REPLY_HEADER(Msg);
 800bd1e:	4628      	mov	r0, r5
 800bd20:	f7fe fba4 	bl	800a46c <BUILD_REPLY_HEADER>
  Serialize(&Msg->Data[5], (int) odr_list[0], 4);
 800bd24:	edd4 7a3c 	vldr	s15, [r4, #240]	; 0xf0
 800bd28:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800bd2c:	2204      	movs	r2, #4
 800bd2e:	ee17 1a90 	vmov	r1, s15
 800bd32:	f105 0009 	add.w	r0, r5, #9
 800bd36:	f000 fa0f 	bl	800c158 <Serialize>
  for (i = 0; i < odr_list[0]; i++)
 800bd3a:	edd4 7a3c 	vldr	s15, [r4, #240]	; 0xf0
 800bd3e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800bd42:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bd46:	dd41      	ble.n	800bdcc <SC_Get_ODR_List+0x388>
 800bd48:	4633      	mov	r3, r6
 800bd4a:	f104 01f4 	add.w	r1, r4, #244	; 0xf4
 800bd4e:	f105 020d 	add.w	r2, r5, #13
    FloatToArray(&Msg->Data[9 + i * 4], odr_list[i + 1]);
 800bd52:	f851 0b04 	ldr.w	r0, [r1], #4
  memcpy(Dest, (void *) &data, 4);
 800bd56:	f842 0b04 	str.w	r0, [r2], #4
  for (i = 0; i < odr_list[0]; i++)
 800bd5a:	3301      	adds	r3, #1
 800bd5c:	ee07 3a10 	vmov	s14, r3
 800bd60:	edd4 7a3c 	vldr	s15, [r4, #240]	; 0xf0
 800bd64:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800bd68:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800bd6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bd70:	d4ef      	bmi.n	800bd52 <SC_Get_ODR_List+0x30e>
 800bd72:	e6ba      	b.n	800baea <SC_Get_ODR_List+0xa6>
  Serialize(&Msg->Data[5], (int) odr_list[0], 4);
 800bd74:	4c18      	ldr	r4, [pc, #96]	; (800bdd8 <SC_Get_ODR_List+0x394>)
  BUILD_REPLY_HEADER(Msg);
 800bd76:	4628      	mov	r0, r5
 800bd78:	f7fe fb78 	bl	800a46c <BUILD_REPLY_HEADER>
  Serialize(&Msg->Data[5], (int) odr_list[0], 4);
 800bd7c:	edd4 7a1a 	vldr	s15, [r4, #104]	; 0x68
 800bd80:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800bd84:	2204      	movs	r2, #4
 800bd86:	ee17 1a90 	vmov	r1, s15
 800bd8a:	f105 0009 	add.w	r0, r5, #9
 800bd8e:	f000 f9e3 	bl	800c158 <Serialize>
  for (i = 0; i < odr_list[0]; i++)
 800bd92:	edd4 7a1a 	vldr	s15, [r4, #104]	; 0x68
 800bd96:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800bd9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bd9e:	dd15      	ble.n	800bdcc <SC_Get_ODR_List+0x388>
 800bda0:	4633      	mov	r3, r6
 800bda2:	f104 016c 	add.w	r1, r4, #108	; 0x6c
 800bda6:	f105 020d 	add.w	r2, r5, #13
    FloatToArray(&Msg->Data[9 + i * 4], odr_list[i + 1]);
 800bdaa:	f851 0b04 	ldr.w	r0, [r1], #4
  memcpy(Dest, (void *) &data, 4);
 800bdae:	f842 0b04 	str.w	r0, [r2], #4
  for (i = 0; i < odr_list[0]; i++)
 800bdb2:	3301      	adds	r3, #1
 800bdb4:	ee07 3a10 	vmov	s14, r3
 800bdb8:	edd4 7a1a 	vldr	s15, [r4, #104]	; 0x68
 800bdbc:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800bdc0:	eeb4 7ae7 	vcmpe.f32	s14, s15
 800bdc4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bdc8:	d4ef      	bmi.n	800bdaa <SC_Get_ODR_List+0x366>
 800bdca:	e68e      	b.n	800baea <SC_Get_ODR_List+0xa6>
 800bdcc:	2309      	movs	r3, #9
 800bdce:	e68e      	b.n	800baee <SC_Get_ODR_List+0xaa>
 800bdd0:	20000708 	.word	0x20000708
 800bdd4:	20000710 	.word	0x20000710
 800bdd8:	200003dc 	.word	0x200003dc
 800bddc:	200006fc 	.word	0x200006fc
 800bde0:	20000700 	.word	0x20000700
 800bde4:	20000704 	.word	0x20000704
 800bde8:	2000070c 	.word	0x2000070c

0800bdec <SC_Set_ODR>:
{
 800bdec:	b510      	push	{r4, lr}
  switch (Msg->Data[4])
 800bdee:	7a03      	ldrb	r3, [r0, #8]
}

void ArrayToFloat(uint8_t *Source, float *data)
{
  memcpy((void *) data, Source, 4);
 800bdf0:	f8d0 2009 	ldr.w	r2, [r0, #9]
{
 800bdf4:	b082      	sub	sp, #8
  switch (Msg->Data[4])
 800bdf6:	3b01      	subs	r3, #1
{
 800bdf8:	4604      	mov	r4, r0
  memcpy((void *) data, Source, 4);
 800bdfa:	9201      	str	r2, [sp, #4]
  switch (Msg->Data[4])
 800bdfc:	2b05      	cmp	r3, #5
 800bdfe:	d83a      	bhi.n	800be76 <SC_Set_ODR+0x8a>
 800be00:	e8df f003 	tbb	[pc, r3]
 800be04:	2b241d0c 	.word	0x2b241d0c
 800be08:	0332      	.short	0x0332
      BSP_PRESSURE_Set_ODR_Value( PRESSURE_handle, odr );
 800be0a:	4b1c      	ldr	r3, [pc, #112]	; (800be7c <SC_Set_ODR+0x90>)
 800be0c:	ee00 2a10 	vmov	s0, r2
 800be10:	6818      	ldr	r0, [r3, #0]
 800be12:	f7fc f929 	bl	8008068 <BSP_PRESSURE_Set_ODR_Value>
      return 0;
 800be16:	2000      	movs	r0, #0
}
 800be18:	b002      	add	sp, #8
 800be1a:	bd10      	pop	{r4, pc}
      BSP_ACCELERO_Set_ODR_Value( ACCELERO_handle, odr );
 800be1c:	4b18      	ldr	r3, [pc, #96]	; (800be80 <SC_Set_ODR+0x94>)
 800be1e:	ee00 2a10 	vmov	s0, r2
 800be22:	6818      	ldr	r0, [r3, #0]
 800be24:	f7fb fd1c 	bl	8007860 <BSP_ACCELERO_Set_ODR_Value>
  BUILD_REPLY_HEADER(Msg);
 800be28:	4620      	mov	r0, r4
 800be2a:	f7fe fb1f 	bl	800a46c <BUILD_REPLY_HEADER>
  Msg->Len = 9;
 800be2e:	2309      	movs	r3, #9
  UART_SendMsg(Msg);
 800be30:	4620      	mov	r0, r4
  Msg->Len = 9;
 800be32:	6023      	str	r3, [r4, #0]
  UART_SendMsg(Msg);
 800be34:	f7fe fd20 	bl	800a878 <UART_SendMsg>
  return 1;
 800be38:	2001      	movs	r0, #1
}
 800be3a:	b002      	add	sp, #8
 800be3c:	bd10      	pop	{r4, pc}
      BSP_GYRO_Set_ODR_Value( GYRO_handle, odr );
 800be3e:	4b11      	ldr	r3, [pc, #68]	; (800be84 <SC_Set_ODR+0x98>)
 800be40:	ee00 2a10 	vmov	s0, r2
 800be44:	6818      	ldr	r0, [r3, #0]
 800be46:	f7fb fe19 	bl	8007a7c <BSP_GYRO_Set_ODR_Value>
      break;
 800be4a:	e7ed      	b.n	800be28 <SC_Set_ODR+0x3c>
      BSP_MAGNETO_Set_ODR_Value( MAGNETO_handle, odr );
 800be4c:	4b0e      	ldr	r3, [pc, #56]	; (800be88 <SC_Set_ODR+0x9c>)
 800be4e:	ee00 2a10 	vmov	s0, r2
 800be52:	6818      	ldr	r0, [r3, #0]
 800be54:	f7fc f80a 	bl	8007e6c <BSP_MAGNETO_Set_ODR_Value>
      break;
 800be58:	e7e6      	b.n	800be28 <SC_Set_ODR+0x3c>
      BSP_TEMPERATURE_Set_ODR_Value( TEMPERATURE_handle, odr );
 800be5a:	4b0c      	ldr	r3, [pc, #48]	; (800be8c <SC_Set_ODR+0xa0>)
 800be5c:	ee00 2a10 	vmov	s0, r2
 800be60:	6818      	ldr	r0, [r3, #0]
 800be62:	f7fc fa6b 	bl	800833c <BSP_TEMPERATURE_Set_ODR_Value>
      break;
 800be66:	e7df      	b.n	800be28 <SC_Set_ODR+0x3c>
      BSP_HUMIDITY_Set_ODR_Value( HUMIDITY_handle, odr );
 800be68:	4b09      	ldr	r3, [pc, #36]	; (800be90 <SC_Set_ODR+0xa4>)
 800be6a:	ee00 2a10 	vmov	s0, r2
 800be6e:	6818      	ldr	r0, [r3, #0]
 800be70:	f7fb ff08 	bl	8007c84 <BSP_HUMIDITY_Set_ODR_Value>
      break;
 800be74:	e7d8      	b.n	800be28 <SC_Set_ODR+0x3c>
      return 0;
 800be76:	2000      	movs	r0, #0
 800be78:	e7ce      	b.n	800be18 <SC_Set_ODR+0x2c>
 800be7a:	bf00      	nop
 800be7c:	20000710 	.word	0x20000710
 800be80:	200006fc 	.word	0x200006fc
 800be84:	20000700 	.word	0x20000700
 800be88:	20000704 	.word	0x20000704
 800be8c:	2000070c 	.word	0x2000070c
 800be90:	20000708 	.word	0x20000708

0800be94 <Handle_Sensor_command>:
  switch (Msg->Data[3])
 800be94:	79c3      	ldrb	r3, [r0, #7]
 800be96:	3b01      	subs	r3, #1
 800be98:	2b06      	cmp	r3, #6
 800be9a:	d840      	bhi.n	800bf1e <Handle_Sensor_command+0x8a>
 800be9c:	e8df f003 	tbb	[pc, r3]
 800bea0:	0c0a0806 	.word	0x0c0a0806
 800bea4:	1f0e      	.short	0x1f0e
 800bea6:	04          	.byte	0x04
 800bea7:	00          	.byte	0x00
      return SC_Set_ODR(Msg);
 800bea8:	f7ff bfa0 	b.w	800bdec <SC_Set_ODR>
      return SC_Get_Sensor_Name(Msg);
 800beac:	f7ff bab0 	b.w	800b410 <SC_Get_Sensor_Name>
      return SC_Read_Register(Msg);
 800beb0:	f7ff bbc0 	b.w	800b634 <SC_Read_Register>
      return SC_Write_Register(Msg);
 800beb4:	f7ff bc16 	b.w	800b6e4 <SC_Write_Register>
      return SC_Get_Full_Scale_List(Msg);
 800beb8:	f7ff bc60 	b.w	800b77c <SC_Get_Full_Scale_List>
{
 800bebc:	b510      	push	{r4, lr}
 800bebe:	4604      	mov	r4, r0
 800bec0:	b082      	sub	sp, #8
  full_scale = Deserialize(&Msg->Data[5], 4);
 800bec2:	2104      	movs	r1, #4
 800bec4:	3009      	adds	r0, #9
 800bec6:	f000 f951 	bl	800c16c <Deserialize>
  switch (Msg->Data[4])
 800beca:	7a23      	ldrb	r3, [r4, #8]
  full_scale = Deserialize(&Msg->Data[5], 4);
 800becc:	9001      	str	r0, [sp, #4]
  switch (Msg->Data[4])
 800bece:	3b01      	subs	r3, #1
 800bed0:	2b04      	cmp	r3, #4
 800bed2:	d822      	bhi.n	800bf1a <Handle_Sensor_command+0x86>
 800bed4:	e8df f003 	tbb	[pc, r3]
 800bed8:	0d0d0518 	.word	0x0d0d0518
 800bedc:	0d          	.byte	0x0d
 800bedd:	00          	.byte	0x00
      return SC_Get_ODR_List(Msg);
 800bede:	f7ff bdb1 	b.w	800ba44 <SC_Get_ODR_List>
      BSP_GYRO_Set_FS_Value( GYRO_handle, full_scale );
 800bee2:	4b10      	ldr	r3, [pc, #64]	; (800bf24 <Handle_Sensor_command+0x90>)
 800bee4:	eddd 7a01 	vldr	s15, [sp, #4]
 800bee8:	6818      	ldr	r0, [r3, #0]
 800beea:	eeb8 0a67 	vcvt.f32.u32	s0, s15
 800beee:	f7fb fdd5 	bl	8007a9c <BSP_GYRO_Set_FS_Value>
  BUILD_REPLY_HEADER(Msg);
 800bef2:	4620      	mov	r0, r4
 800bef4:	f7fe faba 	bl	800a46c <BUILD_REPLY_HEADER>
  Msg->Len = 9;
 800bef8:	2309      	movs	r3, #9
  UART_SendMsg(Msg);
 800befa:	4620      	mov	r0, r4
  Msg->Len = 9;
 800befc:	6023      	str	r3, [r4, #0]
  UART_SendMsg(Msg);
 800befe:	f7fe fcbb 	bl	800a878 <UART_SendMsg>
  return 1;
 800bf02:	2001      	movs	r0, #1
}
 800bf04:	b002      	add	sp, #8
 800bf06:	bd10      	pop	{r4, pc}
      BSP_ACCELERO_Set_FS_Value( ACCELERO_handle, full_scale );
 800bf08:	4b07      	ldr	r3, [pc, #28]	; (800bf28 <Handle_Sensor_command+0x94>)
 800bf0a:	eddd 7a01 	vldr	s15, [sp, #4]
 800bf0e:	6818      	ldr	r0, [r3, #0]
 800bf10:	eeb8 0a67 	vcvt.f32.u32	s0, s15
 800bf14:	f7fb fcb4 	bl	8007880 <BSP_ACCELERO_Set_FS_Value>
 800bf18:	e7eb      	b.n	800bef2 <Handle_Sensor_command+0x5e>
      return 0;
 800bf1a:	2000      	movs	r0, #0
 800bf1c:	e7f2      	b.n	800bf04 <Handle_Sensor_command+0x70>
      return 0;
 800bf1e:	2000      	movs	r0, #0
 800bf20:	4770      	bx	lr
 800bf22:	bf00      	nop
 800bf24:	20000700 	.word	0x20000700
 800bf28:	200006fc 	.word	0x200006fc

0800bf2c <ByteStuffCopy>:
int ByteStuffCopy(uint8_t *Dest, TMsg *Source)
{
  int i, Count;

  Count = 0;
  for (i = 0; i < Source->Len; i++)
 800bf2c:	680a      	ldr	r2, [r1, #0]
{
 800bf2e:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bf30:	4607      	mov	r7, r0
  for (i = 0; i < Source->Len; i++)
 800bf32:	b342      	cbz	r2, 800bf86 <ByteStuffCopy+0x5a>
 800bf34:	2200      	movs	r2, #0
 800bf36:	4610      	mov	r0, r2
 800bf38:	1ccd      	adds	r5, r1, #3
      Dest[0] = TMsg_BS;
 800bf3a:	f04f 0cf1 	mov.w	ip, #241	; 0xf1
      Dest[1] = TMsg_BS_EOF;
 800bf3e:	f04f 0ef2 	mov.w	lr, #242	; 0xf2
 800bf42:	e009      	b.n	800bf58 <ByteStuffCopy+0x2c>
  switch(Source)
 800bf44:	2bf1      	cmp	r3, #241	; 0xf1
 800bf46:	d11b      	bne.n	800bf80 <ByteStuffCopy+0x54>
      Dest[0] = TMsg_BS;
 800bf48:	7023      	strb	r3, [r4, #0]
      Dest[1] = TMsg_BS;
 800bf4a:	7063      	strb	r3, [r4, #1]
      return 2;
 800bf4c:	2602      	movs	r6, #2
  for (i = 0; i < Source->Len; i++)
 800bf4e:	680b      	ldr	r3, [r1, #0]
 800bf50:	3001      	adds	r0, #1
 800bf52:	4283      	cmp	r3, r0
  {
    Count += ByteStuffCopyByte(&Dest[Count], Source->Data[i]);
 800bf54:	4432      	add	r2, r6
  for (i = 0; i < Source->Len; i++)
 800bf56:	d90f      	bls.n	800bf78 <ByteStuffCopy+0x4c>
    Count += ByteStuffCopyByte(&Dest[Count], Source->Data[i]);
 800bf58:	f815 3f01 	ldrb.w	r3, [r5, #1]!
  switch(Source)
 800bf5c:	2bf0      	cmp	r3, #240	; 0xf0
    Count += ByteStuffCopyByte(&Dest[Count], Source->Data[i]);
 800bf5e:	eb07 0402 	add.w	r4, r7, r2
  switch(Source)
 800bf62:	d1ef      	bne.n	800bf44 <ByteStuffCopy+0x18>
      Dest[0] = TMsg_BS;
 800bf64:	f807 c002 	strb.w	ip, [r7, r2]
      Dest[1] = TMsg_BS_EOF;
 800bf68:	f884 e001 	strb.w	lr, [r4, #1]
  for (i = 0; i < Source->Len; i++)
 800bf6c:	680b      	ldr	r3, [r1, #0]
 800bf6e:	3001      	adds	r0, #1
      return 2;
 800bf70:	2602      	movs	r6, #2
  for (i = 0; i < Source->Len; i++)
 800bf72:	4283      	cmp	r3, r0
    Count += ByteStuffCopyByte(&Dest[Count], Source->Data[i]);
 800bf74:	4432      	add	r2, r6
  for (i = 0; i < Source->Len; i++)
 800bf76:	d8ef      	bhi.n	800bf58 <ByteStuffCopy+0x2c>
 800bf78:	1c50      	adds	r0, r2, #1
  }
  Dest[Count] = TMsg_EOF;
 800bf7a:	23f0      	movs	r3, #240	; 0xf0
 800bf7c:	54bb      	strb	r3, [r7, r2]
  Count++;
  return Count;
}
 800bf7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      return 1;
 800bf80:	2601      	movs	r6, #1
      Dest[0] = Source;
 800bf82:	7023      	strb	r3, [r4, #0]
 800bf84:	e7e3      	b.n	800bf4e <ByteStuffCopy+0x22>
  for (i = 0; i < Source->Len; i++)
 800bf86:	2001      	movs	r0, #1
 800bf88:	e7f7      	b.n	800bf7a <ByteStuffCopy+0x4e>
 800bf8a:	bf00      	nop

0800bf8c <ReverseByteStuffCopyByte2>:
 * @param  Dest the destination data
 * @retval Number of input bytes processed (1 or 2) or 0 for invalid sequence
 */
int ReverseByteStuffCopyByte2(uint8_t Source0, uint8_t Source1, uint8_t *Dest)
{
  if (Source0 == TMsg_BS)
 800bf8c:	28f1      	cmp	r0, #241	; 0xf1
 800bf8e:	d002      	beq.n	800bf96 <ReverseByteStuffCopyByte2+0xa>
    }
    return 0; // invalid sequence
  }
  else
  {
    *Dest = Source0;
 800bf90:	7010      	strb	r0, [r2, #0]
    return 1;
 800bf92:	2001      	movs	r0, #1
 800bf94:	4770      	bx	lr
    if (Source1 == TMsg_BS)
 800bf96:	29f1      	cmp	r1, #241	; 0xf1
 800bf98:	d003      	beq.n	800bfa2 <ReverseByteStuffCopyByte2+0x16>
    if (Source1 == TMsg_BS_EOF)
 800bf9a:	29f2      	cmp	r1, #242	; 0xf2
 800bf9c:	d004      	beq.n	800bfa8 <ReverseByteStuffCopyByte2+0x1c>
    return 0; // invalid sequence
 800bf9e:	2000      	movs	r0, #0
  }
}
 800bfa0:	4770      	bx	lr
      *Dest = TMsg_BS;
 800bfa2:	7011      	strb	r1, [r2, #0]
      return 2;
 800bfa4:	2002      	movs	r0, #2
 800bfa6:	4770      	bx	lr
      *Dest = TMsg_EOF;
 800bfa8:	23f0      	movs	r3, #240	; 0xf0
 800bfaa:	7013      	strb	r3, [r2, #0]
      return 2;
 800bfac:	2002      	movs	r0, #2
 800bfae:	4770      	bx	lr

0800bfb0 <CHK_ComputeAndAdd>:
void CHK_ComputeAndAdd(TMsg *Msg)
{
  uint8_t CHK = 0;
  int i;

  for(i = 0; i < Msg->Len; i++)
 800bfb0:	6802      	ldr	r2, [r0, #0]
 800bfb2:	2a00      	cmp	r2, #0
 800bfb4:	d064      	beq.n	800c080 <CHK_ComputeAndAdd+0xd0>
{
 800bfb6:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bfb8:	1f17      	subs	r7, r2, #4
 800bfba:	08bf      	lsrs	r7, r7, #2
 800bfbc:	1e53      	subs	r3, r2, #1
 800bfbe:	3701      	adds	r7, #1
 800bfc0:	2b06      	cmp	r3, #6
 800bfc2:	ea4f 0187 	mov.w	r1, r7, lsl #2
 800bfc6:	d958      	bls.n	800c07a <CHK_ComputeAndAdd+0xca>
  for(i = 0; i < Msg->Len; i++)
 800bfc8:	2600      	movs	r6, #0
 800bfca:	4633      	mov	r3, r6
 800bfcc:	f100 0e04 	add.w	lr, r0, #4
  {
    CHK -= Msg->Data[i];
 800bfd0:	f85e 5b04 	ldr.w	r5, [lr], #4
 800bfd4:	ea83 0405 	eor.w	r4, r3, r5
 800bfd8:	43e4      	mvns	r4, r4
 800bfda:	f043 3380 	orr.w	r3, r3, #2155905152	; 0x80808080
 800bfde:	f005 357f 	and.w	r5, r5, #2139062143	; 0x7f7f7f7f
 800bfe2:	3601      	adds	r6, #1
 800bfe4:	f004 3480 	and.w	r4, r4, #2155905152	; 0x80808080
 800bfe8:	1b5d      	subs	r5, r3, r5
 800bfea:	42b7      	cmp	r7, r6
 800bfec:	ea84 0305 	eor.w	r3, r4, r5
 800bff0:	d8ee      	bhi.n	800bfd0 <CHK_ComputeAndAdd+0x20>
 800bff2:	f3c3 2407 	ubfx	r4, r3, #8, #8
 800bff6:	441c      	add	r4, r3
 800bff8:	f3c3 4507 	ubfx	r5, r3, #16, #8
 800bffc:	442c      	add	r4, r5
 800bffe:	eb04 6313 	add.w	r3, r4, r3, lsr #24
 800c002:	4291      	cmp	r1, r2
 800c004:	b2db      	uxtb	r3, r3
 800c006:	d033      	beq.n	800c070 <CHK_ComputeAndAdd+0xc0>
 800c008:	1845      	adds	r5, r0, r1
  for(i = 0; i < Msg->Len; i++)
 800c00a:	1c4c      	adds	r4, r1, #1
    CHK -= Msg->Data[i];
 800c00c:	792d      	ldrb	r5, [r5, #4]
  for(i = 0; i < Msg->Len; i++)
 800c00e:	4294      	cmp	r4, r2
    CHK -= Msg->Data[i];
 800c010:	eba3 0305 	sub.w	r3, r3, r5
 800c014:	b2db      	uxtb	r3, r3
  for(i = 0; i < Msg->Len; i++)
 800c016:	d22b      	bcs.n	800c070 <CHK_ComputeAndAdd+0xc0>
    CHK -= Msg->Data[i];
 800c018:	1905      	adds	r5, r0, r4
  for(i = 0; i < Msg->Len; i++)
 800c01a:	1c8c      	adds	r4, r1, #2
    CHK -= Msg->Data[i];
 800c01c:	792d      	ldrb	r5, [r5, #4]
  for(i = 0; i < Msg->Len; i++)
 800c01e:	42a2      	cmp	r2, r4
    CHK -= Msg->Data[i];
 800c020:	eba3 0305 	sub.w	r3, r3, r5
 800c024:	b2db      	uxtb	r3, r3
  for(i = 0; i < Msg->Len; i++)
 800c026:	d923      	bls.n	800c070 <CHK_ComputeAndAdd+0xc0>
    CHK -= Msg->Data[i];
 800c028:	1905      	adds	r5, r0, r4
  for(i = 0; i < Msg->Len; i++)
 800c02a:	1ccc      	adds	r4, r1, #3
    CHK -= Msg->Data[i];
 800c02c:	792d      	ldrb	r5, [r5, #4]
  for(i = 0; i < Msg->Len; i++)
 800c02e:	42a2      	cmp	r2, r4
    CHK -= Msg->Data[i];
 800c030:	eba3 0305 	sub.w	r3, r3, r5
 800c034:	b2db      	uxtb	r3, r3
  for(i = 0; i < Msg->Len; i++)
 800c036:	d91b      	bls.n	800c070 <CHK_ComputeAndAdd+0xc0>
    CHK -= Msg->Data[i];
 800c038:	1905      	adds	r5, r0, r4
  for(i = 0; i < Msg->Len; i++)
 800c03a:	1d0c      	adds	r4, r1, #4
    CHK -= Msg->Data[i];
 800c03c:	792d      	ldrb	r5, [r5, #4]
  for(i = 0; i < Msg->Len; i++)
 800c03e:	42a2      	cmp	r2, r4
    CHK -= Msg->Data[i];
 800c040:	eba3 0305 	sub.w	r3, r3, r5
 800c044:	b2db      	uxtb	r3, r3
  for(i = 0; i < Msg->Len; i++)
 800c046:	d913      	bls.n	800c070 <CHK_ComputeAndAdd+0xc0>
    CHK -= Msg->Data[i];
 800c048:	1905      	adds	r5, r0, r4
  for(i = 0; i < Msg->Len; i++)
 800c04a:	1d4c      	adds	r4, r1, #5
    CHK -= Msg->Data[i];
 800c04c:	792d      	ldrb	r5, [r5, #4]
  for(i = 0; i < Msg->Len; i++)
 800c04e:	42a2      	cmp	r2, r4
    CHK -= Msg->Data[i];
 800c050:	eba3 0305 	sub.w	r3, r3, r5
 800c054:	b2db      	uxtb	r3, r3
  for(i = 0; i < Msg->Len; i++)
 800c056:	d90b      	bls.n	800c070 <CHK_ComputeAndAdd+0xc0>
    CHK -= Msg->Data[i];
 800c058:	4404      	add	r4, r0
  for(i = 0; i < Msg->Len; i++)
 800c05a:	3106      	adds	r1, #6
    CHK -= Msg->Data[i];
 800c05c:	7924      	ldrb	r4, [r4, #4]
  for(i = 0; i < Msg->Len; i++)
 800c05e:	428a      	cmp	r2, r1
    CHK -= Msg->Data[i];
 800c060:	eba3 0304 	sub.w	r3, r3, r4
 800c064:	b2db      	uxtb	r3, r3
  for(i = 0; i < Msg->Len; i++)
 800c066:	d903      	bls.n	800c070 <CHK_ComputeAndAdd+0xc0>
    CHK -= Msg->Data[i];
 800c068:	4401      	add	r1, r0
 800c06a:	7909      	ldrb	r1, [r1, #4]
 800c06c:	1a5b      	subs	r3, r3, r1
 800c06e:	b2db      	uxtb	r3, r3
 800c070:	1c51      	adds	r1, r2, #1
  }
  Msg->Data[i] = CHK;
 800c072:	4402      	add	r2, r0
 800c074:	7113      	strb	r3, [r2, #4]
  Msg->Len++;
 800c076:	6001      	str	r1, [r0, #0]
 800c078:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for(i = 0; i < Msg->Len; i++)
 800c07a:	2100      	movs	r1, #0
 800c07c:	460b      	mov	r3, r1
 800c07e:	e7c3      	b.n	800c008 <CHK_ComputeAndAdd+0x58>
 800c080:	4613      	mov	r3, r2
  Msg->Data[i] = CHK;
 800c082:	4402      	add	r2, r0
  for(i = 0; i < Msg->Len; i++)
 800c084:	2101      	movs	r1, #1
  Msg->Data[i] = CHK;
 800c086:	7113      	strb	r3, [r2, #4]
  Msg->Len++;
 800c088:	6001      	str	r1, [r0, #0]
 800c08a:	4770      	bx	lr

0800c08c <CHK_CheckAndRemove>:
 * @brief  Compute and remove checksum
 * @param  Msg pointer to the message
 * @retval A number different from 0 if the operation succeeds, 0 if an error occurs
 */
int CHK_CheckAndRemove(TMsg *Msg)
{
 800c08c:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8_t CHK = 0;
  int i;

  for(i = 0; i < Msg->Len; i++)
 800c08e:	6805      	ldr	r5, [r0, #0]
 800c090:	2d00      	cmp	r5, #0
 800c092:	d05c      	beq.n	800c14e <CHK_CheckAndRemove+0xc2>
 800c094:	1f2c      	subs	r4, r5, #4
 800c096:	08a4      	lsrs	r4, r4, #2
 800c098:	1e6e      	subs	r6, r5, #1
 800c09a:	3401      	adds	r4, #1
 800c09c:	2e06      	cmp	r6, #6
 800c09e:	ea4f 0284 	mov.w	r2, r4, lsl #2
 800c0a2:	d951      	bls.n	800c148 <CHK_CheckAndRemove+0xbc>
 800c0a4:	2700      	movs	r7, #0
 800c0a6:	463b      	mov	r3, r7
 800c0a8:	f100 0e04 	add.w	lr, r0, #4
  {
    CHK += Msg->Data[i];
 800c0ac:	f85e 1b04 	ldr.w	r1, [lr], #4
 800c0b0:	3701      	adds	r7, #1
 800c0b2:	f001 3c7f 	and.w	ip, r1, #2139062143	; 0x7f7f7f7f
 800c0b6:	4059      	eors	r1, r3
 800c0b8:	f003 337f 	and.w	r3, r3, #2139062143	; 0x7f7f7f7f
 800c0bc:	f001 3180 	and.w	r1, r1, #2155905152	; 0x80808080
 800c0c0:	4463      	add	r3, ip
 800c0c2:	42a7      	cmp	r7, r4
 800c0c4:	ea83 0301 	eor.w	r3, r3, r1
 800c0c8:	d3f0      	bcc.n	800c0ac <CHK_CheckAndRemove+0x20>
 800c0ca:	f3c3 2107 	ubfx	r1, r3, #8, #8
 800c0ce:	4419      	add	r1, r3
 800c0d0:	f3c3 4407 	ubfx	r4, r3, #16, #8
 800c0d4:	4421      	add	r1, r4
 800c0d6:	eb01 6313 	add.w	r3, r1, r3, lsr #24
 800c0da:	4295      	cmp	r5, r2
 800c0dc:	b2db      	uxtb	r3, r3
 800c0de:	d02d      	beq.n	800c13c <CHK_CheckAndRemove+0xb0>
 800c0e0:	1884      	adds	r4, r0, r2
  for(i = 0; i < Msg->Len; i++)
 800c0e2:	1c51      	adds	r1, r2, #1
    CHK += Msg->Data[i];
 800c0e4:	7924      	ldrb	r4, [r4, #4]
  for(i = 0; i < Msg->Len; i++)
 800c0e6:	42a9      	cmp	r1, r5
    CHK += Msg->Data[i];
 800c0e8:	4423      	add	r3, r4
 800c0ea:	b2db      	uxtb	r3, r3
  for(i = 0; i < Msg->Len; i++)
 800c0ec:	d226      	bcs.n	800c13c <CHK_CheckAndRemove+0xb0>
    CHK += Msg->Data[i];
 800c0ee:	1844      	adds	r4, r0, r1
  for(i = 0; i < Msg->Len; i++)
 800c0f0:	1c91      	adds	r1, r2, #2
    CHK += Msg->Data[i];
 800c0f2:	7924      	ldrb	r4, [r4, #4]
  for(i = 0; i < Msg->Len; i++)
 800c0f4:	428d      	cmp	r5, r1
    CHK += Msg->Data[i];
 800c0f6:	4423      	add	r3, r4
 800c0f8:	b2db      	uxtb	r3, r3
  for(i = 0; i < Msg->Len; i++)
 800c0fa:	d91f      	bls.n	800c13c <CHK_CheckAndRemove+0xb0>
    CHK += Msg->Data[i];
 800c0fc:	1844      	adds	r4, r0, r1
  for(i = 0; i < Msg->Len; i++)
 800c0fe:	1cd1      	adds	r1, r2, #3
    CHK += Msg->Data[i];
 800c100:	7924      	ldrb	r4, [r4, #4]
  for(i = 0; i < Msg->Len; i++)
 800c102:	428d      	cmp	r5, r1
    CHK += Msg->Data[i];
 800c104:	4423      	add	r3, r4
 800c106:	b2db      	uxtb	r3, r3
  for(i = 0; i < Msg->Len; i++)
 800c108:	d918      	bls.n	800c13c <CHK_CheckAndRemove+0xb0>
    CHK += Msg->Data[i];
 800c10a:	1844      	adds	r4, r0, r1
  for(i = 0; i < Msg->Len; i++)
 800c10c:	1d11      	adds	r1, r2, #4
    CHK += Msg->Data[i];
 800c10e:	7924      	ldrb	r4, [r4, #4]
  for(i = 0; i < Msg->Len; i++)
 800c110:	428d      	cmp	r5, r1
    CHK += Msg->Data[i];
 800c112:	4423      	add	r3, r4
 800c114:	b2db      	uxtb	r3, r3
  for(i = 0; i < Msg->Len; i++)
 800c116:	d911      	bls.n	800c13c <CHK_CheckAndRemove+0xb0>
    CHK += Msg->Data[i];
 800c118:	1844      	adds	r4, r0, r1
  for(i = 0; i < Msg->Len; i++)
 800c11a:	1d51      	adds	r1, r2, #5
    CHK += Msg->Data[i];
 800c11c:	7924      	ldrb	r4, [r4, #4]
  for(i = 0; i < Msg->Len; i++)
 800c11e:	428d      	cmp	r5, r1
    CHK += Msg->Data[i];
 800c120:	4423      	add	r3, r4
 800c122:	b2db      	uxtb	r3, r3
  for(i = 0; i < Msg->Len; i++)
 800c124:	d90a      	bls.n	800c13c <CHK_CheckAndRemove+0xb0>
    CHK += Msg->Data[i];
 800c126:	4401      	add	r1, r0
  for(i = 0; i < Msg->Len; i++)
 800c128:	3206      	adds	r2, #6
    CHK += Msg->Data[i];
 800c12a:	7909      	ldrb	r1, [r1, #4]
  for(i = 0; i < Msg->Len; i++)
 800c12c:	4295      	cmp	r5, r2
    CHK += Msg->Data[i];
 800c12e:	440b      	add	r3, r1
 800c130:	b2db      	uxtb	r3, r3
  for(i = 0; i < Msg->Len; i++)
 800c132:	d903      	bls.n	800c13c <CHK_CheckAndRemove+0xb0>
    CHK += Msg->Data[i];
 800c134:	4402      	add	r2, r0
 800c136:	7912      	ldrb	r2, [r2, #4]
 800c138:	4413      	add	r3, r2
 800c13a:	b2db      	uxtb	r3, r3
 800c13c:	fab3 f383 	clz	r3, r3
 800c140:	095b      	lsrs	r3, r3, #5
  }
  Msg->Len--;
 800c142:	6006      	str	r6, [r0, #0]
  return (CHK == 0);
}
 800c144:	4618      	mov	r0, r3
 800c146:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for(i = 0; i < Msg->Len; i++)
 800c148:	2200      	movs	r2, #0
 800c14a:	4613      	mov	r3, r2
 800c14c:	e7c8      	b.n	800c0e0 <CHK_CheckAndRemove+0x54>
 800c14e:	2301      	movs	r3, #1
 800c150:	f04f 36ff 	mov.w	r6, #4294967295
 800c154:	e7f5      	b.n	800c142 <CHK_CheckAndRemove+0xb6>
 800c156:	bf00      	nop

0800c158 <Serialize>:
 * @retval None
 */
void Serialize(uint8_t *Dest, uint32_t Source, uint32_t Len)
{
  int i;
  for (i = 0; i < Len; i++)
 800c158:	b132      	cbz	r2, 800c168 <Serialize+0x10>
 800c15a:	4402      	add	r2, r0
  {
    Dest[i] = Source & 0xFF;
 800c15c:	f800 1b01 	strb.w	r1, [r0], #1
  for (i = 0; i < Len; i++)
 800c160:	4282      	cmp	r2, r0
    Source >>= 8;
 800c162:	ea4f 2111 	mov.w	r1, r1, lsr #8
  for (i = 0; i < Len; i++)
 800c166:	d1f9      	bne.n	800c15c <Serialize+0x4>
 800c168:	4770      	bx	lr
 800c16a:	bf00      	nop

0800c16c <Deserialize>:
 * @retval Rebuild unsigned int variable
 */
uint32_t Deserialize(uint8_t *Source, uint32_t Len)
{
  uint32_t app;
  app = Source[--Len];
 800c16c:	3901      	subs	r1, #1
 800c16e:	1843      	adds	r3, r0, r1
 800c170:	5c42      	ldrb	r2, [r0, r1]
  while(Len > 0)
 800c172:	b129      	cbz	r1, 800c180 <Deserialize+0x14>
  {
    app <<= 8;
    app += Source[--Len];
 800c174:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
  while(Len > 0)
 800c178:	4298      	cmp	r0, r3
    app += Source[--Len];
 800c17a:	eb01 2202 	add.w	r2, r1, r2, lsl #8
  while(Len > 0)
 800c17e:	d1f9      	bne.n	800c174 <Deserialize+0x8>
  }
  return app;
}
 800c180:	4610      	mov	r0, r2
 800c182:	4770      	bx	lr

0800c184 <Serialize_s32>:
 * @retval None
 */
void Serialize_s32(uint8_t *Dest, int32_t Source, uint32_t Len)
{
  int i;
  for (i = 0; i < Len; i++)
 800c184:	b132      	cbz	r2, 800c194 <Serialize_s32+0x10>
 800c186:	4402      	add	r2, r0
  {
    Dest[i] = Source & 0xFF;
 800c188:	f800 1b01 	strb.w	r1, [r0], #1
  for (i = 0; i < Len; i++)
 800c18c:	4282      	cmp	r2, r0
    Source >>= 8;
 800c18e:	ea4f 2121 	mov.w	r1, r1, asr #8
  for (i = 0; i < Len; i++)
 800c192:	d1f9      	bne.n	800c188 <Serialize_s32+0x4>
 800c194:	4770      	bx	lr
 800c196:	bf00      	nop

0800c198 <HAL_RTC_MspInit>:
  *        the backup registers) and RCC_BDCR register are set to their reset values.
  *
  * @retval None
  */
void HAL_RTC_MspInit(RTC_HandleTypeDef *hrtc)
{
 800c198:	b500      	push	{lr}
  RCC_OscInitTypeDef        RCC_OscInitStruct;
  RCC_PeriphCLKInitTypeDef  PeriphClkInitStruct;

  /*##-1- Configue LSE as RTC clock soucre ###################################*/
  if(use_LSI == 0)
 800c19a:	4b1f      	ldr	r3, [pc, #124]	; (800c218 <HAL_RTC_MspInit+0x80>)
 800c19c:	681b      	ldr	r3, [r3, #0]
{
 800c19e:	b093      	sub	sp, #76	; 0x4c
  {
    RCC_OscInitStruct.OscillatorType =  RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_LSE;
 800c1a0:	210c      	movs	r1, #12
  if(use_LSI == 0)
 800c1a2:	bb0b      	cbnz	r3, 800c1e8 <HAL_RTC_MspInit+0x50>
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
    RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 800c1a4:	2201      	movs	r2, #1
    RCC_OscInitStruct.LSIState = RCC_LSI_OFF;
    if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800c1a6:	a806      	add	r0, sp, #24
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 800c1a8:	930c      	str	r3, [sp, #48]	; 0x30
    RCC_OscInitStruct.LSIState = RCC_LSI_OFF;
 800c1aa:	930b      	str	r3, [sp, #44]	; 0x2c
    RCC_OscInitStruct.OscillatorType =  RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_LSE;
 800c1ac:	9106      	str	r1, [sp, #24]
    RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 800c1ae:	9208      	str	r2, [sp, #32]
    if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800c1b0:	f7fd f8d4 	bl	800935c <HAL_RCC_OscConfig>
 800c1b4:	bb60      	cbnz	r0, 800c210 <HAL_RTC_MspInit+0x78>
    {
      /* Initialization Error */
      Error_Handler();
    }

    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 800c1b6:	2202      	movs	r2, #2
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 800c1b8:	f44f 7380 	mov.w	r3, #256	; 0x100
    if(HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800c1bc:	a801      	add	r0, sp, #4
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 800c1be:	9201      	str	r2, [sp, #4]
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 800c1c0:	9304      	str	r3, [sp, #16]
    if(HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800c1c2:	f7fd fb77 	bl	80098b4 <HAL_RCCEx_PeriphCLKConfig>
 800c1c6:	b108      	cbz	r0, 800c1cc <HAL_RTC_MspInit+0x34>
    {
      /* Initialization Error */
      Error_Handler();
 800c1c8:	f7ff f920 	bl	800b40c <Error_Handler>
    }
  }

  /*##-2- Enable RTC peripheral Clocks #######################################*/
  /* Enable RTC Clock */
  __HAL_RCC_RTC_ENABLE();
 800c1cc:	4b13      	ldr	r3, [pc, #76]	; (800c21c <HAL_RTC_MspInit+0x84>)
 800c1ce:	2201      	movs	r2, #1
 800c1d0:	601a      	str	r2, [r3, #0]

  /*##-3- Configure the NVIC for RTC TimeStamp ###################################*/
  HAL_NVIC_SetPriority(TAMP_STAMP_IRQn, 0x0F, 0);
 800c1d2:	210f      	movs	r1, #15
 800c1d4:	2200      	movs	r2, #0
 800c1d6:	2002      	movs	r0, #2
 800c1d8:	f7fc f98e 	bl	80084f8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TAMP_STAMP_IRQn);
 800c1dc:	2002      	movs	r0, #2
 800c1de:	f7fc f9c1 	bl	8008564 <HAL_NVIC_EnableIRQ>
}
 800c1e2:	b013      	add	sp, #76	; 0x4c
 800c1e4:	f85d fb04 	ldr.w	pc, [sp], #4
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 800c1e8:	2300      	movs	r3, #0
    RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 800c1ea:	2201      	movs	r2, #1
    if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800c1ec:	a806      	add	r0, sp, #24
    RCC_OscInitStruct.OscillatorType =  RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_LSE;
 800c1ee:	9106      	str	r1, [sp, #24]
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 800c1f0:	930c      	str	r3, [sp, #48]	; 0x30
    RCC_OscInitStruct.LSEState = RCC_LSE_OFF;
 800c1f2:	9308      	str	r3, [sp, #32]
    RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 800c1f4:	920b      	str	r2, [sp, #44]	; 0x2c
    if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800c1f6:	f7fd f8b1 	bl	800935c <HAL_RCC_OscConfig>
 800c1fa:	b918      	cbnz	r0, 800c204 <HAL_RTC_MspInit+0x6c>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 800c1fc:	2202      	movs	r2, #2
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 800c1fe:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c202:	e7db      	b.n	800c1bc <HAL_RTC_MspInit+0x24>
      Error_Handler();
 800c204:	f7ff f902 	bl	800b40c <Error_Handler>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 800c208:	2202      	movs	r2, #2
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 800c20a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c20e:	e7d5      	b.n	800c1bc <HAL_RTC_MspInit+0x24>
      Error_Handler();
 800c210:	f7ff f8fc 	bl	800b40c <Error_Handler>
 800c214:	e7cf      	b.n	800c1b6 <HAL_RTC_MspInit+0x1e>
 800c216:	bf00      	nop
 800c218:	20000740 	.word	0x20000740
 800c21c:	42470e3c 	.word	0x42470e3c

0800c220 <NMI_Handler>:
 800c220:	4770      	bx	lr
 800c222:	bf00      	nop

0800c224 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 800c224:	e7fe      	b.n	800c224 <HardFault_Handler>
 800c226:	bf00      	nop

0800c228 <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 800c228:	4770      	bx	lr
 800c22a:	bf00      	nop

0800c22c <SysTick_Handler>:
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
  HAL_IncTick();
 800c22c:	f7fc b92e 	b.w	800848c <HAL_IncTick>

0800c230 <EXTI15_10_IRQHandler>:
  * @param  None
  * @retval None
  */
void EXTI15_10_IRQHandler( void )
{
  HAL_GPIO_EXTI_IRQHandler(KEY_BUTTON_PIN);
 800c230:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 800c234:	f7fc bb8e 	b.w	8008954 <HAL_GPIO_EXTI_IRQHandler>

0800c238 <_read>:
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
}

int _read (int file, char *ptr, int len)
{
 800c238:	b570      	push	{r4, r5, r6, lr}
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 800c23a:	1e16      	subs	r6, r2, #0
 800c23c:	dd07      	ble.n	800c24e <_read+0x16>
 800c23e:	460c      	mov	r4, r1
 800c240:	198d      	adds	r5, r1, r6
  {
    *ptr++ = __io_getchar();
 800c242:	f3af 8000 	nop.w
 800c246:	f804 0b01 	strb.w	r0, [r4], #1
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 800c24a:	42a5      	cmp	r5, r4
 800c24c:	d1f9      	bne.n	800c242 <_read+0xa>
  }

  return len;
}
 800c24e:	4630      	mov	r0, r6
 800c250:	bd70      	pop	{r4, r5, r6, pc}
 800c252:	bf00      	nop

0800c254 <_write>:

int _write(int file, char *ptr, int len)
{
 800c254:	b570      	push	{r4, r5, r6, lr}
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 800c256:	1e16      	subs	r6, r2, #0
 800c258:	dd07      	ble.n	800c26a <_write+0x16>
 800c25a:	460c      	mov	r4, r1
 800c25c:	198d      	adds	r5, r1, r6
  {
    __io_putchar(*ptr++);
 800c25e:	f814 0b01 	ldrb.w	r0, [r4], #1
 800c262:	f3af 8000 	nop.w
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 800c266:	42ac      	cmp	r4, r5
 800c268:	d1f9      	bne.n	800c25e <_write+0xa>
  }
  return len;
}
 800c26a:	4630      	mov	r0, r6
 800c26c:	bd70      	pop	{r4, r5, r6, pc}
 800c26e:	bf00      	nop

0800c270 <_sbrk>:
{
  extern char end asm("end");
  static char *heap_end;
  char *prev_heap_end;

  if (heap_end == 0)
 800c270:	4a0a      	ldr	r2, [pc, #40]	; (800c29c <_sbrk+0x2c>)
{
 800c272:	b508      	push	{r3, lr}
  if (heap_end == 0)
 800c274:	6813      	ldr	r3, [r2, #0]
 800c276:	b173      	cbz	r3, 800c296 <_sbrk+0x26>
    heap_end = &end;

  prev_heap_end = heap_end;
  if (heap_end + incr > stack_ptr)
 800c278:	4418      	add	r0, r3
 800c27a:	4669      	mov	r1, sp
 800c27c:	4288      	cmp	r0, r1
 800c27e:	d802      	bhi.n	800c286 <_sbrk+0x16>
//    abort();
    errno = ENOMEM;
    return (caddr_t) - 1;
  }

  heap_end += incr;
 800c280:	6010      	str	r0, [r2, #0]

  return (caddr_t) prev_heap_end;
}
 800c282:	4618      	mov	r0, r3
 800c284:	bd08      	pop	{r3, pc}
    errno = ENOMEM;
 800c286:	f000 f81b 	bl	800c2c0 <__errno>
 800c28a:	230c      	movs	r3, #12
 800c28c:	6003      	str	r3, [r0, #0]
    return (caddr_t) - 1;
 800c28e:	f04f 33ff 	mov.w	r3, #4294967295
}
 800c292:	4618      	mov	r0, r3
 800c294:	bd08      	pop	{r3, pc}
    heap_end = &end;
 800c296:	4b02      	ldr	r3, [pc, #8]	; (800c2a0 <_sbrk+0x30>)
 800c298:	6013      	str	r3, [r2, #0]
 800c29a:	e7ed      	b.n	800c278 <_sbrk+0x8>
 800c29c:	20000744 	.word	0x20000744
 800c2a0:	20000dd0 	.word	0x20000dd0

0800c2a4 <_close>:

int _close(int file)
{
  return -1;
}
 800c2a4:	f04f 30ff 	mov.w	r0, #4294967295
 800c2a8:	4770      	bx	lr
 800c2aa:	bf00      	nop

0800c2ac <_fstat>:


int _fstat(int file, struct stat *st)
{
  st->st_mode = S_IFCHR;
 800c2ac:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800c2b0:	604b      	str	r3, [r1, #4]
  return 0;
}
 800c2b2:	2000      	movs	r0, #0
 800c2b4:	4770      	bx	lr
 800c2b6:	bf00      	nop

0800c2b8 <_isatty>:

int _isatty(int file)
{
  return 1;
}
 800c2b8:	2001      	movs	r0, #1
 800c2ba:	4770      	bx	lr

0800c2bc <_lseek>:

int _lseek(int file, int ptr, int dir)
{
  return 0;
}
 800c2bc:	2000      	movs	r0, #0
 800c2be:	4770      	bx	lr

0800c2c0 <__errno>:
 800c2c0:	4b01      	ldr	r3, [pc, #4]	; (800c2c8 <__errno+0x8>)
 800c2c2:	6818      	ldr	r0, [r3, #0]
 800c2c4:	4770      	bx	lr
 800c2c6:	bf00      	nop
 800c2c8:	2000051c 	.word	0x2000051c

0800c2cc <__libc_init_array>:
 800c2cc:	b570      	push	{r4, r5, r6, lr}
 800c2ce:	4e0d      	ldr	r6, [pc, #52]	; (800c304 <__libc_init_array+0x38>)
 800c2d0:	4c0d      	ldr	r4, [pc, #52]	; (800c308 <__libc_init_array+0x3c>)
 800c2d2:	1ba4      	subs	r4, r4, r6
 800c2d4:	10a4      	asrs	r4, r4, #2
 800c2d6:	2500      	movs	r5, #0
 800c2d8:	42a5      	cmp	r5, r4
 800c2da:	d109      	bne.n	800c2f0 <__libc_init_array+0x24>
 800c2dc:	4e0b      	ldr	r6, [pc, #44]	; (800c30c <__libc_init_array+0x40>)
 800c2de:	4c0c      	ldr	r4, [pc, #48]	; (800c310 <__libc_init_array+0x44>)
 800c2e0:	f001 f8f2 	bl	800d4c8 <_init>
 800c2e4:	1ba4      	subs	r4, r4, r6
 800c2e6:	10a4      	asrs	r4, r4, #2
 800c2e8:	2500      	movs	r5, #0
 800c2ea:	42a5      	cmp	r5, r4
 800c2ec:	d105      	bne.n	800c2fa <__libc_init_array+0x2e>
 800c2ee:	bd70      	pop	{r4, r5, r6, pc}
 800c2f0:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800c2f4:	4798      	blx	r3
 800c2f6:	3501      	adds	r5, #1
 800c2f8:	e7ee      	b.n	800c2d8 <__libc_init_array+0xc>
 800c2fa:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800c2fe:	4798      	blx	r3
 800c300:	3501      	adds	r5, #1
 800c302:	e7f2      	b.n	800c2ea <__libc_init_array+0x1e>
 800c304:	0800d724 	.word	0x0800d724
 800c308:	0800d724 	.word	0x0800d724
 800c30c:	0800d724 	.word	0x0800d724
 800c310:	0800d728 	.word	0x0800d728

0800c314 <memset>:
 800c314:	4402      	add	r2, r0
 800c316:	4603      	mov	r3, r0
 800c318:	4293      	cmp	r3, r2
 800c31a:	d100      	bne.n	800c31e <memset+0xa>
 800c31c:	4770      	bx	lr
 800c31e:	f803 1b01 	strb.w	r1, [r3], #1
 800c322:	e7f9      	b.n	800c318 <memset+0x4>

0800c324 <iprintf>:
 800c324:	b40f      	push	{r0, r1, r2, r3}
 800c326:	4b0a      	ldr	r3, [pc, #40]	; (800c350 <iprintf+0x2c>)
 800c328:	b513      	push	{r0, r1, r4, lr}
 800c32a:	681c      	ldr	r4, [r3, #0]
 800c32c:	b124      	cbz	r4, 800c338 <iprintf+0x14>
 800c32e:	69a3      	ldr	r3, [r4, #24]
 800c330:	b913      	cbnz	r3, 800c338 <iprintf+0x14>
 800c332:	4620      	mov	r0, r4
 800c334:	f000 f882 	bl	800c43c <__sinit>
 800c338:	ab05      	add	r3, sp, #20
 800c33a:	9a04      	ldr	r2, [sp, #16]
 800c33c:	68a1      	ldr	r1, [r4, #8]
 800c33e:	9301      	str	r3, [sp, #4]
 800c340:	4620      	mov	r0, r4
 800c342:	f000 fadd 	bl	800c900 <_vfiprintf_r>
 800c346:	b002      	add	sp, #8
 800c348:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800c34c:	b004      	add	sp, #16
 800c34e:	4770      	bx	lr
 800c350:	2000051c 	.word	0x2000051c

0800c354 <sniprintf>:
 800c354:	b40c      	push	{r2, r3}
 800c356:	b530      	push	{r4, r5, lr}
 800c358:	4b17      	ldr	r3, [pc, #92]	; (800c3b8 <sniprintf+0x64>)
 800c35a:	1e0c      	subs	r4, r1, #0
 800c35c:	b09d      	sub	sp, #116	; 0x74
 800c35e:	681d      	ldr	r5, [r3, #0]
 800c360:	da08      	bge.n	800c374 <sniprintf+0x20>
 800c362:	238b      	movs	r3, #139	; 0x8b
 800c364:	602b      	str	r3, [r5, #0]
 800c366:	f04f 30ff 	mov.w	r0, #4294967295
 800c36a:	b01d      	add	sp, #116	; 0x74
 800c36c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 800c370:	b002      	add	sp, #8
 800c372:	4770      	bx	lr
 800c374:	f44f 7302 	mov.w	r3, #520	; 0x208
 800c378:	f8ad 3014 	strh.w	r3, [sp, #20]
 800c37c:	bf14      	ite	ne
 800c37e:	f104 33ff 	addne.w	r3, r4, #4294967295
 800c382:	4623      	moveq	r3, r4
 800c384:	9304      	str	r3, [sp, #16]
 800c386:	9307      	str	r3, [sp, #28]
 800c388:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800c38c:	9002      	str	r0, [sp, #8]
 800c38e:	9006      	str	r0, [sp, #24]
 800c390:	f8ad 3016 	strh.w	r3, [sp, #22]
 800c394:	9a20      	ldr	r2, [sp, #128]	; 0x80
 800c396:	ab21      	add	r3, sp, #132	; 0x84
 800c398:	a902      	add	r1, sp, #8
 800c39a:	4628      	mov	r0, r5
 800c39c:	9301      	str	r3, [sp, #4]
 800c39e:	f000 f991 	bl	800c6c4 <_svfiprintf_r>
 800c3a2:	1c43      	adds	r3, r0, #1
 800c3a4:	bfbc      	itt	lt
 800c3a6:	238b      	movlt	r3, #139	; 0x8b
 800c3a8:	602b      	strlt	r3, [r5, #0]
 800c3aa:	2c00      	cmp	r4, #0
 800c3ac:	d0dd      	beq.n	800c36a <sniprintf+0x16>
 800c3ae:	9b02      	ldr	r3, [sp, #8]
 800c3b0:	2200      	movs	r2, #0
 800c3b2:	701a      	strb	r2, [r3, #0]
 800c3b4:	e7d9      	b.n	800c36a <sniprintf+0x16>
 800c3b6:	bf00      	nop
 800c3b8:	2000051c 	.word	0x2000051c

0800c3bc <_cleanup_r>:
 800c3bc:	4901      	ldr	r1, [pc, #4]	; (800c3c4 <_cleanup_r+0x8>)
 800c3be:	f000 b8a9 	b.w	800c514 <_fwalk_reent>
 800c3c2:	bf00      	nop
 800c3c4:	0800d1d5 	.word	0x0800d1d5

0800c3c8 <std.isra.0>:
 800c3c8:	2300      	movs	r3, #0
 800c3ca:	b510      	push	{r4, lr}
 800c3cc:	4604      	mov	r4, r0
 800c3ce:	6003      	str	r3, [r0, #0]
 800c3d0:	6043      	str	r3, [r0, #4]
 800c3d2:	6083      	str	r3, [r0, #8]
 800c3d4:	8181      	strh	r1, [r0, #12]
 800c3d6:	6643      	str	r3, [r0, #100]	; 0x64
 800c3d8:	81c2      	strh	r2, [r0, #14]
 800c3da:	6103      	str	r3, [r0, #16]
 800c3dc:	6143      	str	r3, [r0, #20]
 800c3de:	6183      	str	r3, [r0, #24]
 800c3e0:	4619      	mov	r1, r3
 800c3e2:	2208      	movs	r2, #8
 800c3e4:	305c      	adds	r0, #92	; 0x5c
 800c3e6:	f7ff ff95 	bl	800c314 <memset>
 800c3ea:	4b05      	ldr	r3, [pc, #20]	; (800c400 <std.isra.0+0x38>)
 800c3ec:	6263      	str	r3, [r4, #36]	; 0x24
 800c3ee:	4b05      	ldr	r3, [pc, #20]	; (800c404 <std.isra.0+0x3c>)
 800c3f0:	62a3      	str	r3, [r4, #40]	; 0x28
 800c3f2:	4b05      	ldr	r3, [pc, #20]	; (800c408 <std.isra.0+0x40>)
 800c3f4:	62e3      	str	r3, [r4, #44]	; 0x2c
 800c3f6:	4b05      	ldr	r3, [pc, #20]	; (800c40c <std.isra.0+0x44>)
 800c3f8:	6224      	str	r4, [r4, #32]
 800c3fa:	6323      	str	r3, [r4, #48]	; 0x30
 800c3fc:	bd10      	pop	{r4, pc}
 800c3fe:	bf00      	nop
 800c400:	0800ce79 	.word	0x0800ce79
 800c404:	0800ce9b 	.word	0x0800ce9b
 800c408:	0800ced3 	.word	0x0800ced3
 800c40c:	0800cef7 	.word	0x0800cef7

0800c410 <__sfmoreglue>:
 800c410:	b570      	push	{r4, r5, r6, lr}
 800c412:	1e4a      	subs	r2, r1, #1
 800c414:	2568      	movs	r5, #104	; 0x68
 800c416:	4355      	muls	r5, r2
 800c418:	460e      	mov	r6, r1
 800c41a:	f105 0174 	add.w	r1, r5, #116	; 0x74
 800c41e:	f000 f897 	bl	800c550 <_malloc_r>
 800c422:	4604      	mov	r4, r0
 800c424:	b140      	cbz	r0, 800c438 <__sfmoreglue+0x28>
 800c426:	2100      	movs	r1, #0
 800c428:	e880 0042 	stmia.w	r0, {r1, r6}
 800c42c:	300c      	adds	r0, #12
 800c42e:	60a0      	str	r0, [r4, #8]
 800c430:	f105 0268 	add.w	r2, r5, #104	; 0x68
 800c434:	f7ff ff6e 	bl	800c314 <memset>
 800c438:	4620      	mov	r0, r4
 800c43a:	bd70      	pop	{r4, r5, r6, pc}

0800c43c <__sinit>:
 800c43c:	6983      	ldr	r3, [r0, #24]
 800c43e:	b510      	push	{r4, lr}
 800c440:	4604      	mov	r4, r0
 800c442:	bb33      	cbnz	r3, 800c492 <__sinit+0x56>
 800c444:	6483      	str	r3, [r0, #72]	; 0x48
 800c446:	64c3      	str	r3, [r0, #76]	; 0x4c
 800c448:	6503      	str	r3, [r0, #80]	; 0x50
 800c44a:	4b12      	ldr	r3, [pc, #72]	; (800c494 <__sinit+0x58>)
 800c44c:	4a12      	ldr	r2, [pc, #72]	; (800c498 <__sinit+0x5c>)
 800c44e:	681b      	ldr	r3, [r3, #0]
 800c450:	6282      	str	r2, [r0, #40]	; 0x28
 800c452:	4298      	cmp	r0, r3
 800c454:	bf04      	itt	eq
 800c456:	2301      	moveq	r3, #1
 800c458:	6183      	streq	r3, [r0, #24]
 800c45a:	f000 f81f 	bl	800c49c <__sfp>
 800c45e:	6060      	str	r0, [r4, #4]
 800c460:	4620      	mov	r0, r4
 800c462:	f000 f81b 	bl	800c49c <__sfp>
 800c466:	60a0      	str	r0, [r4, #8]
 800c468:	4620      	mov	r0, r4
 800c46a:	f000 f817 	bl	800c49c <__sfp>
 800c46e:	2200      	movs	r2, #0
 800c470:	60e0      	str	r0, [r4, #12]
 800c472:	2104      	movs	r1, #4
 800c474:	6860      	ldr	r0, [r4, #4]
 800c476:	f7ff ffa7 	bl	800c3c8 <std.isra.0>
 800c47a:	2201      	movs	r2, #1
 800c47c:	2109      	movs	r1, #9
 800c47e:	68a0      	ldr	r0, [r4, #8]
 800c480:	f7ff ffa2 	bl	800c3c8 <std.isra.0>
 800c484:	2202      	movs	r2, #2
 800c486:	2112      	movs	r1, #18
 800c488:	68e0      	ldr	r0, [r4, #12]
 800c48a:	f7ff ff9d 	bl	800c3c8 <std.isra.0>
 800c48e:	2301      	movs	r3, #1
 800c490:	61a3      	str	r3, [r4, #24]
 800c492:	bd10      	pop	{r4, pc}
 800c494:	0800d684 	.word	0x0800d684
 800c498:	0800c3bd 	.word	0x0800c3bd

0800c49c <__sfp>:
 800c49c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c49e:	4b1c      	ldr	r3, [pc, #112]	; (800c510 <__sfp+0x74>)
 800c4a0:	681e      	ldr	r6, [r3, #0]
 800c4a2:	69b3      	ldr	r3, [r6, #24]
 800c4a4:	4607      	mov	r7, r0
 800c4a6:	b913      	cbnz	r3, 800c4ae <__sfp+0x12>
 800c4a8:	4630      	mov	r0, r6
 800c4aa:	f7ff ffc7 	bl	800c43c <__sinit>
 800c4ae:	3648      	adds	r6, #72	; 0x48
 800c4b0:	68b4      	ldr	r4, [r6, #8]
 800c4b2:	6873      	ldr	r3, [r6, #4]
 800c4b4:	3b01      	subs	r3, #1
 800c4b6:	d503      	bpl.n	800c4c0 <__sfp+0x24>
 800c4b8:	6833      	ldr	r3, [r6, #0]
 800c4ba:	b133      	cbz	r3, 800c4ca <__sfp+0x2e>
 800c4bc:	6836      	ldr	r6, [r6, #0]
 800c4be:	e7f7      	b.n	800c4b0 <__sfp+0x14>
 800c4c0:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 800c4c4:	b16d      	cbz	r5, 800c4e2 <__sfp+0x46>
 800c4c6:	3468      	adds	r4, #104	; 0x68
 800c4c8:	e7f4      	b.n	800c4b4 <__sfp+0x18>
 800c4ca:	2104      	movs	r1, #4
 800c4cc:	4638      	mov	r0, r7
 800c4ce:	f7ff ff9f 	bl	800c410 <__sfmoreglue>
 800c4d2:	6030      	str	r0, [r6, #0]
 800c4d4:	2800      	cmp	r0, #0
 800c4d6:	d1f1      	bne.n	800c4bc <__sfp+0x20>
 800c4d8:	230c      	movs	r3, #12
 800c4da:	603b      	str	r3, [r7, #0]
 800c4dc:	4604      	mov	r4, r0
 800c4de:	4620      	mov	r0, r4
 800c4e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c4e2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800c4e6:	81e3      	strh	r3, [r4, #14]
 800c4e8:	2301      	movs	r3, #1
 800c4ea:	81a3      	strh	r3, [r4, #12]
 800c4ec:	6665      	str	r5, [r4, #100]	; 0x64
 800c4ee:	6025      	str	r5, [r4, #0]
 800c4f0:	60a5      	str	r5, [r4, #8]
 800c4f2:	6065      	str	r5, [r4, #4]
 800c4f4:	6125      	str	r5, [r4, #16]
 800c4f6:	6165      	str	r5, [r4, #20]
 800c4f8:	61a5      	str	r5, [r4, #24]
 800c4fa:	2208      	movs	r2, #8
 800c4fc:	4629      	mov	r1, r5
 800c4fe:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 800c502:	f7ff ff07 	bl	800c314 <memset>
 800c506:	6365      	str	r5, [r4, #52]	; 0x34
 800c508:	63a5      	str	r5, [r4, #56]	; 0x38
 800c50a:	64a5      	str	r5, [r4, #72]	; 0x48
 800c50c:	64e5      	str	r5, [r4, #76]	; 0x4c
 800c50e:	e7e6      	b.n	800c4de <__sfp+0x42>
 800c510:	0800d684 	.word	0x0800d684

0800c514 <_fwalk_reent>:
 800c514:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800c518:	4680      	mov	r8, r0
 800c51a:	4689      	mov	r9, r1
 800c51c:	f100 0448 	add.w	r4, r0, #72	; 0x48
 800c520:	2600      	movs	r6, #0
 800c522:	b914      	cbnz	r4, 800c52a <_fwalk_reent+0x16>
 800c524:	4630      	mov	r0, r6
 800c526:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800c52a:	68a5      	ldr	r5, [r4, #8]
 800c52c:	6867      	ldr	r7, [r4, #4]
 800c52e:	3f01      	subs	r7, #1
 800c530:	d501      	bpl.n	800c536 <_fwalk_reent+0x22>
 800c532:	6824      	ldr	r4, [r4, #0]
 800c534:	e7f5      	b.n	800c522 <_fwalk_reent+0xe>
 800c536:	89ab      	ldrh	r3, [r5, #12]
 800c538:	2b01      	cmp	r3, #1
 800c53a:	d907      	bls.n	800c54c <_fwalk_reent+0x38>
 800c53c:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 800c540:	3301      	adds	r3, #1
 800c542:	d003      	beq.n	800c54c <_fwalk_reent+0x38>
 800c544:	4629      	mov	r1, r5
 800c546:	4640      	mov	r0, r8
 800c548:	47c8      	blx	r9
 800c54a:	4306      	orrs	r6, r0
 800c54c:	3568      	adds	r5, #104	; 0x68
 800c54e:	e7ee      	b.n	800c52e <_fwalk_reent+0x1a>

0800c550 <_malloc_r>:
 800c550:	b570      	push	{r4, r5, r6, lr}
 800c552:	1ccd      	adds	r5, r1, #3
 800c554:	f025 0503 	bic.w	r5, r5, #3
 800c558:	3508      	adds	r5, #8
 800c55a:	2d0c      	cmp	r5, #12
 800c55c:	bf38      	it	cc
 800c55e:	250c      	movcc	r5, #12
 800c560:	2d00      	cmp	r5, #0
 800c562:	4606      	mov	r6, r0
 800c564:	db01      	blt.n	800c56a <_malloc_r+0x1a>
 800c566:	42a9      	cmp	r1, r5
 800c568:	d903      	bls.n	800c572 <_malloc_r+0x22>
 800c56a:	230c      	movs	r3, #12
 800c56c:	6033      	str	r3, [r6, #0]
 800c56e:	2000      	movs	r0, #0
 800c570:	bd70      	pop	{r4, r5, r6, pc}
 800c572:	f000 fef4 	bl	800d35e <__malloc_lock>
 800c576:	4a23      	ldr	r2, [pc, #140]	; (800c604 <_malloc_r+0xb4>)
 800c578:	6814      	ldr	r4, [r2, #0]
 800c57a:	4621      	mov	r1, r4
 800c57c:	b991      	cbnz	r1, 800c5a4 <_malloc_r+0x54>
 800c57e:	4c22      	ldr	r4, [pc, #136]	; (800c608 <_malloc_r+0xb8>)
 800c580:	6823      	ldr	r3, [r4, #0]
 800c582:	b91b      	cbnz	r3, 800c58c <_malloc_r+0x3c>
 800c584:	4630      	mov	r0, r6
 800c586:	f000 fc67 	bl	800ce58 <_sbrk_r>
 800c58a:	6020      	str	r0, [r4, #0]
 800c58c:	4629      	mov	r1, r5
 800c58e:	4630      	mov	r0, r6
 800c590:	f000 fc62 	bl	800ce58 <_sbrk_r>
 800c594:	1c43      	adds	r3, r0, #1
 800c596:	d126      	bne.n	800c5e6 <_malloc_r+0x96>
 800c598:	230c      	movs	r3, #12
 800c59a:	6033      	str	r3, [r6, #0]
 800c59c:	4630      	mov	r0, r6
 800c59e:	f000 fedf 	bl	800d360 <__malloc_unlock>
 800c5a2:	e7e4      	b.n	800c56e <_malloc_r+0x1e>
 800c5a4:	680b      	ldr	r3, [r1, #0]
 800c5a6:	1b5b      	subs	r3, r3, r5
 800c5a8:	d41a      	bmi.n	800c5e0 <_malloc_r+0x90>
 800c5aa:	2b0b      	cmp	r3, #11
 800c5ac:	d90f      	bls.n	800c5ce <_malloc_r+0x7e>
 800c5ae:	600b      	str	r3, [r1, #0]
 800c5b0:	50cd      	str	r5, [r1, r3]
 800c5b2:	18cc      	adds	r4, r1, r3
 800c5b4:	4630      	mov	r0, r6
 800c5b6:	f000 fed3 	bl	800d360 <__malloc_unlock>
 800c5ba:	f104 000b 	add.w	r0, r4, #11
 800c5be:	1d23      	adds	r3, r4, #4
 800c5c0:	f020 0007 	bic.w	r0, r0, #7
 800c5c4:	1ac3      	subs	r3, r0, r3
 800c5c6:	d01b      	beq.n	800c600 <_malloc_r+0xb0>
 800c5c8:	425a      	negs	r2, r3
 800c5ca:	50e2      	str	r2, [r4, r3]
 800c5cc:	bd70      	pop	{r4, r5, r6, pc}
 800c5ce:	428c      	cmp	r4, r1
 800c5d0:	bf0d      	iteet	eq
 800c5d2:	6863      	ldreq	r3, [r4, #4]
 800c5d4:	684b      	ldrne	r3, [r1, #4]
 800c5d6:	6063      	strne	r3, [r4, #4]
 800c5d8:	6013      	streq	r3, [r2, #0]
 800c5da:	bf18      	it	ne
 800c5dc:	460c      	movne	r4, r1
 800c5de:	e7e9      	b.n	800c5b4 <_malloc_r+0x64>
 800c5e0:	460c      	mov	r4, r1
 800c5e2:	6849      	ldr	r1, [r1, #4]
 800c5e4:	e7ca      	b.n	800c57c <_malloc_r+0x2c>
 800c5e6:	1cc4      	adds	r4, r0, #3
 800c5e8:	f024 0403 	bic.w	r4, r4, #3
 800c5ec:	42a0      	cmp	r0, r4
 800c5ee:	d005      	beq.n	800c5fc <_malloc_r+0xac>
 800c5f0:	1a21      	subs	r1, r4, r0
 800c5f2:	4630      	mov	r0, r6
 800c5f4:	f000 fc30 	bl	800ce58 <_sbrk_r>
 800c5f8:	3001      	adds	r0, #1
 800c5fa:	d0cd      	beq.n	800c598 <_malloc_r+0x48>
 800c5fc:	6025      	str	r5, [r4, #0]
 800c5fe:	e7d9      	b.n	800c5b4 <_malloc_r+0x64>
 800c600:	bd70      	pop	{r4, r5, r6, pc}
 800c602:	bf00      	nop
 800c604:	2000074c 	.word	0x2000074c
 800c608:	20000750 	.word	0x20000750

0800c60c <__ssputs_r>:
 800c60c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800c610:	688e      	ldr	r6, [r1, #8]
 800c612:	429e      	cmp	r6, r3
 800c614:	4682      	mov	sl, r0
 800c616:	460c      	mov	r4, r1
 800c618:	4691      	mov	r9, r2
 800c61a:	4698      	mov	r8, r3
 800c61c:	d835      	bhi.n	800c68a <__ssputs_r+0x7e>
 800c61e:	898a      	ldrh	r2, [r1, #12]
 800c620:	f412 6f90 	tst.w	r2, #1152	; 0x480
 800c624:	d031      	beq.n	800c68a <__ssputs_r+0x7e>
 800c626:	6825      	ldr	r5, [r4, #0]
 800c628:	6909      	ldr	r1, [r1, #16]
 800c62a:	1a6f      	subs	r7, r5, r1
 800c62c:	6965      	ldr	r5, [r4, #20]
 800c62e:	2302      	movs	r3, #2
 800c630:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 800c634:	fb95 f5f3 	sdiv	r5, r5, r3
 800c638:	f108 0301 	add.w	r3, r8, #1
 800c63c:	443b      	add	r3, r7
 800c63e:	429d      	cmp	r5, r3
 800c640:	bf38      	it	cc
 800c642:	461d      	movcc	r5, r3
 800c644:	0553      	lsls	r3, r2, #21
 800c646:	d531      	bpl.n	800c6ac <__ssputs_r+0xa0>
 800c648:	4629      	mov	r1, r5
 800c64a:	f7ff ff81 	bl	800c550 <_malloc_r>
 800c64e:	4606      	mov	r6, r0
 800c650:	b950      	cbnz	r0, 800c668 <__ssputs_r+0x5c>
 800c652:	230c      	movs	r3, #12
 800c654:	f8ca 3000 	str.w	r3, [sl]
 800c658:	89a3      	ldrh	r3, [r4, #12]
 800c65a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800c65e:	81a3      	strh	r3, [r4, #12]
 800c660:	f04f 30ff 	mov.w	r0, #4294967295
 800c664:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800c668:	463a      	mov	r2, r7
 800c66a:	6921      	ldr	r1, [r4, #16]
 800c66c:	f000 fe52 	bl	800d314 <memcpy>
 800c670:	89a3      	ldrh	r3, [r4, #12]
 800c672:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 800c676:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800c67a:	81a3      	strh	r3, [r4, #12]
 800c67c:	6126      	str	r6, [r4, #16]
 800c67e:	6165      	str	r5, [r4, #20]
 800c680:	443e      	add	r6, r7
 800c682:	1bed      	subs	r5, r5, r7
 800c684:	6026      	str	r6, [r4, #0]
 800c686:	60a5      	str	r5, [r4, #8]
 800c688:	4646      	mov	r6, r8
 800c68a:	4546      	cmp	r6, r8
 800c68c:	bf28      	it	cs
 800c68e:	4646      	movcs	r6, r8
 800c690:	4632      	mov	r2, r6
 800c692:	4649      	mov	r1, r9
 800c694:	6820      	ldr	r0, [r4, #0]
 800c696:	f000 fe48 	bl	800d32a <memmove>
 800c69a:	68a3      	ldr	r3, [r4, #8]
 800c69c:	1b9b      	subs	r3, r3, r6
 800c69e:	60a3      	str	r3, [r4, #8]
 800c6a0:	6823      	ldr	r3, [r4, #0]
 800c6a2:	441e      	add	r6, r3
 800c6a4:	6026      	str	r6, [r4, #0]
 800c6a6:	2000      	movs	r0, #0
 800c6a8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800c6ac:	462a      	mov	r2, r5
 800c6ae:	f000 fea7 	bl	800d400 <_realloc_r>
 800c6b2:	4606      	mov	r6, r0
 800c6b4:	2800      	cmp	r0, #0
 800c6b6:	d1e1      	bne.n	800c67c <__ssputs_r+0x70>
 800c6b8:	6921      	ldr	r1, [r4, #16]
 800c6ba:	4650      	mov	r0, sl
 800c6bc:	f000 fe52 	bl	800d364 <_free_r>
 800c6c0:	e7c7      	b.n	800c652 <__ssputs_r+0x46>
	...

0800c6c4 <_svfiprintf_r>:
 800c6c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c6c8:	b09d      	sub	sp, #116	; 0x74
 800c6ca:	4680      	mov	r8, r0
 800c6cc:	9303      	str	r3, [sp, #12]
 800c6ce:	898b      	ldrh	r3, [r1, #12]
 800c6d0:	061c      	lsls	r4, r3, #24
 800c6d2:	460d      	mov	r5, r1
 800c6d4:	4616      	mov	r6, r2
 800c6d6:	d50f      	bpl.n	800c6f8 <_svfiprintf_r+0x34>
 800c6d8:	690b      	ldr	r3, [r1, #16]
 800c6da:	b96b      	cbnz	r3, 800c6f8 <_svfiprintf_r+0x34>
 800c6dc:	2140      	movs	r1, #64	; 0x40
 800c6de:	f7ff ff37 	bl	800c550 <_malloc_r>
 800c6e2:	6028      	str	r0, [r5, #0]
 800c6e4:	6128      	str	r0, [r5, #16]
 800c6e6:	b928      	cbnz	r0, 800c6f4 <_svfiprintf_r+0x30>
 800c6e8:	230c      	movs	r3, #12
 800c6ea:	f8c8 3000 	str.w	r3, [r8]
 800c6ee:	f04f 30ff 	mov.w	r0, #4294967295
 800c6f2:	e0c5      	b.n	800c880 <_svfiprintf_r+0x1bc>
 800c6f4:	2340      	movs	r3, #64	; 0x40
 800c6f6:	616b      	str	r3, [r5, #20]
 800c6f8:	2300      	movs	r3, #0
 800c6fa:	9309      	str	r3, [sp, #36]	; 0x24
 800c6fc:	2320      	movs	r3, #32
 800c6fe:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 800c702:	2330      	movs	r3, #48	; 0x30
 800c704:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 800c708:	f04f 0b01 	mov.w	fp, #1
 800c70c:	4637      	mov	r7, r6
 800c70e:	463c      	mov	r4, r7
 800c710:	f814 3b01 	ldrb.w	r3, [r4], #1
 800c714:	2b00      	cmp	r3, #0
 800c716:	d13c      	bne.n	800c792 <_svfiprintf_r+0xce>
 800c718:	ebb7 0a06 	subs.w	sl, r7, r6
 800c71c:	d00b      	beq.n	800c736 <_svfiprintf_r+0x72>
 800c71e:	4653      	mov	r3, sl
 800c720:	4632      	mov	r2, r6
 800c722:	4629      	mov	r1, r5
 800c724:	4640      	mov	r0, r8
 800c726:	f7ff ff71 	bl	800c60c <__ssputs_r>
 800c72a:	3001      	adds	r0, #1
 800c72c:	f000 80a3 	beq.w	800c876 <_svfiprintf_r+0x1b2>
 800c730:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c732:	4453      	add	r3, sl
 800c734:	9309      	str	r3, [sp, #36]	; 0x24
 800c736:	783b      	ldrb	r3, [r7, #0]
 800c738:	2b00      	cmp	r3, #0
 800c73a:	f000 809c 	beq.w	800c876 <_svfiprintf_r+0x1b2>
 800c73e:	2300      	movs	r3, #0
 800c740:	f04f 32ff 	mov.w	r2, #4294967295
 800c744:	9304      	str	r3, [sp, #16]
 800c746:	9307      	str	r3, [sp, #28]
 800c748:	9205      	str	r2, [sp, #20]
 800c74a:	9306      	str	r3, [sp, #24]
 800c74c:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 800c750:	931a      	str	r3, [sp, #104]	; 0x68
 800c752:	2205      	movs	r2, #5
 800c754:	7821      	ldrb	r1, [r4, #0]
 800c756:	4850      	ldr	r0, [pc, #320]	; (800c898 <_svfiprintf_r+0x1d4>)
 800c758:	f7f3 fd4a 	bl	80001f0 <memchr>
 800c75c:	1c67      	adds	r7, r4, #1
 800c75e:	9b04      	ldr	r3, [sp, #16]
 800c760:	b9d8      	cbnz	r0, 800c79a <_svfiprintf_r+0xd6>
 800c762:	06d9      	lsls	r1, r3, #27
 800c764:	bf44      	itt	mi
 800c766:	2220      	movmi	r2, #32
 800c768:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 800c76c:	071a      	lsls	r2, r3, #28
 800c76e:	bf44      	itt	mi
 800c770:	222b      	movmi	r2, #43	; 0x2b
 800c772:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 800c776:	7822      	ldrb	r2, [r4, #0]
 800c778:	2a2a      	cmp	r2, #42	; 0x2a
 800c77a:	d016      	beq.n	800c7aa <_svfiprintf_r+0xe6>
 800c77c:	9a07      	ldr	r2, [sp, #28]
 800c77e:	2100      	movs	r1, #0
 800c780:	200a      	movs	r0, #10
 800c782:	4627      	mov	r7, r4
 800c784:	3401      	adds	r4, #1
 800c786:	783b      	ldrb	r3, [r7, #0]
 800c788:	3b30      	subs	r3, #48	; 0x30
 800c78a:	2b09      	cmp	r3, #9
 800c78c:	d951      	bls.n	800c832 <_svfiprintf_r+0x16e>
 800c78e:	b1c9      	cbz	r1, 800c7c4 <_svfiprintf_r+0x100>
 800c790:	e011      	b.n	800c7b6 <_svfiprintf_r+0xf2>
 800c792:	2b25      	cmp	r3, #37	; 0x25
 800c794:	d0c0      	beq.n	800c718 <_svfiprintf_r+0x54>
 800c796:	4627      	mov	r7, r4
 800c798:	e7b9      	b.n	800c70e <_svfiprintf_r+0x4a>
 800c79a:	4a3f      	ldr	r2, [pc, #252]	; (800c898 <_svfiprintf_r+0x1d4>)
 800c79c:	1a80      	subs	r0, r0, r2
 800c79e:	fa0b f000 	lsl.w	r0, fp, r0
 800c7a2:	4318      	orrs	r0, r3
 800c7a4:	9004      	str	r0, [sp, #16]
 800c7a6:	463c      	mov	r4, r7
 800c7a8:	e7d3      	b.n	800c752 <_svfiprintf_r+0x8e>
 800c7aa:	9a03      	ldr	r2, [sp, #12]
 800c7ac:	1d11      	adds	r1, r2, #4
 800c7ae:	6812      	ldr	r2, [r2, #0]
 800c7b0:	9103      	str	r1, [sp, #12]
 800c7b2:	2a00      	cmp	r2, #0
 800c7b4:	db01      	blt.n	800c7ba <_svfiprintf_r+0xf6>
 800c7b6:	9207      	str	r2, [sp, #28]
 800c7b8:	e004      	b.n	800c7c4 <_svfiprintf_r+0x100>
 800c7ba:	4252      	negs	r2, r2
 800c7bc:	f043 0302 	orr.w	r3, r3, #2
 800c7c0:	9207      	str	r2, [sp, #28]
 800c7c2:	9304      	str	r3, [sp, #16]
 800c7c4:	783b      	ldrb	r3, [r7, #0]
 800c7c6:	2b2e      	cmp	r3, #46	; 0x2e
 800c7c8:	d10e      	bne.n	800c7e8 <_svfiprintf_r+0x124>
 800c7ca:	787b      	ldrb	r3, [r7, #1]
 800c7cc:	2b2a      	cmp	r3, #42	; 0x2a
 800c7ce:	f107 0101 	add.w	r1, r7, #1
 800c7d2:	d132      	bne.n	800c83a <_svfiprintf_r+0x176>
 800c7d4:	9b03      	ldr	r3, [sp, #12]
 800c7d6:	1d1a      	adds	r2, r3, #4
 800c7d8:	681b      	ldr	r3, [r3, #0]
 800c7da:	9203      	str	r2, [sp, #12]
 800c7dc:	2b00      	cmp	r3, #0
 800c7de:	bfb8      	it	lt
 800c7e0:	f04f 33ff 	movlt.w	r3, #4294967295
 800c7e4:	3702      	adds	r7, #2
 800c7e6:	9305      	str	r3, [sp, #20]
 800c7e8:	4c2c      	ldr	r4, [pc, #176]	; (800c89c <_svfiprintf_r+0x1d8>)
 800c7ea:	7839      	ldrb	r1, [r7, #0]
 800c7ec:	2203      	movs	r2, #3
 800c7ee:	4620      	mov	r0, r4
 800c7f0:	f7f3 fcfe 	bl	80001f0 <memchr>
 800c7f4:	b138      	cbz	r0, 800c806 <_svfiprintf_r+0x142>
 800c7f6:	2340      	movs	r3, #64	; 0x40
 800c7f8:	1b00      	subs	r0, r0, r4
 800c7fa:	fa03 f000 	lsl.w	r0, r3, r0
 800c7fe:	9b04      	ldr	r3, [sp, #16]
 800c800:	4303      	orrs	r3, r0
 800c802:	9304      	str	r3, [sp, #16]
 800c804:	3701      	adds	r7, #1
 800c806:	7839      	ldrb	r1, [r7, #0]
 800c808:	4825      	ldr	r0, [pc, #148]	; (800c8a0 <_svfiprintf_r+0x1dc>)
 800c80a:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 800c80e:	2206      	movs	r2, #6
 800c810:	1c7e      	adds	r6, r7, #1
 800c812:	f7f3 fced 	bl	80001f0 <memchr>
 800c816:	2800      	cmp	r0, #0
 800c818:	d035      	beq.n	800c886 <_svfiprintf_r+0x1c2>
 800c81a:	4b22      	ldr	r3, [pc, #136]	; (800c8a4 <_svfiprintf_r+0x1e0>)
 800c81c:	b9fb      	cbnz	r3, 800c85e <_svfiprintf_r+0x19a>
 800c81e:	9b03      	ldr	r3, [sp, #12]
 800c820:	3307      	adds	r3, #7
 800c822:	f023 0307 	bic.w	r3, r3, #7
 800c826:	3308      	adds	r3, #8
 800c828:	9303      	str	r3, [sp, #12]
 800c82a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c82c:	444b      	add	r3, r9
 800c82e:	9309      	str	r3, [sp, #36]	; 0x24
 800c830:	e76c      	b.n	800c70c <_svfiprintf_r+0x48>
 800c832:	fb00 3202 	mla	r2, r0, r2, r3
 800c836:	2101      	movs	r1, #1
 800c838:	e7a3      	b.n	800c782 <_svfiprintf_r+0xbe>
 800c83a:	2300      	movs	r3, #0
 800c83c:	9305      	str	r3, [sp, #20]
 800c83e:	4618      	mov	r0, r3
 800c840:	240a      	movs	r4, #10
 800c842:	460f      	mov	r7, r1
 800c844:	3101      	adds	r1, #1
 800c846:	783a      	ldrb	r2, [r7, #0]
 800c848:	3a30      	subs	r2, #48	; 0x30
 800c84a:	2a09      	cmp	r2, #9
 800c84c:	d903      	bls.n	800c856 <_svfiprintf_r+0x192>
 800c84e:	2b00      	cmp	r3, #0
 800c850:	d0ca      	beq.n	800c7e8 <_svfiprintf_r+0x124>
 800c852:	9005      	str	r0, [sp, #20]
 800c854:	e7c8      	b.n	800c7e8 <_svfiprintf_r+0x124>
 800c856:	fb04 2000 	mla	r0, r4, r0, r2
 800c85a:	2301      	movs	r3, #1
 800c85c:	e7f1      	b.n	800c842 <_svfiprintf_r+0x17e>
 800c85e:	ab03      	add	r3, sp, #12
 800c860:	9300      	str	r3, [sp, #0]
 800c862:	462a      	mov	r2, r5
 800c864:	4b10      	ldr	r3, [pc, #64]	; (800c8a8 <_svfiprintf_r+0x1e4>)
 800c866:	a904      	add	r1, sp, #16
 800c868:	4640      	mov	r0, r8
 800c86a:	f3af 8000 	nop.w
 800c86e:	f1b0 3fff 	cmp.w	r0, #4294967295
 800c872:	4681      	mov	r9, r0
 800c874:	d1d9      	bne.n	800c82a <_svfiprintf_r+0x166>
 800c876:	89ab      	ldrh	r3, [r5, #12]
 800c878:	065b      	lsls	r3, r3, #25
 800c87a:	f53f af38 	bmi.w	800c6ee <_svfiprintf_r+0x2a>
 800c87e:	9809      	ldr	r0, [sp, #36]	; 0x24
 800c880:	b01d      	add	sp, #116	; 0x74
 800c882:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c886:	ab03      	add	r3, sp, #12
 800c888:	9300      	str	r3, [sp, #0]
 800c88a:	462a      	mov	r2, r5
 800c88c:	4b06      	ldr	r3, [pc, #24]	; (800c8a8 <_svfiprintf_r+0x1e4>)
 800c88e:	a904      	add	r1, sp, #16
 800c890:	4640      	mov	r0, r8
 800c892:	f000 f9c1 	bl	800cc18 <_printf_i>
 800c896:	e7ea      	b.n	800c86e <_svfiprintf_r+0x1aa>
 800c898:	0800d6e8 	.word	0x0800d6e8
 800c89c:	0800d6ee 	.word	0x0800d6ee
 800c8a0:	0800d6f2 	.word	0x0800d6f2
 800c8a4:	00000000 	.word	0x00000000
 800c8a8:	0800c60d 	.word	0x0800c60d

0800c8ac <__sfputc_r>:
 800c8ac:	6893      	ldr	r3, [r2, #8]
 800c8ae:	3b01      	subs	r3, #1
 800c8b0:	2b00      	cmp	r3, #0
 800c8b2:	b410      	push	{r4}
 800c8b4:	6093      	str	r3, [r2, #8]
 800c8b6:	da09      	bge.n	800c8cc <__sfputc_r+0x20>
 800c8b8:	6994      	ldr	r4, [r2, #24]
 800c8ba:	42a3      	cmp	r3, r4
 800c8bc:	db02      	blt.n	800c8c4 <__sfputc_r+0x18>
 800c8be:	b2cb      	uxtb	r3, r1
 800c8c0:	2b0a      	cmp	r3, #10
 800c8c2:	d103      	bne.n	800c8cc <__sfputc_r+0x20>
 800c8c4:	f85d 4b04 	ldr.w	r4, [sp], #4
 800c8c8:	f000 bb1a 	b.w	800cf00 <__swbuf_r>
 800c8cc:	6813      	ldr	r3, [r2, #0]
 800c8ce:	1c58      	adds	r0, r3, #1
 800c8d0:	6010      	str	r0, [r2, #0]
 800c8d2:	7019      	strb	r1, [r3, #0]
 800c8d4:	b2c8      	uxtb	r0, r1
 800c8d6:	f85d 4b04 	ldr.w	r4, [sp], #4
 800c8da:	4770      	bx	lr

0800c8dc <__sfputs_r>:
 800c8dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c8de:	4606      	mov	r6, r0
 800c8e0:	460f      	mov	r7, r1
 800c8e2:	4614      	mov	r4, r2
 800c8e4:	18d5      	adds	r5, r2, r3
 800c8e6:	42ac      	cmp	r4, r5
 800c8e8:	d101      	bne.n	800c8ee <__sfputs_r+0x12>
 800c8ea:	2000      	movs	r0, #0
 800c8ec:	e007      	b.n	800c8fe <__sfputs_r+0x22>
 800c8ee:	463a      	mov	r2, r7
 800c8f0:	f814 1b01 	ldrb.w	r1, [r4], #1
 800c8f4:	4630      	mov	r0, r6
 800c8f6:	f7ff ffd9 	bl	800c8ac <__sfputc_r>
 800c8fa:	1c43      	adds	r3, r0, #1
 800c8fc:	d1f3      	bne.n	800c8e6 <__sfputs_r+0xa>
 800c8fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800c900 <_vfiprintf_r>:
 800c900:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c904:	b09d      	sub	sp, #116	; 0x74
 800c906:	460c      	mov	r4, r1
 800c908:	4617      	mov	r7, r2
 800c90a:	9303      	str	r3, [sp, #12]
 800c90c:	4606      	mov	r6, r0
 800c90e:	b118      	cbz	r0, 800c918 <_vfiprintf_r+0x18>
 800c910:	6983      	ldr	r3, [r0, #24]
 800c912:	b90b      	cbnz	r3, 800c918 <_vfiprintf_r+0x18>
 800c914:	f7ff fd92 	bl	800c43c <__sinit>
 800c918:	4b7c      	ldr	r3, [pc, #496]	; (800cb0c <_vfiprintf_r+0x20c>)
 800c91a:	429c      	cmp	r4, r3
 800c91c:	d157      	bne.n	800c9ce <_vfiprintf_r+0xce>
 800c91e:	6874      	ldr	r4, [r6, #4]
 800c920:	89a3      	ldrh	r3, [r4, #12]
 800c922:	0718      	lsls	r0, r3, #28
 800c924:	d55d      	bpl.n	800c9e2 <_vfiprintf_r+0xe2>
 800c926:	6923      	ldr	r3, [r4, #16]
 800c928:	2b00      	cmp	r3, #0
 800c92a:	d05a      	beq.n	800c9e2 <_vfiprintf_r+0xe2>
 800c92c:	2300      	movs	r3, #0
 800c92e:	9309      	str	r3, [sp, #36]	; 0x24
 800c930:	2320      	movs	r3, #32
 800c932:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 800c936:	2330      	movs	r3, #48	; 0x30
 800c938:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 800c93c:	f04f 0b01 	mov.w	fp, #1
 800c940:	46b8      	mov	r8, r7
 800c942:	4645      	mov	r5, r8
 800c944:	f815 3b01 	ldrb.w	r3, [r5], #1
 800c948:	2b00      	cmp	r3, #0
 800c94a:	d155      	bne.n	800c9f8 <_vfiprintf_r+0xf8>
 800c94c:	ebb8 0a07 	subs.w	sl, r8, r7
 800c950:	d00b      	beq.n	800c96a <_vfiprintf_r+0x6a>
 800c952:	4653      	mov	r3, sl
 800c954:	463a      	mov	r2, r7
 800c956:	4621      	mov	r1, r4
 800c958:	4630      	mov	r0, r6
 800c95a:	f7ff ffbf 	bl	800c8dc <__sfputs_r>
 800c95e:	3001      	adds	r0, #1
 800c960:	f000 80c4 	beq.w	800caec <_vfiprintf_r+0x1ec>
 800c964:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c966:	4453      	add	r3, sl
 800c968:	9309      	str	r3, [sp, #36]	; 0x24
 800c96a:	f898 3000 	ldrb.w	r3, [r8]
 800c96e:	2b00      	cmp	r3, #0
 800c970:	f000 80bc 	beq.w	800caec <_vfiprintf_r+0x1ec>
 800c974:	2300      	movs	r3, #0
 800c976:	f04f 32ff 	mov.w	r2, #4294967295
 800c97a:	9304      	str	r3, [sp, #16]
 800c97c:	9307      	str	r3, [sp, #28]
 800c97e:	9205      	str	r2, [sp, #20]
 800c980:	9306      	str	r3, [sp, #24]
 800c982:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 800c986:	931a      	str	r3, [sp, #104]	; 0x68
 800c988:	2205      	movs	r2, #5
 800c98a:	7829      	ldrb	r1, [r5, #0]
 800c98c:	4860      	ldr	r0, [pc, #384]	; (800cb10 <_vfiprintf_r+0x210>)
 800c98e:	f7f3 fc2f 	bl	80001f0 <memchr>
 800c992:	f105 0801 	add.w	r8, r5, #1
 800c996:	9b04      	ldr	r3, [sp, #16]
 800c998:	2800      	cmp	r0, #0
 800c99a:	d131      	bne.n	800ca00 <_vfiprintf_r+0x100>
 800c99c:	06d9      	lsls	r1, r3, #27
 800c99e:	bf44      	itt	mi
 800c9a0:	2220      	movmi	r2, #32
 800c9a2:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 800c9a6:	071a      	lsls	r2, r3, #28
 800c9a8:	bf44      	itt	mi
 800c9aa:	222b      	movmi	r2, #43	; 0x2b
 800c9ac:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 800c9b0:	782a      	ldrb	r2, [r5, #0]
 800c9b2:	2a2a      	cmp	r2, #42	; 0x2a
 800c9b4:	d02c      	beq.n	800ca10 <_vfiprintf_r+0x110>
 800c9b6:	9a07      	ldr	r2, [sp, #28]
 800c9b8:	2100      	movs	r1, #0
 800c9ba:	200a      	movs	r0, #10
 800c9bc:	46a8      	mov	r8, r5
 800c9be:	3501      	adds	r5, #1
 800c9c0:	f898 3000 	ldrb.w	r3, [r8]
 800c9c4:	3b30      	subs	r3, #48	; 0x30
 800c9c6:	2b09      	cmp	r3, #9
 800c9c8:	d96d      	bls.n	800caa6 <_vfiprintf_r+0x1a6>
 800c9ca:	b371      	cbz	r1, 800ca2a <_vfiprintf_r+0x12a>
 800c9cc:	e026      	b.n	800ca1c <_vfiprintf_r+0x11c>
 800c9ce:	4b51      	ldr	r3, [pc, #324]	; (800cb14 <_vfiprintf_r+0x214>)
 800c9d0:	429c      	cmp	r4, r3
 800c9d2:	d101      	bne.n	800c9d8 <_vfiprintf_r+0xd8>
 800c9d4:	68b4      	ldr	r4, [r6, #8]
 800c9d6:	e7a3      	b.n	800c920 <_vfiprintf_r+0x20>
 800c9d8:	4b4f      	ldr	r3, [pc, #316]	; (800cb18 <_vfiprintf_r+0x218>)
 800c9da:	429c      	cmp	r4, r3
 800c9dc:	bf08      	it	eq
 800c9de:	68f4      	ldreq	r4, [r6, #12]
 800c9e0:	e79e      	b.n	800c920 <_vfiprintf_r+0x20>
 800c9e2:	4621      	mov	r1, r4
 800c9e4:	4630      	mov	r0, r6
 800c9e6:	f000 faef 	bl	800cfc8 <__swsetup_r>
 800c9ea:	2800      	cmp	r0, #0
 800c9ec:	d09e      	beq.n	800c92c <_vfiprintf_r+0x2c>
 800c9ee:	f04f 30ff 	mov.w	r0, #4294967295
 800c9f2:	b01d      	add	sp, #116	; 0x74
 800c9f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c9f8:	2b25      	cmp	r3, #37	; 0x25
 800c9fa:	d0a7      	beq.n	800c94c <_vfiprintf_r+0x4c>
 800c9fc:	46a8      	mov	r8, r5
 800c9fe:	e7a0      	b.n	800c942 <_vfiprintf_r+0x42>
 800ca00:	4a43      	ldr	r2, [pc, #268]	; (800cb10 <_vfiprintf_r+0x210>)
 800ca02:	1a80      	subs	r0, r0, r2
 800ca04:	fa0b f000 	lsl.w	r0, fp, r0
 800ca08:	4318      	orrs	r0, r3
 800ca0a:	9004      	str	r0, [sp, #16]
 800ca0c:	4645      	mov	r5, r8
 800ca0e:	e7bb      	b.n	800c988 <_vfiprintf_r+0x88>
 800ca10:	9a03      	ldr	r2, [sp, #12]
 800ca12:	1d11      	adds	r1, r2, #4
 800ca14:	6812      	ldr	r2, [r2, #0]
 800ca16:	9103      	str	r1, [sp, #12]
 800ca18:	2a00      	cmp	r2, #0
 800ca1a:	db01      	blt.n	800ca20 <_vfiprintf_r+0x120>
 800ca1c:	9207      	str	r2, [sp, #28]
 800ca1e:	e004      	b.n	800ca2a <_vfiprintf_r+0x12a>
 800ca20:	4252      	negs	r2, r2
 800ca22:	f043 0302 	orr.w	r3, r3, #2
 800ca26:	9207      	str	r2, [sp, #28]
 800ca28:	9304      	str	r3, [sp, #16]
 800ca2a:	f898 3000 	ldrb.w	r3, [r8]
 800ca2e:	2b2e      	cmp	r3, #46	; 0x2e
 800ca30:	d110      	bne.n	800ca54 <_vfiprintf_r+0x154>
 800ca32:	f898 3001 	ldrb.w	r3, [r8, #1]
 800ca36:	2b2a      	cmp	r3, #42	; 0x2a
 800ca38:	f108 0101 	add.w	r1, r8, #1
 800ca3c:	d137      	bne.n	800caae <_vfiprintf_r+0x1ae>
 800ca3e:	9b03      	ldr	r3, [sp, #12]
 800ca40:	1d1a      	adds	r2, r3, #4
 800ca42:	681b      	ldr	r3, [r3, #0]
 800ca44:	9203      	str	r2, [sp, #12]
 800ca46:	2b00      	cmp	r3, #0
 800ca48:	bfb8      	it	lt
 800ca4a:	f04f 33ff 	movlt.w	r3, #4294967295
 800ca4e:	f108 0802 	add.w	r8, r8, #2
 800ca52:	9305      	str	r3, [sp, #20]
 800ca54:	4d31      	ldr	r5, [pc, #196]	; (800cb1c <_vfiprintf_r+0x21c>)
 800ca56:	f898 1000 	ldrb.w	r1, [r8]
 800ca5a:	2203      	movs	r2, #3
 800ca5c:	4628      	mov	r0, r5
 800ca5e:	f7f3 fbc7 	bl	80001f0 <memchr>
 800ca62:	b140      	cbz	r0, 800ca76 <_vfiprintf_r+0x176>
 800ca64:	2340      	movs	r3, #64	; 0x40
 800ca66:	1b40      	subs	r0, r0, r5
 800ca68:	fa03 f000 	lsl.w	r0, r3, r0
 800ca6c:	9b04      	ldr	r3, [sp, #16]
 800ca6e:	4303      	orrs	r3, r0
 800ca70:	9304      	str	r3, [sp, #16]
 800ca72:	f108 0801 	add.w	r8, r8, #1
 800ca76:	f898 1000 	ldrb.w	r1, [r8]
 800ca7a:	4829      	ldr	r0, [pc, #164]	; (800cb20 <_vfiprintf_r+0x220>)
 800ca7c:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 800ca80:	2206      	movs	r2, #6
 800ca82:	f108 0701 	add.w	r7, r8, #1
 800ca86:	f7f3 fbb3 	bl	80001f0 <memchr>
 800ca8a:	2800      	cmp	r0, #0
 800ca8c:	d034      	beq.n	800caf8 <_vfiprintf_r+0x1f8>
 800ca8e:	4b25      	ldr	r3, [pc, #148]	; (800cb24 <_vfiprintf_r+0x224>)
 800ca90:	bb03      	cbnz	r3, 800cad4 <_vfiprintf_r+0x1d4>
 800ca92:	9b03      	ldr	r3, [sp, #12]
 800ca94:	3307      	adds	r3, #7
 800ca96:	f023 0307 	bic.w	r3, r3, #7
 800ca9a:	3308      	adds	r3, #8
 800ca9c:	9303      	str	r3, [sp, #12]
 800ca9e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800caa0:	444b      	add	r3, r9
 800caa2:	9309      	str	r3, [sp, #36]	; 0x24
 800caa4:	e74c      	b.n	800c940 <_vfiprintf_r+0x40>
 800caa6:	fb00 3202 	mla	r2, r0, r2, r3
 800caaa:	2101      	movs	r1, #1
 800caac:	e786      	b.n	800c9bc <_vfiprintf_r+0xbc>
 800caae:	2300      	movs	r3, #0
 800cab0:	9305      	str	r3, [sp, #20]
 800cab2:	4618      	mov	r0, r3
 800cab4:	250a      	movs	r5, #10
 800cab6:	4688      	mov	r8, r1
 800cab8:	3101      	adds	r1, #1
 800caba:	f898 2000 	ldrb.w	r2, [r8]
 800cabe:	3a30      	subs	r2, #48	; 0x30
 800cac0:	2a09      	cmp	r2, #9
 800cac2:	d903      	bls.n	800cacc <_vfiprintf_r+0x1cc>
 800cac4:	2b00      	cmp	r3, #0
 800cac6:	d0c5      	beq.n	800ca54 <_vfiprintf_r+0x154>
 800cac8:	9005      	str	r0, [sp, #20]
 800caca:	e7c3      	b.n	800ca54 <_vfiprintf_r+0x154>
 800cacc:	fb05 2000 	mla	r0, r5, r0, r2
 800cad0:	2301      	movs	r3, #1
 800cad2:	e7f0      	b.n	800cab6 <_vfiprintf_r+0x1b6>
 800cad4:	ab03      	add	r3, sp, #12
 800cad6:	9300      	str	r3, [sp, #0]
 800cad8:	4622      	mov	r2, r4
 800cada:	4b13      	ldr	r3, [pc, #76]	; (800cb28 <_vfiprintf_r+0x228>)
 800cadc:	a904      	add	r1, sp, #16
 800cade:	4630      	mov	r0, r6
 800cae0:	f3af 8000 	nop.w
 800cae4:	f1b0 3fff 	cmp.w	r0, #4294967295
 800cae8:	4681      	mov	r9, r0
 800caea:	d1d8      	bne.n	800ca9e <_vfiprintf_r+0x19e>
 800caec:	89a3      	ldrh	r3, [r4, #12]
 800caee:	065b      	lsls	r3, r3, #25
 800caf0:	f53f af7d 	bmi.w	800c9ee <_vfiprintf_r+0xee>
 800caf4:	9809      	ldr	r0, [sp, #36]	; 0x24
 800caf6:	e77c      	b.n	800c9f2 <_vfiprintf_r+0xf2>
 800caf8:	ab03      	add	r3, sp, #12
 800cafa:	9300      	str	r3, [sp, #0]
 800cafc:	4622      	mov	r2, r4
 800cafe:	4b0a      	ldr	r3, [pc, #40]	; (800cb28 <_vfiprintf_r+0x228>)
 800cb00:	a904      	add	r1, sp, #16
 800cb02:	4630      	mov	r0, r6
 800cb04:	f000 f888 	bl	800cc18 <_printf_i>
 800cb08:	e7ec      	b.n	800cae4 <_vfiprintf_r+0x1e4>
 800cb0a:	bf00      	nop
 800cb0c:	0800d6a8 	.word	0x0800d6a8
 800cb10:	0800d6e8 	.word	0x0800d6e8
 800cb14:	0800d6c8 	.word	0x0800d6c8
 800cb18:	0800d688 	.word	0x0800d688
 800cb1c:	0800d6ee 	.word	0x0800d6ee
 800cb20:	0800d6f2 	.word	0x0800d6f2
 800cb24:	00000000 	.word	0x00000000
 800cb28:	0800c8dd 	.word	0x0800c8dd

0800cb2c <_printf_common>:
 800cb2c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800cb30:	4691      	mov	r9, r2
 800cb32:	461f      	mov	r7, r3
 800cb34:	688a      	ldr	r2, [r1, #8]
 800cb36:	690b      	ldr	r3, [r1, #16]
 800cb38:	f8dd 8020 	ldr.w	r8, [sp, #32]
 800cb3c:	4293      	cmp	r3, r2
 800cb3e:	bfb8      	it	lt
 800cb40:	4613      	movlt	r3, r2
 800cb42:	f8c9 3000 	str.w	r3, [r9]
 800cb46:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 800cb4a:	4606      	mov	r6, r0
 800cb4c:	460c      	mov	r4, r1
 800cb4e:	b112      	cbz	r2, 800cb56 <_printf_common+0x2a>
 800cb50:	3301      	adds	r3, #1
 800cb52:	f8c9 3000 	str.w	r3, [r9]
 800cb56:	6823      	ldr	r3, [r4, #0]
 800cb58:	0699      	lsls	r1, r3, #26
 800cb5a:	bf42      	ittt	mi
 800cb5c:	f8d9 3000 	ldrmi.w	r3, [r9]
 800cb60:	3302      	addmi	r3, #2
 800cb62:	f8c9 3000 	strmi.w	r3, [r9]
 800cb66:	6825      	ldr	r5, [r4, #0]
 800cb68:	f015 0506 	ands.w	r5, r5, #6
 800cb6c:	d107      	bne.n	800cb7e <_printf_common+0x52>
 800cb6e:	f104 0a19 	add.w	sl, r4, #25
 800cb72:	68e3      	ldr	r3, [r4, #12]
 800cb74:	f8d9 2000 	ldr.w	r2, [r9]
 800cb78:	1a9b      	subs	r3, r3, r2
 800cb7a:	429d      	cmp	r5, r3
 800cb7c:	db29      	blt.n	800cbd2 <_printf_common+0xa6>
 800cb7e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 800cb82:	6822      	ldr	r2, [r4, #0]
 800cb84:	3300      	adds	r3, #0
 800cb86:	bf18      	it	ne
 800cb88:	2301      	movne	r3, #1
 800cb8a:	0692      	lsls	r2, r2, #26
 800cb8c:	d42e      	bmi.n	800cbec <_printf_common+0xc0>
 800cb8e:	f104 0243 	add.w	r2, r4, #67	; 0x43
 800cb92:	4639      	mov	r1, r7
 800cb94:	4630      	mov	r0, r6
 800cb96:	47c0      	blx	r8
 800cb98:	3001      	adds	r0, #1
 800cb9a:	d021      	beq.n	800cbe0 <_printf_common+0xb4>
 800cb9c:	6823      	ldr	r3, [r4, #0]
 800cb9e:	68e5      	ldr	r5, [r4, #12]
 800cba0:	f8d9 2000 	ldr.w	r2, [r9]
 800cba4:	f003 0306 	and.w	r3, r3, #6
 800cba8:	2b04      	cmp	r3, #4
 800cbaa:	bf08      	it	eq
 800cbac:	1aad      	subeq	r5, r5, r2
 800cbae:	68a3      	ldr	r3, [r4, #8]
 800cbb0:	6922      	ldr	r2, [r4, #16]
 800cbb2:	bf0c      	ite	eq
 800cbb4:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 800cbb8:	2500      	movne	r5, #0
 800cbba:	4293      	cmp	r3, r2
 800cbbc:	bfc4      	itt	gt
 800cbbe:	1a9b      	subgt	r3, r3, r2
 800cbc0:	18ed      	addgt	r5, r5, r3
 800cbc2:	f04f 0900 	mov.w	r9, #0
 800cbc6:	341a      	adds	r4, #26
 800cbc8:	454d      	cmp	r5, r9
 800cbca:	d11b      	bne.n	800cc04 <_printf_common+0xd8>
 800cbcc:	2000      	movs	r0, #0
 800cbce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800cbd2:	2301      	movs	r3, #1
 800cbd4:	4652      	mov	r2, sl
 800cbd6:	4639      	mov	r1, r7
 800cbd8:	4630      	mov	r0, r6
 800cbda:	47c0      	blx	r8
 800cbdc:	3001      	adds	r0, #1
 800cbde:	d103      	bne.n	800cbe8 <_printf_common+0xbc>
 800cbe0:	f04f 30ff 	mov.w	r0, #4294967295
 800cbe4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800cbe8:	3501      	adds	r5, #1
 800cbea:	e7c2      	b.n	800cb72 <_printf_common+0x46>
 800cbec:	18e1      	adds	r1, r4, r3
 800cbee:	1c5a      	adds	r2, r3, #1
 800cbf0:	2030      	movs	r0, #48	; 0x30
 800cbf2:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 800cbf6:	4422      	add	r2, r4
 800cbf8:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 800cbfc:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 800cc00:	3302      	adds	r3, #2
 800cc02:	e7c4      	b.n	800cb8e <_printf_common+0x62>
 800cc04:	2301      	movs	r3, #1
 800cc06:	4622      	mov	r2, r4
 800cc08:	4639      	mov	r1, r7
 800cc0a:	4630      	mov	r0, r6
 800cc0c:	47c0      	blx	r8
 800cc0e:	3001      	adds	r0, #1
 800cc10:	d0e6      	beq.n	800cbe0 <_printf_common+0xb4>
 800cc12:	f109 0901 	add.w	r9, r9, #1
 800cc16:	e7d7      	b.n	800cbc8 <_printf_common+0x9c>

0800cc18 <_printf_i>:
 800cc18:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800cc1c:	4617      	mov	r7, r2
 800cc1e:	7e0a      	ldrb	r2, [r1, #24]
 800cc20:	b085      	sub	sp, #20
 800cc22:	2a6e      	cmp	r2, #110	; 0x6e
 800cc24:	4698      	mov	r8, r3
 800cc26:	4606      	mov	r6, r0
 800cc28:	460c      	mov	r4, r1
 800cc2a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800cc2c:	f101 0e43 	add.w	lr, r1, #67	; 0x43
 800cc30:	f000 80bc 	beq.w	800cdac <_printf_i+0x194>
 800cc34:	d81a      	bhi.n	800cc6c <_printf_i+0x54>
 800cc36:	2a63      	cmp	r2, #99	; 0x63
 800cc38:	d02e      	beq.n	800cc98 <_printf_i+0x80>
 800cc3a:	d80a      	bhi.n	800cc52 <_printf_i+0x3a>
 800cc3c:	2a00      	cmp	r2, #0
 800cc3e:	f000 80c8 	beq.w	800cdd2 <_printf_i+0x1ba>
 800cc42:	2a58      	cmp	r2, #88	; 0x58
 800cc44:	f000 808a 	beq.w	800cd5c <_printf_i+0x144>
 800cc48:	f104 0542 	add.w	r5, r4, #66	; 0x42
 800cc4c:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
 800cc50:	e02a      	b.n	800cca8 <_printf_i+0x90>
 800cc52:	2a64      	cmp	r2, #100	; 0x64
 800cc54:	d001      	beq.n	800cc5a <_printf_i+0x42>
 800cc56:	2a69      	cmp	r2, #105	; 0x69
 800cc58:	d1f6      	bne.n	800cc48 <_printf_i+0x30>
 800cc5a:	6821      	ldr	r1, [r4, #0]
 800cc5c:	681a      	ldr	r2, [r3, #0]
 800cc5e:	f011 0f80 	tst.w	r1, #128	; 0x80
 800cc62:	d023      	beq.n	800ccac <_printf_i+0x94>
 800cc64:	1d11      	adds	r1, r2, #4
 800cc66:	6019      	str	r1, [r3, #0]
 800cc68:	6813      	ldr	r3, [r2, #0]
 800cc6a:	e027      	b.n	800ccbc <_printf_i+0xa4>
 800cc6c:	2a73      	cmp	r2, #115	; 0x73
 800cc6e:	f000 80b4 	beq.w	800cdda <_printf_i+0x1c2>
 800cc72:	d808      	bhi.n	800cc86 <_printf_i+0x6e>
 800cc74:	2a6f      	cmp	r2, #111	; 0x6f
 800cc76:	d02a      	beq.n	800ccce <_printf_i+0xb6>
 800cc78:	2a70      	cmp	r2, #112	; 0x70
 800cc7a:	d1e5      	bne.n	800cc48 <_printf_i+0x30>
 800cc7c:	680a      	ldr	r2, [r1, #0]
 800cc7e:	f042 0220 	orr.w	r2, r2, #32
 800cc82:	600a      	str	r2, [r1, #0]
 800cc84:	e003      	b.n	800cc8e <_printf_i+0x76>
 800cc86:	2a75      	cmp	r2, #117	; 0x75
 800cc88:	d021      	beq.n	800ccce <_printf_i+0xb6>
 800cc8a:	2a78      	cmp	r2, #120	; 0x78
 800cc8c:	d1dc      	bne.n	800cc48 <_printf_i+0x30>
 800cc8e:	2278      	movs	r2, #120	; 0x78
 800cc90:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
 800cc94:	496e      	ldr	r1, [pc, #440]	; (800ce50 <_printf_i+0x238>)
 800cc96:	e064      	b.n	800cd62 <_printf_i+0x14a>
 800cc98:	681a      	ldr	r2, [r3, #0]
 800cc9a:	f101 0542 	add.w	r5, r1, #66	; 0x42
 800cc9e:	1d11      	adds	r1, r2, #4
 800cca0:	6019      	str	r1, [r3, #0]
 800cca2:	6813      	ldr	r3, [r2, #0]
 800cca4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 800cca8:	2301      	movs	r3, #1
 800ccaa:	e0a3      	b.n	800cdf4 <_printf_i+0x1dc>
 800ccac:	f011 0f40 	tst.w	r1, #64	; 0x40
 800ccb0:	f102 0104 	add.w	r1, r2, #4
 800ccb4:	6019      	str	r1, [r3, #0]
 800ccb6:	d0d7      	beq.n	800cc68 <_printf_i+0x50>
 800ccb8:	f9b2 3000 	ldrsh.w	r3, [r2]
 800ccbc:	2b00      	cmp	r3, #0
 800ccbe:	da03      	bge.n	800ccc8 <_printf_i+0xb0>
 800ccc0:	222d      	movs	r2, #45	; 0x2d
 800ccc2:	425b      	negs	r3, r3
 800ccc4:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 800ccc8:	4962      	ldr	r1, [pc, #392]	; (800ce54 <_printf_i+0x23c>)
 800ccca:	220a      	movs	r2, #10
 800cccc:	e017      	b.n	800ccfe <_printf_i+0xe6>
 800ccce:	6820      	ldr	r0, [r4, #0]
 800ccd0:	6819      	ldr	r1, [r3, #0]
 800ccd2:	f010 0f80 	tst.w	r0, #128	; 0x80
 800ccd6:	d003      	beq.n	800cce0 <_printf_i+0xc8>
 800ccd8:	1d08      	adds	r0, r1, #4
 800ccda:	6018      	str	r0, [r3, #0]
 800ccdc:	680b      	ldr	r3, [r1, #0]
 800ccde:	e006      	b.n	800ccee <_printf_i+0xd6>
 800cce0:	f010 0f40 	tst.w	r0, #64	; 0x40
 800cce4:	f101 0004 	add.w	r0, r1, #4
 800cce8:	6018      	str	r0, [r3, #0]
 800ccea:	d0f7      	beq.n	800ccdc <_printf_i+0xc4>
 800ccec:	880b      	ldrh	r3, [r1, #0]
 800ccee:	4959      	ldr	r1, [pc, #356]	; (800ce54 <_printf_i+0x23c>)
 800ccf0:	2a6f      	cmp	r2, #111	; 0x6f
 800ccf2:	bf14      	ite	ne
 800ccf4:	220a      	movne	r2, #10
 800ccf6:	2208      	moveq	r2, #8
 800ccf8:	2000      	movs	r0, #0
 800ccfa:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
 800ccfe:	6865      	ldr	r5, [r4, #4]
 800cd00:	60a5      	str	r5, [r4, #8]
 800cd02:	2d00      	cmp	r5, #0
 800cd04:	f2c0 809c 	blt.w	800ce40 <_printf_i+0x228>
 800cd08:	6820      	ldr	r0, [r4, #0]
 800cd0a:	f020 0004 	bic.w	r0, r0, #4
 800cd0e:	6020      	str	r0, [r4, #0]
 800cd10:	2b00      	cmp	r3, #0
 800cd12:	d13f      	bne.n	800cd94 <_printf_i+0x17c>
 800cd14:	2d00      	cmp	r5, #0
 800cd16:	f040 8095 	bne.w	800ce44 <_printf_i+0x22c>
 800cd1a:	4675      	mov	r5, lr
 800cd1c:	2a08      	cmp	r2, #8
 800cd1e:	d10b      	bne.n	800cd38 <_printf_i+0x120>
 800cd20:	6823      	ldr	r3, [r4, #0]
 800cd22:	07da      	lsls	r2, r3, #31
 800cd24:	d508      	bpl.n	800cd38 <_printf_i+0x120>
 800cd26:	6923      	ldr	r3, [r4, #16]
 800cd28:	6862      	ldr	r2, [r4, #4]
 800cd2a:	429a      	cmp	r2, r3
 800cd2c:	bfde      	ittt	le
 800cd2e:	2330      	movle	r3, #48	; 0x30
 800cd30:	f805 3c01 	strble.w	r3, [r5, #-1]
 800cd34:	f105 35ff 	addle.w	r5, r5, #4294967295
 800cd38:	ebae 0305 	sub.w	r3, lr, r5
 800cd3c:	6123      	str	r3, [r4, #16]
 800cd3e:	f8cd 8000 	str.w	r8, [sp]
 800cd42:	463b      	mov	r3, r7
 800cd44:	aa03      	add	r2, sp, #12
 800cd46:	4621      	mov	r1, r4
 800cd48:	4630      	mov	r0, r6
 800cd4a:	f7ff feef 	bl	800cb2c <_printf_common>
 800cd4e:	3001      	adds	r0, #1
 800cd50:	d155      	bne.n	800cdfe <_printf_i+0x1e6>
 800cd52:	f04f 30ff 	mov.w	r0, #4294967295
 800cd56:	b005      	add	sp, #20
 800cd58:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800cd5c:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
 800cd60:	493c      	ldr	r1, [pc, #240]	; (800ce54 <_printf_i+0x23c>)
 800cd62:	6822      	ldr	r2, [r4, #0]
 800cd64:	6818      	ldr	r0, [r3, #0]
 800cd66:	f012 0f80 	tst.w	r2, #128	; 0x80
 800cd6a:	f100 0504 	add.w	r5, r0, #4
 800cd6e:	601d      	str	r5, [r3, #0]
 800cd70:	d001      	beq.n	800cd76 <_printf_i+0x15e>
 800cd72:	6803      	ldr	r3, [r0, #0]
 800cd74:	e002      	b.n	800cd7c <_printf_i+0x164>
 800cd76:	0655      	lsls	r5, r2, #25
 800cd78:	d5fb      	bpl.n	800cd72 <_printf_i+0x15a>
 800cd7a:	8803      	ldrh	r3, [r0, #0]
 800cd7c:	07d0      	lsls	r0, r2, #31
 800cd7e:	bf44      	itt	mi
 800cd80:	f042 0220 	orrmi.w	r2, r2, #32
 800cd84:	6022      	strmi	r2, [r4, #0]
 800cd86:	b91b      	cbnz	r3, 800cd90 <_printf_i+0x178>
 800cd88:	6822      	ldr	r2, [r4, #0]
 800cd8a:	f022 0220 	bic.w	r2, r2, #32
 800cd8e:	6022      	str	r2, [r4, #0]
 800cd90:	2210      	movs	r2, #16
 800cd92:	e7b1      	b.n	800ccf8 <_printf_i+0xe0>
 800cd94:	4675      	mov	r5, lr
 800cd96:	fbb3 f0f2 	udiv	r0, r3, r2
 800cd9a:	fb02 3310 	mls	r3, r2, r0, r3
 800cd9e:	5ccb      	ldrb	r3, [r1, r3]
 800cda0:	f805 3d01 	strb.w	r3, [r5, #-1]!
 800cda4:	4603      	mov	r3, r0
 800cda6:	2800      	cmp	r0, #0
 800cda8:	d1f5      	bne.n	800cd96 <_printf_i+0x17e>
 800cdaa:	e7b7      	b.n	800cd1c <_printf_i+0x104>
 800cdac:	6808      	ldr	r0, [r1, #0]
 800cdae:	681a      	ldr	r2, [r3, #0]
 800cdb0:	6949      	ldr	r1, [r1, #20]
 800cdb2:	f010 0f80 	tst.w	r0, #128	; 0x80
 800cdb6:	d004      	beq.n	800cdc2 <_printf_i+0x1aa>
 800cdb8:	1d10      	adds	r0, r2, #4
 800cdba:	6018      	str	r0, [r3, #0]
 800cdbc:	6813      	ldr	r3, [r2, #0]
 800cdbe:	6019      	str	r1, [r3, #0]
 800cdc0:	e007      	b.n	800cdd2 <_printf_i+0x1ba>
 800cdc2:	f010 0f40 	tst.w	r0, #64	; 0x40
 800cdc6:	f102 0004 	add.w	r0, r2, #4
 800cdca:	6018      	str	r0, [r3, #0]
 800cdcc:	6813      	ldr	r3, [r2, #0]
 800cdce:	d0f6      	beq.n	800cdbe <_printf_i+0x1a6>
 800cdd0:	8019      	strh	r1, [r3, #0]
 800cdd2:	2300      	movs	r3, #0
 800cdd4:	6123      	str	r3, [r4, #16]
 800cdd6:	4675      	mov	r5, lr
 800cdd8:	e7b1      	b.n	800cd3e <_printf_i+0x126>
 800cdda:	681a      	ldr	r2, [r3, #0]
 800cddc:	1d11      	adds	r1, r2, #4
 800cdde:	6019      	str	r1, [r3, #0]
 800cde0:	6815      	ldr	r5, [r2, #0]
 800cde2:	6862      	ldr	r2, [r4, #4]
 800cde4:	2100      	movs	r1, #0
 800cde6:	4628      	mov	r0, r5
 800cde8:	f7f3 fa02 	bl	80001f0 <memchr>
 800cdec:	b108      	cbz	r0, 800cdf2 <_printf_i+0x1da>
 800cdee:	1b40      	subs	r0, r0, r5
 800cdf0:	6060      	str	r0, [r4, #4]
 800cdf2:	6863      	ldr	r3, [r4, #4]
 800cdf4:	6123      	str	r3, [r4, #16]
 800cdf6:	2300      	movs	r3, #0
 800cdf8:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800cdfc:	e79f      	b.n	800cd3e <_printf_i+0x126>
 800cdfe:	6923      	ldr	r3, [r4, #16]
 800ce00:	462a      	mov	r2, r5
 800ce02:	4639      	mov	r1, r7
 800ce04:	4630      	mov	r0, r6
 800ce06:	47c0      	blx	r8
 800ce08:	3001      	adds	r0, #1
 800ce0a:	d0a2      	beq.n	800cd52 <_printf_i+0x13a>
 800ce0c:	6823      	ldr	r3, [r4, #0]
 800ce0e:	079b      	lsls	r3, r3, #30
 800ce10:	d507      	bpl.n	800ce22 <_printf_i+0x20a>
 800ce12:	2500      	movs	r5, #0
 800ce14:	f104 0919 	add.w	r9, r4, #25
 800ce18:	68e3      	ldr	r3, [r4, #12]
 800ce1a:	9a03      	ldr	r2, [sp, #12]
 800ce1c:	1a9b      	subs	r3, r3, r2
 800ce1e:	429d      	cmp	r5, r3
 800ce20:	db05      	blt.n	800ce2e <_printf_i+0x216>
 800ce22:	68e0      	ldr	r0, [r4, #12]
 800ce24:	9b03      	ldr	r3, [sp, #12]
 800ce26:	4298      	cmp	r0, r3
 800ce28:	bfb8      	it	lt
 800ce2a:	4618      	movlt	r0, r3
 800ce2c:	e793      	b.n	800cd56 <_printf_i+0x13e>
 800ce2e:	2301      	movs	r3, #1
 800ce30:	464a      	mov	r2, r9
 800ce32:	4639      	mov	r1, r7
 800ce34:	4630      	mov	r0, r6
 800ce36:	47c0      	blx	r8
 800ce38:	3001      	adds	r0, #1
 800ce3a:	d08a      	beq.n	800cd52 <_printf_i+0x13a>
 800ce3c:	3501      	adds	r5, #1
 800ce3e:	e7eb      	b.n	800ce18 <_printf_i+0x200>
 800ce40:	2b00      	cmp	r3, #0
 800ce42:	d1a7      	bne.n	800cd94 <_printf_i+0x17c>
 800ce44:	780b      	ldrb	r3, [r1, #0]
 800ce46:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 800ce4a:	f104 0542 	add.w	r5, r4, #66	; 0x42
 800ce4e:	e765      	b.n	800cd1c <_printf_i+0x104>
 800ce50:	0800d70a 	.word	0x0800d70a
 800ce54:	0800d6f9 	.word	0x0800d6f9

0800ce58 <_sbrk_r>:
 800ce58:	b538      	push	{r3, r4, r5, lr}
 800ce5a:	4c06      	ldr	r4, [pc, #24]	; (800ce74 <_sbrk_r+0x1c>)
 800ce5c:	2300      	movs	r3, #0
 800ce5e:	4605      	mov	r5, r0
 800ce60:	4608      	mov	r0, r1
 800ce62:	6023      	str	r3, [r4, #0]
 800ce64:	f7ff fa04 	bl	800c270 <_sbrk>
 800ce68:	1c43      	adds	r3, r0, #1
 800ce6a:	d102      	bne.n	800ce72 <_sbrk_r+0x1a>
 800ce6c:	6823      	ldr	r3, [r4, #0]
 800ce6e:	b103      	cbz	r3, 800ce72 <_sbrk_r+0x1a>
 800ce70:	602b      	str	r3, [r5, #0]
 800ce72:	bd38      	pop	{r3, r4, r5, pc}
 800ce74:	20000dcc 	.word	0x20000dcc

0800ce78 <__sread>:
 800ce78:	b510      	push	{r4, lr}
 800ce7a:	460c      	mov	r4, r1
 800ce7c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800ce80:	f000 fae4 	bl	800d44c <_read_r>
 800ce84:	2800      	cmp	r0, #0
 800ce86:	bfab      	itete	ge
 800ce88:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 800ce8a:	89a3      	ldrhlt	r3, [r4, #12]
 800ce8c:	181b      	addge	r3, r3, r0
 800ce8e:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 800ce92:	bfac      	ite	ge
 800ce94:	6563      	strge	r3, [r4, #84]	; 0x54
 800ce96:	81a3      	strhlt	r3, [r4, #12]
 800ce98:	bd10      	pop	{r4, pc}

0800ce9a <__swrite>:
 800ce9a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ce9e:	461f      	mov	r7, r3
 800cea0:	898b      	ldrh	r3, [r1, #12]
 800cea2:	05db      	lsls	r3, r3, #23
 800cea4:	4605      	mov	r5, r0
 800cea6:	460c      	mov	r4, r1
 800cea8:	4616      	mov	r6, r2
 800ceaa:	d505      	bpl.n	800ceb8 <__swrite+0x1e>
 800ceac:	2302      	movs	r3, #2
 800ceae:	2200      	movs	r2, #0
 800ceb0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800ceb4:	f000 f9b8 	bl	800d228 <_lseek_r>
 800ceb8:	89a3      	ldrh	r3, [r4, #12]
 800ceba:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800cebe:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800cec2:	81a3      	strh	r3, [r4, #12]
 800cec4:	4632      	mov	r2, r6
 800cec6:	463b      	mov	r3, r7
 800cec8:	4628      	mov	r0, r5
 800ceca:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800cece:	f000 b869 	b.w	800cfa4 <_write_r>

0800ced2 <__sseek>:
 800ced2:	b510      	push	{r4, lr}
 800ced4:	460c      	mov	r4, r1
 800ced6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800ceda:	f000 f9a5 	bl	800d228 <_lseek_r>
 800cede:	1c43      	adds	r3, r0, #1
 800cee0:	89a3      	ldrh	r3, [r4, #12]
 800cee2:	bf15      	itete	ne
 800cee4:	6560      	strne	r0, [r4, #84]	; 0x54
 800cee6:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 800ceea:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 800ceee:	81a3      	strheq	r3, [r4, #12]
 800cef0:	bf18      	it	ne
 800cef2:	81a3      	strhne	r3, [r4, #12]
 800cef4:	bd10      	pop	{r4, pc}

0800cef6 <__sclose>:
 800cef6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800cefa:	f000 b8d3 	b.w	800d0a4 <_close_r>
	...

0800cf00 <__swbuf_r>:
 800cf00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800cf02:	460e      	mov	r6, r1
 800cf04:	4614      	mov	r4, r2
 800cf06:	4605      	mov	r5, r0
 800cf08:	b118      	cbz	r0, 800cf12 <__swbuf_r+0x12>
 800cf0a:	6983      	ldr	r3, [r0, #24]
 800cf0c:	b90b      	cbnz	r3, 800cf12 <__swbuf_r+0x12>
 800cf0e:	f7ff fa95 	bl	800c43c <__sinit>
 800cf12:	4b21      	ldr	r3, [pc, #132]	; (800cf98 <__swbuf_r+0x98>)
 800cf14:	429c      	cmp	r4, r3
 800cf16:	d12a      	bne.n	800cf6e <__swbuf_r+0x6e>
 800cf18:	686c      	ldr	r4, [r5, #4]
 800cf1a:	69a3      	ldr	r3, [r4, #24]
 800cf1c:	60a3      	str	r3, [r4, #8]
 800cf1e:	89a3      	ldrh	r3, [r4, #12]
 800cf20:	071a      	lsls	r2, r3, #28
 800cf22:	d52e      	bpl.n	800cf82 <__swbuf_r+0x82>
 800cf24:	6923      	ldr	r3, [r4, #16]
 800cf26:	b363      	cbz	r3, 800cf82 <__swbuf_r+0x82>
 800cf28:	6923      	ldr	r3, [r4, #16]
 800cf2a:	6820      	ldr	r0, [r4, #0]
 800cf2c:	1ac0      	subs	r0, r0, r3
 800cf2e:	6963      	ldr	r3, [r4, #20]
 800cf30:	b2f6      	uxtb	r6, r6
 800cf32:	4298      	cmp	r0, r3
 800cf34:	4637      	mov	r7, r6
 800cf36:	db04      	blt.n	800cf42 <__swbuf_r+0x42>
 800cf38:	4621      	mov	r1, r4
 800cf3a:	4628      	mov	r0, r5
 800cf3c:	f000 f94a 	bl	800d1d4 <_fflush_r>
 800cf40:	bb28      	cbnz	r0, 800cf8e <__swbuf_r+0x8e>
 800cf42:	68a3      	ldr	r3, [r4, #8]
 800cf44:	3b01      	subs	r3, #1
 800cf46:	60a3      	str	r3, [r4, #8]
 800cf48:	6823      	ldr	r3, [r4, #0]
 800cf4a:	1c5a      	adds	r2, r3, #1
 800cf4c:	6022      	str	r2, [r4, #0]
 800cf4e:	701e      	strb	r6, [r3, #0]
 800cf50:	6963      	ldr	r3, [r4, #20]
 800cf52:	3001      	adds	r0, #1
 800cf54:	4298      	cmp	r0, r3
 800cf56:	d004      	beq.n	800cf62 <__swbuf_r+0x62>
 800cf58:	89a3      	ldrh	r3, [r4, #12]
 800cf5a:	07db      	lsls	r3, r3, #31
 800cf5c:	d519      	bpl.n	800cf92 <__swbuf_r+0x92>
 800cf5e:	2e0a      	cmp	r6, #10
 800cf60:	d117      	bne.n	800cf92 <__swbuf_r+0x92>
 800cf62:	4621      	mov	r1, r4
 800cf64:	4628      	mov	r0, r5
 800cf66:	f000 f935 	bl	800d1d4 <_fflush_r>
 800cf6a:	b190      	cbz	r0, 800cf92 <__swbuf_r+0x92>
 800cf6c:	e00f      	b.n	800cf8e <__swbuf_r+0x8e>
 800cf6e:	4b0b      	ldr	r3, [pc, #44]	; (800cf9c <__swbuf_r+0x9c>)
 800cf70:	429c      	cmp	r4, r3
 800cf72:	d101      	bne.n	800cf78 <__swbuf_r+0x78>
 800cf74:	68ac      	ldr	r4, [r5, #8]
 800cf76:	e7d0      	b.n	800cf1a <__swbuf_r+0x1a>
 800cf78:	4b09      	ldr	r3, [pc, #36]	; (800cfa0 <__swbuf_r+0xa0>)
 800cf7a:	429c      	cmp	r4, r3
 800cf7c:	bf08      	it	eq
 800cf7e:	68ec      	ldreq	r4, [r5, #12]
 800cf80:	e7cb      	b.n	800cf1a <__swbuf_r+0x1a>
 800cf82:	4621      	mov	r1, r4
 800cf84:	4628      	mov	r0, r5
 800cf86:	f000 f81f 	bl	800cfc8 <__swsetup_r>
 800cf8a:	2800      	cmp	r0, #0
 800cf8c:	d0cc      	beq.n	800cf28 <__swbuf_r+0x28>
 800cf8e:	f04f 37ff 	mov.w	r7, #4294967295
 800cf92:	4638      	mov	r0, r7
 800cf94:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800cf96:	bf00      	nop
 800cf98:	0800d6a8 	.word	0x0800d6a8
 800cf9c:	0800d6c8 	.word	0x0800d6c8
 800cfa0:	0800d688 	.word	0x0800d688

0800cfa4 <_write_r>:
 800cfa4:	b538      	push	{r3, r4, r5, lr}
 800cfa6:	4c07      	ldr	r4, [pc, #28]	; (800cfc4 <_write_r+0x20>)
 800cfa8:	4605      	mov	r5, r0
 800cfaa:	4608      	mov	r0, r1
 800cfac:	4611      	mov	r1, r2
 800cfae:	2200      	movs	r2, #0
 800cfb0:	6022      	str	r2, [r4, #0]
 800cfb2:	461a      	mov	r2, r3
 800cfb4:	f7ff f94e 	bl	800c254 <_write>
 800cfb8:	1c43      	adds	r3, r0, #1
 800cfba:	d102      	bne.n	800cfc2 <_write_r+0x1e>
 800cfbc:	6823      	ldr	r3, [r4, #0]
 800cfbe:	b103      	cbz	r3, 800cfc2 <_write_r+0x1e>
 800cfc0:	602b      	str	r3, [r5, #0]
 800cfc2:	bd38      	pop	{r3, r4, r5, pc}
 800cfc4:	20000dcc 	.word	0x20000dcc

0800cfc8 <__swsetup_r>:
 800cfc8:	4b32      	ldr	r3, [pc, #200]	; (800d094 <__swsetup_r+0xcc>)
 800cfca:	b570      	push	{r4, r5, r6, lr}
 800cfcc:	681d      	ldr	r5, [r3, #0]
 800cfce:	4606      	mov	r6, r0
 800cfd0:	460c      	mov	r4, r1
 800cfd2:	b125      	cbz	r5, 800cfde <__swsetup_r+0x16>
 800cfd4:	69ab      	ldr	r3, [r5, #24]
 800cfd6:	b913      	cbnz	r3, 800cfde <__swsetup_r+0x16>
 800cfd8:	4628      	mov	r0, r5
 800cfda:	f7ff fa2f 	bl	800c43c <__sinit>
 800cfde:	4b2e      	ldr	r3, [pc, #184]	; (800d098 <__swsetup_r+0xd0>)
 800cfe0:	429c      	cmp	r4, r3
 800cfe2:	d10f      	bne.n	800d004 <__swsetup_r+0x3c>
 800cfe4:	686c      	ldr	r4, [r5, #4]
 800cfe6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800cfea:	b29a      	uxth	r2, r3
 800cfec:	0715      	lsls	r5, r2, #28
 800cfee:	d42c      	bmi.n	800d04a <__swsetup_r+0x82>
 800cff0:	06d0      	lsls	r0, r2, #27
 800cff2:	d411      	bmi.n	800d018 <__swsetup_r+0x50>
 800cff4:	2209      	movs	r2, #9
 800cff6:	6032      	str	r2, [r6, #0]
 800cff8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800cffc:	81a3      	strh	r3, [r4, #12]
 800cffe:	f04f 30ff 	mov.w	r0, #4294967295
 800d002:	bd70      	pop	{r4, r5, r6, pc}
 800d004:	4b25      	ldr	r3, [pc, #148]	; (800d09c <__swsetup_r+0xd4>)
 800d006:	429c      	cmp	r4, r3
 800d008:	d101      	bne.n	800d00e <__swsetup_r+0x46>
 800d00a:	68ac      	ldr	r4, [r5, #8]
 800d00c:	e7eb      	b.n	800cfe6 <__swsetup_r+0x1e>
 800d00e:	4b24      	ldr	r3, [pc, #144]	; (800d0a0 <__swsetup_r+0xd8>)
 800d010:	429c      	cmp	r4, r3
 800d012:	bf08      	it	eq
 800d014:	68ec      	ldreq	r4, [r5, #12]
 800d016:	e7e6      	b.n	800cfe6 <__swsetup_r+0x1e>
 800d018:	0751      	lsls	r1, r2, #29
 800d01a:	d512      	bpl.n	800d042 <__swsetup_r+0x7a>
 800d01c:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800d01e:	b141      	cbz	r1, 800d032 <__swsetup_r+0x6a>
 800d020:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800d024:	4299      	cmp	r1, r3
 800d026:	d002      	beq.n	800d02e <__swsetup_r+0x66>
 800d028:	4630      	mov	r0, r6
 800d02a:	f000 f99b 	bl	800d364 <_free_r>
 800d02e:	2300      	movs	r3, #0
 800d030:	6363      	str	r3, [r4, #52]	; 0x34
 800d032:	89a3      	ldrh	r3, [r4, #12]
 800d034:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 800d038:	81a3      	strh	r3, [r4, #12]
 800d03a:	2300      	movs	r3, #0
 800d03c:	6063      	str	r3, [r4, #4]
 800d03e:	6923      	ldr	r3, [r4, #16]
 800d040:	6023      	str	r3, [r4, #0]
 800d042:	89a3      	ldrh	r3, [r4, #12]
 800d044:	f043 0308 	orr.w	r3, r3, #8
 800d048:	81a3      	strh	r3, [r4, #12]
 800d04a:	6923      	ldr	r3, [r4, #16]
 800d04c:	b94b      	cbnz	r3, 800d062 <__swsetup_r+0x9a>
 800d04e:	89a3      	ldrh	r3, [r4, #12]
 800d050:	f403 7320 	and.w	r3, r3, #640	; 0x280
 800d054:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800d058:	d003      	beq.n	800d062 <__swsetup_r+0x9a>
 800d05a:	4621      	mov	r1, r4
 800d05c:	4630      	mov	r0, r6
 800d05e:	f000 f919 	bl	800d294 <__smakebuf_r>
 800d062:	89a2      	ldrh	r2, [r4, #12]
 800d064:	f012 0301 	ands.w	r3, r2, #1
 800d068:	d00c      	beq.n	800d084 <__swsetup_r+0xbc>
 800d06a:	2300      	movs	r3, #0
 800d06c:	60a3      	str	r3, [r4, #8]
 800d06e:	6963      	ldr	r3, [r4, #20]
 800d070:	425b      	negs	r3, r3
 800d072:	61a3      	str	r3, [r4, #24]
 800d074:	6923      	ldr	r3, [r4, #16]
 800d076:	b953      	cbnz	r3, 800d08e <__swsetup_r+0xc6>
 800d078:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800d07c:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 800d080:	d1ba      	bne.n	800cff8 <__swsetup_r+0x30>
 800d082:	bd70      	pop	{r4, r5, r6, pc}
 800d084:	0792      	lsls	r2, r2, #30
 800d086:	bf58      	it	pl
 800d088:	6963      	ldrpl	r3, [r4, #20]
 800d08a:	60a3      	str	r3, [r4, #8]
 800d08c:	e7f2      	b.n	800d074 <__swsetup_r+0xac>
 800d08e:	2000      	movs	r0, #0
 800d090:	e7f7      	b.n	800d082 <__swsetup_r+0xba>
 800d092:	bf00      	nop
 800d094:	2000051c 	.word	0x2000051c
 800d098:	0800d6a8 	.word	0x0800d6a8
 800d09c:	0800d6c8 	.word	0x0800d6c8
 800d0a0:	0800d688 	.word	0x0800d688

0800d0a4 <_close_r>:
 800d0a4:	b538      	push	{r3, r4, r5, lr}
 800d0a6:	4c06      	ldr	r4, [pc, #24]	; (800d0c0 <_close_r+0x1c>)
 800d0a8:	2300      	movs	r3, #0
 800d0aa:	4605      	mov	r5, r0
 800d0ac:	4608      	mov	r0, r1
 800d0ae:	6023      	str	r3, [r4, #0]
 800d0b0:	f7ff f8f8 	bl	800c2a4 <_close>
 800d0b4:	1c43      	adds	r3, r0, #1
 800d0b6:	d102      	bne.n	800d0be <_close_r+0x1a>
 800d0b8:	6823      	ldr	r3, [r4, #0]
 800d0ba:	b103      	cbz	r3, 800d0be <_close_r+0x1a>
 800d0bc:	602b      	str	r3, [r5, #0]
 800d0be:	bd38      	pop	{r3, r4, r5, pc}
 800d0c0:	20000dcc 	.word	0x20000dcc

0800d0c4 <__sflush_r>:
 800d0c4:	898a      	ldrh	r2, [r1, #12]
 800d0c6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d0ca:	4605      	mov	r5, r0
 800d0cc:	0710      	lsls	r0, r2, #28
 800d0ce:	460c      	mov	r4, r1
 800d0d0:	d45a      	bmi.n	800d188 <__sflush_r+0xc4>
 800d0d2:	684b      	ldr	r3, [r1, #4]
 800d0d4:	2b00      	cmp	r3, #0
 800d0d6:	dc05      	bgt.n	800d0e4 <__sflush_r+0x20>
 800d0d8:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 800d0da:	2b00      	cmp	r3, #0
 800d0dc:	dc02      	bgt.n	800d0e4 <__sflush_r+0x20>
 800d0de:	2000      	movs	r0, #0
 800d0e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d0e4:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800d0e6:	2e00      	cmp	r6, #0
 800d0e8:	d0f9      	beq.n	800d0de <__sflush_r+0x1a>
 800d0ea:	2300      	movs	r3, #0
 800d0ec:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 800d0f0:	682f      	ldr	r7, [r5, #0]
 800d0f2:	602b      	str	r3, [r5, #0]
 800d0f4:	d033      	beq.n	800d15e <__sflush_r+0x9a>
 800d0f6:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800d0f8:	89a3      	ldrh	r3, [r4, #12]
 800d0fa:	075a      	lsls	r2, r3, #29
 800d0fc:	d505      	bpl.n	800d10a <__sflush_r+0x46>
 800d0fe:	6863      	ldr	r3, [r4, #4]
 800d100:	1ac0      	subs	r0, r0, r3
 800d102:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800d104:	b10b      	cbz	r3, 800d10a <__sflush_r+0x46>
 800d106:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800d108:	1ac0      	subs	r0, r0, r3
 800d10a:	2300      	movs	r3, #0
 800d10c:	4602      	mov	r2, r0
 800d10e:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800d110:	6a21      	ldr	r1, [r4, #32]
 800d112:	4628      	mov	r0, r5
 800d114:	47b0      	blx	r6
 800d116:	1c43      	adds	r3, r0, #1
 800d118:	89a3      	ldrh	r3, [r4, #12]
 800d11a:	d106      	bne.n	800d12a <__sflush_r+0x66>
 800d11c:	6829      	ldr	r1, [r5, #0]
 800d11e:	291d      	cmp	r1, #29
 800d120:	d84b      	bhi.n	800d1ba <__sflush_r+0xf6>
 800d122:	4a2b      	ldr	r2, [pc, #172]	; (800d1d0 <__sflush_r+0x10c>)
 800d124:	40ca      	lsrs	r2, r1
 800d126:	07d6      	lsls	r6, r2, #31
 800d128:	d547      	bpl.n	800d1ba <__sflush_r+0xf6>
 800d12a:	2200      	movs	r2, #0
 800d12c:	6062      	str	r2, [r4, #4]
 800d12e:	04d9      	lsls	r1, r3, #19
 800d130:	6922      	ldr	r2, [r4, #16]
 800d132:	6022      	str	r2, [r4, #0]
 800d134:	d504      	bpl.n	800d140 <__sflush_r+0x7c>
 800d136:	1c42      	adds	r2, r0, #1
 800d138:	d101      	bne.n	800d13e <__sflush_r+0x7a>
 800d13a:	682b      	ldr	r3, [r5, #0]
 800d13c:	b903      	cbnz	r3, 800d140 <__sflush_r+0x7c>
 800d13e:	6560      	str	r0, [r4, #84]	; 0x54
 800d140:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800d142:	602f      	str	r7, [r5, #0]
 800d144:	2900      	cmp	r1, #0
 800d146:	d0ca      	beq.n	800d0de <__sflush_r+0x1a>
 800d148:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800d14c:	4299      	cmp	r1, r3
 800d14e:	d002      	beq.n	800d156 <__sflush_r+0x92>
 800d150:	4628      	mov	r0, r5
 800d152:	f000 f907 	bl	800d364 <_free_r>
 800d156:	2000      	movs	r0, #0
 800d158:	6360      	str	r0, [r4, #52]	; 0x34
 800d15a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d15e:	6a21      	ldr	r1, [r4, #32]
 800d160:	2301      	movs	r3, #1
 800d162:	4628      	mov	r0, r5
 800d164:	47b0      	blx	r6
 800d166:	1c41      	adds	r1, r0, #1
 800d168:	d1c6      	bne.n	800d0f8 <__sflush_r+0x34>
 800d16a:	682b      	ldr	r3, [r5, #0]
 800d16c:	2b00      	cmp	r3, #0
 800d16e:	d0c3      	beq.n	800d0f8 <__sflush_r+0x34>
 800d170:	2b1d      	cmp	r3, #29
 800d172:	d001      	beq.n	800d178 <__sflush_r+0xb4>
 800d174:	2b16      	cmp	r3, #22
 800d176:	d101      	bne.n	800d17c <__sflush_r+0xb8>
 800d178:	602f      	str	r7, [r5, #0]
 800d17a:	e7b0      	b.n	800d0de <__sflush_r+0x1a>
 800d17c:	89a3      	ldrh	r3, [r4, #12]
 800d17e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800d182:	81a3      	strh	r3, [r4, #12]
 800d184:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d188:	690f      	ldr	r7, [r1, #16]
 800d18a:	2f00      	cmp	r7, #0
 800d18c:	d0a7      	beq.n	800d0de <__sflush_r+0x1a>
 800d18e:	0793      	lsls	r3, r2, #30
 800d190:	680e      	ldr	r6, [r1, #0]
 800d192:	bf08      	it	eq
 800d194:	694b      	ldreq	r3, [r1, #20]
 800d196:	600f      	str	r7, [r1, #0]
 800d198:	bf18      	it	ne
 800d19a:	2300      	movne	r3, #0
 800d19c:	eba6 0807 	sub.w	r8, r6, r7
 800d1a0:	608b      	str	r3, [r1, #8]
 800d1a2:	f1b8 0f00 	cmp.w	r8, #0
 800d1a6:	dd9a      	ble.n	800d0de <__sflush_r+0x1a>
 800d1a8:	4643      	mov	r3, r8
 800d1aa:	463a      	mov	r2, r7
 800d1ac:	6a21      	ldr	r1, [r4, #32]
 800d1ae:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 800d1b0:	4628      	mov	r0, r5
 800d1b2:	47b0      	blx	r6
 800d1b4:	2800      	cmp	r0, #0
 800d1b6:	dc07      	bgt.n	800d1c8 <__sflush_r+0x104>
 800d1b8:	89a3      	ldrh	r3, [r4, #12]
 800d1ba:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800d1be:	81a3      	strh	r3, [r4, #12]
 800d1c0:	f04f 30ff 	mov.w	r0, #4294967295
 800d1c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d1c8:	4407      	add	r7, r0
 800d1ca:	eba8 0800 	sub.w	r8, r8, r0
 800d1ce:	e7e8      	b.n	800d1a2 <__sflush_r+0xde>
 800d1d0:	20400001 	.word	0x20400001

0800d1d4 <_fflush_r>:
 800d1d4:	b538      	push	{r3, r4, r5, lr}
 800d1d6:	690b      	ldr	r3, [r1, #16]
 800d1d8:	4605      	mov	r5, r0
 800d1da:	460c      	mov	r4, r1
 800d1dc:	b1db      	cbz	r3, 800d216 <_fflush_r+0x42>
 800d1de:	b118      	cbz	r0, 800d1e8 <_fflush_r+0x14>
 800d1e0:	6983      	ldr	r3, [r0, #24]
 800d1e2:	b90b      	cbnz	r3, 800d1e8 <_fflush_r+0x14>
 800d1e4:	f7ff f92a 	bl	800c43c <__sinit>
 800d1e8:	4b0c      	ldr	r3, [pc, #48]	; (800d21c <_fflush_r+0x48>)
 800d1ea:	429c      	cmp	r4, r3
 800d1ec:	d109      	bne.n	800d202 <_fflush_r+0x2e>
 800d1ee:	686c      	ldr	r4, [r5, #4]
 800d1f0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800d1f4:	b17b      	cbz	r3, 800d216 <_fflush_r+0x42>
 800d1f6:	4621      	mov	r1, r4
 800d1f8:	4628      	mov	r0, r5
 800d1fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800d1fe:	f7ff bf61 	b.w	800d0c4 <__sflush_r>
 800d202:	4b07      	ldr	r3, [pc, #28]	; (800d220 <_fflush_r+0x4c>)
 800d204:	429c      	cmp	r4, r3
 800d206:	d101      	bne.n	800d20c <_fflush_r+0x38>
 800d208:	68ac      	ldr	r4, [r5, #8]
 800d20a:	e7f1      	b.n	800d1f0 <_fflush_r+0x1c>
 800d20c:	4b05      	ldr	r3, [pc, #20]	; (800d224 <_fflush_r+0x50>)
 800d20e:	429c      	cmp	r4, r3
 800d210:	bf08      	it	eq
 800d212:	68ec      	ldreq	r4, [r5, #12]
 800d214:	e7ec      	b.n	800d1f0 <_fflush_r+0x1c>
 800d216:	2000      	movs	r0, #0
 800d218:	bd38      	pop	{r3, r4, r5, pc}
 800d21a:	bf00      	nop
 800d21c:	0800d6a8 	.word	0x0800d6a8
 800d220:	0800d6c8 	.word	0x0800d6c8
 800d224:	0800d688 	.word	0x0800d688

0800d228 <_lseek_r>:
 800d228:	b538      	push	{r3, r4, r5, lr}
 800d22a:	4c07      	ldr	r4, [pc, #28]	; (800d248 <_lseek_r+0x20>)
 800d22c:	4605      	mov	r5, r0
 800d22e:	4608      	mov	r0, r1
 800d230:	4611      	mov	r1, r2
 800d232:	2200      	movs	r2, #0
 800d234:	6022      	str	r2, [r4, #0]
 800d236:	461a      	mov	r2, r3
 800d238:	f7ff f840 	bl	800c2bc <_lseek>
 800d23c:	1c43      	adds	r3, r0, #1
 800d23e:	d102      	bne.n	800d246 <_lseek_r+0x1e>
 800d240:	6823      	ldr	r3, [r4, #0]
 800d242:	b103      	cbz	r3, 800d246 <_lseek_r+0x1e>
 800d244:	602b      	str	r3, [r5, #0]
 800d246:	bd38      	pop	{r3, r4, r5, pc}
 800d248:	20000dcc 	.word	0x20000dcc

0800d24c <__swhatbuf_r>:
 800d24c:	b570      	push	{r4, r5, r6, lr}
 800d24e:	460e      	mov	r6, r1
 800d250:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d254:	2900      	cmp	r1, #0
 800d256:	b090      	sub	sp, #64	; 0x40
 800d258:	4614      	mov	r4, r2
 800d25a:	461d      	mov	r5, r3
 800d25c:	da07      	bge.n	800d26e <__swhatbuf_r+0x22>
 800d25e:	2300      	movs	r3, #0
 800d260:	602b      	str	r3, [r5, #0]
 800d262:	89b3      	ldrh	r3, [r6, #12]
 800d264:	061a      	lsls	r2, r3, #24
 800d266:	d410      	bmi.n	800d28a <__swhatbuf_r+0x3e>
 800d268:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800d26c:	e00e      	b.n	800d28c <__swhatbuf_r+0x40>
 800d26e:	aa01      	add	r2, sp, #4
 800d270:	f000 f8fe 	bl	800d470 <_fstat_r>
 800d274:	2800      	cmp	r0, #0
 800d276:	dbf2      	blt.n	800d25e <__swhatbuf_r+0x12>
 800d278:	9a02      	ldr	r2, [sp, #8]
 800d27a:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 800d27e:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 800d282:	425a      	negs	r2, r3
 800d284:	415a      	adcs	r2, r3
 800d286:	602a      	str	r2, [r5, #0]
 800d288:	e7ee      	b.n	800d268 <__swhatbuf_r+0x1c>
 800d28a:	2340      	movs	r3, #64	; 0x40
 800d28c:	2000      	movs	r0, #0
 800d28e:	6023      	str	r3, [r4, #0]
 800d290:	b010      	add	sp, #64	; 0x40
 800d292:	bd70      	pop	{r4, r5, r6, pc}

0800d294 <__smakebuf_r>:
 800d294:	898b      	ldrh	r3, [r1, #12]
 800d296:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800d298:	079d      	lsls	r5, r3, #30
 800d29a:	4606      	mov	r6, r0
 800d29c:	460c      	mov	r4, r1
 800d29e:	d507      	bpl.n	800d2b0 <__smakebuf_r+0x1c>
 800d2a0:	f104 0347 	add.w	r3, r4, #71	; 0x47
 800d2a4:	6023      	str	r3, [r4, #0]
 800d2a6:	6123      	str	r3, [r4, #16]
 800d2a8:	2301      	movs	r3, #1
 800d2aa:	6163      	str	r3, [r4, #20]
 800d2ac:	b002      	add	sp, #8
 800d2ae:	bd70      	pop	{r4, r5, r6, pc}
 800d2b0:	ab01      	add	r3, sp, #4
 800d2b2:	466a      	mov	r2, sp
 800d2b4:	f7ff ffca 	bl	800d24c <__swhatbuf_r>
 800d2b8:	9900      	ldr	r1, [sp, #0]
 800d2ba:	4605      	mov	r5, r0
 800d2bc:	4630      	mov	r0, r6
 800d2be:	f7ff f947 	bl	800c550 <_malloc_r>
 800d2c2:	b948      	cbnz	r0, 800d2d8 <__smakebuf_r+0x44>
 800d2c4:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800d2c8:	059a      	lsls	r2, r3, #22
 800d2ca:	d4ef      	bmi.n	800d2ac <__smakebuf_r+0x18>
 800d2cc:	f023 0303 	bic.w	r3, r3, #3
 800d2d0:	f043 0302 	orr.w	r3, r3, #2
 800d2d4:	81a3      	strh	r3, [r4, #12]
 800d2d6:	e7e3      	b.n	800d2a0 <__smakebuf_r+0xc>
 800d2d8:	4b0d      	ldr	r3, [pc, #52]	; (800d310 <__smakebuf_r+0x7c>)
 800d2da:	62b3      	str	r3, [r6, #40]	; 0x28
 800d2dc:	89a3      	ldrh	r3, [r4, #12]
 800d2de:	6020      	str	r0, [r4, #0]
 800d2e0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800d2e4:	81a3      	strh	r3, [r4, #12]
 800d2e6:	9b00      	ldr	r3, [sp, #0]
 800d2e8:	6163      	str	r3, [r4, #20]
 800d2ea:	9b01      	ldr	r3, [sp, #4]
 800d2ec:	6120      	str	r0, [r4, #16]
 800d2ee:	b15b      	cbz	r3, 800d308 <__smakebuf_r+0x74>
 800d2f0:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800d2f4:	4630      	mov	r0, r6
 800d2f6:	f000 f8cd 	bl	800d494 <_isatty_r>
 800d2fa:	b128      	cbz	r0, 800d308 <__smakebuf_r+0x74>
 800d2fc:	89a3      	ldrh	r3, [r4, #12]
 800d2fe:	f023 0303 	bic.w	r3, r3, #3
 800d302:	f043 0301 	orr.w	r3, r3, #1
 800d306:	81a3      	strh	r3, [r4, #12]
 800d308:	89a3      	ldrh	r3, [r4, #12]
 800d30a:	431d      	orrs	r5, r3
 800d30c:	81a5      	strh	r5, [r4, #12]
 800d30e:	e7cd      	b.n	800d2ac <__smakebuf_r+0x18>
 800d310:	0800c3bd 	.word	0x0800c3bd

0800d314 <memcpy>:
 800d314:	b510      	push	{r4, lr}
 800d316:	1e43      	subs	r3, r0, #1
 800d318:	440a      	add	r2, r1
 800d31a:	4291      	cmp	r1, r2
 800d31c:	d100      	bne.n	800d320 <memcpy+0xc>
 800d31e:	bd10      	pop	{r4, pc}
 800d320:	f811 4b01 	ldrb.w	r4, [r1], #1
 800d324:	f803 4f01 	strb.w	r4, [r3, #1]!
 800d328:	e7f7      	b.n	800d31a <memcpy+0x6>

0800d32a <memmove>:
 800d32a:	4288      	cmp	r0, r1
 800d32c:	b510      	push	{r4, lr}
 800d32e:	eb01 0302 	add.w	r3, r1, r2
 800d332:	d803      	bhi.n	800d33c <memmove+0x12>
 800d334:	1e42      	subs	r2, r0, #1
 800d336:	4299      	cmp	r1, r3
 800d338:	d10c      	bne.n	800d354 <memmove+0x2a>
 800d33a:	bd10      	pop	{r4, pc}
 800d33c:	4298      	cmp	r0, r3
 800d33e:	d2f9      	bcs.n	800d334 <memmove+0xa>
 800d340:	1881      	adds	r1, r0, r2
 800d342:	1ad2      	subs	r2, r2, r3
 800d344:	42d3      	cmn	r3, r2
 800d346:	d100      	bne.n	800d34a <memmove+0x20>
 800d348:	bd10      	pop	{r4, pc}
 800d34a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 800d34e:	f801 4d01 	strb.w	r4, [r1, #-1]!
 800d352:	e7f7      	b.n	800d344 <memmove+0x1a>
 800d354:	f811 4b01 	ldrb.w	r4, [r1], #1
 800d358:	f802 4f01 	strb.w	r4, [r2, #1]!
 800d35c:	e7eb      	b.n	800d336 <memmove+0xc>

0800d35e <__malloc_lock>:
 800d35e:	4770      	bx	lr

0800d360 <__malloc_unlock>:
 800d360:	4770      	bx	lr
	...

0800d364 <_free_r>:
 800d364:	b538      	push	{r3, r4, r5, lr}
 800d366:	4605      	mov	r5, r0
 800d368:	2900      	cmp	r1, #0
 800d36a:	d045      	beq.n	800d3f8 <_free_r+0x94>
 800d36c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 800d370:	1f0c      	subs	r4, r1, #4
 800d372:	2b00      	cmp	r3, #0
 800d374:	bfb8      	it	lt
 800d376:	18e4      	addlt	r4, r4, r3
 800d378:	f7ff fff1 	bl	800d35e <__malloc_lock>
 800d37c:	4a1f      	ldr	r2, [pc, #124]	; (800d3fc <_free_r+0x98>)
 800d37e:	6813      	ldr	r3, [r2, #0]
 800d380:	4610      	mov	r0, r2
 800d382:	b933      	cbnz	r3, 800d392 <_free_r+0x2e>
 800d384:	6063      	str	r3, [r4, #4]
 800d386:	6014      	str	r4, [r2, #0]
 800d388:	4628      	mov	r0, r5
 800d38a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800d38e:	f7ff bfe7 	b.w	800d360 <__malloc_unlock>
 800d392:	42a3      	cmp	r3, r4
 800d394:	d90c      	bls.n	800d3b0 <_free_r+0x4c>
 800d396:	6821      	ldr	r1, [r4, #0]
 800d398:	1862      	adds	r2, r4, r1
 800d39a:	4293      	cmp	r3, r2
 800d39c:	bf04      	itt	eq
 800d39e:	681a      	ldreq	r2, [r3, #0]
 800d3a0:	685b      	ldreq	r3, [r3, #4]
 800d3a2:	6063      	str	r3, [r4, #4]
 800d3a4:	bf04      	itt	eq
 800d3a6:	1852      	addeq	r2, r2, r1
 800d3a8:	6022      	streq	r2, [r4, #0]
 800d3aa:	6004      	str	r4, [r0, #0]
 800d3ac:	e7ec      	b.n	800d388 <_free_r+0x24>
 800d3ae:	4613      	mov	r3, r2
 800d3b0:	685a      	ldr	r2, [r3, #4]
 800d3b2:	b10a      	cbz	r2, 800d3b8 <_free_r+0x54>
 800d3b4:	42a2      	cmp	r2, r4
 800d3b6:	d9fa      	bls.n	800d3ae <_free_r+0x4a>
 800d3b8:	6819      	ldr	r1, [r3, #0]
 800d3ba:	1858      	adds	r0, r3, r1
 800d3bc:	42a0      	cmp	r0, r4
 800d3be:	d10b      	bne.n	800d3d8 <_free_r+0x74>
 800d3c0:	6820      	ldr	r0, [r4, #0]
 800d3c2:	4401      	add	r1, r0
 800d3c4:	1858      	adds	r0, r3, r1
 800d3c6:	4282      	cmp	r2, r0
 800d3c8:	6019      	str	r1, [r3, #0]
 800d3ca:	d1dd      	bne.n	800d388 <_free_r+0x24>
 800d3cc:	6810      	ldr	r0, [r2, #0]
 800d3ce:	6852      	ldr	r2, [r2, #4]
 800d3d0:	605a      	str	r2, [r3, #4]
 800d3d2:	4401      	add	r1, r0
 800d3d4:	6019      	str	r1, [r3, #0]
 800d3d6:	e7d7      	b.n	800d388 <_free_r+0x24>
 800d3d8:	d902      	bls.n	800d3e0 <_free_r+0x7c>
 800d3da:	230c      	movs	r3, #12
 800d3dc:	602b      	str	r3, [r5, #0]
 800d3de:	e7d3      	b.n	800d388 <_free_r+0x24>
 800d3e0:	6820      	ldr	r0, [r4, #0]
 800d3e2:	1821      	adds	r1, r4, r0
 800d3e4:	428a      	cmp	r2, r1
 800d3e6:	bf04      	itt	eq
 800d3e8:	6811      	ldreq	r1, [r2, #0]
 800d3ea:	6852      	ldreq	r2, [r2, #4]
 800d3ec:	6062      	str	r2, [r4, #4]
 800d3ee:	bf04      	itt	eq
 800d3f0:	1809      	addeq	r1, r1, r0
 800d3f2:	6021      	streq	r1, [r4, #0]
 800d3f4:	605c      	str	r4, [r3, #4]
 800d3f6:	e7c7      	b.n	800d388 <_free_r+0x24>
 800d3f8:	bd38      	pop	{r3, r4, r5, pc}
 800d3fa:	bf00      	nop
 800d3fc:	2000074c 	.word	0x2000074c

0800d400 <_realloc_r>:
 800d400:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d402:	4607      	mov	r7, r0
 800d404:	4614      	mov	r4, r2
 800d406:	460e      	mov	r6, r1
 800d408:	b921      	cbnz	r1, 800d414 <_realloc_r+0x14>
 800d40a:	4611      	mov	r1, r2
 800d40c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 800d410:	f7ff b89e 	b.w	800c550 <_malloc_r>
 800d414:	b922      	cbnz	r2, 800d420 <_realloc_r+0x20>
 800d416:	f7ff ffa5 	bl	800d364 <_free_r>
 800d41a:	4625      	mov	r5, r4
 800d41c:	4628      	mov	r0, r5
 800d41e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800d420:	f000 f848 	bl	800d4b4 <_malloc_usable_size_r>
 800d424:	4284      	cmp	r4, r0
 800d426:	d90f      	bls.n	800d448 <_realloc_r+0x48>
 800d428:	4621      	mov	r1, r4
 800d42a:	4638      	mov	r0, r7
 800d42c:	f7ff f890 	bl	800c550 <_malloc_r>
 800d430:	4605      	mov	r5, r0
 800d432:	2800      	cmp	r0, #0
 800d434:	d0f2      	beq.n	800d41c <_realloc_r+0x1c>
 800d436:	4631      	mov	r1, r6
 800d438:	4622      	mov	r2, r4
 800d43a:	f7ff ff6b 	bl	800d314 <memcpy>
 800d43e:	4631      	mov	r1, r6
 800d440:	4638      	mov	r0, r7
 800d442:	f7ff ff8f 	bl	800d364 <_free_r>
 800d446:	e7e9      	b.n	800d41c <_realloc_r+0x1c>
 800d448:	4635      	mov	r5, r6
 800d44a:	e7e7      	b.n	800d41c <_realloc_r+0x1c>

0800d44c <_read_r>:
 800d44c:	b538      	push	{r3, r4, r5, lr}
 800d44e:	4c07      	ldr	r4, [pc, #28]	; (800d46c <_read_r+0x20>)
 800d450:	4605      	mov	r5, r0
 800d452:	4608      	mov	r0, r1
 800d454:	4611      	mov	r1, r2
 800d456:	2200      	movs	r2, #0
 800d458:	6022      	str	r2, [r4, #0]
 800d45a:	461a      	mov	r2, r3
 800d45c:	f7fe feec 	bl	800c238 <_read>
 800d460:	1c43      	adds	r3, r0, #1
 800d462:	d102      	bne.n	800d46a <_read_r+0x1e>
 800d464:	6823      	ldr	r3, [r4, #0]
 800d466:	b103      	cbz	r3, 800d46a <_read_r+0x1e>
 800d468:	602b      	str	r3, [r5, #0]
 800d46a:	bd38      	pop	{r3, r4, r5, pc}
 800d46c:	20000dcc 	.word	0x20000dcc

0800d470 <_fstat_r>:
 800d470:	b538      	push	{r3, r4, r5, lr}
 800d472:	4c07      	ldr	r4, [pc, #28]	; (800d490 <_fstat_r+0x20>)
 800d474:	2300      	movs	r3, #0
 800d476:	4605      	mov	r5, r0
 800d478:	4608      	mov	r0, r1
 800d47a:	4611      	mov	r1, r2
 800d47c:	6023      	str	r3, [r4, #0]
 800d47e:	f7fe ff15 	bl	800c2ac <_fstat>
 800d482:	1c43      	adds	r3, r0, #1
 800d484:	d102      	bne.n	800d48c <_fstat_r+0x1c>
 800d486:	6823      	ldr	r3, [r4, #0]
 800d488:	b103      	cbz	r3, 800d48c <_fstat_r+0x1c>
 800d48a:	602b      	str	r3, [r5, #0]
 800d48c:	bd38      	pop	{r3, r4, r5, pc}
 800d48e:	bf00      	nop
 800d490:	20000dcc 	.word	0x20000dcc

0800d494 <_isatty_r>:
 800d494:	b538      	push	{r3, r4, r5, lr}
 800d496:	4c06      	ldr	r4, [pc, #24]	; (800d4b0 <_isatty_r+0x1c>)
 800d498:	2300      	movs	r3, #0
 800d49a:	4605      	mov	r5, r0
 800d49c:	4608      	mov	r0, r1
 800d49e:	6023      	str	r3, [r4, #0]
 800d4a0:	f7fe ff0a 	bl	800c2b8 <_isatty>
 800d4a4:	1c43      	adds	r3, r0, #1
 800d4a6:	d102      	bne.n	800d4ae <_isatty_r+0x1a>
 800d4a8:	6823      	ldr	r3, [r4, #0]
 800d4aa:	b103      	cbz	r3, 800d4ae <_isatty_r+0x1a>
 800d4ac:	602b      	str	r3, [r5, #0]
 800d4ae:	bd38      	pop	{r3, r4, r5, pc}
 800d4b0:	20000dcc 	.word	0x20000dcc

0800d4b4 <_malloc_usable_size_r>:
 800d4b4:	f851 0c04 	ldr.w	r0, [r1, #-4]
 800d4b8:	2800      	cmp	r0, #0
 800d4ba:	f1a0 0004 	sub.w	r0, r0, #4
 800d4be:	bfbc      	itt	lt
 800d4c0:	580b      	ldrlt	r3, [r1, r0]
 800d4c2:	18c0      	addlt	r0, r0, r3
 800d4c4:	4770      	bx	lr
	...

0800d4c8 <_init>:
 800d4c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d4ca:	bf00      	nop
 800d4cc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800d4ce:	bc08      	pop	{r3}
 800d4d0:	469e      	mov	lr, r3
 800d4d2:	4770      	bx	lr

0800d4d4 <_fini>:
 800d4d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d4d6:	bf00      	nop
 800d4d8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800d4da:	bc08      	pop	{r3}
 800d4dc:	469e      	mov	lr, r3
 800d4de:	4770      	bx	lr
